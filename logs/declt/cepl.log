Unhandled PRINT-NOT-READABLE in thread #<error printing a SB-THREAD:THREAD: #<PRINT-NOT-READABLE {100716EDC3}>>: #<VARI.TYPES:V-UINT {100C6F72E3}> cannot be printed readably.

Backtrace for: #<SB-THREAD:THREAD "main thread" RUNNING {1001B76E63}>
0: (SB-DEBUG::DEBUGGER-DISABLED-HOOK #<PRINT-NOT-READABLE {100716D193}> #<unused argument>)
1: (SB-DEBUG::RUN-HOOK *INVOKE-DEBUGGER-HOOK* #<PRINT-NOT-READABLE {100716D193}>)
2: (INVOKE-DEBUGGER #<PRINT-NOT-READABLE {100716D193}>)
3: (ERROR #<PRINT-NOT-READABLE {100716D193}>)
4: (SB-KERNEL:WITH-SIMPLE-CONDITION-RESTARTS ERROR NIL PRINT-NOT-READABLE :OBJECT #<VARI.TYPES:V-UINT {100C6F72E3}>)
5: (SB-INT:PRINT-NOT-READABLE-ERROR #<VARI.TYPES:V-UINT {100C6F72E3}> #<SB-IMPL::CASE-FROB-STREAM {100716C493}>)
6: (SB-IMPL::%PRINT-UNREADABLE-OBJECT #<VARI.TYPES:V-UINT {100C6F72E3}> #<SB-IMPL::CASE-FROB-STREAM {100716C493}> T T NIL)
7: ((LABELS SB-IMPL::HANDLE-IT :IN SB-KERNEL:OUTPUT-OBJECT) #<SB-IMPL::CASE-FROB-STREAM {100716C493}>)
8: ((:METHOD PRINT-OBJECT (CONS T)) (COUNT #<VARI.TYPES:V-UINT {100C6F72E3}> CEPL.PIPELINES:ARRAYS-INDIRECT-COMMAND-COUNT "~a.COUNT") #<SB-IMPL::CASE-FROB-STREAM {100716C493}>) [fast-method]
9: ((LABELS SB-IMPL::HANDLE-IT :IN SB-KERNEL:OUTPUT-OBJECT) #<SB-IMPL::CASE-FROB-STREAM {100716C493}>)
10: ((:METHOD PRINT-OBJECT (CONS T)) ((COUNT #<VARI.TYPES:V-UINT {100C6F72E3}> CEPL.PIPELINES:ARRAYS-INDIRECT-COMMAND-COUNT "~a.COUNT") (CEPL.PIPELINES::INSTANCE-COUNT #<VARI.TYPES:V-UINT {100C6F72F3}> CEPL.PIPELINES:ARRAYS-INDIRECT-COMMAND-INSTANCE-COUNT "~a.INSTANCE_COUNT") (FIRST #<VARI.TYPES:V-UINT {100C6F7303}> CEPL.PIPELINES:ARRAYS-INDIRECT-COMMAND-FIRST "~a.FIRST") (CEPL.PIPELINES::BASE-INSTANCE #<VARI.TYPES:V-UINT {100C6F7313}> CEPL.PIPELINES:ARRAYS-INDIRECT-COMMAND-BASE-INSTANCE "~a.BASE_INSTANCE")) #<SB-IMPL::CASE-FROB-STREAM {100716C493}>) [fast-method]
11: ((LABELS SB-IMPL::HANDLE-IT :IN SB-KERNEL:OUTPUT-OBJECT) #<SB-IMPL::CASE-FROB-STREAM {100716C493}>)
12: ((:METHOD PRINT-OBJECT (CONS T)) (QUOTE ((COUNT #<VARI.TYPES:V-UINT {100C6F72E3}> CEPL.PIPELINES:ARRAYS-INDIRECT-COMMAND-COUNT "~a.COUNT") (CEPL.PIPELINES::INSTANCE-COUNT #<VARI.TYPES:V-UINT {100C6F72F3}> CEPL.PIPELINES:ARRAYS-INDIRECT-COMMAND-INSTANCE-COUNT "~a.INSTANCE_COUNT") (FIRST #<VARI.TYPES:V-UINT {100C6F7303}> CEPL.PIPELINES:ARRAYS-INDIRECT-COMMAND-FIRST "~a.FIRST") (CEPL.PIPELINES::BASE-INSTANCE #<VARI.TYPES:V-UINT {100C6F7313}> CEPL.PIPELINES:ARRAYS-INDIRECT-COMMAND-BASE-INSTANCE "~a.BASE_INSTANCE"))) #<SB-IMPL::CASE-FROB-STREAM {100716C493}>) [fast-method]
13: ((LABELS SB-IMPL::HANDLE-IT :IN SB-KERNEL:OUTPUT-OBJECT) #<SB-IMPL::CASE-FROB-STREAM {100716C493}>)
14: (PRIN1 (QUOTE ((COUNT #<VARI.TYPES:V-UINT {100C6F72E3}> CEPL.PIPELINES:ARRAYS-INDIRECT-COMMAND-COUNT "~a.COUNT") (CEPL.PIPELINES::INSTANCE-COUNT #<VARI.TYPES:V-UINT {100C6F72F3}> CEPL.PIPELINES:ARRAYS-INDIRECT-COMMAND-INSTANCE-COUNT "~a.INSTANCE_COUNT") (FIRST #<VARI.TYPES:V-UINT {100C6F7303}> CEPL.PIPELINES:ARRAYS-INDIRECT-COMMAND-FIRST "~a.FIRST") (CEPL.PIPELINES::BASE-INSTANCE #<VARI.TYPES:V-UINT {100C6F7313}> CEPL.PIPELINES:ARRAYS-INDIRECT-COMMAND-BASE-INSTANCE "~a.BASE_INSTANCE"))) #<SB-IMPL::CASE-FROB-STREAM {100716C493}>)
15: ((LAMBDA (NET.DIDIERVERNA.DECLT::VALUE) :IN "/home/didier/share/common-lisp/source/declt/core/src/doc/symbol.lisp") (QUOTE ((COUNT #<VARI.TYPES:V-UINT {100C6F72E3}> CEPL.PIPELINES:ARRAYS-INDIRECT-COMMAND-COUNT "~a.COUNT") (CEPL.PIPELINES::INSTANCE-COUNT #<VARI.TYPES:V-UINT {100C6F72F3}> CEPL.PIPELINES:ARRAYS-INDIRECT-COMMAND-INSTANCE-COUNT "~a.INSTANCE_COUNT") (FIRST #<VARI.TYPES:V-UINT {100C6F7303}> CEPL.PIPELINES:ARRAYS-INDIRECT-COMMAND-FIRST "~a.FIRST") (CEPL.PIPELINES::BASE-INSTANCE #<VARI.TYPES:V-UINT {100C6F7313}> CEPL.PIPELINES:ARRAYS-INDIRECT-COMMAND-BASE-INSTANCE "~a.BASE_INSTANCE"))))
16: (NET.DIDIERVERNA.DECLT::RENDER-SLOT #S(NET.DIDIERVERNA.DECLT::SLOT-DEFINITION :SYMBOL VARJO.INTERNALS::SLOTS :FOREIGNP NIL :SLOT #<SB-MOP:STANDARD-DIRECT-SLOT-DEFINITION VARJO.INTERNALS::SLOTS> :READERS (#S(NET.DIDIERVERNA.DECLT::GENERIC-DEFINITION :SYMBOL VARJO.INTERNALS:V-SLOTS :FOREIGNP T :FUNCTION NIL :UPDATE-EXPANDER NIL :COMBINATION NIL :METHODS NIL)) :WRITERS NIL))
17: (NET.DIDIERVERNA.DECLT::RENDER-SLOTS #S(NET.DIDIERVERNA.DECLT::CLASS-DEFINITION :SYMBOL CEPL.PIPELINES::V_ARRAYS-INDIRECT-COMMAND :FOREIGNP NIL :PARENTS (#S(NET.DIDIERVERNA.DECLT::CLASS-DEFINITION :SYMBOL VARI.TYPES:V-USER-STRUCT :FOREIGNP T :PARENTS NIL :CHILDREN NIL :METHODS NIL :SLOTS NIL)) :CHILDREN NIL :METHODS (#S(NET.DIDIERVERNA.DECLT::METHOD-DEFINITION :SYMBOL VARJO.INTERNALS:TYPE->TYPE-SPEC :FOREIGNP T :METHOD NIL) #S(NET.DIDIERVERNA.DECLT::METHOD-DEFINITION :SYMBOL VARJO.INTERNALS:V-SLOTS :FOREIGNP T :METHOD NIL) #S(NET.DIDIERVERNA.DECLT::METHOD-DEFINITION :SYMBOL VARJO.INTERNALS::V-SIGNATURE :FOREIGNP T :METHOD NIL) #S(NET.DIDIERVERNA.DECLT::METHOD-DEFINITION :SYMBOL VARJO.INTERNALS::V-SIGNATURE :FOREIGNP T :METHOD NIL) #S(NET.DIDIERVERNA.DECLT::METHOD-DEFINITION :SYMBOL VARJO.INTERNALS:V-GLSL-STRING :FOREIGNP T :METHOD NIL)) :SLOTS (#S(NET.DIDIERVERNA.DECLT::SLOT-DEFINITION :SYMBOL VARJO.INTERNALS::TYPE-NAME :FOREIGNP NIL :SLOT #<SB-MOP:STANDARD-DIRECT-SLOT-DEFINITION VARJO.INTERNALS::TYPE-NAME> :READERS NIL :WRITERS NIL) #S(NET.DIDIERVERNA.DECLT::SLOT-DEFINITION :SYMBOL VARJO.INTERNALS::SUPERCLASS :FOREIGNP NIL :SLOT #<SB-MOP:STANDARD-DIRECT-SLOT-DEFINITION VARJO.INTERNALS::SUPERCLASS> :READERS NIL :WRITERS NIL) #S(NET.DIDIERVERNA.DECLT::SLOT-DEFINITION :SYMBOL VARJO.INTERNALS:GLSL-STRING :FOREIGNP NIL :SLOT #<SB-MOP:STANDARD-DIRECT-SLOT-DEFINITION VARJO.INTERNALS:GLSL-STRING> :READERS (#S(NET.DIDIERVERNA.DECLT::GENERIC-DEFINITION :SYMBOL VARJO.INTERNALS:V-GLSL-STRING :FOREIGNP T :FUNCTION NIL :UPDATE-EXPANDER NIL :COMBINATION NIL :METHODS NIL)) :WRITERS NIL) #S(NET.DIDIERVERNA.DECLT::SLOT-DEFINITION :SYMBOL VARJO.INTERNALS::SIGNATURE :FOREIGNP NIL :SLOT #<SB-MOP:STANDARD-DIRECT-SLOT-DEFINITION VARJO.INTERNALS::SIGNATURE> :READERS (#S(NET.DIDIERVERNA.DECLT::GENERIC-DEFINITION :SYMBOL VARJO.INTERNALS::V-SIGNATURE :FOREIGNP T :FUNCTION NIL :UPDATE-EXPANDER NIL :COMBINATION NIL :METHODS NIL)) :WRITERS (#S(NET.DIDIERVERNA.DECLT::GENERIC-WRITER-DEFINITION :SYMBOL VARJO.INTERNALS::V-SIGNATURE :FOREIGNP T :FUNCTION NIL :UPDATE-EXPANDER NIL :COMBINATION NIL :METHODS NIL :READER NIL))) #S(NET.DIDIERVERNA.DECLT::SLOT-DEFINITION :SYMBOL VARJO.INTERNALS::SLOTS :FOREIGNP NIL :SLOT #<SB-MOP:STANDARD-DIRECT-SLOT-DEFINITION VARJO.INTERNALS::SLOTS> :READERS (#S(NET.DIDIERVERNA.DECLT::GENERIC-DEFINITION :SYMBOL VARJO.INTERNALS:V-SLOTS :FOREIGNP T :FUNCTION NIL :UPDATE-EXPANDER NIL :COMBINATION NIL :METHODS NIL)) :WRITERS NIL))))
18: ((:METHOD NET.DIDIERVERNA.DECLT::DOCUMENT (NET.DIDIERVERNA.DECLT::CLASS-DEFINITION T)) #S(NET.DIDIERVERNA.DECLT::CLASS-DEFINITION :SYMBOL CEPL.PIPELINES::V_ARRAYS-INDIRECT-COMMAND :FOREIGNP NIL :PARENTS (#S(NET.DIDIERVERNA.DECLT::CLASS-DEFINITION :SYMBOL VARI.TYPES:V-USER-STRUCT :FOREIGNP T :PARENTS NIL :CHILDREN NIL :METHODS NIL :SLOTS NIL)) :CHILDREN NIL :METHODS (#S(NET.DIDIERVERNA.DECLT::METHOD-DEFINITION :SYMBOL VARJO.INTERNALS:TYPE->TYPE-SPEC :FOREIGNP T :METHOD NIL) #S(NET.DIDIERVERNA.DECLT::METHOD-DEFINITION :SYMBOL VARJO.INTERNALS:V-SLOTS :FOREIGNP T :METHOD NIL) #S(NET.DIDIERVERNA.DECLT::METHOD-DEFINITION :SYMBOL VARJO.INTERNALS::V-SIGNATURE :FOREIGNP T :METHOD NIL) #S(NET.DIDIERVERNA.DECLT::METHOD-DEFINITION :SYMBOL VARJO.INTERNALS::V-SIGNATURE :FOREIGNP T :METHOD NIL) #S(NET.DIDIERVERNA.DECLT::METHOD-DEFINITION :SYMBOL VARJO.INTERNALS:V-GLSL-STRING :FOREIGNP T :METHOD NIL)) :SLOTS (#S(NET.DIDIERVERNA.DECLT::SLOT-DEFINITION :SYMBOL VARJO.INTERNALS::TYPE-NAME :FOREIGNP NIL :SLOT #<SB-MOP:STANDARD-DIRECT-SLOT-DEFINITION VARJO.INTERNALS::TYPE-NAME> :READERS NIL :WRITERS NIL) #S(NET.DIDIERVERNA.DECLT::SLOT-DEFINITION :SYMBOL VARJO.INTERNALS::SUPERCLASS :FOREIGNP NIL :SLOT #<SB-MOP:STANDARD-DIRECT-SLOT-DEFINITION VARJO.INTERNALS::SUPERCLASS> :READERS NIL :WRITERS NIL) #S(NET.DIDIERVERNA.DECLT::SLOT-DEFINITION :SYMBOL VARJO.INTERNALS:GLSL-STRING :FOREIGNP NIL :SLOT #<SB-MOP:STANDARD-DIRECT-SLOT-DEFINITION VARJO.INTERNALS:GLSL-STRING> :READERS (#S(NET.DIDIERVERNA.DECLT::GENERIC-DEFINITION :SYMBOL VARJO.INTERNALS:V-GLSL-STRING :FOREIGNP T :FUNCTION NIL :UPDATE-EXPANDER NIL :COMBINATION NIL :METHODS NIL)) :WRITERS NIL) #S(NET.DIDIERVERNA.DECLT::SLOT-DEFINITION :SYMBOL VARJO.INTERNALS::SIGNATURE :FOREIGNP NIL :SLOT #<SB-MOP:STANDARD-DIRECT-SLOT-DEFINITION VARJO.INTERNALS::SIGNATURE> :READERS (#S(NET.DIDIERVERNA.DECLT::GENERIC-DEFINITION :SYMBOL VARJO.INTERNALS::V-SIGNATURE :FOREIGNP T :FUNCTION NIL :UPDATE-EXPANDER NIL :COMBINATION NIL :METHODS NIL)) :WRITERS (#S(NET.DIDIERVERNA.DECLT::GENERIC-WRITER-DEFINITION :SYMBOL VARJO.INTERNALS::V-SIGNATURE :FOREIGNP T :FUNCTION NIL :UPDATE-EXPANDER NIL :COMBINATION NIL :METHODS NIL :READER NIL))) #S(NET.DIDIERVERNA.DECLT::SLOT-DEFINITION :SYMBOL VARJO.INTERNALS::SLOTS :FOREIGNP NIL :SLOT #<SB-MOP:STANDARD-DIRECT-SLOT-DEFINITION VARJO.INTERNALS::SLOTS> :READERS (#S(NET.DIDIERVERNA.DECLT::GENERIC-DEFINITION :SYMBOL VARJO.INTERNALS:V-SLOTS :FOREIGNP T :FUNCTION NIL :UPDATE-EXPANDER NIL :COMBINATION NIL :METHODS NIL)) :WRITERS NIL))) #S(NET.DIDIERVERNA.DECLT::CONTEXT :SYSTEMS (#<ASDF/SYSTEM:SYSTEM "cepl"> #<ASDF/SYSTEM:SYSTEM "cepl.build">) :PACKAGES (#<PACKAGE "CEPL"> #<PACKAGE "CEPL.PIPELINES"> #<PACKAGE "CEPL.COMPUTE"> #<PACKAGE "CEPL.QUERIES"> #<PACKAGE "CEPL.SYNC"> #<PACKAGE "CEPL.TRANSFORM-FEEDBACK"> #<PACKAGE "CEPL.SCISSOR"> #<PACKAGE "CEPL.STENCIL"> #<PACKAGE "CEPL.BLENDING"> #<PACKAGE "CEPL.FBOS"> #<PACKAGE "CEPL.RENDER-BUFFERS"> #<PACKAGE "CEPL.SAMPLERS"> ...) :EXTERNAL-DEFINITIONS #<HASH-TABLE :TEST EQUAL :COUNT 923 {100C2282E3}> :INTERNAL-DEFINITIONS #<HASH-TABLE :TEST EQUAL :COUNT 1067 {100CA00BE3}> :HYPERLINKSP NIL)) [fast-method]
19: (NET.DIDIERVERNA.DECLT::ADD-CATEGORY-NODE #1=#S(NET.DIDIERVERNA.DECLT::NODE :NAME "Internal definitions" :SYNOPSIS NIL :SECTION-TYPE :NUMBERED :SECTION-NAME NIL :NEXT NIL :PREVIOUS #2=#S(NET.DIDIERVERNA.DECLT::NODE :NAME "Exported definitions" :SYNOPSIS NIL :SECTION-TYPE :NUMBERED :SECTION-NAME NIL :NEXT #1# :PREVIOUS NIL :UP #3=#S(NET.DIDIERVERNA.DECLT::NODE :NAME "Definitions" :SYNOPSIS "The symbols documentation" :SECTION-TYPE :NUMBERED :SECTION-NAME NIL :NEXT NIL :PREVIOUS #4=#S(NET.DIDIERVERNA.DECLT::NODE :NAME "Packages" :SYNOPSIS "The packages documentation" :SECTION-TYPE :NUMBERED :SECTION-NAME NIL :NEXT #3# :PREVIOUS #S(NET.DIDIERVERNA.DECLT::NODE :NAME "Files" :SYNOPSIS "The files documentation" :SECTION-TYPE :NUMBERED :SECTION-NAME NIL :NEXT #4# :PREVIOUS # :UP #5=# :CHILDREN # :BEFORE-MENU-CONTENTS "Files are sorted by type and then listed depth-first from the systems
components trees." :AFTER-MENU-CONTENTS NIL) :UP #5# :CHILDREN (# # # # # # # # # # # # ...) :BEFORE-MENU-CONTENTS "Packages are listed by definition order." :AFTER-MENU-CONTENTS NIL) :UP #5# :CHILDREN (#2# #1#) :BEFORE-MENU-CONTENTS "Definitions are sorted by export status, category, package, and then by
lexicographic order." :AFTER-MENU-CONTENTS NIL) :CHILDREN (#6=#S(NET.DIDIERVERNA.DECLT::NODE :NAME "Exported constants" :SYNOPSIS NIL :SECTION-TYPE :NUMBERED :SECTION-NAME "Constants" :NEXT #7=#S(NET.DIDIERVERNA.DECLT::NODE :NAME "Exported special variables" :SYNOPSIS NIL :SECTION-TYPE :NUMBERED :SECTION-NAME "Special variables" :NEXT #8=# :PREVIOUS #6# :UP #2# :CHILDREN NIL :BEFORE-MENU-CONTENTS "@defvr {Special Variable} *bptc-compressed-formats*
@anchor{go to the CEPL<dot>IMAGE-FORMATS<colon><colon>*BPTC-COMPRESSED-FORMATS* special variable}@c
@specialsubindex{*bptc-compressed-formats*}@c

A list of all of OpenGL's bptc compressed formats
@table @strong
@item Package
@ref{go to the CEPL<dot>IMAGE-FORMATS package, , @t{cepl.image-formats}}
@item Source
@ref{go to the cepl/core/types/image-format<dot>lisp file, , @t{core/types/image-format.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *color-renderable-formats*
@anchor{go to the CEPL<dot>IMAGE-FORMATS<colon><colon>*COLOR-RENDERABLE-FORMATS* special variable}@c
@specialsubindex{*color-renderable-formats*}@c

A list of all of OpenGL's color renderable formats
@table @strong
@item Package
@ref{go to the CEPL<dot>IMAGE-FORMATS package, , @t{cepl.image-formats}}
@item Source
@ref{go to the cepl/core/types/image-format<dot>lisp file, , @t{core/types/image-format.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *depth-formats*
@anchor{go to the CEPL<dot>IMAGE-FORMATS<colon><colon>*DEPTH-FORMATS* special variable}@c
@specialsubindex{*depth-formats*}@c

A list of all of OpenGL's depth formats
@table @strong
@item Package
@ref{go to the CEPL<dot>IMAGE-FORMATS package, , @t{cepl.image-formats}}
@item Source
@ref{go to the cepl/core/types/image-format<dot>lisp file, , @t{core/types/image-format.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *depth-stencil-formats*
@anchor{go to the CEPL<dot>IMAGE-FORMATS<colon><colon>*DEPTH-STENCIL-FORMATS* special variable}@c
@specialsubindex{*depth-stencil-formats*}@c

A list of all of OpenGL's depth stencil formats
@table @strong
@item Package
@ref{go to the CEPL<dot>IMAGE-FORMATS package, , @t{cepl.image-formats}}
@item Source
@ref{go to the cepl/core/types/image-format<dot>lisp file, , @t{core/types/image-format.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *floating-point-formats*
@anchor{go to the CEPL<dot>IMAGE-FORMATS<colon><colon>*FLOATING-POINT-FORMATS* special variable}@c
@specialsubindex{*floating-point-formats*}@c

A list of all of OpenGL's floating point formats
@table @strong
@item Package
@ref{go to the CEPL<dot>IMAGE-FORMATS package, , @t{cepl.image-formats}}
@item Source
@ref{go to the cepl/core/types/image-format<dot>lisp file, , @t{core/types/image-format.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *image-formats*
@anchor{go to the CEPL<dot>IMAGE-FORMATS<colon><colon>*IMAGE-FORMATS* special variable}@c
@specialsubindex{*image-formats*}@c

A list of all of OpenGL's image formats
@table @strong
@item Package
@ref{go to the CEPL<dot>IMAGE-FORMATS package, , @t{cepl.image-formats}}
@item Source
@ref{go to the cepl/core/types/image-format<dot>lisp file, , @t{core/types/image-format.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *immutable-available*
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>*IMMUTABLE-AVAILABLE* special variable}@c
@specialsubindex{*immutable-available*}@c

After CEPL has been initialized this variable will hold t if immutable `texture`
storage is available and nil if not.@*

Immutable texture storage does not mean that the texture's `gpu-array` data is
immutable. It means that the underlying format of the texture data cannot be
changed. It is rare that you would want mutable storage and when you do, it is
very hard to not create 'incomplete-textures'.
https://www.opengl.org/wiki/Immutable_Storage_Texture#Texture_completeness@*

CEPL tries to make only complete textures so this is not a concern. If you do
need this level of control, please raise a github issue as I would love to
understand your usecase.
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *red/green-compressed-formats*
@anchor{go to the CEPL<dot>IMAGE-FORMATS<colon><colon>*RED/GREEN-COMPRESSED-FORMATS* special variable}@c
@specialsubindex{*red/green-compressed-formats*}@c

A list of all of OpenGL's red/green compressed formats
@table @strong
@item Package
@ref{go to the CEPL<dot>IMAGE-FORMATS package, , @t{cepl.image-formats}}
@item Source
@ref{go to the cepl/core/types/image-format<dot>lisp file, , @t{core/types/image-format.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *regular-color-formats*
@anchor{go to the CEPL<dot>IMAGE-FORMATS<colon><colon>*REGULAR-COLOR-FORMATS* special variable}@c
@specialsubindex{*regular-color-formats*}@c

A list of all of OpenGL's regular color formats
@table @strong
@item Package
@ref{go to the CEPL<dot>IMAGE-FORMATS package, , @t{cepl.image-formats}}
@item Source
@ref{go to the cepl/core/types/image-format<dot>lisp file, , @t{core/types/image-format.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *s3tc/dxt-compessed-formats*
@anchor{go to the CEPL<dot>IMAGE-FORMATS<colon><colon>*S3TC/DXT-COMPESSED-FORMATS* special variable}@c
@specialsubindex{*s3tc/dxt-compessed-formats*}@c

A list of all of OpenGL's s3tc/dxt compessed formats
@table @strong
@item Package
@ref{go to the CEPL<dot>IMAGE-FORMATS package, , @t{cepl.image-formats}}
@item Source
@ref{go to the cepl/core/types/image-format<dot>lisp file, , @t{core/types/image-format.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *signed-integral-formats*
@anchor{go to the CEPL<dot>IMAGE-FORMATS<colon><colon>*SIGNED-INTEGRAL-FORMATS* special variable}@c
@specialsubindex{*signed-integral-formats*}@c

A list of all of OpenGL's signed integral formats
@table @strong
@item Package
@ref{go to the CEPL<dot>IMAGE-FORMATS package, , @t{cepl.image-formats}}
@item Source
@ref{go to the cepl/core/types/image-format<dot>lisp file, , @t{core/types/image-format.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *signed-normalized-integer-formats*
@anchor{go to the CEPL<dot>IMAGE-FORMATS<colon><colon>*SIGNED-NORMALIZED-INTEGER-FORMATS* special variable}@c
@specialsubindex{*signed-normalized-integer-formats*}@c

A list of all of OpenGL's signed normalized integer formats
@table @strong
@item Package
@ref{go to the CEPL<dot>IMAGE-FORMATS package, , @t{cepl.image-formats}}
@item Source
@ref{go to the cepl/core/types/image-format<dot>lisp file, , @t{core/types/image-format.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *special-color-formats*
@anchor{go to the CEPL<dot>IMAGE-FORMATS<colon><colon>*SPECIAL-COLOR-FORMATS* special variable}@c
@specialsubindex{*special-color-formats*}@c

A list of all of OpenGL's special color formats
@table @strong
@item Package
@ref{go to the CEPL<dot>IMAGE-FORMATS package, , @t{cepl.image-formats}}
@item Source
@ref{go to the cepl/core/types/image-format<dot>lisp file, , @t{core/types/image-format.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *srgb-color-formats*
@anchor{go to the CEPL<dot>IMAGE-FORMATS<colon><colon>*SRGB-COLOR-FORMATS* special variable}@c
@specialsubindex{*srgb-color-formats*}@c

A list of all of OpenGL's srgb color formats
@table @strong
@item Package
@ref{go to the CEPL<dot>IMAGE-FORMATS package, , @t{cepl.image-formats}}
@item Source
@ref{go to the cepl/core/types/image-format<dot>lisp file, , @t{core/types/image-format.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *stencil-formats*
@anchor{go to the CEPL<dot>IMAGE-FORMATS<colon><colon>*STENCIL-FORMATS* special variable}@c
@specialsubindex{*stencil-formats*}@c

A list of all of OpenGL's stencil formats
@table @strong
@item Package
@ref{go to the CEPL<dot>IMAGE-FORMATS package, , @t{cepl.image-formats}}
@item Source
@ref{go to the cepl/core/types/image-format<dot>lisp file, , @t{core/types/image-format.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *unsigned-integral-formats*
@anchor{go to the CEPL<dot>IMAGE-FORMATS<colon><colon>*UNSIGNED-INTEGRAL-FORMATS* special variable}@c
@specialsubindex{*unsigned-integral-formats*}@c

A list of all of OpenGL's unsigned integral formats
@table @strong
@item Package
@ref{go to the CEPL<dot>IMAGE-FORMATS package, , @t{cepl.image-formats}}
@item Source
@ref{go to the cepl/core/types/image-format<dot>lisp file, , @t{core/types/image-format.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *unsigned-normalized-integer-formats*
@anchor{go to the CEPL<dot>IMAGE-FORMATS<colon><colon>*UNSIGNED-NORMALIZED-INTEGER-FORMATS* special variable}@c
@specialsubindex{*unsigned-normalized-integer-formats*}@c

A list of all of OpenGL's unsigned normalized integer formats
@table @strong
@item Package
@ref{go to the CEPL<dot>IMAGE-FORMATS package, , @t{cepl.image-formats}}
@item Source
@ref{go to the cepl/core/types/image-format<dot>lisp file, , @t{core/types/image-format.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *valid-image-formats-for-buffer-backed-texture*
@anchor{go to the CEPL<dot>IMAGE-FORMATS<colon><colon>*VALID-IMAGE-FORMATS-FOR-BUFFER-BACKED-TEXTURE* special variable}@c
@specialsubindex{*valid-image-formats-for-buffer-backed-texture*}@c

A list of all of OpenGL's valid image formats for buffer backed texture
@table @strong
@item Package
@ref{go to the CEPL<dot>IMAGE-FORMATS package, , @t{cepl.image-formats}}
@item Source
@ref{go to the cepl/core/types/image-format<dot>lisp file, , @t{core/types/image-format.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} +null-buffer-backed-gpu-array+
@anchor{go to the %CEPL<dot>TYPES<colon><colon>+NULL-BUFFER-BACKED-GPU-ARRAY+ special variable}@c
@specialsubindex{+null-buffer-backed-gpu-array+}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/nulls-and-uninitialized<dot>lisp file, , @t{core/types/nulls-and-uninitialized.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} +null-fbo+
@anchor{go to the %CEPL<dot>TYPES<colon><colon>+NULL-FBO+ special variable}@c
@specialsubindex{+null-fbo+}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/nulls-and-uninitialized<dot>lisp file, , @t{core/types/nulls-and-uninitialized.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} +null-gpu-buffer+
@anchor{go to the %CEPL<dot>TYPES<colon><colon>+NULL-GPU-BUFFER+ special variable}@c
@specialsubindex{+null-gpu-buffer+}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/nulls-and-uninitialized<dot>lisp file, , @t{core/types/nulls-and-uninitialized.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} +null-texture+
@anchor{go to the %CEPL<dot>TYPES<colon><colon>+NULL-TEXTURE+ special variable}@c
@specialsubindex{+null-texture+}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/nulls-and-uninitialized<dot>lisp file, , @t{core/types/nulls-and-uninitialized.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} +null-texture-backed-gpu-array+
@anchor{go to the %CEPL<dot>TYPES<colon><colon>+NULL-TEXTURE-BACKED-GPU-ARRAY+ special variable}@c
@specialsubindex{+null-texture-backed-gpu-array+}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/nulls-and-uninitialized<dot>lisp file, , @t{core/types/nulls-and-uninitialized.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} +null-vao+
@anchor{go to the %CEPL<dot>TYPES<colon><colon>+NULL-VAO+ special variable}@c
@specialsubindex{+null-vao+}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/nulls-and-uninitialized<dot>lisp file, , @t{core/types/nulls-and-uninitialized.lisp}} (file)
@end table
@end defvr
" :AFTER-MENU-CONTENTS NIL) :PREVIOUS NIL :UP #2# :CHILDREN NIL :BEFORE-MENU-CONTENTS "@defvr {Constant} +gl-id-bit-size+
@anchor{go to the %CEPL<dot>TYPES<colon><colon>+GL-ID-BIT-SIZE+ constant}@c
@constantsubindex{+gl-id-bit-size+}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end defvr
@defvr {Constant} +max-context-count+
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>+MAX-CONTEXT-COUNT+ constant}@c
@constantsubindex{+max-context-count+}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end defvr
@defvr {Constant} +null-gl-id+
@anchor{go to the %CEPL<dot>TYPES<colon><colon>+NULL-GL-ID+ constant}@c
@constantsubindex{+null-gl-id+}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end defvr
@defvr {Constant} +unknown-gl-id+
@anchor{go to the %CEPL<dot>TYPES<colon><colon>+UNKNOWN-GL-ID+ constant}@c
@constantsubindex{+unknown-gl-id+}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end defvr
" :AFTER-MENU-CONTENTS NIL) #7# #8# #9=#S(NET.DIDIERVERNA.DECLT::NODE :NAME "Exported compiler macros" :SYNOPSIS NIL :SECTION-TYPE :NUMBERED :SECTION-NAME "Compiler macros" :NEXT #10=#S(NET.DIDIERVERNA.DECLT::NODE :NAME "Exported functions" :SYNOPSIS NIL :SECTION-TYPE :NUMBERED :SECTION-NAME "Functions" :NEXT #11=# :PREVIOUS #9# :UP #2# :CHILDREN NIL :BEFORE-MENU-CONTENTS "@deffn {Function} {%%make-buffer-texture} &key (ID ID) (CACHE-ID CACHE-ID) (BASE-DIMENSIONS BASE-DIMENSIONS) (TYPE TYPE) (IMAGE-FORMAT IMAGE-FORMAT) (MIPMAP-LEVELS MIPMAP-LEVELS) (LAYER-COUNT LAYER-COUNT) (CUBES-P CUBES-P) (ALLOCATED-P ALLOCATED-P) (MUTABLE-P MUTABLE-P) (SAMPLES SAMPLES) (FIXED-SAMPLE-LOCATIONS-P FIXED-SAMPLE-LOCATIONS-P) (LAST-SAMPLER-ID LAST-SAMPLER-ID) (BACKING-ARRAY BACKING-ARRAY) (OWNS-ARRAY OWNS-ARRAY)
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%%MAKE-BUFFER-TEXTURE function}@c
@functionsubindex{%%make-buffer-texture}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%%make-fbo} &key (ID ID) (EMPTY-PARAMS EMPTY-PARAMS) (COLOR-ARRAYS COLOR-ARRAYS) (DEPTH-ARRAY DEPTH-ARRAY) (STENCIL-ARRAY STENCIL-ARRAY) (DRAW-BUFFER-MAP DRAW-BUFFER-MAP) (CLEAR-MASK CLEAR-MASK) (IS-DEFAULT IS-DEFAULT) (ATTACHMENT-COUNT ATTACHMENT-COUNT) (BLENDING-PARAMS BLENDING-PARAMS)
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%%MAKE-FBO function}@c
@functionsubindex{%%make-fbo}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%%make-texture} &key (ID ID) (CACHE-ID CACHE-ID) (BASE-DIMENSIONS BASE-DIMENSIONS) (TYPE TYPE) (IMAGE-FORMAT IMAGE-FORMAT) (MIPMAP-LEVELS MIPMAP-LEVELS) (LAYER-COUNT LAYER-COUNT) (CUBES-P CUBES-P) (ALLOCATED-P ALLOCATED-P) (MUTABLE-P MUTABLE-P) (SAMPLES SAMPLES) (FIXED-SAMPLE-LOCATIONS-P FIXED-SAMPLE-LOCATIONS-P) (LAST-SAMPLER-ID LAST-SAMPLER-ID)
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%%MAKE-TEXTURE function}@c
@functionsubindex{%%make-texture}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%empty-fbo-params-dimensions} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%EMPTY-FBO-PARAMS-DIMENSIONS function}@c
@functionsubindex{%empty-fbo-params-dimensions}@c
@deffnx {Function} {(setf %empty-fbo-params-dimensions)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %EMPTY-FBO-PARAMS-DIMENSIONS) function}@c
@functionsubindex{(setf %empty-fbo-params-dimensions)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%empty-fbo-params-fbo} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%EMPTY-FBO-PARAMS-FBO function}@c
@functionsubindex{%empty-fbo-params-fbo}@c
@deffnx {Function} {(setf %empty-fbo-params-fbo)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %EMPTY-FBO-PARAMS-FBO) function}@c
@functionsubindex{(setf %empty-fbo-params-fbo)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%empty-fbo-params-fixed-sample-locations-p} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%EMPTY-FBO-PARAMS-FIXED-SAMPLE-LOCATIONS-P function}@c
@functionsubindex{%empty-fbo-params-fixed-sample-locations-p}@c
@deffnx {Function} {(setf %empty-fbo-params-fixed-sample-locations-p)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %EMPTY-FBO-PARAMS-FIXED-SAMPLE-LOCATIONS-P) function}@c
@functionsubindex{(setf %empty-fbo-params-fixed-sample-locations-p)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%empty-fbo-params-layer-count} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%EMPTY-FBO-PARAMS-LAYER-COUNT function}@c
@functionsubindex{%empty-fbo-params-layer-count}@c
@deffnx {Function} {(setf %empty-fbo-params-layer-count)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %EMPTY-FBO-PARAMS-LAYER-COUNT) function}@c
@functionsubindex{(setf %empty-fbo-params-layer-count)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%empty-fbo-params-samples} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%EMPTY-FBO-PARAMS-SAMPLES function}@c
@functionsubindex{%empty-fbo-params-samples}@c
@deffnx {Function} {(setf %empty-fbo-params-samples)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %EMPTY-FBO-PARAMS-SAMPLES) function}@c
@functionsubindex{(setf %empty-fbo-params-samples)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%empty-fbo-params-viewport} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%EMPTY-FBO-PARAMS-VIEWPORT function}@c
@functionsubindex{%empty-fbo-params-viewport}@c
@deffnx {Function} {(setf %empty-fbo-params-viewport)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %EMPTY-FBO-PARAMS-VIEWPORT) function}@c
@functionsubindex{(setf %empty-fbo-params-viewport)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%fbo-attachment-count} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%FBO-ATTACHMENT-COUNT function}@c
@functionsubindex{%fbo-attachment-count}@c
@deffnx {Function} {(setf %fbo-attachment-count)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %FBO-ATTACHMENT-COUNT) function}@c
@functionsubindex{(setf %fbo-attachment-count)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%fbo-blending-params} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%FBO-BLENDING-PARAMS function}@c
@functionsubindex{%fbo-blending-params}@c
@deffnx {Function} {(setf %fbo-blending-params)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %FBO-BLENDING-PARAMS) function}@c
@functionsubindex{(setf %fbo-blending-params)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%fbo-clear-mask} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%FBO-CLEAR-MASK function}@c
@functionsubindex{%fbo-clear-mask}@c
@deffnx {Function} {(setf %fbo-clear-mask)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %FBO-CLEAR-MASK) function}@c
@functionsubindex{(setf %fbo-clear-mask)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%fbo-color-arrays} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%FBO-COLOR-ARRAYS function}@c
@functionsubindex{%fbo-color-arrays}@c
@deffnx {Function} {(setf %fbo-color-arrays)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %FBO-COLOR-ARRAYS) function}@c
@functionsubindex{(setf %fbo-color-arrays)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%fbo-depth-array} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%FBO-DEPTH-ARRAY function}@c
@functionsubindex{%fbo-depth-array}@c
@deffnx {Function} {(setf %fbo-depth-array)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %FBO-DEPTH-ARRAY) function}@c
@functionsubindex{(setf %fbo-depth-array)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%fbo-draw-buffer-map} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%FBO-DRAW-BUFFER-MAP function}@c
@functionsubindex{%fbo-draw-buffer-map}@c
@deffnx {Function} {(setf %fbo-draw-buffer-map)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %FBO-DRAW-BUFFER-MAP) function}@c
@functionsubindex{(setf %fbo-draw-buffer-map)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%fbo-empty-params} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%FBO-EMPTY-PARAMS function}@c
@functionsubindex{%fbo-empty-params}@c
@deffnx {Function} {(setf %fbo-empty-params)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %FBO-EMPTY-PARAMS) function}@c
@functionsubindex{(setf %fbo-empty-params)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%fbo-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%FBO-ID function}@c
@functionsubindex{%fbo-id}@c
@deffnx {Function} {(setf %fbo-id)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %FBO-ID) function}@c
@functionsubindex{(setf %fbo-id)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%fbo-is-default} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%FBO-IS-DEFAULT function}@c
@functionsubindex{%fbo-is-default}@c
@deffnx {Function} {(setf %fbo-is-default)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %FBO-IS-DEFAULT) function}@c
@functionsubindex{(setf %fbo-is-default)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%fbo-stencil-array} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%FBO-STENCIL-ARRAY function}@c
@functionsubindex{%fbo-stencil-array}@c
@deffnx {Function} {(setf %fbo-stencil-array)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %FBO-STENCIL-ARRAY) function}@c
@functionsubindex{(setf %fbo-stencil-array)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%gpu-fence-obj} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%GPU-FENCE-OBJ function}@c
@functionsubindex{%gpu-fence-obj}@c
@deffnx {Function} {(setf %gpu-fence-obj)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %GPU-FENCE-OBJ) function}@c
@functionsubindex{(setf %gpu-fence-obj)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%make-c-array} &key (POINTER POINTER) (DIMENSIONS DIMENSIONS) (TOTAL-SIZE TOTAL-SIZE) (ELEMENT-TYPE ELEMENT-TYPE) (SIZES SIZES) (ROW-ALIGNMENT ROW-ALIGNMENT) (STRUCT-ELEMENT-TYPEP STRUCT-ELEMENT-TYPEP) (ELEMENT-PIXEL-FORMAT ELEMENT-PIXEL-FORMAT) (ELEMENT-FROM-FOREIGN ELEMENT-FROM-FOREIGN) (ELEMENT-TO-FOREIGN ELEMENT-TO-FOREIGN) (FREE FREE)
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%MAKE-C-ARRAY function}@c
@functionsubindex{%make-c-array}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%make-gpu-array} &key (DIMENSIONS DIMENSIONS)
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%MAKE-GPU-ARRAY function}@c
@functionsubindex{%make-gpu-array}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%make-gpu-array-bb} &key (DIMENSIONS DIMENSIONS) (BUFFER BUFFER) (ACCESS-STYLE ACCESS-STYLE) (ELEMENT-TYPE ELEMENT-TYPE) (BYTE-SIZE BYTE-SIZE) (ELEMENT-BYTE-SIZE ELEMENT-BYTE-SIZE) (OFFSET-IN-BYTES-INTO-BUFFER OFFSET-IN-BYTES-INTO-BUFFER) (ELEMENT-PIXEL-FORMAT ELEMENT-PIXEL-FORMAT) (ROW-ALIGNMENT ROW-ALIGNMENT)
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%MAKE-GPU-ARRAY-BB function}@c
@functionsubindex{%make-gpu-array-bb}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%make-gpu-array-t} &key (DIMENSIONS DIMENSIONS) (TEXTURE TEXTURE) (TEXTURE-TYPE TEXTURE-TYPE) (LEVEL-NUM LEVEL-NUM) (LAYER-NUM LAYER-NUM) (FACE-NUM FACE-NUM) (IMAGE-FORMAT IMAGE-FORMAT)
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%MAKE-GPU-ARRAY-T function}@c
@functionsubindex{%make-gpu-array-t}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%make-gpu-buffer} &key (ID ID) (CACHE-ID CACHE-ID) (ARRAYS ARRAYS)
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%MAKE-GPU-BUFFER function}@c
@functionsubindex{%make-gpu-buffer}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%make-gpu-fence} OBJ
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%MAKE-GPU-FENCE function}@c
@functionsubindex{%make-gpu-fence}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%make-render-buffer} &key (ID ID) (IMAGE-FORMAT IMAGE-FORMAT) (RESOLUTION RESOLUTION) (MULTISAMPLE-P MULTISAMPLE-P)
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%MAKE-RENDER-BUFFER function}@c
@functionsubindex{%make-render-buffer}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%make-sampler} &key (CONTEXT-ID CONTEXT-ID) (ID-BOX ID-BOX) (TYPE TYPE) (TEXTURE TEXTURE) (LOD-BIAS LOD-BIAS) (MIN-LOD MIN-LOD) (MAX-LOD MAX-LOD) (BORDER-COLOR BORDER-COLOR) (EXPECTS-MIPMAP EXPECTS-MIPMAP) (MINIFY-FILTER MINIFY-FILTER) (MAGNIFY-FILTER MAGNIFY-FILTER) (WRAP WRAP) (EXPECTS-DEPTH EXPECTS-DEPTH) (COMPARE COMPARE)
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%MAKE-SAMPLER function}@c
@functionsubindex{%make-sampler}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%make-ssbo} &key (ID ID) (DATA DATA) (INDEX INDEX) (OWNS-GPU-ARRAY OWNS-GPU-ARRAY)
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%MAKE-SSBO function}@c
@functionsubindex{%make-ssbo}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%make-stencil-params} &key (TEST TEST) (VALUE VALUE) (MASK MASK) (ON-STENCIL-TEST-FAIL ON-STENCIL-TEST-FAIL) (ON-STENCIL-PASS-DEPTH-TEST-FAIL ON-STENCIL-PASS-DEPTH-TEST-FAIL) (ON-STENCIL-PASS-DEPTH-TEST-PASS ON-STENCIL-PASS-DEPTH-TEST-PASS)
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%MAKE-STENCIL-PARAMS function}@c
@functionsubindex{%make-stencil-params}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%make-tfs} &key (ARRAYS ARRAYS) (PENDING-ARRAYS PENDING-ARRAYS) (BOUND BOUND) (CURRENT-PROG-ID CURRENT-PROG-ID)
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%MAKE-TFS function}@c
@functionsubindex{%make-tfs}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%make-ubo} &key (ID ID) (DATA DATA) (INDEX INDEX) (OWNS-GPU-ARRAY OWNS-GPU-ARRAY)
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%MAKE-UBO function}@c
@functionsubindex{%make-ubo}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%make-viewport} &key (RESOLUTION-X RESOLUTION-X) (RESOLUTION-Y RESOLUTION-Y) (ORIGIN-X ORIGIN-X) (ORIGIN-Y ORIGIN-Y)
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%MAKE-VIEWPORT function}@c
@functionsubindex{%make-viewport}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%render-buffer-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%RENDER-BUFFER-ID function}@c
@functionsubindex{%render-buffer-id}@c
@deffnx {Function} {(setf %render-buffer-id)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %RENDER-BUFFER-ID) function}@c
@functionsubindex{(setf %render-buffer-id)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%render-buffer-image-format} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%RENDER-BUFFER-IMAGE-FORMAT function}@c
@functionsubindex{%render-buffer-image-format}@c
@deffnx {Function} {(setf %render-buffer-image-format)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %RENDER-BUFFER-IMAGE-FORMAT) function}@c
@functionsubindex{(setf %render-buffer-image-format)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%render-buffer-multisample-p} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%RENDER-BUFFER-MULTISAMPLE-P function}@c
@functionsubindex{%render-buffer-multisample-p}@c
@deffnx {Function} {(setf %render-buffer-multisample-p)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %RENDER-BUFFER-MULTISAMPLE-P) function}@c
@functionsubindex{(setf %render-buffer-multisample-p)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%render-buffer-resolution} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%RENDER-BUFFER-RESOLUTION function}@c
@functionsubindex{%render-buffer-resolution}@c
@deffnx {Function} {(setf %render-buffer-resolution)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %RENDER-BUFFER-RESOLUTION) function}@c
@functionsubindex{(setf %render-buffer-resolution)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%sampler-border-color} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-BORDER-COLOR function}@c
@functionsubindex{%sampler-border-color}@c
@deffnx {Function} {(setf %sampler-border-color)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-BORDER-COLOR) function}@c
@functionsubindex{(setf %sampler-border-color)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%sampler-compare} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-COMPARE function}@c
@functionsubindex{%sampler-compare}@c
@deffnx {Function} {(setf %sampler-compare)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-COMPARE) function}@c
@functionsubindex{(setf %sampler-compare)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%sampler-expects-depth} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-EXPECTS-DEPTH function}@c
@functionsubindex{%sampler-expects-depth}@c
@deffnx {Function} {(setf %sampler-expects-depth)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-EXPECTS-DEPTH) function}@c
@functionsubindex{(setf %sampler-expects-depth)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%sampler-expects-mipmap} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-EXPECTS-MIPMAP function}@c
@functionsubindex{%sampler-expects-mipmap}@c
@deffnx {Function} {(setf %sampler-expects-mipmap)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-EXPECTS-MIPMAP) function}@c
@functionsubindex{(setf %sampler-expects-mipmap)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%sampler-id} SAMPLER
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-ID function}@c
@functionsubindex{%sampler-id}@c
@deffnx {Function} {(setf %sampler-id)} VALUE SAMPLER
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-ID) function}@c
@functionsubindex{(setf %sampler-id)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%sampler-id-box} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-ID-BOX function}@c
@functionsubindex{%sampler-id-box}@c
@deffnx {Function} {(setf %sampler-id-box)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-ID-BOX) function}@c
@functionsubindex{(setf %sampler-id-box)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%sampler-lod-bias} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-LOD-BIAS function}@c
@functionsubindex{%sampler-lod-bias}@c
@deffnx {Function} {(setf %sampler-lod-bias)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-LOD-BIAS) function}@c
@functionsubindex{(setf %sampler-lod-bias)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%sampler-magnify-filter} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-MAGNIFY-FILTER function}@c
@functionsubindex{%sampler-magnify-filter}@c
@deffnx {Function} {(setf %sampler-magnify-filter)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-MAGNIFY-FILTER) function}@c
@functionsubindex{(setf %sampler-magnify-filter)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%sampler-max-lod} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-MAX-LOD function}@c
@functionsubindex{%sampler-max-lod}@c
@deffnx {Function} {(setf %sampler-max-lod)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-MAX-LOD) function}@c
@functionsubindex{(setf %sampler-max-lod)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%sampler-min-lod} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-MIN-LOD function}@c
@functionsubindex{%sampler-min-lod}@c
@deffnx {Function} {(setf %sampler-min-lod)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-MIN-LOD) function}@c
@functionsubindex{(setf %sampler-min-lod)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%sampler-minify-filter} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-MINIFY-FILTER function}@c
@functionsubindex{%sampler-minify-filter}@c
@deffnx {Function} {(setf %sampler-minify-filter)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-MINIFY-FILTER) function}@c
@functionsubindex{(setf %sampler-minify-filter)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%sampler-texture} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-TEXTURE function}@c
@functionsubindex{%sampler-texture}@c
@deffnx {Function} {(setf %sampler-texture)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-TEXTURE) function}@c
@functionsubindex{(setf %sampler-texture)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%sampler-type} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-TYPE function}@c
@functionsubindex{%sampler-type}@c
@deffnx {Function} {(setf %sampler-type)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-TYPE) function}@c
@functionsubindex{(setf %sampler-type)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%sampler-wrap} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-WRAP function}@c
@functionsubindex{%sampler-wrap}@c
@deffnx {Function} {(setf %sampler-wrap)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-WRAP) function}@c
@functionsubindex{(setf %sampler-wrap)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%stencil-params-mask} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%STENCIL-PARAMS-MASK function}@c
@functionsubindex{%stencil-params-mask}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%stencil-params-on-stencil-pass-depth-test-fail} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%STENCIL-PARAMS-ON-STENCIL-PASS-DEPTH-TEST-FAIL function}@c
@functionsubindex{%stencil-params-on-stencil-pass-depth-test-fail}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%stencil-params-on-stencil-pass-depth-test-pass} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%STENCIL-PARAMS-ON-STENCIL-PASS-DEPTH-TEST-PASS function}@c
@functionsubindex{%stencil-params-on-stencil-pass-depth-test-pass}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%stencil-params-on-stencil-test-fail} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%STENCIL-PARAMS-ON-STENCIL-TEST-FAIL function}@c
@functionsubindex{%stencil-params-on-stencil-test-fail}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%stencil-params-test} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%STENCIL-PARAMS-TEST function}@c
@functionsubindex{%stencil-params-test}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%stencil-params-value} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%STENCIL-PARAMS-VALUE function}@c
@functionsubindex{%stencil-params-value}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%tfs-arrays} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%TFS-ARRAYS function}@c
@functionsubindex{%tfs-arrays}@c
@deffnx {Function} {(setf %tfs-arrays)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %TFS-ARRAYS) function}@c
@functionsubindex{(setf %tfs-arrays)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%tfs-bound} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%TFS-BOUND function}@c
@functionsubindex{%tfs-bound}@c
@deffnx {Function} {(setf %tfs-bound)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %TFS-BOUND) function}@c
@functionsubindex{(setf %tfs-bound)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%tfs-current-prog-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%TFS-CURRENT-PROG-ID function}@c
@functionsubindex{%tfs-current-prog-id}@c
@deffnx {Function} {(setf %tfs-current-prog-id)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %TFS-CURRENT-PROG-ID) function}@c
@functionsubindex{(setf %tfs-current-prog-id)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%tfs-pending-arrays} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%TFS-PENDING-ARRAYS function}@c
@functionsubindex{%tfs-pending-arrays}@c
@deffnx {Function} {(setf %tfs-pending-arrays)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %TFS-PENDING-ARRAYS) function}@c
@functionsubindex{(setf %tfs-pending-arrays)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%viewport-origin-x} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%VIEWPORT-ORIGIN-X function}@c
@functionsubindex{%viewport-origin-x}@c
@deffnx {Function} {(setf %viewport-origin-x)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %VIEWPORT-ORIGIN-X) function}@c
@functionsubindex{(setf %viewport-origin-x)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%viewport-origin-y} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%VIEWPORT-ORIGIN-Y function}@c
@functionsubindex{%viewport-origin-y}@c
@deffnx {Function} {(setf %viewport-origin-y)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %VIEWPORT-ORIGIN-Y) function}@c
@functionsubindex{(setf %viewport-origin-y)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%viewport-resolution-x} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%VIEWPORT-RESOLUTION-X function}@c
@functionsubindex{%viewport-resolution-x}@c
@deffnx {Function} {(setf %viewport-resolution-x)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %VIEWPORT-RESOLUTION-X) function}@c
@functionsubindex{(setf %viewport-resolution-x)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%viewport-resolution-y} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%VIEWPORT-RESOLUTION-Y function}@c
@functionsubindex{%viewport-resolution-y}@c
@deffnx {Function} {(setf %viewport-resolution-y)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %VIEWPORT-RESOLUTION-Y) function}@c
@functionsubindex{(setf %viewport-resolution-y)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {1d-p} OBJECT
@anchor{go to the CEPL<dot>INTERNALS<colon><colon>1D-P function}@c
@functionsubindex{1d-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>INTERNALS package, , @t{cepl.internals}}
@item Source
@ref{go to the cepl/core/internals<dot>lisp file, , @t{core/internals.lisp}} (file)
@end table
@end deffn
@deffn {Function} {across-c-ptr} FUNCTION C-ARRAY
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>ACROSS-C-PTR function}@c
@functionsubindex{across-c-ptr}@c

This function takes two arguments:@*

- A function that takes a pointer and a (unsigned-byte 32)@*
- A `c-array`@*

`across-c-ptr` will then call the given function once for every element in the
c-array passing in the pointer to an element of the array and the index to that
element.
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/map<dot>lisp file, , @t{core/c-arrays/map.lisp}} (file)
@end table
@end deffn
@deffn {Function} {active-texture-num} NUM
@anchor{go to the %CEPL<dot>TYPES<colon><colon>ACTIVE-TEXTURE-NUM function}@c
@functionsubindex{active-texture-num}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {add-surface} CONTEXT &key TITLE WIDTH HEIGHT FULLSCREEN RESIZABLE NO-FRAME HIDDEN MAKE-CURRENT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>ADD-SURFACE function}@c
@functionsubindex{add-surface}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/surface<dot>lisp file, , @t{core/context/surface.lisp}} (file)
@end table
@end deffn
@deffn {Function} {adjust-gpu-array} BUFFER-BACKED-GPU-ARRAY NEW-DIMENSIONS &key INITIAL-CONTENTS ACCESS-STYLE ROW-ALIGNMENT
@anchor{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED<colon><colon>ADJUST-GPU-ARRAY function}@c
@functionsubindex{adjust-gpu-array}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED package, , @t{cepl.gpu-arrays.buffer-backed}}
@item Source
@ref{go to the cepl/core/gpu-arrays/buffer-backed<dot>lisp file, , @t{core/gpu-arrays/buffer-backed.lisp}} (file)
@end table
@end deffn
@deffn {Function} {always} INCOMING-VAL STORED-VAL
@anchor{go to the CEPL<dot>DOCUMENTATION-FUNCTIONS<colon><colon>ALWAYS function}@c
@functionsubindex{always}@c
Always passes
@table @strong
@item Package
@ref{go to the CEPL<dot>DOCUMENTATION-FUNCTIONS package, , @t{cepl.documentation-functions}}
@item Source
@ref{go to the cepl/core/context/documentation-functions<dot>lisp file, , @t{core/context/documentation-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {arange} X &optional Y Z U V
@anchor{go to the CEPL-UTILS<colon><colon>ARANGE function}@c
@functionsubindex{arange}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {arangei} X &optional Y Z U V
@anchor{go to the CEPL-UTILS<colon><colon>ARANGEI function}@c
@functionsubindex{arangei}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {aref-c} C-ARRAY &rest SUBSCRIPTS
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>AREF-C function}@c
@functionsubindex{aref-c}@c

Accesses the `c-array` element specified by the subscripts
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/aref-c<dot>lisp file, , @t{core/c-arrays/aref-c.lisp}} (file)
@item Writer
@ref{go to the CEPL<dot>C-ARRAYS<colon><colon>(SETF AREF-C) function, , @t{(setf aref-c)}} (function)
@end table
@end deffn
@deffn {Function} {(setf aref-c)} VALUE C-ARRAY &rest SUBSCRIPTS
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>(SETF AREF-C) function}@c
@functionsubindex{(setf aref-c)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/aref-c<dot>lisp file, , @t{core/c-arrays/aref-c.lisp}} (file)
@item Reader
@ref{go to the CEPL<dot>C-ARRAYS<colon><colon>AREF-C function, , @t{aref-c}} (function)
@end table
@end deffn
@deffn {Function} {aref-c*} C-ARRAY SUBSCRIPTS
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>AREF-C* function}@c
@functionsubindex{aref-c*}@c

Accesses the `c-array` element specified by the subscripts.@*

The difference between this and `aref-c` is that this this function takes the
subscripts as a list.
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/aref-c<dot>lisp file, , @t{core/c-arrays/aref-c.lisp}} (file)
@item Writer
@ref{go to the CEPL<dot>C-ARRAYS<colon><colon>(SETF AREF-C*) function, , @t{(setf aref-c*)}} (function)
@end table
@end deffn
@deffn {Function} {(setf aref-c*)} VALUE C-ARRAY SUBSCRIPTS
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>(SETF AREF-C*) function}@c
@functionsubindex{(setf aref-c*)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/aref-c<dot>lisp file, , @t{core/c-arrays/aref-c.lisp}} (file)
@item Reader
@ref{go to the CEPL<dot>C-ARRAYS<colon><colon>AREF-C* function, , @t{aref-c*}} (function)
@end table
@end deffn
@deffn {Function} {arrays-indirect-command-base-instance} WRAPPED-OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ARRAYS-INDIRECT-COMMAND-BASE-INSTANCE function}@c
@functionsubindex{arrays-indirect-command-base-instance}@c
@deffnx {Function} {(setf arrays-indirect-command-base-instance)} VALUE WRAPPED-OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF ARRAYS-INDIRECT-COMMAND-BASE-INSTANCE) function}@c
@functionsubindex{(setf arrays-indirect-command-base-instance)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/multi-draw<dot>lisp file, , @t{core/pipelines/multi-draw.lisp}} (file)
@end table
@end deffn
@deffn {Function} {arrays-indirect-command-count} WRAPPED-OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ARRAYS-INDIRECT-COMMAND-COUNT function}@c
@functionsubindex{arrays-indirect-command-count}@c
@deffnx {Function} {(setf arrays-indirect-command-count)} VALUE WRAPPED-OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF ARRAYS-INDIRECT-COMMAND-COUNT) function}@c
@functionsubindex{(setf arrays-indirect-command-count)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/multi-draw<dot>lisp file, , @t{core/pipelines/multi-draw.lisp}} (file)
@end table
@end deffn
@deffn {Function} {arrays-indirect-command-first} WRAPPED-OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ARRAYS-INDIRECT-COMMAND-FIRST function}@c
@functionsubindex{arrays-indirect-command-first}@c
@deffnx {Function} {(setf arrays-indirect-command-first)} VALUE WRAPPED-OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF ARRAYS-INDIRECT-COMMAND-FIRST) function}@c
@functionsubindex{(setf arrays-indirect-command-first)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/multi-draw<dot>lisp file, , @t{core/pipelines/multi-draw.lisp}} (file)
@end table
@end deffn
@deffn {Function} {arrays-indirect-command-instance-count} WRAPPED-OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ARRAYS-INDIRECT-COMMAND-INSTANCE-COUNT function}@c
@functionsubindex{arrays-indirect-command-instance-count}@c
@deffnx {Function} {(setf arrays-indirect-command-instance-count)} VALUE WRAPPED-OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF ARRAYS-INDIRECT-COMMAND-INSTANCE-COUNT) function}@c
@functionsubindex{(setf arrays-indirect-command-instance-count)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/multi-draw<dot>lisp file, , @t{core/pipelines/multi-draw.lisp}} (file)
@end table
@end deffn
@deffn {Function} {assocr} ITEM ALIST &key KEY TEST TEST-NOT
@anchor{go to the CEPL-UTILS<colon><colon>ASSOCR function}@c
@functionsubindex{assocr}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {att-array} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>ATT-ARRAY function}@c
@functionsubindex{att-array}@c
@deffnx {Function} {(setf att-array)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF ATT-ARRAY) function}@c
@functionsubindex{(setf att-array)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {att-blend} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>ATT-BLEND function}@c
@functionsubindex{att-blend}@c
@deffnx {Function} {(setf att-blend)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF ATT-BLEND) function}@c
@functionsubindex{(setf att-blend)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {att-bparams} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>ATT-BPARAMS function}@c
@functionsubindex{att-bparams}@c
@deffnx {Function} {(setf att-bparams)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF ATT-BPARAMS) function}@c
@functionsubindex{(setf att-bparams)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {att-owned-p} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>ATT-OWNED-P function}@c
@functionsubindex{att-owned-p}@c
@deffnx {Function} {(setf att-owned-p)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF ATT-OWNED-P) function}@c
@functionsubindex{(setf att-owned-p)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {att-viewport} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>ATT-VIEWPORT function}@c
@functionsubindex{att-viewport}@c
@deffnx {Function} {(setf att-viewport)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF ATT-VIEWPORT) function}@c
@functionsubindex{(setf att-viewport)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {attachment} FBO ATTACHMENT-NAME
@anchor{go to the CEPL<dot>FBOS<colon><colon>ATTACHMENT function}@c
@functionsubindex{attachment}@c

This function retrieves the `attachment` named by attachment-name from the
given `fbo`. The result is a `gpu-array`@*

The attachment-name can be one of the following:@*

 a positive integer - In which case this function returns the@*
                      nth color-attachments where (= n attachment-name)@*

 :d - the depth-attachment is returned@*

 :s - the stencil-attachment is returned [0]@*

 :ds - the depth-stencil-attachment is returned [0]@*


You can also setf this function, the value must be a texture-backed gpu-array
with a valid element-type for that attachment.@*

For color attachments this means the element type must be a member of@*
the `*color-renderable-formats*` list@*

For color attachments this means the element type must be a member of@*
the `*depth-formats*` list@*

For stencil attachments this means the element type must be a member of
the `*stencil-formats*` list@*

For depth-stencil attachments this means the element type must be a member of
the `*depth-stencil-formats*` list@*

[0] *WARNING:* :s & :ds are not supported in the current version of CEPL
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@item Writer
@ref{go to the CEPL<dot>FBOS<colon><colon>(SETF ATTACHMENT) function, , @t{(setf attachment)}} (function)
@end table
@end deffn
@deffn {Function} {(setf attachment)} VALUE FBO ATTACHMENT-NAME
@anchor{go to the CEPL<dot>FBOS<colon><colon>(SETF ATTACHMENT) function}@c
@functionsubindex{(setf attachment)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@item Reader
@ref{go to the CEPL<dot>FBOS<colon><colon>ATTACHMENT function, , @t{attachment}} (function)
@end table
@end deffn
@deffn {Function} {attachment-blending} FBO ATTACHMENT-NAME
@anchor{go to the CEPL<dot>FBOS<colon><colon>ATTACHMENT-BLENDING function}@c
@functionsubindex{attachment-blending}@c

This function returns the blending parameters that will be used when rendering
into the specified `attachment` on the given `fbo`@*

Blending parameters tell OpenGL how values written into a `gpu-array` should be
combined with any values that are already present.@*

The canonical use for this is implementing transparency.@*

The details of blending parameters and where they can be used is best covered in
the docstring for the `blending-params` struct.
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@item Writer
@ref{go to the CEPL<dot>FBOS<colon><colon>(SETF ATTACHMENT-BLENDING) function, , @t{(setf attachment-blending)}} (function)
@end table
@end deffn
@deffn {Function} {(setf attachment-blending)} VALUE FBO ATTACHMENT-NAME
@anchor{go to the CEPL<dot>FBOS<colon><colon>(SETF ATTACHMENT-BLENDING) function}@c
@functionsubindex{(setf attachment-blending)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@item Reader
@ref{go to the CEPL<dot>FBOS<colon><colon>ATTACHMENT-BLENDING function, , @t{attachment-blending}} (function)
@end table
@end deffn
@deffn {Function} {attachment-pattern} ()
@anchor{go to the CEPL<dot>FBOS<colon><colon>ATTACHMENT-PATTERN function}@c
@functionsubindex{attachment-pattern}@c

This function returns a typed simple-array with is suitable to pass as
the :draw-buffers argument in `with-fbo-bound`.@*

The arguments must evaluate to numbers of type (unsigned-byte 32).

When called inline in a `with-fbo-bound` form there is an opportunity
for CEPL to optimize the code. For example in this case@*

    (defun foo (fbo)@*
      (with-fbo-bound (fbo :draw-buffers (attachment-pattern 0 2))
        ..@*
        etc))
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {attachment-tex} FBO ATTACHMENT-NAME
@anchor{go to the CEPL<dot>FBOS<colon><colon>ATTACHMENT-TEX function}@c
@functionsubindex{attachment-tex}@c
This function take an `fbo` and the name of an `attachment`. It then returns
the `texture` that backs the `gpu-array` in the specified attachment.@*

It is equivalent to writing:@*

    (gpu-array-texture (attachment fbo attachmnent-name))
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {attachment-viewport} FBO ATTACHMENT-NAME
@anchor{go to the CEPL<dot>FBOS<colon><colon>ATTACHMENT-VIEWPORT function}@c
@functionsubindex{attachment-viewport}@c

This function takes an `fbo` and attachment-name and returns a new `viewport` whos
dimensionsmatch those of the `gpu-array` connected to the `attachment`.
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {backed-by} GPU-ARRAY
@anchor{go to the CEPL<dot>GPU-ARRAYS<colon><colon>BACKED-BY function}@c
@functionsubindex{backed-by}@c

This function takes a `gpu-array` and returns either :texture or :buffer depending
on whether it is a texture-backed gpu-array or a buffer-backed gpu-array.
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS package, , @t{cepl.gpu-arrays}}
@item Source
@ref{go to the cepl/core/gpu-arrays/with-and-push<dot>lisp file, , @t{core/gpu-arrays/with-and-push.lisp}} (file)
@end table
@end deffn
@deffn {Function} {bake-uniforms} PIPELINE &rest UNIFORMS &key &allow-other-keys
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>BAKE-UNIFORMS function}@c
@functionsubindex{bake-uniforms}@c

__WARNING__ EXPRERIMENTAL FEATURE@*

This allows you to create a new lambda-pipeline from existing pipeline whilst also
fixing the values for certain uniforms.@*

These values will be baked into the gpu-code so that they will not need to be uploaded
each time the pipeline is mapped over.@*

For example:@*

    (defpipeline-g draw-cube ()@*
      :vertex (draw-cube-vert g-pnt)@*
      :fragment (draw-cube-frag :vec2))@*

    (defun fix-cube-size (size)@*
      (bake-uniforms #'draw-cube :edge-length (float size)))
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/bake<dot>lisp file, , @t{core/pipelines/bake.lisp}} (file)
@end table
@end deffn
@deffn {Function} {blending-params} FBO &optional ATTACHMENT-NAME
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BLENDING-PARAMS function}@c
@functionsubindex{blending-params}@c

This function, when passed an `fbo` or attachment will return the `blending-params`
for that object.@*

For details on what blending-params are, see the docstring for the
blending-params struct
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF BLENDING-PARAMS) function, , @t{(setf blending-params)}} (function)
@end table
@end deffn
@deffn {Function} {(setf blending-params)} VALUE FBO &optional ATTACHMENT-NAME
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BLENDING-PARAMS) function}@c
@functionsubindex{(setf blending-params)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>BLENDING-PARAMS function, , @t{blending-params}} (function)
@end table
@end deffn
@deffn {Function} {blending-params-destination-alpha} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BLENDING-PARAMS-DESTINATION-ALPHA function}@c
@functionsubindex{blending-params-destination-alpha}@c
@deffnx {Function} {(setf blending-params-destination-alpha)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BLENDING-PARAMS-DESTINATION-ALPHA) function}@c
@functionsubindex{(setf blending-params-destination-alpha)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {blending-params-destination-rgb} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BLENDING-PARAMS-DESTINATION-RGB function}@c
@functionsubindex{blending-params-destination-rgb}@c
@deffnx {Function} {(setf blending-params-destination-rgb)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BLENDING-PARAMS-DESTINATION-RGB) function}@c
@functionsubindex{(setf blending-params-destination-rgb)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {blending-params-mode-alpha} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BLENDING-PARAMS-MODE-ALPHA function}@c
@functionsubindex{blending-params-mode-alpha}@c
@deffnx {Function} {(setf blending-params-mode-alpha)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BLENDING-PARAMS-MODE-ALPHA) function}@c
@functionsubindex{(setf blending-params-mode-alpha)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {blending-params-mode-rgb} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BLENDING-PARAMS-MODE-RGB function}@c
@functionsubindex{blending-params-mode-rgb}@c
@deffnx {Function} {(setf blending-params-mode-rgb)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BLENDING-PARAMS-MODE-RGB) function}@c
@functionsubindex{(setf blending-params-mode-rgb)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {blending-params-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BLENDING-PARAMS-P function}@c
@functionsubindex{blending-params-p}@c

This function returns t when the given value is a `blending-params` object,
otherwise it returns nil
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {blending-params-source-alpha} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BLENDING-PARAMS-SOURCE-ALPHA function}@c
@functionsubindex{blending-params-source-alpha}@c
@deffnx {Function} {(setf blending-params-source-alpha)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BLENDING-PARAMS-SOURCE-ALPHA) function}@c
@functionsubindex{(setf blending-params-source-alpha)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {blending-params-source-rgb} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BLENDING-PARAMS-SOURCE-RGB function}@c
@functionsubindex{blending-params-source-rgb}@c
@deffnx {Function} {(setf blending-params-source-rgb)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BLENDING-PARAMS-SOURCE-RGB) function}@c
@functionsubindex{(setf blending-params-source-rgb)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-data} BUFFER C-ARRAY &key TARGET USAGE OFFSET BYTE-SIZE
@anchor{go to the CEPL<dot>GPU-BUFFERS<colon><colon>BUFFER-DATA function}@c
@functionsubindex{buffer-data}@c

This function populates the `gpu-buffer` with the contents of the `c-array`.

You also pass in the buffer type and the draw type this buffer is to be used
for.@*

The function returns a buffer object with its format slot populated with the
details of the data stored within the buffer
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-BUFFERS package, , @t{cepl.gpu-buffers}}
@item Source
@ref{go to the cepl/core/gpu-buffers/gpu-buffers<dot>lisp file, , @t{core/gpu-buffers/gpu-buffers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-data-raw} DATA-POINTER BYTE-SIZE BUFFER &optional TARGET USAGE BYTE-OFFSET
@anchor{go to the CEPL<dot>GPU-BUFFERS<colon><colon>BUFFER-DATA-RAW function}@c
@functionsubindex{buffer-data-raw}@c

This function populates an opengl buffer with the 'data-byte-size' bytes of data
from the given point, optionally at the offset provided.@*

You also pass in the buffer type and the draw type this buffer is to be@*
used for.@*

The function returns a buffer object with its format slot populated with the
details of the data stored within the buffer
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-BUFFERS package, , @t{cepl.gpu-buffers}}
@item Source
@ref{go to the cepl/core/gpu-buffers/gpu-buffers<dot>lisp file, , @t{core/gpu-buffers/gpu-buffers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-reserve-block} BUFFER TYPE DIMENSIONS TARGET USAGE &key ROW-ALIGNMENT
@anchor{go to the CEPL<dot>GPU-BUFFERS<colon><colon>BUFFER-RESERVE-BLOCK function}@c
@functionsubindex{buffer-reserve-block}@c

This function creates an empty block of data in the opengl buffer equal in size
to:@*

    (* length size-in-bytes-of-type).@*

It will remove ALL data currently in the buffer
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-BUFFERS package, , @t{cepl.gpu-buffers}}
@item Source
@ref{go to the cepl/core/gpu-buffers/gpu-buffers<dot>lisp file, , @t{core/gpu-buffers/gpu-buffers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-stream-%index-type-enum} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-%INDEX-TYPE-ENUM function}@c
@functionsubindex{buffer-stream-%index-type-enum}@c
@deffnx {Function} {(setf buffer-stream-%index-type-enum)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-%INDEX-TYPE-ENUM) function}@c
@functionsubindex{(setf buffer-stream-%index-type-enum)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-stream-%index-type-size} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-%INDEX-TYPE-SIZE function}@c
@functionsubindex{buffer-stream-%index-type-size}@c
@deffnx {Function} {(setf buffer-stream-%index-type-size)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-%INDEX-TYPE-SIZE) function}@c
@functionsubindex{(setf buffer-stream-%index-type-size)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-stream-%primitive} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-%PRIMITIVE function}@c
@functionsubindex{buffer-stream-%primitive}@c
@deffnx {Function} {(setf buffer-stream-%primitive)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-%PRIMITIVE) function}@c
@functionsubindex{(setf buffer-stream-%primitive)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-stream-%start} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-%START function}@c
@functionsubindex{buffer-stream-%start}@c
@deffnx {Function} {(setf buffer-stream-%start)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-%START) function}@c
@functionsubindex{(setf buffer-stream-%start)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-stream-%start-byte} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-%START-BYTE function}@c
@functionsubindex{buffer-stream-%start-byte}@c
@deffnx {Function} {(setf buffer-stream-%start-byte)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-%START-BYTE) function}@c
@functionsubindex{(setf buffer-stream-%start-byte)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-stream-base-vertex} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-BASE-VERTEX function}@c
@functionsubindex{buffer-stream-base-vertex}@c
@deffnx {Function} {(setf buffer-stream-base-vertex)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-BASE-VERTEX) function}@c
@functionsubindex{(setf buffer-stream-base-vertex)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-stream-draw-mode-val} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-DRAW-MODE-VAL function}@c
@functionsubindex{buffer-stream-draw-mode-val}@c
@deffnx {Function} {(setf buffer-stream-draw-mode-val)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-DRAW-MODE-VAL) function}@c
@functionsubindex{(setf buffer-stream-draw-mode-val)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-stream-gpu-arrays} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-GPU-ARRAYS function}@c
@functionsubindex{buffer-stream-gpu-arrays}@c

When you construct a buffer-stream it will (by default) hold onto the
gpu-arrays that were composed.@*

This function when given a buffer-stream will return those stored gpu-arrays
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-GPU-ARRAYS) function, , @t{(setf buffer-stream-gpu-arrays)}} (function)
@end table
@end deffn
@deffn {Function} {(setf buffer-stream-gpu-arrays)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-GPU-ARRAYS) function}@c
@functionsubindex{(setf buffer-stream-gpu-arrays)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-GPU-ARRAYS function, , @t{buffer-stream-gpu-arrays}} (function)
@end table
@end deffn
@deffn {Function} {buffer-stream-index-type} STREAM
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-INDEX-TYPE function}@c
@functionsubindex{buffer-stream-index-type}@c

When passed a buffer-stream with an index this function will return the
element-type of the index-data.
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-INDEX-TYPE) function, , @t{(setf buffer-stream-index-type)}} (function)
@end table
@end deffn
@deffn {Function} {(setf buffer-stream-index-type)} VALUE STREAM
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-INDEX-TYPE) function}@c
@functionsubindex{(setf buffer-stream-index-type)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-INDEX-TYPE function, , @t{buffer-stream-index-type}} (function)
@end table
@end deffn
@deffn {Function} {buffer-stream-length} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-LENGTH function}@c
@functionsubindex{buffer-stream-length}@c

Returns the number of elements in the buffer-stream
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-LENGTH) function, , @t{(setf buffer-stream-length)}} (function)
@end table
@end deffn
@deffn {Function} {(setf buffer-stream-length)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-LENGTH) function}@c
@functionsubindex{(setf buffer-stream-length)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-LENGTH function, , @t{buffer-stream-length}} (function)
@end table
@end deffn
@deffn {Function} {buffer-stream-managed} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-MANAGED function}@c
@functionsubindex{buffer-stream-managed}@c
@deffnx {Function} {(setf buffer-stream-managed)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-MANAGED) function}@c
@functionsubindex{(setf buffer-stream-managed)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-stream-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-P function}@c
@functionsubindex{buffer-stream-p}@c

Returns t if the value passed is a buffer-stream
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-stream-patch-length} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-PATCH-LENGTH function}@c
@functionsubindex{buffer-stream-patch-length}@c
@deffnx {Function} {(setf buffer-stream-patch-length)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-PATCH-LENGTH) function}@c
@functionsubindex{(setf buffer-stream-patch-length)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-stream-primitive} STREAM
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-PRIMITIVE function}@c
@functionsubindex{buffer-stream-primitive}@c

This function returns the primitive that the data pulled from buffer stream
represents.@*

The primitive says what the gpu will draw this data as. It can be any one of:

 :points@*
 :lines@*
 :line-loop@*
 :line-strip@*
 :lines-adjacency@*
 :line-strip-adjacency@*
 :triangles@*
 :triangle-fan@*
 :triangle-strip@*
 :triangles-adjacency@*
 :triangle-strip-adjacency@*
 (:patch <patch-size>)@*

By default the primitive-type is :triangles
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-PRIMITIVE) function, , @t{(setf buffer-stream-primitive)}} (function)
@end table
@end deffn
@deffn {Function} {(setf buffer-stream-primitive)} PRIMITIVE STREAM
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-PRIMITIVE) function}@c
@functionsubindex{(setf buffer-stream-primitive)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-PRIMITIVE function, , @t{buffer-stream-primitive}} (function)
@end table
@end deffn
@deffn {Function} {buffer-stream-primitive-group-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-PRIMITIVE-GROUP-ID function}@c
@functionsubindex{buffer-stream-primitive-group-id}@c
@deffnx {Function} {(setf buffer-stream-primitive-group-id)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-PRIMITIVE-GROUP-ID) function}@c
@functionsubindex{(setf buffer-stream-primitive-group-id)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-stream-start} STREAM
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-START function}@c
@functionsubindex{buffer-stream-start}@c
@deffnx {Function} {(setf buffer-stream-start)} VALUE STREAM
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-START) function}@c
@functionsubindex{(setf buffer-stream-start)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-stream-start-byte} STREAM
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-START-BYTE function}@c
@functionsubindex{buffer-stream-start-byte}@c
@deffnx {Function} {(setf buffer-stream-start-byte)} VALUE STREAM
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-START-BYTE) function}@c
@functionsubindex{(setf buffer-stream-start-byte)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-stream-vao} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-VAO function}@c
@functionsubindex{buffer-stream-vao}@c

Returns the OpenGL Vertex Array Object (VAO) owned by this stream.

Do not modify this unless you are sure what you are doing.@*
In most cases you do not need to interact with the VAO directly
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-VAO) function, , @t{(setf buffer-stream-vao)}} (function)
@end table
@end deffn
@deffn {Function} {(setf buffer-stream-vao)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-VAO) function}@c
@functionsubindex{(setf buffer-stream-vao)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-VAO function, , @t{buffer-stream-vao}} (function)
@end table
@end deffn
@deffn {Function} {buffer-texture-backing-array} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-TEXTURE-BACKING-ARRAY function}@c
@functionsubindex{buffer-texture-backing-array}@c
@deffnx {Function} {(setf buffer-texture-backing-array)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-TEXTURE-BACKING-ARRAY) function}@c
@functionsubindex{(setf buffer-texture-backing-array)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-texture-owns-array} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-TEXTURE-OWNS-ARRAY function}@c
@functionsubindex{buffer-texture-owns-array}@c
@deffnx {Function} {(setf buffer-texture-owns-array)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-TEXTURE-OWNS-ARRAY) function}@c
@functionsubindex{(setf buffer-texture-owns-array)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-texture-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-TEXTURE-P function}@c
@functionsubindex{buffer-texture-p}@c

Return t if the given value is a `texture` who data is stored in a `gpu-buffer` as
opposed to the usual texture memory. Returns nil otherwise
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {c-array-dimensions} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY-DIMENSIONS function}@c
@functionsubindex{c-array-dimensions}@c

`C-ARRAY-DIMENSIONS` takes a `c-array` as an argument and returns the
dimensions of the c-array@*

You can also use the generic function `DIMENSIONS` to get the same
result.
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF C-ARRAY-DIMENSIONS) function, , @t{(setf c-array-dimensions)}} (function)
@end table
@end deffn
@deffn {Function} {(setf c-array-dimensions)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF C-ARRAY-DIMENSIONS) function}@c
@functionsubindex{(setf c-array-dimensions)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY-DIMENSIONS function, , @t{c-array-dimensions}} (function)
@end table
@end deffn
@deffn {Function} {c-array-element-byte-size} C-ARRAY
@anchor{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY-ELEMENT-BYTE-SIZE function}@c
@functionsubindex{c-array-element-byte-size}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {c-array-element-from-foreign} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY-ELEMENT-FROM-FOREIGN function}@c
@functionsubindex{c-array-element-from-foreign}@c
@deffnx {Function} {(setf c-array-element-from-foreign)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF C-ARRAY-ELEMENT-FROM-FOREIGN) function}@c
@functionsubindex{(setf c-array-element-from-foreign)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {c-array-element-pixel-format} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY-ELEMENT-PIXEL-FORMAT function}@c
@functionsubindex{c-array-element-pixel-format}@c
@deffnx {Function} {(setf c-array-element-pixel-format)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF C-ARRAY-ELEMENT-PIXEL-FORMAT) function}@c
@functionsubindex{(setf c-array-element-pixel-format)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {c-array-element-to-foreign} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY-ELEMENT-TO-FOREIGN function}@c
@functionsubindex{c-array-element-to-foreign}@c
@deffnx {Function} {(setf c-array-element-to-foreign)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF C-ARRAY-ELEMENT-TO-FOREIGN) function}@c
@functionsubindex{(setf c-array-element-to-foreign)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {c-array-element-type} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY-ELEMENT-TYPE function}@c
@functionsubindex{c-array-element-type}@c

`C-ARRAY-POINTER` takes a `c-array` as an argument and returns the
type of the elements of the array.@*

You can also use the generic function `ELEMENT-TYPE` to get the same
result.
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF C-ARRAY-ELEMENT-TYPE) function, , @t{(setf c-array-element-type)}} (function)
@end table
@end deffn
@deffn {Function} {(setf c-array-element-type)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF C-ARRAY-ELEMENT-TYPE) function}@c
@functionsubindex{(setf c-array-element-type)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY-ELEMENT-TYPE function, , @t{c-array-element-type}} (function)
@end table
@end deffn
@deffn {Function} {c-array-free} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY-FREE function}@c
@functionsubindex{c-array-free}@c
@deffnx {Function} {(setf c-array-free)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF C-ARRAY-FREE) function}@c
@functionsubindex{(setf c-array-free)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {c-array-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY-P function}@c
@functionsubindex{c-array-p}@c

Return t if the argument is a `c-array`. Returns nil otherwise.
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {c-array-pointer} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY-POINTER function}@c
@functionsubindex{c-array-pointer}@c

`C-ARRAY-POINTER` takes a `c-array` as an argument and returns the
pointer to the foreign data.@*

You can also use the generic function `POINTER` to get the same result.
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF C-ARRAY-POINTER) function, , @t{(setf c-array-pointer)}} (function)
@end table
@end deffn
@deffn {Function} {(setf c-array-pointer)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF C-ARRAY-POINTER) function}@c
@functionsubindex{(setf c-array-pointer)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY-POINTER function, , @t{c-array-pointer}} (function)
@end table
@end deffn
@deffn {Function} {c-array-row-alignment} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY-ROW-ALIGNMENT function}@c
@functionsubindex{c-array-row-alignment}@c
@deffnx {Function} {(setf c-array-row-alignment)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF C-ARRAY-ROW-ALIGNMENT) function}@c
@functionsubindex{(setf c-array-row-alignment)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {c-array-sizes} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY-SIZES function}@c
@functionsubindex{c-array-sizes}@c
@deffnx {Function} {(setf c-array-sizes)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF C-ARRAY-SIZES) function}@c
@functionsubindex{(setf c-array-sizes)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {c-array-struct-element-typep} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY-STRUCT-ELEMENT-TYPEP function}@c
@functionsubindex{c-array-struct-element-typep}@c
@deffnx {Function} {(setf c-array-struct-element-typep)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF C-ARRAY-STRUCT-ELEMENT-TYPEP) function}@c
@functionsubindex{(setf c-array-struct-element-typep)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {c-array-total-size} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY-TOTAL-SIZE function}@c
@functionsubindex{c-array-total-size}@c
@deffnx {Function} {(setf c-array-total-size)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF C-ARRAY-TOTAL-SIZE) function}@c
@functionsubindex{(setf c-array-total-size)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {calc-block-layout} LAYOUT-SPECIFIER VARJO-STRUCT-TYPE-NAME
@anchor{go to the %CEPL<dot>TYPES<colon><colon>CALC-BLOCK-LAYOUT function}@c
@functionsubindex{calc-block-layout}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/layout<dot>lisp file, , @t{core/types/layout.lisp}} (file)
@end table
@end deffn
@deffn {Function} {calc-struct-layout-from-name-type-pairs} LAYOUT-SPECIFIER NAME NAME-TYPE-PAIRS
@anchor{go to the %CEPL<dot>TYPES<colon><colon>CALC-STRUCT-LAYOUT-FROM-NAME-TYPE-PAIRS function}@c
@functionsubindex{calc-struct-layout-from-name-type-pairs}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/layout<dot>lisp file, , @t{core/types/layout.lisp}} (file)
@end table
@end deffn
@deffn {Function} {can-bind-query-p} CEPL-CONTEXT QUERY
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>CAN-BIND-QUERY-P function}@c
@functionsubindex{can-bind-query-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl-context} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>CEPL-CONTEXT function}@c
@functionsubindex{cepl-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl-describe} NAME &optional STREAM
@anchor{go to the CEPL<colon><colon>CEPL-DESCRIBE function}@c
@functionsubindex{cepl-describe}@c
@table @strong
@item Package
@ref{go to the CEPL package, , @t{cepl}}
@item Source
@ref{go to the cepl/core/repl<dot>lisp file, , @t{core/repl.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cffi-type->gl-type} TYPE
@anchor{go to the CEPL<dot>INTERNALS<colon><colon>CFFI-TYPE->GL-TYPE function}@c
@functionsubindex{cffi-type->gl-type}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>INTERNALS package, , @t{cepl.internals}}
@item Source
@ref{go to the cepl/core/internals<dot>lisp file, , @t{core/internals.lisp}} (file)
@end table
@end deffn
@deffn {Function} {check-array-sizes-for-copy} SRC-DIMS DST-DIMS
@anchor{go to the %CEPL<dot>TYPES<colon><colon>CHECK-ARRAY-SIZES-FOR-COPY function}@c
@functionsubindex{check-array-sizes-for-copy}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/checks<dot>lisp file, , @t{core/types/checks.lisp}} (file)
@end table
@end deffn
@deffn {Function} {check-array-types-for-copy} SRC-ELEM-TYPE DST-ELEM-TYPE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>CHECK-ARRAY-TYPES-FOR-COPY function}@c
@functionsubindex{check-array-types-for-copy}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/checks<dot>lisp file, , @t{core/types/checks.lisp}} (file)
@end table
@end deffn
@deffn {Function} {check-framebuffer-status} FBO
@anchor{go to the CEPL<dot>FBOS<colon><colon>CHECK-FRAMEBUFFER-STATUS function}@c
@functionsubindex{check-framebuffer-status}@c

This function asks OpenGL to check the given `FBO` and ensure that it is@*
'complete'.@*

This function will either return the particular 'framebuffer complete' flag or@*
will throw a condition with an explanation of the problem.@*

For a full rundown on what it means for a fbo to be complete see:@*
[glwiki- framebuffer completeness](https://www.opengl.org/wiki/Framebuffer_Object#Framebuffer_Completeness)

All fbos made in CEPL using `make-fbo` are checked for completeness before@*
being returned to the user.
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {clear} &optional TARGET
@anchor{go to the CEPL<dot>FBOS<colon><colon>CLEAR function}@c
@functionsubindex{clear}@c

What this function will clear depends on what is passed:@*

- a `fbo` - See 'clearing fbos' below@*
- an `attachment` - See 'clearing a single attachment' below@*
- nothing - The 'current fbo' will be cleared@*

**-- Clearing Fbos --**@*

In this case clearing means that all the elements of the attachments will be set
to a certain value. The value that the attachment's `gpu-array`s will be set to
varies based on the attachment.@*

- color attachments: Will be set to the value set in #'gl:clear-color@*
- depth attachments: Will be set to the value set in #'gl:clear-depth@*
- stencil attachments: Will be set to the value set in #'gl:clear-stencil@*

You can also use `clear-fbo` for this task@*


**-- Clearing a single attachment --**@*

Not currently implemented
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {clear-attachment} ATTACHMENT
@anchor{go to the CEPL<dot>FBOS<colon><colon>CLEAR-ATTACHMENT function}@c
@functionsubindex{clear-attachment}@c

Not currently implemented@*

This function will clear a single `attachment` of a `fbo`.
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {clear-color} &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>CLEAR-COLOR function}@c
@functionsubindex{clear-color}@c
@deffnx {Function} {(setf clear-color)} VEC4-COLOR &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF CLEAR-COLOR) function}@c
@functionsubindex{(setf clear-color)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/color/color<dot>lisp file, , @t{core/color/color.lisp}} (file)
@end table
@end deffn
@deffn {Function} {clear-fbo} FBO
@anchor{go to the CEPL<dot>FBOS<colon><colon>CLEAR-FBO function}@c
@functionsubindex{clear-fbo}@c

This function will set the elements of the `attachment`s of the `fbo` to a
certain value. The value that the attachment's `gpu-array`s will be set to
varies based on the attachment.@*

- color attachments: Will be set to the value set in #'gl:clear-color
- depth attachments: Will be set to the value set in #'gl:clear-depth
- stencil attachments: Will be set to the value set in #'gl:clear-stencil

You can also perform this action by calling `clear` with an fbo
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {clone-c-array} C-ARRAY
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>CLONE-C-ARRAY function}@c
@functionsubindex{clone-c-array}@c

Takes a `c-array` and makes a new c-array with the same contents as the the
original. The contents in foreign memory are copied.
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/make<dot>lisp file, , @t{core/c-arrays/make.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cls} ()
@anchor{go to the CEPL<colon><colon>CLS function}@c
@functionsubindex{cls}@c

CLS is here as it reminds me of qbasic and that makes me happy.@*

It calls #'clear and #'swap twice so dont use this in your actually rendering
code. It can be handy though if you want to clear the screen from the repl.
@table @strong
@item Package
@ref{go to the CEPL package, , @t{cepl}}
@item Source
@ref{go to the cepl/core/repl<dot>lisp file, , @t{core/repl.lisp}} (file)
@end table
@end deffn
@deffn {Function} {color-attachment-enum} ATTACHMENT-NUM
@anchor{go to the CEPL<dot>INTERNALS<colon><colon>COLOR-ATTACHMENT-ENUM function}@c
@functionsubindex{color-attachment-enum}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>INTERNALS package, , @t{cepl.internals}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {color-mask} INDEX &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>COLOR-MASK function}@c
@functionsubindex{color-mask}@c
@deffnx {Function} {(setf color-mask)} VALUE INDEX &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF COLOR-MASK) function}@c
@functionsubindex{(setf color-mask)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/color/color<dot>lisp file, , @t{core/color/color.lisp}} (file)
@end table
@end deffn
@deffn {Function} {color-masks} &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>COLOR-MASKS function}@c
@functionsubindex{color-masks}@c
@deffnx {Function} {(setf color-masks)} VALUE &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF COLOR-MASKS) function}@c
@functionsubindex{(setf color-masks)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/color/color<dot>lisp file, , @t{core/color/color.lisp}} (file)
@end table
@end deffn
@deffn {Function} {color-renderable-formatp} FORMAT
@anchor{go to the CEPL<dot>IMAGE-FORMATS<colon><colon>COLOR-RENDERABLE-FORMATP function}@c
@functionsubindex{color-renderable-formatp}@c

This function returns t if the value provided is a keyword that can be found in
*color-renderable-formats*
@table @strong
@item Package
@ref{go to the CEPL<dot>IMAGE-FORMATS package, , @t{cepl.image-formats}}
@item Source
@ref{go to the cepl/core/types/image-format<dot>lisp file, , @t{core/types/image-format.lisp}} (file)
@end table
@end deffn
@deffn {Function} {compare} SAMPLER
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COMPARE function}@c
@functionsubindex{compare}@c

This function sets the comparison mode of the `texture` or `sampler` given@*

-WARNING-@*

This feature is currently unsupported until shadow samplers are more fully
tested in CEPL. Use at your own risk@*


**-- Comparison --**@*

Depth `texture`s (textures that have a depth component image format) can be
sampled in one of two ways. They can be sampled as a normal texture, which
simply retrieves the depth value (with filtering applied). This will return a
vec4 containing a single floating-point value.@*

They can also be fetched in comparison mode. This means that sampling from
the texture requires a value to compare to those pulled from the texture;
this value is called the reference value. The result of the comparison
depends on the comparison function set in the texture. If the function
succeeds, the resulting value is 1s0; if it fails, it is 0s0.@*

When linear filtering is used, the actual returned value is
implementation-defined. However, the value will be on the range 0  1 and
will be proportional to the number of neighboring texels that pass the
comparison based on the single given value.@*

If the texture is a normalized integer depth format, then the reference value
is clamped to 0  1, to match the values from the texture. Otherwise, the value
is not clamped.@*

Using this mode requires two special settings. First, the sampler used in GLSL
must be a shadow sampler. Second, the texture used in that sampler must have
activated depth comparison mode. Attempting to use a texture without comparison
with a shadow sampler, or vice-versa, will result in an error upon rendering.

To set the texture to comparison mode, set the :texture-compare-mode
texture parameter to :compare-ref-to-texture. The comparison function to
use when comparing the reference to the texture is set with the
:texture-compare-func texture parameter. Acceptable values are:@*

    :never (always fails)@*
    :always (always succeeds)@*
    :less@*
    :lequal@*
    :equal,@*
    :not-equal@*
    :gequal@*
    :greater@*

The comparison works as follows:@*

    (funcall operator ref texture)@*

where ref is the reference value given to the texture lookup function by
GLSL, and texture is the value fetched from the texture. So :LESS will be
true if the reference value is strictly less than the value pulled from the
texture.
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF COMPARE) function, , @t{(setf compare)}} (function)
@end table
@end deffn
@deffn {Function} {(setf compare)} VALUE SAMPLER
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF COMPARE) function}@c
@functionsubindex{(setf compare)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>COMPARE function, , @t{compare}} (function)
@end table
@end deffn
@deffn {Function} {compile-g} NAME &optional DEFINITION
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>COMPILE-G function}@c
@functionsubindex{compile-g}@c

This function takes a lambda-g form and compiles it to a gpu-lambda object.

This is used for similar reasons to `compile` in Common Lisp, you have a
lambda definition as lists and you want a compiled lambda.@*

The result of this function is suitable for passing to pipeline-g which lets
you define a map-g'able pipeline at runtime.@*

Whilst this shares the same signature as CL's #'compile in our version the
'name' argument must be nil.
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-lambda<dot>lisp file, , @t{core/pipelines/gpu-lambda.lisp}} (file)
@end table
@end deffn
@deffn {Function} {compute-space-as-uvec3} SPACE
@anchor{go to the CEPL<dot>COMPUTE<colon><colon>COMPUTE-SPACE-AS-UVEC3 function}@c
@functionsubindex{compute-space-as-uvec3}@c
@deffnx {Function} {(setf compute-space-as-uvec3)} VALUE SPACE
@anchor{go to the CEPL<dot>COMPUTE<colon><colon>(SETF COMPUTE-SPACE-AS-UVEC3) function}@c
@functionsubindex{(setf compute-space-as-uvec3)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>COMPUTE package, , @t{cepl.compute}}
@item Source
@ref{go to the cepl/core/compute/compute<dot>lisp file, , @t{core/compute/compute.lisp}} (file)
@end table
@end deffn
@deffn {Function} {compute-space-dimensions} SPACE
@anchor{go to the CEPL<dot>COMPUTE<colon><colon>COMPUTE-SPACE-DIMENSIONS function}@c
@functionsubindex{compute-space-dimensions}@c
@deffnx {Function} {(setf compute-space-dimensions)} VALUE SPACE
@anchor{go to the CEPL<dot>COMPUTE<colon><colon>(SETF COMPUTE-SPACE-DIMENSIONS) function}@c
@functionsubindex{(setf compute-space-dimensions)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>COMPUTE package, , @t{cepl.compute}}
@item Source
@ref{go to the cepl/core/compute/compute<dot>lisp file, , @t{core/compute/compute.lisp}} (file)
@end table
@end deffn
@deffn {Function} {compute-space-size-x} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COMPUTE-SPACE-SIZE-X function}@c
@functionsubindex{compute-space-size-x}@c
@deffnx {Function} {(setf compute-space-size-x)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF COMPUTE-SPACE-SIZE-X) function}@c
@functionsubindex{(setf compute-space-size-x)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {compute-space-size-y} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COMPUTE-SPACE-SIZE-Y function}@c
@functionsubindex{compute-space-size-y}@c
@deffnx {Function} {(setf compute-space-size-y)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF COMPUTE-SPACE-SIZE-Y) function}@c
@functionsubindex{(setf compute-space-size-y)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {compute-space-size-z} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COMPUTE-SPACE-SIZE-Z function}@c
@functionsubindex{compute-space-size-z}@c
@deffnx {Function} {(setf compute-space-size-z)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF COMPUTE-SPACE-SIZE-Z) function}@c
@functionsubindex{(setf compute-space-size-z)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {consecutive-integers-p} INTEGERS
@anchor{go to the CEPL-UTILS<colon><colon>CONSECUTIVE-INTEGERS-P function}@c
@functionsubindex{consecutive-integers-p}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {context-id} CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>CONTEXT-ID function}@c
@functionsubindex{context-id}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-blending-params} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-BLENDING-PARAMS function}@c
@functionsubindex{copy-blending-params}@c

This function, when passed a `blending-params` object, will create a new
blending-params object with the same settings as the one passed.
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-buffer-backed-gpu-array-to-new-c-array} SRC
@anchor{go to the CEPL<dot>GPU-ARRAYS<colon><colon>COPY-BUFFER-BACKED-GPU-ARRAY-TO-NEW-C-ARRAY function}@c
@functionsubindex{copy-buffer-backed-gpu-array-to-new-c-array}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS package, , @t{cepl.gpu-arrays}}
@item Source
@ref{go to the cepl/core/gpu-arrays/with-and-push<dot>lisp file, , @t{core/gpu-arrays/with-and-push.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-buffer-backed-gpu-array-to-new-lisp-data} SRC
@anchor{go to the CEPL<dot>GPU-ARRAYS<colon><colon>COPY-BUFFER-BACKED-GPU-ARRAY-TO-NEW-LISP-DATA function}@c
@functionsubindex{copy-buffer-backed-gpu-array-to-new-lisp-data}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS package, , @t{cepl.gpu-arrays}}
@item Source
@ref{go to the cepl/core/gpu-arrays/with-and-push<dot>lisp file, , @t{core/gpu-arrays/with-and-push.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-buffer-backed-gpu-array-to-texture-backed-gpu-array} SRC DST
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>COPY-BUFFER-BACKED-GPU-ARRAY-TO-TEXTURE-BACKED-GPU-ARRAY function}@c
@functionsubindex{copy-buffer-backed-gpu-array-to-texture-backed-gpu-array}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-c-array-to-buffer-backed-gpu-array} SRC DST
@anchor{go to the CEPL<dot>GPU-ARRAYS<colon><colon>COPY-C-ARRAY-TO-BUFFER-BACKED-GPU-ARRAY function}@c
@functionsubindex{copy-c-array-to-buffer-backed-gpu-array}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS package, , @t{cepl.gpu-arrays}}
@item Source
@ref{go to the cepl/core/gpu-arrays/with-and-push<dot>lisp file, , @t{core/gpu-arrays/with-and-push.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-c-array-to-new-lisp-data} SRC
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>COPY-C-ARRAY-TO-NEW-LISP-DATA function}@c
@functionsubindex{copy-c-array-to-new-lisp-data}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/rest<dot>lisp file, , @t{core/c-arrays/rest.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-c-array-to-texture-backed-gpu-array} SRC DST
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>COPY-C-ARRAY-TO-TEXTURE-BACKED-GPU-ARRAY function}@c
@functionsubindex{copy-c-array-to-texture-backed-gpu-array}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-lisp-data-to-buffer-backed-gpu-array} SRC DST
@anchor{go to the CEPL<dot>GPU-ARRAYS<colon><colon>COPY-LISP-DATA-TO-BUFFER-BACKED-GPU-ARRAY function}@c
@functionsubindex{copy-lisp-data-to-buffer-backed-gpu-array}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS package, , @t{cepl.gpu-arrays}}
@item Source
@ref{go to the cepl/core/gpu-arrays/with-and-push<dot>lisp file, , @t{core/gpu-arrays/with-and-push.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-lisp-data-to-c-array} C-ARRAY DATA &optional CHECK-SIZES
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>COPY-LISP-DATA-TO-C-ARRAY function}@c
@functionsubindex{copy-lisp-data-to-c-array}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/populate<dot>lisp file, , @t{core/c-arrays/populate.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-lisp-data-to-texture-backed-gpu-array} SRC DST
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>COPY-LISP-DATA-TO-TEXTURE-BACKED-GPU-ARRAY function}@c
@functionsubindex{copy-lisp-data-to-texture-backed-gpu-array}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-texture-backed-gpu-array-to-buffer-backed-gpu-array} SRC DST
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>COPY-TEXTURE-BACKED-GPU-ARRAY-TO-BUFFER-BACKED-GPU-ARRAY function}@c
@functionsubindex{copy-texture-backed-gpu-array-to-buffer-backed-gpu-array}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-texture-backed-gpu-array-to-c-array} SRC DST
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>COPY-TEXTURE-BACKED-GPU-ARRAY-TO-C-ARRAY function}@c
@functionsubindex{copy-texture-backed-gpu-array-to-c-array}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-texture-backed-gpu-array-to-new-buffer-backed-gpu-array} SRC
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>COPY-TEXTURE-BACKED-GPU-ARRAY-TO-NEW-BUFFER-BACKED-GPU-ARRAY function}@c
@functionsubindex{copy-texture-backed-gpu-array-to-new-buffer-backed-gpu-array}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-texture-backed-gpu-array-to-new-c-array} SRC
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>COPY-TEXTURE-BACKED-GPU-ARRAY-TO-NEW-C-ARRAY function}@c
@functionsubindex{copy-texture-backed-gpu-array-to-new-c-array}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-texture-backed-gpu-array-to-new-lisp-data} SRC
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>COPY-TEXTURE-BACKED-GPU-ARRAY-TO-NEW-LISP-DATA function}@c
@functionsubindex{copy-texture-backed-gpu-array-to-new-lisp-data}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-viewport} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-VIEWPORT function}@c
@functionsubindex{copy-viewport}@c

This function returns a new `viewport` with identical origin and resolution to the
viewport provided.
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cull-face} &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>CULL-FACE function}@c
@functionsubindex{cull-face}@c
@deffnx {Function} {(setf cull-face)} FACE &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF CULL-FACE) function}@c
@functionsubindex{(setf cull-face)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/face/face<dot>lisp file, , @t{core/face/face.lisp}} (file)
@end table
@end deffn
@deffn {Function} {current-stencil-params} FACE &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>STENCIL<colon><colon>CURRENT-STENCIL-PARAMS function}@c
@functionsubindex{current-stencil-params}@c
@deffnx {Function} {(setf current-stencil-params)} PARAMS FACE &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>STENCIL<colon><colon>(SETF CURRENT-STENCIL-PARAMS) function}@c
@functionsubindex{(setf current-stencil-params)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>STENCIL package, , @t{cepl.stencil}}
@item Source
@ref{go to the cepl/core/stencil/stencil<dot>lisp file, , @t{core/stencil/stencil.lisp}} (file)
@end table
@end deffn
@deffn {Function} {current-surface} &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>CURRENT-SURFACE function}@c
@functionsubindex{current-surface}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {current-viewport} &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>VIEWPORTS<colon><colon>CURRENT-VIEWPORT function}@c
@functionsubindex{current-viewport}@c

This function returns the `viewport` that is current in this scope.@*

If no other code in the callstack has used `with-viewport` or `with-fbo-viewport`
then the result will be the default viewport.
@table @strong
@item Package
@ref{go to the CEPL<dot>VIEWPORTS package, , @t{cepl.viewports}}
@item Source
@ref{go to the cepl/core/viewports/viewport<dot>lisp file, , @t{core/viewports/viewport.lisp}} (file)
@end table
@end deffn
@deffn {Function} {depth-clamp} &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>DEPTH-CLAMP function}@c
@functionsubindex{depth-clamp}@c
@deffnx {Function} {(setf depth-clamp)} VALUE &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF DEPTH-CLAMP) function}@c
@functionsubindex{(setf depth-clamp)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/depth/depth<dot>lisp file, , @t{core/depth/depth.lisp}} (file)
@end table
@end deffn
@deffn {Function} {depth-formatp} FORMAT
@anchor{go to the CEPL<dot>IMAGE-FORMATS<colon><colon>DEPTH-FORMATP function}@c
@functionsubindex{depth-formatp}@c

This function returns t if the value provided is a keyword that can be found in
*depth-formats*
@table @strong
@item Package
@ref{go to the CEPL<dot>IMAGE-FORMATS package, , @t{cepl.image-formats}}
@item Source
@ref{go to the cepl/core/types/image-format<dot>lisp file, , @t{core/types/image-format.lisp}} (file)
@end table
@end deffn
@deffn {Function} {depth-mask} &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>DEPTH-MASK function}@c
@functionsubindex{depth-mask}@c
@deffnx {Function} {(setf depth-mask)} VALUE &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF DEPTH-MASK) function}@c
@functionsubindex{(setf depth-mask)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/depth/depth<dot>lisp file, , @t{core/depth/depth.lisp}} (file)
@end table
@end deffn
@deffn {Function} {depth-range-vec2} &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>DEPTH-RANGE-VEC2 function}@c
@functionsubindex{depth-range-vec2}@c
@deffnx {Function} {(setf depth-range-vec2)} VEC2-RANGE &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF DEPTH-RANGE-VEC2) function}@c
@functionsubindex{(setf depth-range-vec2)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/depth/depth<dot>lisp file, , @t{core/depth/depth.lisp}} (file)
@end table
@end deffn
@deffn {Function} {depth-stencil-formatp} FORMAT
@anchor{go to the CEPL<dot>IMAGE-FORMATS<colon><colon>DEPTH-STENCIL-FORMATP function}@c
@functionsubindex{depth-stencil-formatp}@c

This function returns t if the value provided is a keyword that can be found in
*depth-stencil-formats*
@table @strong
@item Package
@ref{go to the CEPL<dot>IMAGE-FORMATS package, , @t{cepl.image-formats}}
@item Source
@ref{go to the cepl/core/types/image-format<dot>lisp file, , @t{core/types/image-format.lisp}} (file)
@end table
@end deffn
@deffn {Function} {depth-test-function} &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>DEPTH-TEST-FUNCTION function}@c
@functionsubindex{depth-test-function}@c
@deffnx {Function} {(setf depth-test-function)} FUNCTION &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF DEPTH-TEST-FUNCTION) function}@c
@functionsubindex{(setf depth-test-function)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/depth/depth<dot>lisp file, , @t{core/depth/depth.lisp}} (file)
@end table
@end deffn
@deffn {Function} {destination-alpha} FBO &optional ATTACHMENT-NAME
@anchor{go to the CEPL<dot>BLENDING<colon><colon>DESTINATION-ALPHA function}@c
@functionsubindex{destination-alpha}@c

This function, when passed a `blending-params` object, will return the name of the
function that will be applied to the alpha value that is currently in the `fbo`
and is about to be combined with the value coming from the pipeline.@*

The result will be one of the following:@*

    :zero@*
    :one@*
    :src-color@*
    :one-minus-src-color@*
    :dst-color@*
    :one-minus-dst-color@*
    :src-alpha@*
    :one-minus-src-alpha@*
    :dst-alpha@*
    :one-minus-dst-alpha@*
    :constant-color@*
    :one-minus-constant-color@*
    :constant-alpha@*
    :one-minus-constant-alpha@*
    :src-alpha-saturate@*
    :src1-color@*
    :one-minus-src-color@*
    :src1-alpha@*
    :one-minus-src-alpha@*

To see more info on this subject please see the doc-string for the
blending-params struct.
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@item Writer
@ref{go to the CEPL<dot>BLENDING<colon><colon>(SETF DESTINATION-ALPHA) function, , @t{(setf destination-alpha)}} (function)
@end table
@end deffn
@deffn {Function} {(setf destination-alpha)} VALUE FBO &optional ATTACHMENT-NAME
@anchor{go to the CEPL<dot>BLENDING<colon><colon>(SETF DESTINATION-ALPHA) function}@c
@functionsubindex{(setf destination-alpha)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@item Reader
@ref{go to the CEPL<dot>BLENDING<colon><colon>DESTINATION-ALPHA function, , @t{destination-alpha}} (function)
@end table
@end deffn
@deffn {Function} {destination-rgb} FBO &optional ATTACHMENT-NAME
@anchor{go to the CEPL<dot>BLENDING<colon><colon>DESTINATION-RGB function}@c
@functionsubindex{destination-rgb}@c

This function, when passed a `blending-params` object, will return the name of the
function that will be applied to the color value that is currently in the `fbo`
and is about to be combined with the value coming from the pipeline.@*

The result will be one of the following:@*

    :zero@*
    :one@*
    :src-color@*
    :one-minus-src-color@*
    :dst-color@*
    :one-minus-dst-color@*
    :src-alpha@*
    :one-minus-src-alpha@*
    :dst-alpha@*
    :one-minus-dst-alpha@*
    :constant-color@*
    :one-minus-constant-color@*
    :constant-alpha@*
    :one-minus-constant-alpha@*
    :src-alpha-saturate@*
    :src1-color@*
    :one-minus-src-color@*
    :src1-alpha@*
    :one-minus-src-alpha@*

To see more info on this subject please see the doc-string for the
blending-params struct.
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@item Writer
@ref{go to the CEPL<dot>BLENDING<colon><colon>(SETF DESTINATION-RGB) function, , @t{(setf destination-rgb)}} (function)
@end table
@end deffn
@deffn {Function} {(setf destination-rgb)} VALUE FBO &optional ATTACHMENT-NAME
@anchor{go to the CEPL<dot>BLENDING<colon><colon>(SETF DESTINATION-RGB) function}@c
@functionsubindex{(setf destination-rgb)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@item Reader
@ref{go to the CEPL<dot>BLENDING<colon><colon>DESTINATION-RGB function, , @t{destination-rgb}} (function)
@end table
@end deffn
@deffn {Function} {destroy-surface} SURFACE &rest ARGS &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>DESTROY-SURFACE function}@c
@functionsubindex{destroy-surface}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Function} {double-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>DOUBLE-FROM-FOREIGN function}@c
@functionsubindex{double-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {double-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>DOUBLE-TO-FOREIGN function}@c
@functionsubindex{double-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {draw-fbo-bound} CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>DRAW-FBO-BOUND function}@c
@functionsubindex{draw-fbo-bound}@c
@deffnx {Function} {(setf draw-fbo-bound)} FBO CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF DRAW-FBO-BOUND) function}@c
@functionsubindex{(setf draw-fbo-bound)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {draw-mode-group-id} X
@anchor{go to the %CEPL<dot>TYPES<colon><colon>DRAW-MODE-GROUP-ID function}@c
@functionsubindex{draw-mode-group-id}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {elements-indirect-command-base-instance} WRAPPED-OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ELEMENTS-INDIRECT-COMMAND-BASE-INSTANCE function}@c
@functionsubindex{elements-indirect-command-base-instance}@c
@deffnx {Function} {(setf elements-indirect-command-base-instance)} VALUE WRAPPED-OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF ELEMENTS-INDIRECT-COMMAND-BASE-INSTANCE) function}@c
@functionsubindex{(setf elements-indirect-command-base-instance)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/multi-draw<dot>lisp file, , @t{core/pipelines/multi-draw.lisp}} (file)
@end table
@end deffn
@deffn {Function} {elements-indirect-command-base-vertex} WRAPPED-OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ELEMENTS-INDIRECT-COMMAND-BASE-VERTEX function}@c
@functionsubindex{elements-indirect-command-base-vertex}@c
@deffnx {Function} {(setf elements-indirect-command-base-vertex)} VALUE WRAPPED-OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF ELEMENTS-INDIRECT-COMMAND-BASE-VERTEX) function}@c
@functionsubindex{(setf elements-indirect-command-base-vertex)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/multi-draw<dot>lisp file, , @t{core/pipelines/multi-draw.lisp}} (file)
@end table
@end deffn
@deffn {Function} {elements-indirect-command-count} WRAPPED-OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ELEMENTS-INDIRECT-COMMAND-COUNT function}@c
@functionsubindex{elements-indirect-command-count}@c
@deffnx {Function} {(setf elements-indirect-command-count)} VALUE WRAPPED-OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF ELEMENTS-INDIRECT-COMMAND-COUNT) function}@c
@functionsubindex{(setf elements-indirect-command-count)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/multi-draw<dot>lisp file, , @t{core/pipelines/multi-draw.lisp}} (file)
@end table
@end deffn
@deffn {Function} {elements-indirect-command-first-index} WRAPPED-OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ELEMENTS-INDIRECT-COMMAND-FIRST-INDEX function}@c
@functionsubindex{elements-indirect-command-first-index}@c
@deffnx {Function} {(setf elements-indirect-command-first-index)} VALUE WRAPPED-OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF ELEMENTS-INDIRECT-COMMAND-FIRST-INDEX) function}@c
@functionsubindex{(setf elements-indirect-command-first-index)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/multi-draw<dot>lisp file, , @t{core/pipelines/multi-draw.lisp}} (file)
@end table
@end deffn
@deffn {Function} {elements-indirect-command-instance-count} WRAPPED-OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ELEMENTS-INDIRECT-COMMAND-INSTANCE-COUNT function}@c
@functionsubindex{elements-indirect-command-instance-count}@c
@deffnx {Function} {(setf elements-indirect-command-instance-count)} VALUE WRAPPED-OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF ELEMENTS-INDIRECT-COMMAND-INSTANCE-COUNT) function}@c
@functionsubindex{(setf elements-indirect-command-instance-count)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/multi-draw<dot>lisp file, , @t{core/pipelines/multi-draw.lisp}} (file)
@end table
@end deffn
@deffn {Function} {empty-fbo-params} FBO
@anchor{go to the %CEPL<dot>TYPES<colon><colon>EMPTY-FBO-PARAMS function}@c
@functionsubindex{empty-fbo-params}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {empty-fbo-params-dimensions} PARAMS
@anchor{go to the CEPL<dot>FBOS<colon><colon>EMPTY-FBO-PARAMS-DIMENSIONS function}@c
@functionsubindex{empty-fbo-params-dimensions}@c
@deffnx {Function} {(setf empty-fbo-params-dimensions)} VALUE PARAMS
@anchor{go to the CEPL<dot>FBOS<colon><colon>(SETF EMPTY-FBO-PARAMS-DIMENSIONS) function}@c
@functionsubindex{(setf empty-fbo-params-dimensions)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {empty-fbo-params-fixed-sample-locations-p} PARAMS
@anchor{go to the CEPL<dot>FBOS<colon><colon>EMPTY-FBO-PARAMS-FIXED-SAMPLE-LOCATIONS-P function}@c
@functionsubindex{empty-fbo-params-fixed-sample-locations-p}@c
@deffnx {Function} {(setf empty-fbo-params-fixed-sample-locations-p)} VALUE PARAMS
@anchor{go to the CEPL<dot>FBOS<colon><colon>(SETF EMPTY-FBO-PARAMS-FIXED-SAMPLE-LOCATIONS-P) function}@c
@functionsubindex{(setf empty-fbo-params-fixed-sample-locations-p)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {empty-fbo-params-layer-count} PARAMS
@anchor{go to the CEPL<dot>FBOS<colon><colon>EMPTY-FBO-PARAMS-LAYER-COUNT function}@c
@functionsubindex{empty-fbo-params-layer-count}@c
@deffnx {Function} {(setf empty-fbo-params-layer-count)} VALUE PARAMS
@anchor{go to the CEPL<dot>FBOS<colon><colon>(SETF EMPTY-FBO-PARAMS-LAYER-COUNT) function}@c
@functionsubindex{(setf empty-fbo-params-layer-count)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {empty-fbo-params-samples} PARAMS
@anchor{go to the CEPL<dot>FBOS<colon><colon>EMPTY-FBO-PARAMS-SAMPLES function}@c
@functionsubindex{empty-fbo-params-samples}@c
@deffnx {Function} {(setf empty-fbo-params-samples)} VALUE PARAMS
@anchor{go to the CEPL<dot>FBOS<colon><colon>(SETF EMPTY-FBO-PARAMS-SAMPLES) function}@c
@functionsubindex{(setf empty-fbo-params-samples)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {empty-fbo-params-viewport} PARAMS
@anchor{go to the CEPL<dot>FBOS<colon><colon>EMPTY-FBO-PARAMS-VIEWPORT function}@c
@functionsubindex{empty-fbo-params-viewport}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {ensure-vec-index} VEC INDEX NULL-ELEMENT &optional ELEMENT-TYPE
@anchor{go to the CEPL-UTILS<colon><colon>ENSURE-VEC-INDEX function}@c
@functionsubindex{ensure-vec-index}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {fbo-bound} CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>FBO-BOUND function}@c
@functionsubindex{fbo-bound}@c
@deffnx {Function} {(setf fbo-bound)} FBO CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF FBO-BOUND) function}@c
@functionsubindex{(setf fbo-bound)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {fbo-empty-p} FBO
@anchor{go to the %CEPL<dot>TYPES<colon><colon>FBO-EMPTY-P function}@c
@functionsubindex{fbo-empty-p}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {fbo-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>FBO-P function}@c
@functionsubindex{fbo-p}@c

This function will return t if the given value is an `fbo`, otherwise it will
return nil
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {file-to-string} PATH
@anchor{go to the CEPL-UTILS<colon><colon>FILE-TO-STRING function}@c
@functionsubindex{file-to-string}@c
Sucks up an entire file from PATH into a freshly-allocated
   string, returning two values: the string and the number of
   bytes read.
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {filter-hash} FUNCTION HASH-TABLE
@anchor{go to the CEPL-UTILS<colon><colon>FILTER-HASH function}@c
@functionsubindex{filter-hash}@c
map through a hash and actually return something
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {find-in-tree} ITEM TREE &key TEST
@anchor{go to the CEPL-UTILS<colon><colon>FIND-IN-TREE function}@c
@functionsubindex{find-in-tree}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {flatten} X
@anchor{go to the CEPL-UTILS<colon><colon>FLATTEN function}@c
@functionsubindex{flatten}@c
Walks a list tree and flattens it (returns a 1d list
   containing all the elements from the tree)
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {float-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>FLOAT-FROM-FOREIGN function}@c
@functionsubindex{float-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {float-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>FLOAT-TO-FOREIGN function}@c
@functionsubindex{float-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {force-bind-query} CEPL-CONTEXT QUERY
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>FORCE-BIND-QUERY function}@c
@functionsubindex{force-bind-query}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {force-unbind-query} CEPL-CONTEXT QUERY
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>FORCE-UNBIND-QUERY function}@c
@functionsubindex{force-unbind-query}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {free-buffer} BUFFER
@anchor{go to the CEPL<dot>GPU-BUFFERS<colon><colon>FREE-BUFFER function}@c
@functionsubindex{free-buffer}@c

This function, when passed a `gpu-buffer` will free the memory on the gpu and
'blank' the `gpu-buffer`.@*

Blanking in this case means that the slots of the `gpu-buffer` will all be set to
default values.
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-BUFFERS package, , @t{cepl.gpu-buffers}}
@item Source
@ref{go to the cepl/core/gpu-buffers/gpu-buffers<dot>lisp file, , @t{core/gpu-buffers/gpu-buffers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {free-buffer-stream} BUFFER-STREAM
@anchor{go to the CEPL<dot>STREAMS<colon><colon>FREE-BUFFER-STREAM function}@c
@functionsubindex{free-buffer-stream}@c

Calling this with a buffer-stream will free the VAO owned by this buffer-stream
and blank the buffer-stream object.@*

It will not free any of the gpu-data that was composed to make this stream.@*

Calling the generic function `free` with a buffer-stream will call this function
@table @strong
@item Package
@ref{go to the CEPL<dot>STREAMS package, , @t{cepl.streams}}
@item Source
@ref{go to the cepl/core/streams/buffer-streams<dot>lisp file, , @t{core/streams/buffer-streams.lisp}} (file)
@end table
@end deffn
@deffn {Function} {free-buffers} BUFFERS
@anchor{go to the CEPL<dot>GPU-BUFFERS<colon><colon>FREE-BUFFERS function}@c
@functionsubindex{free-buffers}@c

This function, when passed a list of  gpus-buffer will free the gpu memory for
all the gpus-buffers and 'blank' them.@*

Blanking in this case means that the slots of each `gpu-buffer` will all be set to
default values.
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-BUFFERS package, , @t{cepl.gpu-buffers}}
@item Source
@ref{go to the cepl/core/gpu-buffers/gpu-buffers<dot>lisp file, , @t{core/gpu-buffers/gpu-buffers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {free-c-array} C-ARRAY
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>FREE-C-ARRAY function}@c
@functionsubindex{free-c-array}@c

Frees the foreign memory allocated with the `c-array` and 'blanks' the c-array.

Blanking the c-array means its fields will be set to default values,@*
for example dimensions will be 0, the pointer will be null etc.@*

The generic function `free` will call `free-c-array` when passed a c-array.
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/def<dot>lisp file, , @t{core/c-arrays/def.lisp}} (file)
@end table
@end deffn
@deffn {Function} {free-gpu-fence} FENCE
@anchor{go to the CEPL<dot>SYNC<colon><colon>FREE-GPU-FENCE function}@c
@functionsubindex{free-gpu-fence}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SYNC package, , @t{cepl.sync}}
@item Source
@ref{go to the cepl/core/sync/sync<dot>lisp file, , @t{core/sync/sync.lisp}} (file)
@end table
@end deffn
@deffn {Function} {free-pipeline} PIPELINE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>FREE-PIPELINE function}@c
@functionsubindex{free-pipeline}@c

This function takes a pipeline designator[0] and frees it, this releases
frees the gl-program object.@*

[0] either a lambda-pipeline or a symbol naming a pipeline
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {free-sampler} SAMPLER
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>FREE-SAMPLER function}@c
@functionsubindex{free-sampler}@c

Calling this with a `sampler` will free the gl sampler and blank the lisp object representing it.

Calling the generic function `free` with a sampler will call this function
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {free-vao} VAO
@anchor{go to the CEPL<dot>VAOS<colon><colon>FREE-VAO function}@c
@functionsubindex{free-vao}@c

Takes a GL VAO and deletes it
@table @strong
@item Package
@ref{go to the CEPL<dot>VAOS package, , @t{cepl.vaos}}
@item Source
@ref{go to the cepl/core/vaos/vaos<dot>lisp file, , @t{core/vaos/vaos.lisp}} (file)
@end table
@end deffn
@deffn {Function} {free-vaos} VAOS
@anchor{go to the CEPL<dot>VAOS<colon><colon>FREE-VAOS function}@c
@functionsubindex{free-vaos}@c

Takes a list of GL VAOs and deletes them.

This function exists as a minor optimization.
@table @strong
@item Package
@ref{go to the CEPL<dot>VAOS package, , @t{cepl.vaos}}
@item Source
@ref{go to the cepl/core/vaos/vaos<dot>lisp file, , @t{core/vaos/vaos.lisp}} (file)
@end table
@end deffn
@deffn {Function} {front-face} &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>FRONT-FACE function}@c
@functionsubindex{front-face}@c
@deffnx {Function} {(setf front-face)} WINDING-DIRECTION &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF FRONT-FACE) function}@c
@functionsubindex{(setf front-face)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/face/face<dot>lisp file, , @t{core/face/face.lisp}} (file)
@end table
@end deffn
@deffn {Function} {funcall-g} NAME &rest ARGS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>FUNCALL-G function}@c
@functionsubindex{funcall-g}@c

funcall-g is an experimental function. What it aims to allow you to do is to
generate and run a pipeline which runs the requested function once with the
given arguments on the GPU.@*

By doing this it gives you a way to try out your gpu-functions from the REPL
without having to make a pipeline map-g over it whilst use ssbos or
transform-feedback to capture the result.@*

Currently this only works with functions that would work within a vertex
shader  (so things like gl-frag-pos will not work) however we want to expand on
this in the future.@*

This is not intended to be used *anywhere* where performance matters, it was
made solely as a debugging/development aid. Every time it is run it must:@*

- generate a pipeline@*
- compile it@*
- map-g over it@*
- marshal the results back to lisp@*
- free the pipeline@*

This is *extremly* expensive, however as long as it takes less that 20ms or so
it is fast enough for use from the repl.
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/funcall-g<dot>lisp file, , @t{core/pipelines/funcall-g.lisp}} (file)
@end table
@end deffn
@deffn {Function} {generate-mipmaps} TEXTURE
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>GENERATE-MIPMAPS function}@c
@functionsubindex{generate-mipmaps}@c

Calling this with a `texture` asks OpenGL to generate mipmaps for the texture.

You do not normally need to use this function as you can use the :mipmaps
argument on `make-texture`. See `make-texture` for more details.
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gl-enum} KWD
@anchor{go to the CEPL-UTILS<colon><colon>GL-ENUM function}@c
@functionsubindex{gl-enum}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gl-initialized-p} &optional CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>GL-INITIALIZED-P function}@c
@functionsubindex{gl-initialized-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gl-type-size} TYPE
@anchor{go to the CEPL<dot>INTERNALS<colon><colon>GL-TYPE-SIZE function}@c
@functionsubindex{gl-type-size}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>INTERNALS package, , @t{cepl.internals}}
@item Source
@ref{go to the cepl/core/internals<dot>lisp file, , @t{core/internals.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-array-access-style} GPU-ARRAY
@anchor{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED<colon><colon>GPU-ARRAY-ACCESS-STYLE function}@c
@functionsubindex{gpu-array-access-style}@c

When passed a buffer-backed `gpu-array` this function will return the access-style
of the underlying gpu-buffer.@*

The access-style of a gpu-array (or `gpu-buffer`) is a hint to OpenGL on how you
intend to use the array. It is optional whether your gpu manufacturer's
implementation of GL takes any notice of this option. When they do take notice
of it, it will to optimize access to the underlying data.@*

There are also no repercussions for accessing the data in a way contrary to the
declared access-style (other than potential performance costs).
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED package, , @t{cepl.gpu-arrays.buffer-backed}}
@item Source
@ref{go to the cepl/core/gpu-arrays/buffer-backed<dot>lisp file, , @t{core/gpu-arrays/buffer-backed.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-array-bb-access-style} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB-ACCESS-STYLE function}@c
@functionsubindex{gpu-array-bb-access-style}@c
@deffnx {Function} {(setf gpu-array-bb-access-style)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-BB-ACCESS-STYLE) function}@c
@functionsubindex{(setf gpu-array-bb-access-style)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-array-bb-buffer} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB-BUFFER function}@c
@functionsubindex{gpu-array-bb-buffer}@c
@deffnx {Function} {(setf gpu-array-bb-buffer)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-BB-BUFFER) function}@c
@functionsubindex{(setf gpu-array-bb-buffer)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-array-bb-byte-size} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB-BYTE-SIZE function}@c
@functionsubindex{gpu-array-bb-byte-size}@c
@deffnx {Function} {(setf gpu-array-bb-byte-size)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-BB-BYTE-SIZE) function}@c
@functionsubindex{(setf gpu-array-bb-byte-size)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-array-bb-element-byte-size} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB-ELEMENT-BYTE-SIZE function}@c
@functionsubindex{gpu-array-bb-element-byte-size}@c
@deffnx {Function} {(setf gpu-array-bb-element-byte-size)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-BB-ELEMENT-BYTE-SIZE) function}@c
@functionsubindex{(setf gpu-array-bb-element-byte-size)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-array-bb-element-pixel-format} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB-ELEMENT-PIXEL-FORMAT function}@c
@functionsubindex{gpu-array-bb-element-pixel-format}@c
@deffnx {Function} {(setf gpu-array-bb-element-pixel-format)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-BB-ELEMENT-PIXEL-FORMAT) function}@c
@functionsubindex{(setf gpu-array-bb-element-pixel-format)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-array-bb-element-type} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB-ELEMENT-TYPE function}@c
@functionsubindex{gpu-array-bb-element-type}@c
@deffnx {Function} {(setf gpu-array-bb-element-type)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-BB-ELEMENT-TYPE) function}@c
@functionsubindex{(setf gpu-array-bb-element-type)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-array-bb-offset-in-bytes-into-buffer} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB-OFFSET-IN-BYTES-INTO-BUFFER function}@c
@functionsubindex{gpu-array-bb-offset-in-bytes-into-buffer}@c
@deffnx {Function} {(setf gpu-array-bb-offset-in-bytes-into-buffer)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-BB-OFFSET-IN-BYTES-INTO-BUFFER) function}@c
@functionsubindex{(setf gpu-array-bb-offset-in-bytes-into-buffer)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-array-bb-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB-P function}@c
@functionsubindex{gpu-array-bb-p}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-array-bb-row-alignment} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB-ROW-ALIGNMENT function}@c
@functionsubindex{gpu-array-bb-row-alignment}@c
@deffnx {Function} {(setf gpu-array-bb-row-alignment)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-BB-ROW-ALIGNMENT) function}@c
@functionsubindex{(setf gpu-array-bb-row-alignment)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-array-buffer} GPU-ARRAY
@anchor{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED<colon><colon>GPU-ARRAY-BUFFER function}@c
@functionsubindex{gpu-array-buffer}@c

When passed a buffer-backed `gpu-array` this function will return the `gpu-buffer`
backing this array.@*

Note that if you made the array with `make-gpu-arrays` then there will be
multiple gpu-arrays sharing this buffer, so care should be taken when modifying
or freeing data.
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED package, , @t{cepl.gpu-arrays.buffer-backed}}
@item Source
@ref{go to the cepl/core/gpu-arrays/buffer-backed<dot>lisp file, , @t{core/gpu-arrays/buffer-backed.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-array-dimensions} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-DIMENSIONS function}@c
@functionsubindex{gpu-array-dimensions}@c

Return a list whose elements are the dimensions of the array.@*

You can also use the generic function `dimensions` to get this info.
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-DIMENSIONS) function, , @t{(setf gpu-array-dimensions)}} (function)
@end table
@end deffn
@deffn {Function} {(setf gpu-array-dimensions)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-DIMENSIONS) function}@c
@functionsubindex{(setf gpu-array-dimensions)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-DIMENSIONS function, , @t{gpu-array-dimensions}} (function)
@end table
@end deffn
@deffn {Function} {gpu-array-element-type} GPU-ARRAY
@anchor{go to the CEPL<dot>GPU-ARRAYS<colon><colon>GPU-ARRAY-ELEMENT-TYPE function}@c
@functionsubindex{gpu-array-element-type}@c

Will return the type of the elements in the `gpu-array` given.@*

If this is a texture-backed gpu-array then the element-type will be the same as
the 'image-format' of the `texture`.
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS package, , @t{cepl.gpu-arrays}}
@item Source
@ref{go to the cepl/core/gpu-arrays/with-and-push<dot>lisp file, , @t{core/gpu-arrays/with-and-push.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-array-face-num} GPU-ARRAY
@anchor{go to the CEPL<dot>GPU-ARRAYS<dot>TEXTURE-BACKED<colon><colon>GPU-ARRAY-FACE-NUM function}@c
@functionsubindex{gpu-array-face-num}@c

When passed a texture-backed `gpu-array` this function will return the index of
the `texture`'s cubeface that contains this gpu-array. This only truly applies to
gpu-arrays belonging to cubemap `texture`s, for all gpu-arrays this number will
always be 0.
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS<dot>TEXTURE-BACKED package, , @t{cepl.gpu-arrays.texture-backed}}
@item Source
@ref{go to the cepl/core/gpu-arrays/texture-backed<dot>lisp file, , @t{core/gpu-arrays/texture-backed.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-array-layer-num} GPU-ARRAY
@anchor{go to the CEPL<dot>GPU-ARRAYS<dot>TEXTURE-BACKED<colon><colon>GPU-ARRAY-LAYER-NUM function}@c
@functionsubindex{gpu-array-layer-num}@c

When passed a texture-backed `gpu-array` this function will return the index of
the gpu-array within the array-textures. This only truly applies to gpu-arrays
 belonging to array-textures, for all gpu-arrays this number will always be 0.
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS<dot>TEXTURE-BACKED package, , @t{cepl.gpu-arrays.texture-backed}}
@item Source
@ref{go to the cepl/core/gpu-arrays/texture-backed<dot>lisp file, , @t{core/gpu-arrays/texture-backed.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-array-level-num} GPU-ARRAY
@anchor{go to the CEPL<dot>GPU-ARRAYS<dot>TEXTURE-BACKED<colon><colon>GPU-ARRAY-LEVEL-NUM function}@c
@functionsubindex{gpu-array-level-num}@c

When passed a texture-backed `gpu-array` this function will return the
mipmap level the gpu-array resides on within the `texture`.@*

This only truly applies to gpu-arrays with mipmaps, for all gpu-arrays this
number will always be 0.
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS<dot>TEXTURE-BACKED package, , @t{cepl.gpu-arrays.texture-backed}}
@item Source
@ref{go to the cepl/core/gpu-arrays/texture-backed<dot>lisp file, , @t{core/gpu-arrays/texture-backed.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-array-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-P function}@c
@functionsubindex{gpu-array-p}@c

Will return t if the value given is a `gpu-array`.@*

This will return t for both texture-backed and buffer-backed gpu-arrays
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-array-t-face-num} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T-FACE-NUM function}@c
@functionsubindex{gpu-array-t-face-num}@c
@deffnx {Function} {(setf gpu-array-t-face-num)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-T-FACE-NUM) function}@c
@functionsubindex{(setf gpu-array-t-face-num)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-array-t-image-format} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T-IMAGE-FORMAT function}@c
@functionsubindex{gpu-array-t-image-format}@c
@deffnx {Function} {(setf gpu-array-t-image-format)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-T-IMAGE-FORMAT) function}@c
@functionsubindex{(setf gpu-array-t-image-format)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-array-t-layer-num} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T-LAYER-NUM function}@c
@functionsubindex{gpu-array-t-layer-num}@c
@deffnx {Function} {(setf gpu-array-t-layer-num)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-T-LAYER-NUM) function}@c
@functionsubindex{(setf gpu-array-t-layer-num)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-array-t-level-num} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T-LEVEL-NUM function}@c
@functionsubindex{gpu-array-t-level-num}@c
@deffnx {Function} {(setf gpu-array-t-level-num)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-T-LEVEL-NUM) function}@c
@functionsubindex{(setf gpu-array-t-level-num)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-array-t-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T-P function}@c
@functionsubindex{gpu-array-t-p}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-array-t-texture} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T-TEXTURE function}@c
@functionsubindex{gpu-array-t-texture}@c
@deffnx {Function} {(setf gpu-array-t-texture)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-T-TEXTURE) function}@c
@functionsubindex{(setf gpu-array-t-texture)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-array-t-texture-type} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T-TEXTURE-TYPE function}@c
@functionsubindex{gpu-array-t-texture-type}@c
@deffnx {Function} {(setf gpu-array-t-texture-type)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-T-TEXTURE-TYPE) function}@c
@functionsubindex{(setf gpu-array-t-texture-type)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-array-texture} GPU-ARRAY
@anchor{go to the CEPL<dot>GPU-ARRAYS<dot>TEXTURE-BACKED<colon><colon>GPU-ARRAY-TEXTURE function}@c
@functionsubindex{gpu-array-texture}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS<dot>TEXTURE-BACKED package, , @t{cepl.gpu-arrays.texture-backed}}
@item Source
@ref{go to the cepl/core/gpu-arrays/texture-backed<dot>lisp file, , @t{core/gpu-arrays/texture-backed.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-array-texture-type} GPU-ARRAY
@anchor{go to the CEPL<dot>GPU-ARRAYS<dot>TEXTURE-BACKED<colon><colon>GPU-ARRAY-TEXTURE-TYPE function}@c
@functionsubindex{gpu-array-texture-type}@c

When passed a texture-backed `gpu-array` this function will return the
type of the `texture` containing this gpu-array.@*

The result will be one of the following:@*

    :texture-1d@*
    :texture-2d@*
    :texture-3d@*
    :texture-1d-array@*
    :texture-2d-array@*
    :texture-cube-map@*
    :texture-cube-map-array@*
    :texture-rectangle@*
    :texture-buffer@*
    :texture-buffer@*
    :texture-buffer@*
    :texture-2d-multisample@*
    :texture-2d-multisample-array
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS<dot>TEXTURE-BACKED package, , @t{cepl.gpu-arrays.texture-backed}}
@item Source
@ref{go to the cepl/core/gpu-arrays/texture-backed<dot>lisp file, , @t{core/gpu-arrays/texture-backed.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-buffer-arrays} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-BUFFER-ARRAYS function}@c
@functionsubindex{gpu-buffer-arrays}@c

This function returns an array of the raw :uint8 `gpu-array`s that make up the
data in this `gpu-buffer`.
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-BUFFER-ARRAYS) function, , @t{(setf gpu-buffer-arrays)}} (function)
@end table
@end deffn
@deffn {Function} {(setf gpu-buffer-arrays)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-BUFFER-ARRAYS) function}@c
@functionsubindex{(setf gpu-buffer-arrays)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-BUFFER-ARRAYS function, , @t{gpu-buffer-arrays}} (function)
@end table
@end deffn
@deffn {Function} {gpu-buffer-bound} CEPL-CONTEXT TARGET
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>GPU-BUFFER-BOUND function}@c
@functionsubindex{gpu-buffer-bound}@c
@deffnx {Function} {(setf gpu-buffer-bound)} VAL CTX TARGET
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF GPU-BUFFER-BOUND) function}@c
@functionsubindex{(setf gpu-buffer-bound)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-buffer-cache-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-BUFFER-CACHE-ID function}@c
@functionsubindex{gpu-buffer-cache-id}@c
@deffnx {Function} {(setf gpu-buffer-cache-id)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-BUFFER-CACHE-ID) function}@c
@functionsubindex{(setf gpu-buffer-cache-id)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-buffer-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-BUFFER-ID function}@c
@functionsubindex{gpu-buffer-id}@c

This function, when passed a `gpu-buffer` will return the OpenGL buffer object
from the `gpu-buffer`.@*

It is not recommended to modify this directly as the changes from doing so won't
be reflected in the layout of the `gpu-buffer`, which may potentially put the
`gpu-buffer` (and and `gpu-array` or `ubo` using it) into an invalid state.
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-BUFFER-ID) function, , @t{(setf gpu-buffer-id)}} (function)
@end table
@end deffn
@deffn {Function} {(setf gpu-buffer-id)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-BUFFER-ID) function}@c
@functionsubindex{(setf gpu-buffer-id)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-BUFFER-ID function, , @t{gpu-buffer-id}} (function)
@end table
@end deffn
@deffn {Function} {gpu-buffer-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-BUFFER-P function}@c
@functionsubindex{gpu-buffer-p}@c

This function returns t if the given value is a `gpu-buffer`. Otherwise it
returns nil.
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-fence-signalled-p} FENCE
@anchor{go to the CEPL<dot>SYNC<colon><colon>GPU-FENCE-SIGNALLED-P function}@c
@functionsubindex{gpu-fence-signalled-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SYNC package, , @t{cepl.sync}}
@item Source
@ref{go to the cepl/core/sync/sync<dot>lisp file, , @t{core/sync/sync.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-functions} NAME
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GPU-FUNCTIONS function}@c
@functionsubindex{gpu-functions}@c

This function returns all the signatures of the gpu-functions named 'name'.

The reason there may be many is that functions can be 'overloaded' so you
can have multiple gpu-functions with the same name as long as they can be
uniquely identified by the combination of their name and argument types.
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-query-cache-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-QUERY-CACHE-ID function}@c
@functionsubindex{gpu-query-cache-id}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-query-enum} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-QUERY-ENUM function}@c
@functionsubindex{gpu-query-enum}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-query-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-QUERY-ID function}@c
@functionsubindex{gpu-query-id}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-query-result-available-p} QUERY
@anchor{go to the CEPL<dot>QUERIES<colon><colon>GPU-QUERY-RESULT-AVAILABLE-P function}@c
@functionsubindex{gpu-query-result-available-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>QUERIES package, , @t{cepl.queries}}
@item Source
@ref{go to the cepl/core/queries/query<dot>lisp file, , @t{core/queries/query.lisp}} (file)
@end table
@end deffn
@deffn {Function} {group} SOURCE N
@anchor{go to the CEPL-UTILS<colon><colon>GROUP function}@c
@functionsubindex{group}@c
This takes a  flat list and emit a list of lists, each n long
   containing the elements of the original list
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {half-float-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>HALF-FLOAT-FROM-FOREIGN function}@c
@functionsubindex{half-float-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {half-float-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>HALF-FLOAT-TO-FOREIGN function}@c
@functionsubindex{half-float-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {half-vec2-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>HALF-VEC2-FROM-FOREIGN function}@c
@functionsubindex{half-vec2-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {half-vec2-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>HALF-VEC2-TO-FOREIGN function}@c
@functionsubindex{half-vec2-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {half-vec3-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>HALF-VEC3-FROM-FOREIGN function}@c
@functionsubindex{half-vec3-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {half-vec3-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>HALF-VEC3-TO-FOREIGN function}@c
@functionsubindex{half-vec3-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {half-vec4-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>HALF-VEC4-FROM-FOREIGN function}@c
@functionsubindex{half-vec4-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {half-vec4-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>HALF-VEC4-TO-FOREIGN function}@c
@functionsubindex{half-vec4-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {has-feature} X
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>HAS-FEATURE function}@c
@functionsubindex{has-feature}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/gl-context<dot>lisp file, , @t{core/context/gl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {hash-keys} HASH-TABLE
@anchor{go to the CEPL-UTILS<colon><colon>HASH-KEYS function}@c
@functionsubindex{hash-keys}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {hash-values} HASH-TABLE
@anchor{go to the CEPL-UTILS<colon><colon>HASH-VALUES function}@c
@functionsubindex{hash-values}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {hidden-symb} SYMBOL &optional SUB-NAME
@anchor{go to the CEPL-UTILS<colon><colon>HIDDEN-SYMB function}@c
@functionsubindex{hidden-symb}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {holds-gl-object-ref-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>HOLDS-GL-OBJECT-REF-P function}@c
@functionsubindex{holds-gl-object-ref-p}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {host-step} WIN
@anchor{go to the CEPL<dot>HOST<colon><colon>HOST-STEP function}@c
@functionsubindex{host-step}@c
not external
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Function} {host-swap} WIN
@anchor{go to the CEPL<dot>HOST<colon><colon>HOST-SWAP function}@c
@functionsubindex{host-swap}@c
not external
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Function} {image-format->lisp-type} IMAGE-FORMAT
@anchor{go to the CEPL<dot>TYPES<colon><colon>IMAGE-FORMAT->LISP-TYPE function}@c
@functionsubindex{image-format->lisp-type}@c

This function, when given a image-format name, will attempt to find and
return the name of a lisp type that is equivalent.@*

If no such type is found then nil is returned
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/pixel-format<dot>lisp file, , @t{core/types/pixel-format.lisp}} (file)
@end table
@end deffn
@deffn {Function} {image-format->pixel-format} IMAGE-FORMAT &key ERROR-IF-MISSING
@anchor{go to the CEPL<dot>TYPES<colon><colon>IMAGE-FORMAT->PIXEL-FORMAT function}@c
@functionsubindex{image-format->pixel-format}@c

This function, when given an image-format name, will attempt to find and
return equivalent equivalent `pixel-format`.@*

If no such type is found then nil is returned
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/pixel-format<dot>lisp file, , @t{core/types/pixel-format.lisp}} (file)
@end table
@end deffn
@deffn {Function} {image-formatp} FORMAT
@anchor{go to the CEPL<dot>IMAGE-FORMATS<colon><colon>IMAGE-FORMATP function}@c
@functionsubindex{image-formatp}@c

This function returns t if the value provided is a keyword that can be found in
*image-formats*
@table @strong
@item Package
@ref{go to the CEPL<dot>IMAGE-FORMATS package, , @t{cepl.image-formats}}
@item Source
@ref{go to the cepl/core/types/image-format<dot>lisp file, , @t{core/types/image-format.lisp}} (file)
@end table
@end deffn
@deffn {Function} {indexp} X
@anchor{go to the %CEPL<dot>TYPES<colon><colon>INDEXP function}@c
@functionsubindex{indexp}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {initialize} &rest ARGS &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>INITIALIZE function}@c
@functionsubindex{initialize}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Function} {initialize-cepl} &key GL-VERSION HOST-INIT-FLAGS
@anchor{go to the CEPL<colon><colon>INITIALIZE-CEPL function}@c
@functionsubindex{initialize-cepl}@c
@table @strong
@item Package
@ref{go to the CEPL package, , @t{cepl}}
@item Source
@ref{go to the cepl/core/repl<dot>lisp file, , @t{core/repl.lisp}} (file)
@end table
@end deffn
@deffn {Function} {int-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>INT-FROM-FOREIGN function}@c
@functionsubindex{int-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {int-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>INT-TO-FOREIGN function}@c
@functionsubindex{int-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {int32-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>INT32-FROM-FOREIGN function}@c
@functionsubindex{int32-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {int32-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>INT32-TO-FOREIGN function}@c
@functionsubindex{int32-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {int8-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>INT8-FROM-FOREIGN function}@c
@functionsubindex{int8-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {int8-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>INT8-TO-FOREIGN function}@c
@functionsubindex{int8-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {int8-vec2-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>INT8-VEC2-FROM-FOREIGN function}@c
@functionsubindex{int8-vec2-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {int8-vec2-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>INT8-VEC2-TO-FOREIGN function}@c
@functionsubindex{int8-vec2-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {int8-vec3-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>INT8-VEC3-FROM-FOREIGN function}@c
@functionsubindex{int8-vec3-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {int8-vec3-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>INT8-VEC3-TO-FOREIGN function}@c
@functionsubindex{int8-vec3-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {int8-vec4-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>INT8-VEC4-FROM-FOREIGN function}@c
@functionsubindex{int8-vec4-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {int8-vec4-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>INT8-VEC4-TO-FOREIGN function}@c
@functionsubindex{int8-vec4-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {intersperse} SYMB SEQUENCE
@anchor{go to the CEPL-UTILS<colon><colon>INTERSPERSE function}@c
@functionsubindex{intersperse}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {ivec2-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>IVEC2-FROM-FOREIGN function}@c
@functionsubindex{ivec2-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {ivec2-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>IVEC2-TO-FOREIGN function}@c
@functionsubindex{ivec2-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {ivec3-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>IVEC3-FROM-FOREIGN function}@c
@functionsubindex{ivec3-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {ivec3-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>IVEC3-TO-FOREIGN function}@c
@functionsubindex{ivec3-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {ivec4-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>IVEC4-FROM-FOREIGN function}@c
@functionsubindex{ivec4-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {ivec4-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>IVEC4-TO-FOREIGN function}@c
@functionsubindex{ivec4-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {just-ignore} &rest ARGS
@anchor{go to the CEPL-UTILS<colon><colon>JUST-IGNORE function}@c
@functionsubindex{just-ignore}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {keep} INCOMING-VAL STORED-VAL
@anchor{go to the CEPL<dot>DOCUMENTATION-FUNCTIONS<colon><colon>KEEP function}@c
@functionsubindex{keep}@c
Always returns the stored-val
@table @strong
@item Package
@ref{go to the CEPL<dot>DOCUMENTATION-FUNCTIONS package, , @t{cepl.documentation-functions}}
@item Source
@ref{go to the cepl/core/context/documentation-functions<dot>lisp file, , @t{core/context/documentation-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {kwd} &rest ARGS
@anchor{go to the CEPL-UTILS<colon><colon>KWD function}@c
@functionsubindex{kwd}@c
This takes a list of symbols (or strings) and outputs one
   keyword symbol.@*
   If the input is symbol/s then the output is a regular keyword
   If the input is string/s, then the output is@*
   a :|keyword like this|
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {last1} LIST
@anchor{go to the CEPL-UTILS<colon><colon>LAST1 function}@c
@functionsubindex{last1}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {lisp-type->image-format} LISP-TYPE
@anchor{go to the CEPL<dot>TYPES<colon><colon>LISP-TYPE->IMAGE-FORMAT function}@c
@functionsubindex{lisp-type->image-format}@c

This function, when given a lisp type name, will attempt to find and
return the name of a GL image-format that is equivalent.@*

If no such type is found then nil is returned
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/pixel-format<dot>lisp file, , @t{core/types/pixel-format.lisp}} (file)
@end table
@end deffn
@deffn {Function} {lispify-name} NAME
@anchor{go to the CEPL-UTILS<colon><colon>LISPIFY-NAME function}@c
@functionsubindex{lispify-name}@c
take a string and changes it to uppercase and replaces
   all underscores _ with minus symbols -
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {list-not-consp} X
@anchor{go to the CEPL-UTILS<colon><colon>LIST-NOT-CONSP function}@c
@functionsubindex{list-not-consp}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {listen-to-lifecycle-changes} FUNC &rest STATES-TO-SUBSCRIBE-TO
@anchor{go to the CEPL<dot>LIFECYCLE<colon><colon>LISTEN-TO-LIFECYCLE-CHANGES function}@c
@functionsubindex{listen-to-lifecycle-changes}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>LIFECYCLE package, , @t{cepl.lifecycle}}
@item Source
@ref{go to the cepl/core/lifecycle<dot>lisp file, , @t{core/lifecycle.lisp}} (file)
@end table
@end deffn
@deffn {Function} {listify} X
@anchor{go to the CEPL-UTILS<colon><colon>LISTIFY function}@c
@functionsubindex{listify}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {load-in-release-mode} &optional CEPL-HOST
@anchor{go to the CEPL<dot>BUILD<colon><colon>LOAD-IN-RELEASE-MODE function}@c
@functionsubindex{load-in-release-mode}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>BUILD package, , @t{cepl.build}}
@item Source
@ref{go to the cepl<dot>build/build/build<dot>lisp file, , @t{build/build.lisp}} (file)
@end table
@end deffn
@deffn {Function} {lod-bias} SAMPLER
@anchor{go to the %CEPL<dot>TYPES<colon><colon>LOD-BIAS function}@c
@functionsubindex{lod-bias}@c

This function sets the lod-bias of the given `texture` or `sampler`@*


**-- LOD --**@*

There is a pair of sampling parameters that affect the mipmap image selection:
:max-lod and :min-lod (floating-point values).@*

The way these work in mipmap selection is quite complicated; the specification
goes into full detail about it.@*

example:@*

    (setf (min-lod texture-or-sampler) value)@*
    (setf (max-lod texture-or-sampler) value)@*


LOD bias:@*
The mipmap image selection process can be adjusted coarsely by using the
:lod-bias sampling parameter. This bias will be added to the mipmap@*
LOD calculation (as well as added to the bias specified in one of the `texture`
accessing functions in GLSL), which is used to select the image. A positive bias
means that larger mipmaps will be selected even when the texture is viewed from
farther away. This can cause visual aliasing, but in small quantities it can
make textures a bit more sharp.@*

    (setf (lod-bias texture-or-sampler) value)
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF LOD-BIAS) function, , @t{(setf lod-bias)}} (function)
@end table
@end deffn
@deffn {Function} {(setf lod-bias)} VALUE SAMPLER
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF LOD-BIAS) function}@c
@functionsubindex{(setf lod-bias)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>LOD-BIAS function, , @t{lod-bias}} (function)
@end table
@end deffn
@deffn {Function} {magnify-filter} SAMPLER
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MAGNIFY-FILTER function}@c
@functionsubindex{magnify-filter}@c

This function takes a `sampler` or `texture` and sets the approach used when the
area of the fragment in texture space is smaller than a texel.@*


**-- The magnification filter --**@*

The magnification filter is controlled by the :magnify-filter texture parameter.
This value can be :linear or :nearest.@*

If :nearest is used, then the implementation will select the texel nearest the
texture coordinate; this is commonly called 'point sampling').@*

If :linear is used, the implementation will perform a weighted linear blend
between the nearest adjacent samples.@*

    (setf (magnify-filter tex-or-sampler) :linear)@*
    (setf (magnify-filter tex-or-sampler) :nearest)
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF MAGNIFY-FILTER) function, , @t{(setf magnify-filter)}} (function)
@end table
@end deffn
@deffn {Function} {(setf magnify-filter)} VALUE SAMPLER
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF MAGNIFY-FILTER) function}@c
@functionsubindex{(setf magnify-filter)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>MAGNIFY-FILTER function, , @t{magnify-filter}} (function)
@end table
@end deffn
@deffn {Function} {make-any-samples-passed-conservative-query} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MAKE-ANY-SAMPLES-PASSED-CONSERVATIVE-QUERY function}@c
@functionsubindex{make-any-samples-passed-conservative-query}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-any-samples-passed-query} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MAKE-ANY-SAMPLES-PASSED-QUERY function}@c
@functionsubindex{make-any-samples-passed-query}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-att} &key (ARRAY ARRAY) (BLEND BLEND) (BPARAMS BPARAMS) (OWNED-P OWNED-P) (VIEWPORT VIEWPORT)
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MAKE-ATT function}@c
@functionsubindex{make-att}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-blending-params} &key (MODE-RGB MODE-RGB) (MODE-ALPHA MODE-ALPHA) (SOURCE-RGB SOURCE-RGB) (SOURCE-ALPHA SOURCE-ALPHA) (DESTINATION-RGB DESTINATION-RGB) (DESTINATION-ALPHA DESTINATION-ALPHA)
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MAKE-BLENDING-PARAMS function}@c
@functionsubindex{make-blending-params}@c

This function makes a new `blending-params` object.@*

The valid values for `source-rgb`, `source-alpha`, `destination-rgb`
and `destination-alpha` are:@*

    :zero@*
    :one@*
    :src-color@*
    :one-minus-src-color@*
    :dst-color@*
    :one-minus-dst-color@*
    :src-alpha@*
    :one-minus-src-alpha@*
    :dst-alpha@*
    :one-minus-dst-alpha@*
    :constant-color@*
    :one-minus-constant-color@*
    :constant-alpha@*
    :one-minus-constant-alpha@*
    :src-alpha-saturate@*
    :src1-color@*
    :one-minus-src-color@*
    :src1-alpha@*
    :one-minus-src-alpha@*

The valid values for `mode-rgb` and `mode-alpha` are:@*

    :func-add@*
    :func-subtract@*
    :func-reverse-subtract@*
    :min@*
    :max@*

For details on their behaviour on the blending-params object please see the
docstring for blending-params.
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-buffer-stream} GPU-ARRAYS &key INDEX-ARRAY START LENGTH RETAIN-ARRAYS PRIMITIVE BASE-VERTEX
@anchor{go to the CEPL<dot>STREAMS<colon><colon>MAKE-BUFFER-STREAM function}@c
@functionsubindex{make-buffer-stream}@c

This function composes a number of gpu-arrays into a buffer-stream.@*
No data is copied, the buffer-stream simply refers to the gpu-arrays so the
gpu knows where to pull data from.@*

You can optionally pass a gpu-array to act as an index into the other arrays.

Usually when you map over a buffer-stream it will call the pipeline pulling 1
value from each of the composed gpu-arrays on each 'iteration'[0].@*
When you have an index then map-g will pull 1 value from index each 'iteration'
and use that to pick which value to use from the other arrays. This approach
gives bigs boosts in performance and memory usage when rendering.@*

The element-type of the index-array must be of the following:@*
:uint8 :ushort :uint :unsigned-short :unsigned-int@*

As well as an element type you also can specify the primitive-type. This says
what the gpu will draw this data as. It can be any one of:@*

 :points@*
 :lines@*
 :line-loop@*
 :line-strip@*
 :lines-adjacency@*
 :line-strip-adjacency@*
 :triangles@*
 :triangle-fan@*
 :triangle-strip@*
 :triangles-adjacency@*
 :triangle-strip-adjacency@*
 (:patch <patch-size>)@*

By default the primitive-type is :triangles@*

It is also worth noting  that you can also use gpu-sub-arrays in here if you
want to limit the data you are using, for example the following is perfectly
legal code:@*

    (make-buffer-stream@*
      :gpu-arrays `(,(gpu-sub-array monster-pos-data 1000 2000)
                   ,(gpu-sub-array monster-col-data 1000 2000))
      :index-array monster-index-array@*
      :length 1000)@*

[0] The use of the term 'iteration' here is quoted as the gpu is going to be
    doing this work in parallel, however it makes the explanation clearer so
    that is why it is there. If you have a clearer way of explaining the
    behaviour please file it as an issue on github.
@table @strong
@item Package
@ref{go to the CEPL<dot>STREAMS package, , @t{cepl.streams}}
@item Source
@ref{go to the cepl/core/streams/buffer-streams<dot>lisp file, , @t{core/streams/buffer-streams.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-buffer-stream-from-id-and-layouts} VAO-GL-OBJECT DATA-LAYOUTS INDEX-LAYOUT &key START LENGTH PRIMITIVE
@anchor{go to the CEPL<dot>STREAMS<colon><colon>MAKE-BUFFER-STREAM-FROM-ID-AND-LAYOUTS function}@c
@functionsubindex{make-buffer-stream-from-id-and-layouts}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>STREAMS package, , @t{cepl.streams}}
@item Source
@ref{go to the cepl/core/streams/buffer-streams<dot>lisp file, , @t{core/streams/buffer-streams.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-buffer-stream-sharing} STREAM &optional BASE-VERTEX
@anchor{go to the CEPL<dot>STREAMS<colon><colon>MAKE-BUFFER-STREAM-SHARING function}@c
@functionsubindex{make-buffer-stream-sharing}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>STREAMS package, , @t{cepl.streams}}
@item Source
@ref{go to the cepl/core/streams/buffer-streams<dot>lisp file, , @t{core/streams/buffer-streams.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-c-array} INITIAL-CONTENTS &key DIMENSIONS ELEMENT-TYPE ROW-ALIGNMENT
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>MAKE-C-ARRAY function}@c
@functionsubindex{make-c-array}@c

This function will make and return a new `c-array`.@*

It can be used in a few different ways:@*

- with :initial-contents to nil:@*
  In this case you need to provide dimensions and an element-type.@*

- with :initial-contents populated.@*
  The initial-contents can be a (potentially nested) list or array.@*

When :initial-contents is an array then the dimension of the c-array@*
will be the same as the array passed in. CEPL currently only supports up@*
to 4D c-arrays.@*

When the :initial-contents is a flat list then each element is used as one@*
element in the c-array.@*
If the :initial-contents is a nested list then you must either:@*

- specify multiple dimensions and an element-type@*
- specify an element-type to be some struct type, then nested lists are then@*
  used to populate the fields of the foreign structs. For an example of this@*
  please see [this example](https://github.com/cbaggers/cepl.examples/blob/master/examples/triangle.lisp#L30).

If the :element-type is not provided then CEPL will look at every element in@*
the initial-contents and try and find the smallest (in bytes) foreign type@*
which works for every element. This mean if the array is full of single-floats@*
then CEPL will choose :float, not :double.@*
Naturally this behaviour is too slow for use in performance critical@*
applications however it is nice for experimentation and working from the repl.@*

If you need what would be called a displaced array in lisp then please see the@*
`subseq-c` function.
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/make<dot>lisp file, , @t{core/c-arrays/make.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-c-array-from-pointer} DIMENSIONS ELEMENT-TYPE POINTER &key FREE ELEMENT-BYTE-SIZE ROW-ALIGNMENT
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>MAKE-C-ARRAY-FROM-POINTER function}@c
@functionsubindex{make-c-array-from-pointer}@c

Will create a CEPL `c-array` with the element-type and dimensions specified,
and will store the pointer as where the data is expected to be.@*

This function does allocate the memory or validate the type or dimensions so be
very careful when using this function.
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/make<dot>lisp file, , @t{core/c-arrays/make.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-compute-space} &optional SIZE-X SIZE-Y SIZE-Z
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MAKE-COMPUTE-SPACE function}@c
@functionsubindex{make-compute-space}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-context} &key GL-VERSION
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>MAKE-CONTEXT function}@c
@functionsubindex{make-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-context-shared-with-current-context} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>MAKE-CONTEXT-SHARED-WITH-CURRENT-CONTEXT function}@c
@functionsubindex{make-context-shared-with-current-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-empty-fbo-params} &key (FBO FBO) (DIMENSIONS DIMENSIONS) (VIEWPORT VIEWPORT) (LAYER-COUNT LAYER-COUNT) (SAMPLES SAMPLES) (FIXED-SAMPLE-LOCATIONS-P FIXED-SAMPLE-LOCATIONS-P)
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MAKE-EMPTY-FBO-PARAMS function}@c
@functionsubindex{make-empty-fbo-params}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-fbo} &rest FUZZY-ATTACH-ARGS
@anchor{go to the CEPL<dot>FBOS<colon><colon>MAKE-FBO function}@c
@functionsubindex{make-fbo}@c

This, like other make-* functions in CEPL has a large variety of valid
arguments. The goal of this apparent complexity is to make exploration from the
repl easy, whilst still allowing absolutely control when it is needed.@*

Lets look at the behaviour when given different arguments@*


**-- (make-fbo) --**@*

Empty FBOs are possible in CEPL, however they wernt added in GL until v4.3 so
please see the empty FBO section below.@*

**-- (make-fbo 0) --**@*

Make an fbo with one color attachment in attachment slot 0.@*
CEPL with make a `texture` with dimensions equal to that of the current `viewport`
and with the element-type :rgba (which is a sensible default for a color
attachment)@*

**-- (make-fbo 0 1) --**@*

Make an fbo with two color attachments 1 in each of attachment slots 0 & 1.
CEPL with make the textures with dimensions equal to that of the current
viewport and with the element-type :rgba (which is a sensible default for a
color attachment)@*

**-- (make-fbo :d) --**@*

Make an fbo with one depth attachment.@*
CEPL with make a texture with dimensions equal to that of the current viewport
and with the element-type :depth-component24 (which is a sensible default for a
depth attachment)@*

**-- (make-fbo 0 1 :d) --**@*

Make an fbo with two color attachments and one depth attachment.@*

**-- (make-fbo (list 0 some-gpu-array)) --**@*

Makes an fbo with one color attachment whos `gpu-array` is 'some-gpu-array'@*

**--  (make-fbo (list 0 some-texture)) --**@*

Makes an fbo with one color attachment whos gpu-array is (texref some-texture)@*

**-- (make-fbo '(0 :dimensions (100 100) :element-type :rgba8)) --**@*

Makes an fbo with one color attachment whos gpu-array is taken from a new
texture created by taking the arguments after 0 and applying them to
`make-texture`@*

**-- Any combination of the above --**@*

**-- Empty FBOs --**@*

Empty FBOs are interesting in that you have a none of the pipeline outputs will
be written to anywhere, but rendering can otherwise proceed as normal. They were
only added in GL 4.3 so `make-fbo` will error if the current GL version is too low.

When defining an empty fbo there can be at most 1 attachment declaration.@*
When present the name must be NIL. You may also optionally specify the following
parameters as you would in `make-texture`:@*

- :dimensions@*
- :layer-count@*
- :samples@*
- :fixed-sample-locations@*

So the following are legal:@*

- `(make-fbo '(nil :dimensions (1024 1024)))`@*
- `(make-fbo '(nil))`@*
- `(make-fbo)`@*

**-- Cube Texture Initialization --**@*

One last variant is allowed. You are allowed to pass a cube-map texture along
with and optional depth option. This will result in each face of the cube being
bound to the fbo's attachments.@*

    (make-fbo cube-tex)@*

    (make-fbo cube-tex '(:d :dimensions (32 32))@*

    (make-fbo cube-tex :d) ;; depth attachment dimensions will match faces
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-g-pc} &key POSITION COLOR
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>MAKE-G-PC function}@c
@functionsubindex{make-g-pc}@c

This function returns a new instance of the gpu struct of type G-PC
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-g-pn} &key POSITION NORMAL
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>MAKE-G-PN function}@c
@functionsubindex{make-g-pn}@c

This function returns a new instance of the gpu struct of type G-PN
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-g-pnc} &key POSITION NORMAL COLOR
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>MAKE-G-PNC function}@c
@functionsubindex{make-g-pnc}@c

This function returns a new instance of the gpu struct of type G-PNC
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-g-pnt} &key POSITION NORMAL TEXTURE
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>MAKE-G-PNT function}@c
@functionsubindex{make-g-pnt}@c

This function returns a new instance of the gpu struct of type G-PNT
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-g-pntc} &key POSITION NORMAL TEXTURE COLOR
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>MAKE-G-PNTC function}@c
@functionsubindex{make-g-pntc}@c

This function returns a new instance of the gpu struct of type G-PNTC
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-g-pt} &key POSITION TEXTURE
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>MAKE-G-PT function}@c
@functionsubindex{make-g-pt}@c

This function returns a new instance of the gpu struct of type G-PT
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-gl-context} &rest ARGS &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>MAKE-GL-CONTEXT function}@c
@functionsubindex{make-gl-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-gl-context-current-on-surface} GL-CONTEXT SURFACE
@anchor{go to the CEPL<dot>HOST<colon><colon>MAKE-GL-CONTEXT-CURRENT-ON-SURFACE function}@c
@functionsubindex{make-gl-context-current-on-surface}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-gl-context-shared-with-current-context} &rest ARGS &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>MAKE-GL-CONTEXT-SHARED-WITH-CURRENT-CONTEXT function}@c
@functionsubindex{make-gl-context-shared-with-current-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-gpu-array-from-buffer} BUFFER &key ELEMENT-TYPE DIMENSIONS ACCESS-STYLE KEEP-DATA
@anchor{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED<colon><colon>MAKE-GPU-ARRAY-FROM-BUFFER function}@c
@functionsubindex{make-gpu-array-from-buffer}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED package, , @t{cepl.gpu-arrays.buffer-backed}}
@item Source
@ref{go to the cepl/core/gpu-arrays/buffer-backed<dot>lisp file, , @t{core/gpu-arrays/buffer-backed.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-gpu-array-from-buffer-id} GL-BUFFER-ID &key ELEMENT-TYPE DIMENSIONS ACCESS-STYLE
@anchor{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED<colon><colon>MAKE-GPU-ARRAY-FROM-BUFFER-ID function}@c
@functionsubindex{make-gpu-array-from-buffer-id}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED package, , @t{cepl.gpu-arrays.buffer-backed}}
@item Source
@ref{go to the cepl/core/gpu-arrays/buffer-backed<dot>lisp file, , @t{core/gpu-arrays/buffer-backed.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-gpu-arrays} C-ARRAYS &key ACCESS-STYLE
@anchor{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED<colon><colon>MAKE-GPU-ARRAYS function}@c
@functionsubindex{make-gpu-arrays}@c

This function takes a list of x `c-array`s and returns a list of x buffer-backed
`gpu-array`s.@*

The reason to use this rather than:@*

    (mapcar `make-gpu-array` c-arrays-list)@*

is that all of the gpu-arrays created will share the same `gpu-buffer`.@*

Usually you will know if you need this instead of `make-gpu-array` as you will
have some behaviour or performance characteristic in mind.
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED package, , @t{cepl.gpu-arrays.buffer-backed}}
@item Source
@ref{go to the cepl/core/gpu-arrays/buffer-backed<dot>lisp file, , @t{core/gpu-arrays/buffer-backed.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-gpu-arrays-from-buffer} BUFFER LAYOUTS &key ACCESS-STYLE KEEP-DATA
@anchor{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED<colon><colon>MAKE-GPU-ARRAYS-FROM-BUFFER function}@c
@functionsubindex{make-gpu-arrays-from-buffer}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED package, , @t{cepl.gpu-arrays.buffer-backed}}
@item Source
@ref{go to the cepl/core/gpu-arrays/buffer-backed<dot>lisp file, , @t{core/gpu-arrays/buffer-backed.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-gpu-arrays-from-buffer-id} GL-BUFFER-ID LAYOUTS &key ACCESS-STYLE
@anchor{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED<colon><colon>MAKE-GPU-ARRAYS-FROM-BUFFER-ID function}@c
@functionsubindex{make-gpu-arrays-from-buffer-id}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED package, , @t{cepl.gpu-arrays.buffer-backed}}
@item Source
@ref{go to the cepl/core/gpu-arrays/buffer-backed<dot>lisp file, , @t{core/gpu-arrays/buffer-backed.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-gpu-buffer} &key INITIAL-CONTENTS BUFFER-TARGET USAGE
@anchor{go to the CEPL<dot>GPU-BUFFERS<colon><colon>MAKE-GPU-BUFFER function}@c
@functionsubindex{make-gpu-buffer}@c

This function creates and returns a new `gpu-buffer`.@*


If you wish to populate the buffer during construction you can pass a `c-array` as
the :initial-contents.@*


The :usage argument is a hint to OpenGL on how you intend to use the `gpu-buffer`.
It is optional whether your gpu manufacturer's implementation of GL takes any
notice of this option. When they do take notice of it, it will to optimize
access to the underlying data.@*


The :target argument can take any of the following binding targets:@*

    Buffer Binding Target      Purpose
    -------------------------------------------------------------
    :array-buffer              Vertex attributes@*
    :atomic-counter-buffer     Atomic counter storage@*
    :copy-read-buffer          Buffer copy source@*
    :copy-write-buffer         Buffer copy destination
    :dispatch-indirect-buffer  Indirect compute dispatch commands
    :draw-indirect-buffer      Indirect command arguments
    :element-array-buffer      Vertex array indices@*
    :pixel-pack-buffer         Pixel read target@*
    :pixel-unpack-buffer       Texture data source@*
    :query-buffer              Query result buffer@*
    :shader-storage-buffer     Read-write storage for shaders@*
    :texture-buffer            Texture data buffer@*
    :transform-feedback-buffer Transform feedback buffer@*
    :uniform-buffer            Uniform block storage@*

Do note that the default of :array-buffer is perfectly fine for creating the
`gpu-buffer` and uploading the data. It does not limit how the buffer can be used
in future parts of your program.@*

@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-BUFFERS package, , @t{cepl.gpu-buffers}}
@item Source
@ref{go to the cepl/core/gpu-buffers/gpu-buffers<dot>lisp file, , @t{core/gpu-buffers/gpu-buffers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-gpu-buffer-from-id} GL-OBJECT &rest ARGS &key INITIAL-CONTENTS LAYOUTS BUFFER-TARGET USAGE KEEP-DATA
@anchor{go to the CEPL<dot>GPU-BUFFERS<colon><colon>MAKE-GPU-BUFFER-FROM-ID function}@c
@functionsubindex{make-gpu-buffer-from-id}@c

This function takes an existing GL Buffer Object and wraps it in a new
`gpu-buffer`.@*


If you wish to populate the buffer during construction you can pass a `c-array` as
the :initial-contents.@*


The :usage argument is a hint to OpenGL on how you intend to use the `gpu-buffer`.
It is optional whether your gpu manufacturer's implementation of GL takes any
notice of this option. When they do take notice of it, it will to optimize
access to the underlying data.@*


The :target argument can take any of the following binding targets:@*

    Buffer Binding Target      Purpose
    -------------------------------------------------------------
    :array-buffer              Vertex attributes@*
    :atomic-counter-buffer     Atomic counter storage@*
    :copy-read-buffer          Buffer copy source@*
    :copy-write-buffer         Buffer copy destination
    :dispatch-indirect-buffer  Indirect compute dispatch commands
    :draw-indirect-buffer      Indirect command arguments
    :element-array-buffer      Vertex array indices@*
    :pixel-pack-buffer         Pixel read target@*
    :pixel-unpack-buffer       Texture data source@*
    :query-buffer              Query result buffer@*
    :shader-storage-buffer     Read-write storage for shaders@*
    :texture-buffer            Texture data buffer@*
    :transform-feedback-buffer Transform feedback buffer@*
    :uniform-buffer            Uniform block storage@*

Do note that the default of :array-buffer is perfectly fine for creating the
`gpu-buffer` and uploading the data. It does not limit how the buffer can be used
in future parts of your program.
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-BUFFERS package, , @t{cepl.gpu-buffers}}
@item Source
@ref{go to the cepl/core/gpu-buffers/gpu-buffers<dot>lisp file, , @t{core/gpu-buffers/gpu-buffers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-gpu-fence} ()
@anchor{go to the CEPL<dot>SYNC<colon><colon>MAKE-GPU-FENCE function}@c
@functionsubindex{make-gpu-fence}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SYNC package, , @t{cepl.sync}}
@item Source
@ref{go to the cepl/core/sync/sync<dot>lisp file, , @t{core/sync/sync.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-keyword} &rest ARGS
@anchor{go to the CEPL-UTILS<colon><colon>MAKE-KEYWORD function}@c
@functionsubindex{make-keyword}@c
This takes a list of symbols (or strings) and outputs one
   keyword symbol.@*
   If the input is symbol/s then the output is a regular keyword
   If the input is string/s, then the output is@*
   a :|keyword like this|
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-pixel-format} &key (COMPONENTS COMPONENTS) (TYPE TYPE) (NORMALIZE NORMALIZE) (SIZES SIZES) (REVERSED REVERSED) (COMP-LENGTH COMP-LENGTH)
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MAKE-PIXEL-FORMAT function}@c
@functionsubindex{make-pixel-format}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-primitives-generated-query} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MAKE-PRIMITIVES-GENERATED-QUERY function}@c
@functionsubindex{make-primitives-generated-query}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-project} PATHNAME &key NAME HOST REPL DEPENDS-ON
@anchor{go to the CEPL<colon><colon>MAKE-PROJECT function}@c
@functionsubindex{make-project}@c

This function is a simple way to make a lisp project with all the@*
supporting libraries to get up and running with cepl quickly.@*

It uses the excellent quickproject project, so before starting be sure@*
to run the following in your repl:@*

    (ql:quickload :quickproject)@*

By default it assumes you want to use sdl2, skitter and dirt, and that@*
you will be using slime as the communication layer between lisp and your editor.

Valid values for the :repl argument are currently :slime or :slynk.
@table @strong
@item Package
@ref{go to the CEPL package, , @t{cepl}}
@item Source
@ref{go to the cepl/project<dot>lisp file, , @t{project.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-raw-buffer-stream} &key VAO START LENGTH INDEX-TYPE MANAGED GPU-ARRAYS PRIMITIVE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MAKE-RAW-BUFFER-STREAM function}@c
@functionsubindex{make-raw-buffer-stream}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-render-buffer} ELEMENT-TYPE DIMENSIONS &key MULTISAMPLE
@anchor{go to the CEPL<dot>RENDER-BUFFERS<colon><colon>MAKE-RENDER-BUFFER function}@c
@functionsubindex{make-render-buffer}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>RENDER-BUFFERS package, , @t{cepl.render-buffers}}
@item Source
@ref{go to the cepl/core/render-buffers/render-buffer<dot>lisp file, , @t{core/render-buffers/render-buffer.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-sampler-id-box} &key (ID ID) (SHARED-P SHARED-P)
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MAKE-SAMPLER-ID-BOX function}@c
@functionsubindex{make-sampler-id-box}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-samples-passed-query} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MAKE-SAMPLES-PASSED-QUERY function}@c
@functionsubindex{make-samples-passed-query}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-ssbo} DATA &optional ELEMENT-TYPE
@anchor{go to the CEPL<dot>SSBOS<colon><colon>MAKE-SSBO function}@c
@functionsubindex{make-ssbo}@c

This function will make and return a new `ssbo`@*

You need only provide an element type and the lisp data to populate that type.

For example, given the following type:@*

   (defstruct-g test@*
     (scale :float :accessor scale)@*
     (age :int))@*

You create a ssbo using this type as follows:@*

    (make-ssbo '(1.2 10) 'test)@*

You can also pass in a c-array or gpu-array and omit the optional type
specifier.@*

If you wish to make a ssbo from a specific element of a `c-array` or
`gpu-array` please see the #'make-ssbo-from-array function
@table @strong
@item Package
@ref{go to the CEPL<dot>SSBOS package, , @t{cepl.ssbos}}
@item Source
@ref{go to the cepl/core/ssbos/ssbos<dot>lisp file, , @t{core/ssbos/ssbos.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-ssbo-from-array} DATA &optional INDEX ELEMENT-TYPE
@anchor{go to the CEPL<dot>SSBOS<colon><colon>MAKE-SSBO-FROM-ARRAY function}@c
@functionsubindex{make-ssbo-from-array}@c

This function takes a lisp-array, `c-array` or `gpu-array` and an index.@*
It returns a new `ssbo` with the specified element as the data of the ssbo.

If made from a c-array or lisp-array, a fresh gpu memory is allocated to hold
the data@*

If made from a gpu-array the ssbo simply holds a reference to the gpu-array
and the index. No new memory is allocated. This means that if that
gpu-array is destroyed then this ssbo is in an invalid state.@*

This also means it is possible to do invalid things when rendering. For example
say you used the ssbo as an input whilst streaming vertex data from the same
array. Consult GL documentation for details on such exceptional cases.
@table @strong
@item Package
@ref{go to the CEPL<dot>SSBOS package, , @t{cepl.ssbos}}
@item Source
@ref{go to the cepl/core/ssbos/ssbos<dot>lisp file, , @t{core/ssbos/ssbos.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-stencil-params} &key TEST VALUE MASK ON-STENCIL-TEST-FAIL ON-STENCIL-PASS-DEPTH-TEST-FAIL ON-STENCIL-PASS-DEPTH-TEST-PASS
@anchor{go to the CEPL<dot>STENCIL<colon><colon>MAKE-STENCIL-PARAMS function}@c
@functionsubindex{make-stencil-params}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>STENCIL package, , @t{cepl.stencil}}
@item Source
@ref{go to the cepl/core/stencil/stencil<dot>lisp file, , @t{core/stencil/stencil.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-surface} &rest ARGS &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>MAKE-SURFACE function}@c
@functionsubindex{make-surface}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-surface-current} CEPL-CONTEXT SURFACE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>MAKE-SURFACE-CURRENT function}@c
@functionsubindex{make-surface-current}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/surface<dot>lisp file, , @t{core/context/surface.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-texture} INITIAL-CONTENTS &key DIMENSIONS ELEMENT-TYPE MIPMAP LAYER-COUNT CUBES RECTANGLE IMMUTABLE BUFFER-STORAGE GENERATE-MIPMAPS PIXEL-FORMAT SAMPLES FIXED-SAMPLE-LOCATIONS
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>MAKE-TEXTURE function}@c
@functionsubindex{make-texture}@c

This function allows you to make any kind of `texture` based on the arguments@*
provided. Whilst the signature is quite intimidating your rarely need to use@*
more than a few of the arguments to make a given texture.@*

For example:@*

    (make-texture '(1 2 3 4))@*

 will give you a valid texture.@*

We will now go through the arguments and their behaviours:@*

**-- :initial-contents :dimensions & :element-type --**@*

- with :initial-contents to nil:@*
  In this case you need to provide dimensions and an element-type.@*

- with :initial-contents populated.@*
  The initial-contents can be a (potentially nested) list, array or `c-array`.@*

When the :initial-contents are a c-array then the dimensions and element-type@*
are taken from the c-array. As the data is already in foreign memory the@*
upload will be notable faster that from lisp-data->gpu as no type conversions@*
are needed@*

When the :initial-contents are an array then the dimension of the texture@*
will be the same as the array passed in. Remember OpenGL only allows up to@*
3 dimensions for the textures@*

When the :initial-contents is a flat list then each element is used as one@*
element in the textures `gpu-array`@*

If the :initial-contents is a nested list then you must either:@*

- specify multiple dimensions and an element-type@*
- specify an element-type to be some struct type, then nested lists are then@*
  used to populate the fields of the foreign structs. For an example of this@*
  please see this example: https://github.com/cbaggers/cepl.examples/blob/master/examples/triangle.lisp#L30.

If the :element-type is not provided then CEPL will look at every element in@*
the initial-contents and try and find the smallest (in bytes) foreign type@*
which works for every element. This mean if the array is full of single-floats@*
then CEPL will choose :float, not :double.@*
Naturally this behaviour is too slow for use in performance critical@*
applications however it is nice for experimentation and working from the repl.@*

Extra element-type details:@*
Unlike c-array and gpu-arrays (which use foreign types for their elements)@*
textures have a different set of acceptable element-types. These are called@*
'image formats'.@*

If you provide a GL image-format as the :element-type CEPL will use it directly@*

If you provide a (foreign) lisp type then CEPL will try to find the appropriate@*
image-format for that type.@*

**-- :pixel-format --**@*

If this optional argument is not nil, then CEPL will use the pixel format@*
provided when uploading the pixel data.@*

Usually this is not provided as CEPL can calculate a valid pixel-format to@*
use from the element-type.@*

**-- :mipmap & :generate-mipmaps --**@*

If this is set to t then CEPL will make mipmaps for the `texture`. The texture@*
will have (floor (log (apply #'max dimensions) 2)) levels of mipmaps@*

If this is set to a positive integer CEPL will check that the number of levels@*
is allowed for the dimensions given and make that many levels of mipmaps.@*

If generate-mipmaps is t CEPL will ask OpenGL to generate content for all the@*
mipmaps levels.@*

**-- :layer-count --**@*

If this is set to a value greater than 1 then you are trying to create one of@*
the following:@*

:texture-1d-array@*
:texture-2d-array@*
:texture-cube-map-array@*

Which one is created depends on the dimensions provided and whether cubes is t.@*

**-- :cubes --**@*

If this is t then you are trying to make a cube-map texture@*

**-- :rectangle --**@*

If this is t then you are trying to make a rectangle texture.@*

This is different from a regular 2d texture (which can also be rectangular)@*

This texture only has one 2-dimensional `gpu-array`. The texture cannot have@*
mipmapping. Texture coordinates used for these textures are not normalized.@*

**-- :samples --**@*

Specify the number of samples in the texture (see the GL wiki for more details@*
on multisample textures)@*

**-- :immutable --**@*

Set this to nil if you definitely dont want to use immutable texture storage.@*
See the docstring for 'texture for more details@*

**-- :buffer-storage --**@*

If this is set to t you are trying to make a `buffer-texture`.@*

If you set this to t then the `element-type` should NOT be an image-format. Use@*
a foreign lisp type instead. Or leave it nil if you want CEPL to take the type@*
from the initial-contents@*

See the docstring for `texture` for more details.
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-texture-from-id} GL-OBJECT &key BASE-DIMENSIONS TEXTURE-TYPE ELEMENT-TYPE MIPMAP-LEVELS LAYER-COUNT CUBES ALLOCATED MUTABLE-P SAMPLES FIXED-SAMPLE-LOCATIONS
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>MAKE-TEXTURE-FROM-ID function}@c
@functionsubindex{make-texture-from-id}@c

Wrap and existing GL Texture Object in a CEPL `texture` struct.@*

This function does not do ANY sanity checking on the values provided, use only
if you are 100% sure of what you are setting.@*

We will now go through the arguments and their behaviours:@*

**-- :dimensions --**@*

It is required that you provide dimensions when calling this function.@*

The dimensions can be a single integer (for a 1D texture) or a list of
integers (for a multi-dimensional texture).@*

One differnce between make-texture and make-texture-from-id is that in this
function it is valid to pass the symbol ? in place of a dimension when it is
unknown. CEPL will not complain but will store 0 in place of the unknown dimension
which may cause issues if you try and use any function that expects to be able
to get valid size information.@*

**-- :element-type --**@*

It is required that you provide an element-type when calling this function.@*

Unlike c-array and gpu-arrays (which use foreign types for their elements)
textures have a different set of acceptable element-types. These are called
'image formats'.@*

NOTES: Unlike `make-texture`, `make-texture-from-id` does not attempt to
convert lisp types or pixel-formats to GLSL image-formats@*


**-- :mipmap-levels --**@*

This tells CEPL the number of mipmap levels the texture has.@*

1 is the default.@*

**-- :layer-count --**@*

If this is set to a value greater than 1 then the texture is one of@*
the following:@*

:texture-1d-array@*
:texture-2d-array@*
:texture-cube-map-array@*

Which one is created depends on the dimensions provided and whether cubes is t.

**-- :cubes --**@*

If this is t then you are trying to make a cube-map texture@*

**-- :samples --**@*

Specify the number of samples in the texture (see the GL wiki for more details
on multisample textures)@*

**-- :mutable-p --**@*

Speicifies if the texture is using mutable storage.@*

See the docstring for `texture` for more details.
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-time-elapsed-query} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MAKE-TIME-ELAPSED-QUERY function}@c
@functionsubindex{make-time-elapsed-query}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-timestamp-query} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MAKE-TIMESTAMP-QUERY function}@c
@functionsubindex{make-timestamp-query}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-transform-feedback-primitives-written-query} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MAKE-TRANSFORM-FEEDBACK-PRIMITIVES-WRITTEN-QUERY function}@c
@functionsubindex{make-transform-feedback-primitives-written-query}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-transform-feedback-stream} &rest BUFFER-BACKED-GPU-ARRAYS
@anchor{go to the CEPL<dot>TRANSFORM-FEEDBACK<colon><colon>MAKE-TRANSFORM-FEEDBACK-STREAM function}@c
@functionsubindex{make-transform-feedback-stream}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TRANSFORM-FEEDBACK package, , @t{cepl.transform-feedback}}
@item Source
@ref{go to the cepl/core/transform-feedback/transform-feedback<dot>lisp file, , @t{core/transform-feedback/transform-feedback.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-ubo} DATA &optional ELEMENT-TYPE
@anchor{go to the CEPL<dot>UBOS<colon><colon>MAKE-UBO function}@c
@functionsubindex{make-ubo}@c

This function will make and return a new `ubo`@*

You need only provide an element type and the lisp data to populate that type.

For example, given the following type:@*

   (defstruct-g test@*
     (scale :float :accessor scale)@*
     (age :int))@*

You create a ubo using this type as follows:@*

    (make-ubo '(1.2 10) 'test)@*

You can also pass in a c-array or gpu-array and omit the optional type
specifier.@*

If you wish to make a ubo from a specific element of a `c-array` or
`gpu-array` please see the #'make-ubo-from-array function.
@table @strong
@item Package
@ref{go to the CEPL<dot>UBOS package, , @t{cepl.ubos}}
@item Source
@ref{go to the cepl/core/ubos/ubo<dot>lisp file, , @t{core/ubos/ubo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-ubo-from-array} DATA &optional INDEX ELEMENT-TYPE
@anchor{go to the CEPL<dot>UBOS<colon><colon>MAKE-UBO-FROM-ARRAY function}@c
@functionsubindex{make-ubo-from-array}@c

This function takes a lisp-array, `c-array` or `gpu-array` and an index.@*
It returns a new `ubo` with the specified element as the data of the ubo.@*

If made from a c-array or lisp-array, a fresh gpu memory is allocated to hold
the data@*

If made from a gpu-array the ubo simply holds a reference to the gpu-array
and the index. No new memory is allocated. This means that if that
gpu-array is destroyed then this ubo is in an invalid state.@*

This also means it is possible to do invalid things when rendering. For example
say you used the ubo as an input whilst streaming vertex data from the same
array. Consult GL documentation for details on such exceptional cases.
@table @strong
@item Package
@ref{go to the CEPL<dot>UBOS package, , @t{cepl.ubos}}
@item Source
@ref{go to the cepl/core/ubos/ubo<dot>lisp file, , @t{core/ubos/ubo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-uninitialized-buffer-stream} PRIMITIVE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MAKE-UNINITIALIZED-BUFFER-STREAM function}@c
@functionsubindex{make-uninitialized-buffer-stream}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/nulls-and-uninitialized<dot>lisp file, , @t{core/types/nulls-and-uninitialized.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-uninitialized-fbo} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MAKE-UNINITIALIZED-FBO function}@c
@functionsubindex{make-uninitialized-fbo}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/nulls-and-uninitialized<dot>lisp file, , @t{core/types/nulls-and-uninitialized.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-uninitialized-gpu-array-bb} &optional BUFFER
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MAKE-UNINITIALIZED-GPU-ARRAY-BB function}@c
@functionsubindex{make-uninitialized-gpu-array-bb}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/nulls-and-uninitialized<dot>lisp file, , @t{core/types/nulls-and-uninitialized.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-uninitialized-gpu-array-t} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MAKE-UNINITIALIZED-GPU-ARRAY-T function}@c
@functionsubindex{make-uninitialized-gpu-array-t}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/nulls-and-uninitialized<dot>lisp file, , @t{core/types/nulls-and-uninitialized.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-uninitialized-gpu-buffer} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MAKE-UNINITIALIZED-GPU-BUFFER function}@c
@functionsubindex{make-uninitialized-gpu-buffer}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/nulls-and-uninitialized<dot>lisp file, , @t{core/types/nulls-and-uninitialized.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-uninitialized-render-buffer} &optional MULTISAMPLE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MAKE-UNINITIALIZED-RENDER-BUFFER function}@c
@functionsubindex{make-uninitialized-render-buffer}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/nulls-and-uninitialized<dot>lisp file, , @t{core/types/nulls-and-uninitialized.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-uninitialized-sampler} TEXTURE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MAKE-UNINITIALIZED-SAMPLER function}@c
@functionsubindex{make-uninitialized-sampler}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/nulls-and-uninitialized<dot>lisp file, , @t{core/types/nulls-and-uninitialized.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-uninitialized-texture} &optional BUFFER-BACKED-P
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MAKE-UNINITIALIZED-TEXTURE function}@c
@functionsubindex{make-uninitialized-texture}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/nulls-and-uninitialized<dot>lisp file, , @t{core/types/nulls-and-uninitialized.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-vao} GPU-ARRAYS &optional INDEX-ARRAY
@anchor{go to the CEPL<dot>VAOS<colon><colon>MAKE-VAO function}@c
@functionsubindex{make-vao}@c

This function returns a new GL VAO when given

- a list of gpu-arrays@*
- optionally 1 gpu-array to be used as an index
@table @strong
@item Package
@ref{go to the CEPL<dot>VAOS package, , @t{cepl.vaos}}
@item Source
@ref{go to the cepl/core/vaos/vaos<dot>lisp file, , @t{core/vaos/vaos.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-vao-from-id} GL-OBJECT GPU-ARRAYS &optional INDEX-ARRAY
@anchor{go to the CEPL<dot>VAOS<colon><colon>MAKE-VAO-FROM-ID function}@c
@functionsubindex{make-vao-from-id}@c

This function takes an existing OpenGL VAO and set it up to stream vertices from
the given arrays.
@table @strong
@item Package
@ref{go to the CEPL<dot>VAOS package, , @t{cepl.vaos}}
@item Source
@ref{go to the cepl/core/vaos/vaos<dot>lisp file, , @t{core/vaos/vaos.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-viewport} &optional RESOLUTION ORIGIN
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MAKE-VIEWPORT function}@c
@functionsubindex{make-viewport}@c

This function returns a new `viewport` with the specified resolution and
origin
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {map-c} FUNCTION C-ARRAY &optional DESTINATION-ELEMENT-TYPE
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>MAP-C function}@c
@functionsubindex{map-c}@c

When given a function and a `c-array` this function will map the function across
every element of the c-array and write the results of the function into a new
c-array with the same element-type and dimensions as the original c-array.@*

You may also pass in an optional foreign type that will be used as the element
type of the new array.@*

If, rather than making a new c-array, you wish to modify the given c-array you
should use `map-c-into` instead.
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/map<dot>lisp file, , @t{core/c-arrays/map.lisp}} (file)
@end table
@end deffn
@deffn {Function} {map-c-into} DESTINATION-C-ARRAY FUNCTION SOURCE-C-ARRAY
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>MAP-C-INTO function}@c
@functionsubindex{map-c-into}@c

When given a destination `c-array`, a function and a source c-array this function
will map the function across every element of the source c-array and write the
results of the function destrucively into the destination c-array.
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/map<dot>lisp file, , @t{core/c-arrays/map.lisp}} (file)
@end table
@end deffn
@deffn {Function} {mapcat} FUNCTION &rest LISTS
@anchor{go to the CEPL-UTILS<colon><colon>MAPCAT function}@c
@functionsubindex{mapcat}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {mat2-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>MAT2-FROM-FOREIGN function}@c
@functionsubindex{mat2-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {mat2-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>MAT2-TO-FOREIGN function}@c
@functionsubindex{mat2-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {mat2x2-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>MAT2X2-FROM-FOREIGN function}@c
@functionsubindex{mat2x2-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {mat2x2-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>MAT2X2-TO-FOREIGN function}@c
@functionsubindex{mat2x2-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {mat2x3-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>MAT2X3-FROM-FOREIGN function}@c
@functionsubindex{mat2x3-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {mat2x3-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>MAT2X3-TO-FOREIGN function}@c
@functionsubindex{mat2x3-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {mat2x4-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>MAT2X4-FROM-FOREIGN function}@c
@functionsubindex{mat2x4-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {mat2x4-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>MAT2X4-TO-FOREIGN function}@c
@functionsubindex{mat2x4-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {mat3-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>MAT3-FROM-FOREIGN function}@c
@functionsubindex{mat3-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {mat3-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>MAT3-TO-FOREIGN function}@c
@functionsubindex{mat3-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {mat3x2-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>MAT3X2-FROM-FOREIGN function}@c
@functionsubindex{mat3x2-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {mat3x2-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>MAT3X2-TO-FOREIGN function}@c
@functionsubindex{mat3x2-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {mat3x3-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>MAT3X3-FROM-FOREIGN function}@c
@functionsubindex{mat3x3-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {mat3x3-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>MAT3X3-TO-FOREIGN function}@c
@functionsubindex{mat3x3-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {mat3x4-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>MAT3X4-FROM-FOREIGN function}@c
@functionsubindex{mat3x4-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {mat3x4-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>MAT3X4-TO-FOREIGN function}@c
@functionsubindex{mat3x4-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {mat4-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>MAT4-FROM-FOREIGN function}@c
@functionsubindex{mat4-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {mat4-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>MAT4-TO-FOREIGN function}@c
@functionsubindex{mat4-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {mat4x2-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>MAT4X2-FROM-FOREIGN function}@c
@functionsubindex{mat4x2-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {mat4x2-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>MAT4X2-TO-FOREIGN function}@c
@functionsubindex{mat4x2-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {mat4x3-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>MAT4X3-FROM-FOREIGN function}@c
@functionsubindex{mat4x3-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {mat4x3-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>MAT4X3-TO-FOREIGN function}@c
@functionsubindex{mat4x3-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {mat4x4-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>MAT4X4-FROM-FOREIGN function}@c
@functionsubindex{mat4x4-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {mat4x4-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>MAT4X4-TO-FOREIGN function}@c
@functionsubindex{mat4x4-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {max-lod} SAMPLER
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MAX-LOD function}@c
@functionsubindex{max-lod}@c

This function sets the max-lod of the given `texture` or `sampler`@*


**-- LOD --**@*

Together with :min-lod this sampling parameter affects the mipmap image
selection.@*

The way these work in mipmap selection is quite complicated; the specification
goes into full detail about it.@*

example:@*

    (setf (min-lod texture-or-sampler) value)@*
    (setf (max-lod texture-or-sampler) value)
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF MAX-LOD) function, , @t{(setf max-lod)}} (function)
@end table
@end deffn
@deffn {Function} {(setf max-lod)} VALUE SAMPLER
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF MAX-LOD) function}@c
@functionsubindex{(setf max-lod)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>MAX-LOD function, , @t{max-lod}} (function)
@end table
@end deffn
@deffn {Function} {min-lod} SAMPLER
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MIN-LOD function}@c
@functionsubindex{min-lod}@c

This function sets the min-lod of the given `texture` or `sampler`@*


**-- LOD --**@*

Together with :max-lod this sampling parameter affects the mipmap image
selection.@*

The way these work in mipmap selection is quite complicated; the specification
goes into full detail about it.@*

example:@*

    (setf (min-lod texture-or-sampler) value)@*
    (setf (max-lod texture-or-sampler) value)
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF MIN-LOD) function, , @t{(setf min-lod)}} (function)
@end table
@end deffn
@deffn {Function} {(setf min-lod)} VALUE SAMPLER
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF MIN-LOD) function}@c
@functionsubindex{(setf min-lod)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>MIN-LOD function, , @t{min-lod}} (function)
@end table
@end deffn
@deffn {Function} {minify-filter} SAMPLER
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MINIFY-FILTER function}@c
@functionsubindex{minify-filter}@c

This function takes a `sampler` or `texture` and sets the approach used when the
area of the fragment in texture space is larger than a texel.@*

**-- The minification filter --**@*

The minification filter is controlled by the :texture-min-filter texture
parameter. To understand these values better, it is important to discuss what
the particular options are. Here is the full list:@*

    :nearest                 :linear@*
    :nearest-mipmap-nearest  :nearest-mipmap-linear@*
    :linear-mipmap-nearest   :linear-mipmap-linear@*

When doing minification, you can choose to use mipmapping or not. Using
mipmapping means selecting between multiple mipmaps based on the angle and size
of the texture relative to the screen. Whether you use mipmapping or not,
you can still select between linear blending of the particular layer or nearest.
And if you do use mipmapping, you can choose to either select a single mipmap to
sample from, or you can sample the two adjacent mipmaps and linearly blend the
resulting values to get the final result.@*

    The OpenGL minification settings for these are as follows:@*
    Param Setting            Lin within mip-level@*
    :nearest                 No@*
    :linear                  Yes@*
    :nearest-mipmap-nearest  No@*
    :linear-mipmap-nearest   Yes@*
    :nearest-mipmap-linear   No@*
    :linear-mipmap-linear    Yes@*

    Param Setting            Has mipmapping@*
    :nearest                 No@*
    :linear                  No@*
    :nearest-mipmap-nearest  Yes@*
    :linear-mipmap-nearest   Yes@*
    :nearest-mipmap-linear   Yes@*
    :linear-mipmap-linear    Yes@*

    Param Setting            Linear between mip-levels@*
    :nearest                 -@*
    :linear                  -@*
    :nearest-mipmap-nearest  No@*
    :linear-mipmap-nearest   No@*
    :nearest-mipmap-linear   Yes@*
    :linear-mipmap-linear    Yes@*

Remembering these combinations can be annoying so CEPL provides an additional
function called #'set-minify-filter see the docstring for details@*

examples:@*

    (setf (minify-filter tex-or-sampler) :linear)@*
    (setf (minify-filter tex-or-sampler) :nearest-mipmap-nearest)
    (setf-minify-filter tex-or-sampler :nearest :nearest)@*

@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF MINIFY-FILTER) function, , @t{(setf minify-filter)}} (function)
@end table
@end deffn
@deffn {Function} {(setf minify-filter)} VALUE SAMPLER
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF MINIFY-FILTER) function}@c
@functionsubindex{(setf minify-filter)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>MINIFY-FILTER function, , @t{minify-filter}} (function)
@end table
@end deffn
@deffn {Function} {mkstr} &rest ARGS
@anchor{go to the CEPL-UTILS<colon><colon>MKSTR function}@c
@functionsubindex{mkstr}@c
Takes a list of strings or symbols and returns one string
   of them concatenated together. For example:
    CEPL-EXAMPLES> (cepl-utils:mkstr 'jam 'ham')
     'JAMHAM'@*
    CEPL-EXAMPLES> (cepl-utils:mkstr 'jam' 'ham')
     'jamham'
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {mode-alpha} FBO &optional ATTACHMENT-NAME
@anchor{go to the CEPL<dot>BLENDING<colon><colon>MODE-ALPHA function}@c
@functionsubindex{mode-alpha}@c

This function, when passed a `blending-params` object, will return the name of the
equation that will be used to compute the final alpha value from the processed
`source-alpha` and `destination-alpha`.@*

The result will be one of the following:@*

    :func-add@*
    :func-subtract@*
    :func-reverse-subtract@*
    :min@*
    :max@*

To see more info on this subject please see the doc-string for the
blending-params struct.
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@item Writer
@ref{go to the CEPL<dot>BLENDING<colon><colon>(SETF MODE-ALPHA) function, , @t{(setf mode-alpha)}} (function)
@end table
@end deffn
@deffn {Function} {(setf mode-alpha)} VALUE FBO &optional ATTACHMENT-NAME
@anchor{go to the CEPL<dot>BLENDING<colon><colon>(SETF MODE-ALPHA) function}@c
@functionsubindex{(setf mode-alpha)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@item Reader
@ref{go to the CEPL<dot>BLENDING<colon><colon>MODE-ALPHA function, , @t{mode-alpha}} (function)
@end table
@end deffn
@deffn {Function} {mode-rgb} FBO &optional ATTACHMENT-NAME
@anchor{go to the CEPL<dot>BLENDING<colon><colon>MODE-RGB function}@c
@functionsubindex{mode-rgb}@c

This function, when passed a `blending-params` object, will return the name of the
equation that will be used to compute the final color value from the processed
`source-rgb` and `destination-rgb`.@*

The result will be one of the following:@*

    :func-add@*
    :func-subtract@*
    :func-reverse-subtract@*
    :min@*
    :max@*

To see more info on this subject please see the doc-string for the
blending-params struct.
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@item Writer
@ref{go to the CEPL<dot>BLENDING<colon><colon>(SETF MODE-RGB) function, , @t{(setf mode-rgb)}} (function)
@end table
@end deffn
@deffn {Function} {(setf mode-rgb)} VALUE FBO &optional ATTACHMENT-NAME
@anchor{go to the CEPL<dot>BLENDING<colon><colon>(SETF MODE-RGB) function}@c
@functionsubindex{(setf mode-rgb)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@item Reader
@ref{go to the CEPL<dot>BLENDING<colon><colon>MODE-RGB function, , @t{mode-rgb}} (function)
@end table
@end deffn
@deffn {Function} {multi-buffer-data} BUFFER C-ARRAYS TARGET USAGE
@anchor{go to the CEPL<dot>GPU-BUFFERS<colon><colon>MULTI-BUFFER-DATA function}@c
@functionsubindex{multi-buffer-data}@c

This function takes a list of `c-array`s and uploads all of the data to the
`gpu-buffer`.
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-BUFFERS package, , @t{cepl.gpu-buffers}}
@item Source
@ref{go to the cepl/core/gpu-buffers/gpu-buffers<dot>lisp file, , @t{core/gpu-buffers/gpu-buffers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {n-of} THING COUNT
@anchor{go to the CEPL-UTILS<colon><colon>N-OF function}@c
@functionsubindex{n-of}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {never} INCOMING-VAL STORED-VAL
@anchor{go to the CEPL<dot>DOCUMENTATION-FUNCTIONS<colon><colon>NEVER function}@c
@functionsubindex{never}@c
Never passes
@table @strong
@item Package
@ref{go to the CEPL<dot>DOCUMENTATION-FUNCTIONS package, , @t{cepl.documentation-functions}}
@item Source
@ref{go to the cepl/core/context/documentation-functions<dot>lisp file, , @t{core/context/documentation-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {ni-call} PACKAGE-NAME FUNC-NAME &rest ARGS
@anchor{go to the CEPL-UTILS<colon><colon>NI-CALL function}@c
@functionsubindex{ni-call}@c
Non-interning funcall
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {ni-val} PACKAGE-NAME SYMB-NAME
@anchor{go to the CEPL-UTILS<colon><colon>NI-VAL function}@c
@functionsubindex{ni-val}@c
Non-interning get value
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {one} INCOMING-VAL STORED-VAL
@anchor{go to the CEPL<dot>DOCUMENTATION-FUNCTIONS<colon><colon>ONE function}@c
@functionsubindex{one}@c
Always returns 0
@table @strong
@item Package
@ref{go to the CEPL<dot>DOCUMENTATION-FUNCTIONS package, , @t{cepl.documentation-functions}}
@item Source
@ref{go to the cepl/core/context/documentation-functions<dot>lisp file, , @t{core/context/documentation-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {pack-alignment} &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>PACK-ALIGNMENT function}@c
@functionsubindex{pack-alignment}@c
@deffnx {Function} {(setf pack-alignment)} ROW-ALIGNMENT &optional FORCE CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF PACK-ALIGNMENT) function}@c
@functionsubindex{(setf pack-alignment)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/pixel-store/pixel-store<dot>lisp file, , @t{core/pixel-store/pixel-store.lisp}} (file)
@end table
@end deffn
@deffn {Function} {parse-body+} NAME BODY &optional EXTRA-DECLS
@anchor{go to the CEPL<dot>DEFN<colon><colon>PARSE-BODY+ function}@c
@functionsubindex{parse-body+}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>DEFN package, , @t{cepl.defn}}
@item Source
@ref{go to the cepl<dot>build/defn/defn<dot>lisp file, , @t{defn/defn.lisp}} (file)
@end table
@end deffn
@deffn {Function} {per-attachment-blending-available-p} &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>FBOS<colon><colon>PER-ATTACHMENT-BLENDING-AVAILABLE-P function}@c
@functionsubindex{per-attachment-blending-available-p}@c

This function will return t if you are on a version of opengl that supports
setting blending parameters on framebuffer `attachment`s. Otherwise it returns nil

If the result is nil then you will only be able to change blend params on the
first attachment. You can however enable blending on any number of attachments
and they will inherit their params from attachment 0@*

For more details see `cepl.blending`
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@end table
@end deffn
@deffn {Function} {pixel-format->image-format} PIXEL-FORMAT &key ERROR-IF-MISSING
@anchor{go to the CEPL<dot>TYPES<colon><colon>PIXEL-FORMAT->IMAGE-FORMAT function}@c
@functionsubindex{pixel-format->image-format}@c

This function, when given a `pixel-format` object, will attempt to find and
return the name of a GL image-format that is equivalent.@*

If no such type is found then nil is returned
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/pixel-format<dot>lisp file, , @t{core/types/pixel-format.lisp}} (file)
@end table
@end deffn
@deffn {Function} {pixel-format->lisp-type} PIXEL-FORMAT
@anchor{go to the CEPL<dot>TYPES<colon><colon>PIXEL-FORMAT->LISP-TYPE function}@c
@functionsubindex{pixel-format->lisp-type}@c

This function, when given a `pixel-format` object, will attempt to find and
return the name of a lisp type that is equivalent.@*

If no such type is found then nil is returned
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/pixel-format<dot>lisp file, , @t{core/types/pixel-format.lisp}} (file)
@end table
@end deffn
@deffn {Function} {pixel-format-comp-length} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>PIXEL-FORMAT-COMP-LENGTH function}@c
@functionsubindex{pixel-format-comp-length}@c

This function when passed a `pixel-format` will return the number of components
it has. The values will be from 1 upto 4
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF PIXEL-FORMAT-COMP-LENGTH) function, , @t{(setf pixel-format-comp-length)}} (function)
@end table
@end deffn
@deffn {Function} {(setf pixel-format-comp-length)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF PIXEL-FORMAT-COMP-LENGTH) function}@c
@functionsubindex{(setf pixel-format-comp-length)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>PIXEL-FORMAT-COMP-LENGTH function, , @t{pixel-format-comp-length}} (function)
@end table
@end deffn
@deffn {Function} {pixel-format-components} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>PIXEL-FORMAT-COMPONENTS function}@c
@functionsubindex{pixel-format-components}@c

This function returns the components of the given `pixel-format` as a keyword

possible values are:@*
:r@*
:rg@*
:rgb@*
:rgba@*
:stencil-only@*
:depth
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF PIXEL-FORMAT-COMPONENTS) function, , @t{(setf pixel-format-components)}} (function)
@end table
@end deffn
@deffn {Function} {(setf pixel-format-components)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF PIXEL-FORMAT-COMPONENTS) function}@c
@functionsubindex{(setf pixel-format-components)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>PIXEL-FORMAT-COMPONENTS function, , @t{pixel-format-components}} (function)
@end table
@end deffn
@deffn {Function} {pixel-format-normalize} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>PIXEL-FORMAT-NORMALIZE function}@c
@functionsubindex{pixel-format-normalize}@c

This function returns whether values of the components belonging to the
`pixel-format` are normalized.@*

If t then sampling the values on the gpu will gives values in the
range 0s0  1s0
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF PIXEL-FORMAT-NORMALIZE) function, , @t{(setf pixel-format-normalize)}} (function)
@end table
@end deffn
@deffn {Function} {(setf pixel-format-normalize)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF PIXEL-FORMAT-NORMALIZE) function}@c
@functionsubindex{(setf pixel-format-normalize)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>PIXEL-FORMAT-NORMALIZE function, , @t{pixel-format-normalize}} (function)
@end table
@end deffn
@deffn {Function} {pixel-format-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>PIXEL-FORMAT-P function}@c
@functionsubindex{pixel-format-p}@c

This function returns t if the the given value is a `pixel-format`. Otherwise it
returns nil
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {pixel-format-reversed} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>PIXEL-FORMAT-REVERSED function}@c
@functionsubindex{pixel-format-reversed}@c

Some `pixel-format`s are 'reversed' meaning the component order in the data is
reversed.@*

This function will return t if the pixel format provided is a reversed-type
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF PIXEL-FORMAT-REVERSED) function, , @t{(setf pixel-format-reversed)}} (function)
@end table
@end deffn
@deffn {Function} {(setf pixel-format-reversed)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF PIXEL-FORMAT-REVERSED) function}@c
@functionsubindex{(setf pixel-format-reversed)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>PIXEL-FORMAT-REVERSED function, , @t{pixel-format-reversed}} (function)
@end table
@end deffn
@deffn {Function} {pixel-format-sizes} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>PIXEL-FORMAT-SIZES function}@c
@functionsubindex{pixel-format-sizes}@c

Some `pixel-format`s and image-formats are 'special' and have specifically sized
components.@*

This function will return a list of sizes in bits of the components.
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF PIXEL-FORMAT-SIZES) function, , @t{(setf pixel-format-sizes)}} (function)
@end table
@end deffn
@deffn {Function} {(setf pixel-format-sizes)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF PIXEL-FORMAT-SIZES) function}@c
@functionsubindex{(setf pixel-format-sizes)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>PIXEL-FORMAT-SIZES function, , @t{pixel-format-sizes}} (function)
@end table
@end deffn
@deffn {Function} {pixel-format-type} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>PIXEL-FORMAT-TYPE function}@c
@functionsubindex{pixel-format-type}@c

This function returns the lisp type of a single 'element' of the given
`pixel-format`.@*

For example:@*
- the element type of a :vec3 is a :float.@*
- the element type of a :vec2 is a :float.@*
- the element type of a :int8 is a :int8
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF PIXEL-FORMAT-TYPE) function, , @t{(setf pixel-format-type)}} (function)
@end table
@end deffn
@deffn {Function} {(setf pixel-format-type)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF PIXEL-FORMAT-TYPE) function}@c
@functionsubindex{(setf pixel-format-type)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>PIXEL-FORMAT-TYPE function, , @t{pixel-format-type}} (function)
@end table
@end deffn
@deffn {Function} {ptr-index} C-ARRAY X &optional Y Z W
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>PTR-INDEX function}@c
@functionsubindex{ptr-index}@c

This function takes a `c-array` and some subscripts and will return the ptr to the
specified element of the c-array
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/aref-c<dot>lisp file, , @t{core/c-arrays/aref-c.lisp}} (file)
@end table
@end deffn
@deffn {Function} {pull-all-gpu-commands-issued-time} ()
@anchor{go to the CEPL<dot>QUERIES<colon><colon>PULL-ALL-GPU-COMMANDS-ISSUED-TIME function}@c
@functionsubindex{pull-all-gpu-commands-issued-time}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>QUERIES package, , @t{cepl.queries}}
@item Source
@ref{go to the cepl/core/queries/query<dot>lisp file, , @t{core/queries/query.lisp}} (file)
@end table
@end deffn
@deffn {Function} {pull-gpu-query-result} QUERY &optional WAIT
@anchor{go to the CEPL<dot>QUERIES<colon><colon>PULL-GPU-QUERY-RESULT function}@c
@functionsubindex{pull-gpu-query-result}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>QUERIES package, , @t{cepl.queries}}
@item Source
@ref{go to the cepl/core/queries/query<dot>lisp file, , @t{core/queries/query.lisp}} (file)
@end table
@end deffn
@deffn {Function} {push-gpu-query-result-to-gpu-array} QUERY DESTINATION-GPU-ARRAY &optional DESTINATION-ARRAY-INDEX
@anchor{go to the CEPL<dot>QUERIES<colon><colon>PUSH-GPU-QUERY-RESULT-TO-GPU-ARRAY function}@c
@functionsubindex{push-gpu-query-result-to-gpu-array}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>QUERIES package, , @t{cepl.queries}}
@item Source
@ref{go to the cepl/core/queries/query<dot>lisp file, , @t{core/queries/query.lisp}} (file)
@end table
@end deffn
@deffn {Function} {query-all-gpu-commands-completed-time} TIMESTAMP-QUERY
@anchor{go to the CEPL<dot>QUERIES<colon><colon>QUERY-ALL-GPU-COMMANDS-COMPLETED-TIME function}@c
@functionsubindex{query-all-gpu-commands-completed-time}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>QUERIES package, , @t{cepl.queries}}
@item Source
@ref{go to the cepl/core/queries/query<dot>lisp file, , @t{core/queries/query.lisp}} (file)
@end table
@end deffn
@deffn {Function} {quit} ()
@anchor{go to the CEPL<colon><colon>QUIT function}@c
@functionsubindex{quit}@c

Call this to shutdown CEPL.@*

As well as its own internal work, CEPL will ask the host to shut itself down.
@table @strong
@item Package
@ref{go to the CEPL package, , @t{cepl}}
@item Source
@ref{go to the cepl/core/repl<dot>lisp file, , @t{core/repl.lisp}} (file)
@end table
@end deffn
@deffn {Function} {range} X &optional Y Z U V
@anchor{go to the CEPL-UTILS<colon><colon>RANGE function}@c
@functionsubindex{range}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {rangei} X &optional Y Z U V
@anchor{go to the CEPL-UTILS<colon><colon>RANGEI function}@c
@functionsubindex{rangei}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {read-fbo-bound} CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>READ-FBO-BOUND function}@c
@functionsubindex{read-fbo-bound}@c
@deffnx {Function} {(setf read-fbo-bound)} FBO CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF READ-FBO-BOUND) function}@c
@functionsubindex{(setf read-fbo-bound)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {read-integers} &optional STREAM EOF-ERROR-P EOF-VALUE RECURSIVE-P
@anchor{go to the CEPL-UTILS<colon><colon>READ-INTEGERS function}@c
@functionsubindex{read-integers}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {reallocate-buffer} BUFFER
@anchor{go to the CEPL<dot>GPU-BUFFERS<colon><colon>REALLOCATE-BUFFER function}@c
@functionsubindex{reallocate-buffer}@c

This function takes a buffer and recreates the data-store for it. All data currently in the buffer will be lost.
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-BUFFERS package, , @t{cepl.gpu-buffers}}
@item Source
@ref{go to the cepl/core/gpu-buffers/gpu-buffers<dot>lisp file, , @t{core/gpu-buffers/gpu-buffers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {reallocate-gpu-array} GPU-ARRAY
@anchor{go to the CEPL<dot>GPU-ARRAYS<colon><colon>REALLOCATE-GPU-ARRAY function}@c
@functionsubindex{reallocate-gpu-array}@c

This function takes a `gpu-array` and reallocates the buffer that is backing it.
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS package, , @t{cepl.gpu-arrays}}
@item Source
@ref{go to the cepl/core/gpu-arrays/with-and-push<dot>lisp file, , @t{core/gpu-arrays/with-and-push.lisp}} (file)
@end table
@end deffn
@deffn {Function} {register-event-listener} FUNCTION
@anchor{go to the CEPL<colon><colon>REGISTER-EVENT-LISTENER function}@c
@functionsubindex{register-event-listener}@c
Register a function to be called on every event.@*
   The function must take 1 argument, which will be the event.
@table @strong
@item Package
@ref{go to the CEPL package, , @t{cepl}}
@item Source
@ref{go to the cepl/core/repl<dot>lisp file, , @t{core/repl.lisp}} (file)
@end table
@end deffn
@deffn {Function} {register-host} HOST-CLASS-NAME
@anchor{go to the CEPL<dot>HOST<colon><colon>REGISTER-HOST function}@c
@functionsubindex{register-host}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-api<dot>lisp file, , @t{host/api-api.lisp}} (file)
@end table
@end deffn
@deffn {Function} {remove-surface} CONTEXT SURFACE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>REMOVE-SURFACE function}@c
@functionsubindex{remove-surface}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/surface<dot>lisp file, , @t{core/context/surface.lisp}} (file)
@end table
@end deffn
@deffn {Function} {render-buffer-dimensions} RENDER-BUFFER
@anchor{go to the CEPL<dot>RENDER-BUFFERS<colon><colon>RENDER-BUFFER-DIMENSIONS function}@c
@functionsubindex{render-buffer-dimensions}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>RENDER-BUFFERS package, , @t{cepl.render-buffers}}
@item Source
@ref{go to the cepl/core/render-buffers/render-buffer<dot>lisp file, , @t{core/render-buffers/render-buffer.lisp}} (file)
@end table
@end deffn
@deffn {Function} {render-buffer-image-format} RENDER-BUFFER
@anchor{go to the CEPL<dot>RENDER-BUFFERS<colon><colon>RENDER-BUFFER-IMAGE-FORMAT function}@c
@functionsubindex{render-buffer-image-format}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>RENDER-BUFFERS package, , @t{cepl.render-buffers}}
@item Source
@ref{go to the cepl/core/render-buffers/render-buffer<dot>lisp file, , @t{core/render-buffers/render-buffer.lisp}} (file)
@end table
@end deffn
@deffn {Function} {render-buffer-multisample-p} RENDER-BUFFER
@anchor{go to the CEPL<dot>RENDER-BUFFERS<colon><colon>RENDER-BUFFER-MULTISAMPLE-P function}@c
@functionsubindex{render-buffer-multisample-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>RENDER-BUFFERS package, , @t{cepl.render-buffers}}
@item Source
@ref{go to the cepl/core/render-buffers/render-buffer<dot>lisp file, , @t{core/render-buffers/render-buffer.lisp}} (file)
@end table
@end deffn
@deffn {Function} {render-buffer-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>RENDER-BUFFER-P function}@c
@functionsubindex{render-buffer-p}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {render-buffer-resolution} RENDER-BUFFER
@anchor{go to the CEPL<dot>RENDER-BUFFERS<colon><colon>RENDER-BUFFER-RESOLUTION function}@c
@functionsubindex{render-buffer-resolution}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>RENDER-BUFFERS package, , @t{cepl.render-buffers}}
@item Source
@ref{go to the cepl/core/render-buffers/render-buffer<dot>lisp file, , @t{core/render-buffers/render-buffer.lisp}} (file)
@end table
@end deffn
@deffn {Function} {repl} &optional WIDTH HEIGHT GL-VERSION
@anchor{go to the CEPL<colon><colon>REPL function}@c
@functionsubindex{repl}@c

This function is a legacy item at this stage, but is still here as it feels
nice.@*

It calls #'initialize-cepl to make a resizable window and prints out a message
in the repl.
@table @strong
@item Package
@ref{go to the CEPL package, , @t{cepl}}
@item Source
@ref{go to the cepl/core/repl<dot>lisp file, , @t{core/repl.lisp}} (file)
@end table
@end deffn
@deffn {Function} {replace-nth} LIST N FORM
@anchor{go to the CEPL-UTILS<colon><colon>REPLACE-NTH function}@c
@functionsubindex{replace-nth}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {row-major-aref-c} C-ARRAY INDEX
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>ROW-MAJOR-AREF-C function}@c
@functionsubindex{row-major-aref-c}@c
@deffnx {Function} {(setf row-major-aref-c)} VALUE C-ARRAY INDEX
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>(SETF ROW-MAJOR-AREF-C) function}@c
@functionsubindex{(setf row-major-aref-c)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/aref-c<dot>lisp file, , @t{core/c-arrays/aref-c.lisp}} (file)
@end table
@end deffn
@deffn {Function} {sample} TEXTURE &key LOD-BIAS MIN-LOD MAX-LOD MINIFY-FILTER MAGNIFY-FILTER WRAP COMPARE
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>SAMPLE function}@c
@functionsubindex{sample}@c

This function takes a `texture` and optionally some sampling parameters and
returns a `sampler`.@*

The sampler is an object that is passed to a pipeline so that the shaders in
the gpu-functions in the pipeline can read from the gpu-arrays in the texture.

For details on what the parameters are and mean see the docstring for the
'sampler type@*

**-- Note about GL Versions --**@*

Sampler Objects were introduced in GL 3.3. So for now CEPL needs at least v3.3
in future we hope to lower the requirement to 3.1 but this will take some extra
work.@*

**-- NOTE For those with GL experience --**@*

You will have noticed that in CEPL your sampler is tied to one texture which is
unlike in regular GL where a sample object can be used to override the sampling
parameters of any number of textures. At first this would seem very wasteful
however CEPL does not use 1 GL Sampler Object per CEPL sampler. The ID sharing
is done based on the parameters.@*

This means you get the same number of sampler objects as your would normally
but with the added benefit that samplers are semantically dual with buffer-streams
giving greater api consistancy.
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {sampler-id-box-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>SAMPLER-ID-BOX-ID function}@c
@functionsubindex{sampler-id-box-id}@c
@deffnx {Function} {(setf sampler-id-box-id)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF SAMPLER-ID-BOX-ID) function}@c
@functionsubindex{(setf sampler-id-box-id)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {sampler-id-box-shared-p} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>SAMPLER-ID-BOX-SHARED-P function}@c
@functionsubindex{sampler-id-box-shared-p}@c
@deffnx {Function} {(setf sampler-id-box-shared-p)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF SAMPLER-ID-BOX-SHARED-P) function}@c
@functionsubindex{(setf sampler-id-box-shared-p)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {sampler-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>SAMPLER-P function}@c
@functionsubindex{sampler-p}@c

This function returns t if the supplied value is a `sampler` and nil otherwise
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {sampler-shared-p} SAMPLER
@anchor{go to the %CEPL<dot>TYPES<colon><colon>SAMPLER-SHARED-P function}@c
@functionsubindex{sampler-shared-p}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {sampler-texture} SAMPLER
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>SAMPLER-TEXTURE function}@c
@functionsubindex{sampler-texture}@c

This function takes a `sampler` as its only argument and returns the `texture`
being sampled by the sampler.
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {sampler-type} SAMPLER
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>SAMPLER-TYPE function}@c
@functionsubindex{sampler-type}@c

This function takes a `sampler` as its only argument and returns the kind
of sampler it is.@*

The result will be one of the kinds listed in cepl.samplers::+sampler-types+
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {scissor-viewport} &optional INDEX CEPL-CONTEXT
@anchor{go to the CEPL<dot>SCISSOR<colon><colon>SCISSOR-VIEWPORT function}@c
@functionsubindex{scissor-viewport}@c
@deffnx {Function} {(setf scissor-viewport)} VIEWPORT &optional INDEX CEPL-CONTEXT
@anchor{go to the CEPL<dot>SCISSOR<colon><colon>(SETF SCISSOR-VIEWPORT) function}@c
@functionsubindex{(setf scissor-viewport)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SCISSOR package, , @t{cepl.scissor}}
@item Source
@ref{go to the cepl/core/scissor/scissor<dot>lisp file, , @t{core/scissor/scissor.lisp}} (file)
@end table
@end deffn
@deffn {Function} {scoped-gpu-query-active-p} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>SCOPED-GPU-QUERY-ACTIVE-P function}@c
@functionsubindex{scoped-gpu-query-active-p}@c
@deffnx {Function} {(setf scoped-gpu-query-active-p)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF SCOPED-GPU-QUERY-ACTIVE-P) function}@c
@functionsubindex{(setf scoped-gpu-query-active-p)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {set-default-swap-arg} WIN-HANDLE
@anchor{go to the CEPL<dot>HOST<colon><colon>SET-DEFAULT-SWAP-ARG function}@c
@functionsubindex{set-default-swap-arg}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-0<dot>lisp file, , @t{host/api-0.lisp}} (file)
@end table
@end deffn
@deffn {Function} {set-make-gl-context-current-on-surface} FUNC
@anchor{go to the CEPL<dot>HOST<colon><colon>SET-MAKE-GL-CONTEXT-CURRENT-ON-SURFACE function}@c
@functionsubindex{set-make-gl-context-current-on-surface}@c
Call this and pass the function that will be called when the cepl needs to
     make the context current
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Function} {set-minify-filter} SAMPLER FOR-LEVEL &key BETWEEN-LEVELS
@anchor{go to the %CEPL<dot>TYPES<colon><colon>SET-MINIFY-FILTER function}@c
@functionsubindex{set-minify-filter}@c

As the naming of the values for #'minify-filter are quite confusing this
function allows you to set the minify filter for the given `texture` or `sampler`
based on the following:@*

- for-level: what sampling should be used between texels on the current
             mipmap level. The value can be :linear or :nearest@*

- between-level: what sampling should be used between texels on different
                 mipmap levels. The value can be :linear or :nearest@*
                 This argument is optional.
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {set-register-event-callback-func} FUNC
@anchor{go to the CEPL<dot>HOST<colon><colon>SET-REGISTER-EVENT-CALLBACK-FUNC function}@c
@functionsubindex{set-register-event-callback-func}@c
Call this and pass the function that will be called when the cepl needs to
     query the window size
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Function} {set-step-func} FUNC
@anchor{go to the CEPL<dot>HOST<colon><colon>SET-STEP-FUNC function}@c
@functionsubindex{set-step-func}@c
Call this and pass the function that will be called every time
     #'cepl:step-host is called
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Function} {set-surface-fullscreen} SURFACE STATE &rest ARGS &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>SET-SURFACE-FULLSCREEN function}@c
@functionsubindex{set-surface-fullscreen}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Function} {set-surface-size} SURFACE WIDTH HEIGHT &rest ARGS &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>SET-SURFACE-SIZE function}@c
@functionsubindex{set-surface-size}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Function} {set-surface-title} SURFACE TITLE &rest ARGS &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>SET-SURFACE-TITLE function}@c
@functionsubindex{set-surface-title}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Function} {set-swap-func} FUNC
@anchor{go to the CEPL<dot>HOST<colon><colon>SET-SWAP-FUNC function}@c
@functionsubindex{set-swap-func}@c
Call this and pass the function that will be called every time #'cepl:swap
     is called
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Function} {set-window-size-func} FUNC
@anchor{go to the CEPL<dot>HOST<colon><colon>SET-WINDOW-SIZE-FUNC function}@c
@functionsubindex{set-window-size-func}@c
Call this and pass the function that will be called when the cepl needs to
     query the window size
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Function} {short-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>SHORT-FROM-FOREIGN function}@c
@functionsubindex{short-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {short-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>SHORT-TO-FOREIGN function}@c
@functionsubindex{short-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {shutting-down-p} ()
@anchor{go to the CEPL<dot>LIFECYCLE<colon><colon>SHUTTING-DOWN-P function}@c
@functionsubindex{shutting-down-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>LIFECYCLE package, , @t{cepl.lifecycle}}
@item Source
@ref{go to the cepl/core/lifecycle<dot>lisp file, , @t{core/lifecycle.lisp}} (file)
@end table
@end deffn
@deffn {Function} {sn-equal} A B
@anchor{go to the CEPL-UTILS<colon><colon>SN-EQUAL function}@c
@functionsubindex{sn-equal}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {source-alpha} FBO &optional ATTACHMENT-NAME
@anchor{go to the CEPL<dot>BLENDING<colon><colon>SOURCE-ALPHA function}@c
@functionsubindex{source-alpha}@c

This function, when passed a `blending-params` object, will return the name of the
function that will be applied to the alpha value that is coming from the
pipeline and is to be combined with the value already in the `fbo`.@*

The result will be one of the following:@*

    :zero@*
    :one@*
    :src-color@*
    :one-minus-src-color@*
    :dst-color@*
    :one-minus-dst-color@*
    :src-alpha@*
    :one-minus-src-alpha@*
    :dst-alpha@*
    :one-minus-dst-alpha@*
    :constant-color@*
    :one-minus-constant-color@*
    :constant-alpha@*
    :one-minus-constant-alpha@*
    :src-alpha-saturate@*
    :src1-color@*
    :one-minus-src-color@*
    :src1-alpha@*
    :one-minus-src-alpha@*

To see more info on this subject please see the doc-string for the
blending-params struct.
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@item Writer
@ref{go to the CEPL<dot>BLENDING<colon><colon>(SETF SOURCE-ALPHA) function, , @t{(setf source-alpha)}} (function)
@end table
@end deffn
@deffn {Function} {(setf source-alpha)} VALUE FBO &optional ATTACHMENT-NAME
@anchor{go to the CEPL<dot>BLENDING<colon><colon>(SETF SOURCE-ALPHA) function}@c
@functionsubindex{(setf source-alpha)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@item Reader
@ref{go to the CEPL<dot>BLENDING<colon><colon>SOURCE-ALPHA function, , @t{source-alpha}} (function)
@end table
@end deffn
@deffn {Function} {source-rgb} FBO &optional ATTACHMENT-NAME
@anchor{go to the CEPL<dot>BLENDING<colon><colon>SOURCE-RGB function}@c
@functionsubindex{source-rgb}@c

This function, when passed a `blending-params` object, will return the name of the
function that will be applied to the color value that is coming from the
pipeline and is to be combined with the value already in the `fbo`.@*

The result will be one of the following:@*

    :zero@*
    :one@*
    :src-color@*
    :one-minus-src-color@*
    :dst-color@*
    :one-minus-dst-color@*
    :src-alpha@*
    :one-minus-src-alpha@*
    :dst-alpha@*
    :one-minus-dst-alpha@*
    :constant-color@*
    :one-minus-constant-color@*
    :constant-alpha@*
    :one-minus-constant-alpha@*
    :src-alpha-saturate@*
    :src1-color@*
    :one-minus-src-color@*
    :src1-alpha@*
    :one-minus-src-alpha@*

To see more info on this subject please see the doc-string for the
blending-params struct.
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@item Writer
@ref{go to the CEPL<dot>BLENDING<colon><colon>(SETF SOURCE-RGB) function, , @t{(setf source-rgb)}} (function)
@end table
@end deffn
@deffn {Function} {(setf source-rgb)} VALUE FBO &optional ATTACHMENT-NAME
@anchor{go to the CEPL<dot>BLENDING<colon><colon>(SETF SOURCE-RGB) function}@c
@functionsubindex{(setf source-rgb)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@item Reader
@ref{go to the CEPL<dot>BLENDING<colon><colon>SOURCE-RGB function, , @t{source-rgb}} (function)
@end table
@end deffn
@deffn {Function} {split-float-version} FLOAT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>SPLIT-FLOAT-VERSION function}@c
@functionsubindex{split-float-version}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/version<dot>lisp file, , @t{core/context/version.lisp}} (file)
@end table
@end deffn
@deffn {Function} {split-seq-by-seq} DELIM SEQUENCE
@anchor{go to the CEPL-UTILS<colon><colon>SPLIT-SEQ-BY-SEQ function}@c
@functionsubindex{split-seq-by-seq}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {split-string} DELIMITER STRING
@anchor{go to the CEPL-UTILS<colon><colon>SPLIT-STRING function}@c
@functionsubindex{split-string}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {ssbo-data} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>SSBO-DATA function}@c
@functionsubindex{ssbo-data}@c

Returns the `gpu-array` that contains the data presented by this `SSBO`
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF SSBO-DATA) function, , @t{(setf ssbo-data)}} (function)
@end table
@end deffn
@deffn {Function} {(setf ssbo-data)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF SSBO-DATA) function}@c
@functionsubindex{(setf ssbo-data)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>SSBO-DATA function, , @t{ssbo-data}} (function)
@end table
@end deffn
@deffn {Function} {ssbo-data-type} SSBO
@anchor{go to the CEPL<dot>SSBOS<colon><colon>SSBO-DATA-TYPE function}@c
@functionsubindex{ssbo-data-type}@c

This function returns the type of the data that is contained in the `SSBO`
@table @strong
@item Package
@ref{go to the CEPL<dot>SSBOS package, , @t{cepl.ssbos}}
@item Source
@ref{go to the cepl/core/ssbos/ssbos<dot>lisp file, , @t{core/ssbos/ssbos.lisp}} (file)
@end table
@end deffn
@deffn {Function} {ssbo-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>SSBO-ID function}@c
@functionsubindex{ssbo-id}@c

This function return the id of the GL SSBO abstracted by this CEPL `SSBO`.
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF SSBO-ID) function, , @t{(setf ssbo-id)}} (function)
@end table
@end deffn
@deffn {Function} {(setf ssbo-id)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF SSBO-ID) function}@c
@functionsubindex{(setf ssbo-id)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>SSBO-ID function, , @t{ssbo-id}} (function)
@end table
@end deffn
@deffn {Function} {ssbo-index} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>SSBO-INDEX function}@c
@functionsubindex{ssbo-index}@c

This function returns the index into the ssbo-data where the element defined by
this `ssbo` is located
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF SSBO-INDEX) function, , @t{(setf ssbo-index)}} (function)
@end table
@end deffn
@deffn {Function} {(setf ssbo-index)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF SSBO-INDEX) function}@c
@functionsubindex{(setf ssbo-index)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>SSBO-INDEX function, , @t{ssbo-index}} (function)
@end table
@end deffn
@deffn {Function} {ssbo-owns-gpu-array} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>SSBO-OWNS-GPU-ARRAY function}@c
@functionsubindex{ssbo-owns-gpu-array}@c

This function returns t if the `gpu-array` was created by `make-ssbo` or nil if it is
using data from a gpu-array passed to make-ssbo
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF SSBO-OWNS-GPU-ARRAY) function, , @t{(setf ssbo-owns-gpu-array)}} (function)
@end table
@end deffn
@deffn {Function} {(setf ssbo-owns-gpu-array)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF SSBO-OWNS-GPU-ARRAY) function}@c
@functionsubindex{(setf ssbo-owns-gpu-array)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>SSBO-OWNS-GPU-ARRAY function, , @t{ssbo-owns-gpu-array}} (function)
@end table
@end deffn
@deffn {Function} {ssbo-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>SSBO-P function}@c
@functionsubindex{ssbo-p}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {stencil-decf} INCOMING-VAL STORED-VAL
@anchor{go to the CEPL<dot>DOCUMENTATION-FUNCTIONS<colon><colon>STENCIL-DECF function}@c
@functionsubindex{stencil-decf}@c
Decrement the stored value clamping to 0@*

   We only show the implementation for 8bit stencil here due to strong
   recommendations from guides to use 8bit stencils. Not an issue
   as this is only a stand-in function anyway
@table @strong
@item Package
@ref{go to the CEPL<dot>DOCUMENTATION-FUNCTIONS package, , @t{cepl.documentation-functions}}
@item Source
@ref{go to the cepl/core/context/documentation-functions<dot>lisp file, , @t{core/context/documentation-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {stencil-decf-wrap} INCOMING-VAL STORED-VAL
@anchor{go to the CEPL<dot>DOCUMENTATION-FUNCTIONS<colon><colon>STENCIL-DECF-WRAP function}@c
@functionsubindex{stencil-decf-wrap}@c
Decrement the stored value wrapping if underflows@*

   We only show the implementation for 8bit stencil here due to strong
   recommendations from guides to use 8bit stencils. Not an issue
   as this is only a stand-in function anyway
@table @strong
@item Package
@ref{go to the CEPL<dot>DOCUMENTATION-FUNCTIONS package, , @t{cepl.documentation-functions}}
@item Source
@ref{go to the cepl/core/context/documentation-functions<dot>lisp file, , @t{core/context/documentation-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {stencil-formatp} FORMAT
@anchor{go to the CEPL<dot>IMAGE-FORMATS<colon><colon>STENCIL-FORMATP function}@c
@functionsubindex{stencil-formatp}@c

This function returns t if the value provided is a keyword that can be found in
*stencil-formats*
@table @strong
@item Package
@ref{go to the CEPL<dot>IMAGE-FORMATS package, , @t{cepl.image-formats}}
@item Source
@ref{go to the cepl/core/types/image-format<dot>lisp file, , @t{core/types/image-format.lisp}} (file)
@end table
@end deffn
@deffn {Function} {stencil-incf} INCOMING-VAL STORED-VAL
@anchor{go to the CEPL<dot>DOCUMENTATION-FUNCTIONS<colon><colon>STENCIL-INCF function}@c
@functionsubindex{stencil-incf}@c
Increment the stored value clamping to maximum@*

   We only show the implementation for 8bit stencil here due to strong
   recommendations from guides to use 8bit stencils. Not an issue
   as this is only a stand-in function anyway
@table @strong
@item Package
@ref{go to the CEPL<dot>DOCUMENTATION-FUNCTIONS package, , @t{cepl.documentation-functions}}
@item Source
@ref{go to the cepl/core/context/documentation-functions<dot>lisp file, , @t{core/context/documentation-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {stencil-incf-wrap} INCOMING-VAL STORED-VAL
@anchor{go to the CEPL<dot>DOCUMENTATION-FUNCTIONS<colon><colon>STENCIL-INCF-WRAP function}@c
@functionsubindex{stencil-incf-wrap}@c
Increment the stored value wrapping if it overflows@*

   We only show the implementation for 8bit stencil here due to strong
   recommendations from guides to use 8bit stencils. Not an issue
   as this is only a stand-in function anyway
@table @strong
@item Package
@ref{go to the CEPL<dot>DOCUMENTATION-FUNCTIONS package, , @t{cepl.documentation-functions}}
@item Source
@ref{go to the cepl/core/context/documentation-functions<dot>lisp file, , @t{core/context/documentation-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {stencil-invert} INCOMING-VAL STORED-VAL
@anchor{go to the CEPL<dot>DOCUMENTATION-FUNCTIONS<colon><colon>STENCIL-INVERT function}@c
@functionsubindex{stencil-invert}@c
Invert the stored value@*

   We only show the implementation for 8bit stencil here due to strong
   recommendations from guides to use 8bit stencils. Not an issue
   as this function only exists as documentation anyway
@table @strong
@item Package
@ref{go to the CEPL<dot>DOCUMENTATION-FUNCTIONS package, , @t{cepl.documentation-functions}}
@item Source
@ref{go to the cepl/core/context/documentation-functions<dot>lisp file, , @t{core/context/documentation-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {stencil-mask} FACE &optional CEPL-CONTEXT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>STENCIL-MASK function}@c
@functionsubindex{stencil-mask}@c
@deffnx {Function} {(setf stencil-mask)} MASK FACE &optional CEPL-CONTEXT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF STENCIL-MASK) function}@c
@functionsubindex{(setf stencil-mask)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/stencil/mask<dot>lisp file, , @t{core/stencil/mask.lisp}} (file)
@end table
@end deffn
@deffn {Function} {stencil-params-mask} PARAMS
@anchor{go to the CEPL<dot>STENCIL<colon><colon>STENCIL-PARAMS-MASK function}@c
@functionsubindex{stencil-params-mask}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>STENCIL package, , @t{cepl.stencil}}
@item Source
@ref{go to the cepl/core/stencil/stencil<dot>lisp file, , @t{core/stencil/stencil.lisp}} (file)
@end table
@end deffn
@deffn {Function} {stencil-params-on-dpfail} PARAMS
@anchor{go to the CEPL<dot>STENCIL<colon><colon>STENCIL-PARAMS-ON-DPFAIL function}@c
@functionsubindex{stencil-params-on-dpfail}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>STENCIL package, , @t{cepl.stencil}}
@item Source
@ref{go to the cepl/core/stencil/stencil<dot>lisp file, , @t{core/stencil/stencil.lisp}} (file)
@end table
@end deffn
@deffn {Function} {stencil-params-on-dppass} PARAMS
@anchor{go to the CEPL<dot>STENCIL<colon><colon>STENCIL-PARAMS-ON-DPPASS function}@c
@functionsubindex{stencil-params-on-dppass}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>STENCIL package, , @t{cepl.stencil}}
@item Source
@ref{go to the cepl/core/stencil/stencil<dot>lisp file, , @t{core/stencil/stencil.lisp}} (file)
@end table
@end deffn
@deffn {Function} {stencil-params-on-sfail} PARAMS
@anchor{go to the CEPL<dot>STENCIL<colon><colon>STENCIL-PARAMS-ON-SFAIL function}@c
@functionsubindex{stencil-params-on-sfail}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>STENCIL package, , @t{cepl.stencil}}
@item Source
@ref{go to the cepl/core/stencil/stencil<dot>lisp file, , @t{core/stencil/stencil.lisp}} (file)
@end table
@end deffn
@deffn {Function} {stencil-params-on-stencil-pass-depth-test-fail} PARAMS
@anchor{go to the CEPL<dot>STENCIL<colon><colon>STENCIL-PARAMS-ON-STENCIL-PASS-DEPTH-TEST-FAIL function}@c
@functionsubindex{stencil-params-on-stencil-pass-depth-test-fail}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>STENCIL package, , @t{cepl.stencil}}
@item Source
@ref{go to the cepl/core/stencil/stencil<dot>lisp file, , @t{core/stencil/stencil.lisp}} (file)
@end table
@end deffn
@deffn {Function} {stencil-params-on-stencil-pass-depth-test-pass} PARAMS
@anchor{go to the CEPL<dot>STENCIL<colon><colon>STENCIL-PARAMS-ON-STENCIL-PASS-DEPTH-TEST-PASS function}@c
@functionsubindex{stencil-params-on-stencil-pass-depth-test-pass}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>STENCIL package, , @t{cepl.stencil}}
@item Source
@ref{go to the cepl/core/stencil/stencil<dot>lisp file, , @t{core/stencil/stencil.lisp}} (file)
@end table
@end deffn
@deffn {Function} {stencil-params-on-stencil-test-fail} PARAMS
@anchor{go to the CEPL<dot>STENCIL<colon><colon>STENCIL-PARAMS-ON-STENCIL-TEST-FAIL function}@c
@functionsubindex{stencil-params-on-stencil-test-fail}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>STENCIL package, , @t{cepl.stencil}}
@item Source
@ref{go to the cepl/core/stencil/stencil<dot>lisp file, , @t{core/stencil/stencil.lisp}} (file)
@end table
@end deffn
@deffn {Function} {stencil-params-test} PARAMS
@anchor{go to the CEPL<dot>STENCIL<colon><colon>STENCIL-PARAMS-TEST function}@c
@functionsubindex{stencil-params-test}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>STENCIL package, , @t{cepl.stencil}}
@item Source
@ref{go to the cepl/core/stencil/stencil<dot>lisp file, , @t{core/stencil/stencil.lisp}} (file)
@end table
@end deffn
@deffn {Function} {stencil-params-value} PARAMS
@anchor{go to the CEPL<dot>STENCIL<colon><colon>STENCIL-PARAMS-VALUE function}@c
@functionsubindex{stencil-params-value}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>STENCIL package, , @t{cepl.stencil}}
@item Source
@ref{go to the cepl/core/stencil/stencil<dot>lisp file, , @t{core/stencil/stencil.lisp}} (file)
@end table
@end deffn
@deffn {Function} {stencil-replace} INCOMING-VAL STORED-VAL
@anchor{go to the CEPL<dot>DOCUMENTATION-FUNCTIONS<colon><colon>STENCIL-REPLACE function}@c
@functionsubindex{stencil-replace}@c
Invert the stored value@*

   We only show the implementation for 8bit stencil here due to strong
   recommendations from guides to use 8bit stencils. Not an issue
   as this function only exists as documentation anyway
@table @strong
@item Package
@ref{go to the CEPL<dot>DOCUMENTATION-FUNCTIONS package, , @t{cepl.documentation-functions}}
@item Source
@ref{go to the cepl/core/context/documentation-functions<dot>lisp file, , @t{core/context/documentation-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {step-host} &optional CONTEXT
@anchor{go to the CEPL<colon><colon>STEP-HOST function}@c
@functionsubindex{step-host}@c

Call this to ask the host update its own internals.@*

This description is a bit nebulous as cepl doesnt impose what the host should do
when this call is made; however it is usual to call #'step-host every tick of
a main-loop and so often hosts will use this to do per-tick jobs like polling
for input events.
@table @strong
@item Package
@ref{go to the CEPL package, , @t{cepl}}
@item Source
@ref{go to the cepl/core/repl<dot>lisp file, , @t{core/repl.lisp}} (file)
@end table
@end deffn
@deffn {Function} {stop-listening-to-lifecycle-changes} FUNC
@anchor{go to the CEPL<dot>LIFECYCLE<colon><colon>STOP-LISTENING-TO-LIFECYCLE-CHANGES function}@c
@functionsubindex{stop-listening-to-lifecycle-changes}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>LIFECYCLE package, , @t{cepl.lifecycle}}
@item Source
@ref{go to the cepl/core/lifecycle<dot>lisp file, , @t{core/lifecycle.lisp}} (file)
@end table
@end deffn
@deffn {Function} {sub-at-index} SEQ INDEX NEW-VAL
@anchor{go to the CEPL-UTILS<colon><colon>SUB-AT-INDEX function}@c
@functionsubindex{sub-at-index}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {subseq-c} ARRAY START &optional END
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>SUBSEQ-C function}@c
@functionsubindex{subseq-c}@c

This function returns a `c-array` which contains a subset of the array passed into
this function.@*

It does not copy the foreign data, instead this array points to within the data
of the original array. This means these arrays now share data (like a displaced
array in standard CL.@*

Due to this you have to be very careful when freeing the underlying array as
this will affect any other array sharing that data.@*

If you want a copy of a subseq of a c-array then use something like:@*

    (clone-c-array (subseq-c arr 3 10))@*

The reason that this arguably more dangerous behaviour is default is efficiency.
CEPL tries not to allocate new memory when the function is not explicitly about
that.
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/rest<dot>lisp file, , @t{core/c-arrays/rest.lisp}} (file)
@end table
@end deffn
@deffn {Function} {subseq-g} ARRAY START &optional END
@anchor{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED<colon><colon>SUBSEQ-G function}@c
@functionsubindex{subseq-g}@c

This function returns a `gpu-array` which contains a subset of the gpu-array
passed into this function.@*

It does not copy the foreign data, instead this array points to within the data
of the original array. This means these arrays now share data (like a displaced
array in standard CL.@*

Due to this you have to be very careful when freeing the underlying array as
this will affect any other array sharing that data.@*

The reason that this arguably more dangerous behaviour is default is efficiency.
Mofidying gpu memory in performance critical applications should be done at
specific times so as not to get blocked by rendering commands. As such CEPL
tries not to allocate new memory when the function is not explicitly about that.
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED package, , @t{cepl.gpu-arrays.buffer-backed}}
@item Source
@ref{go to the cepl/core/gpu-arrays/buffer-backed<dot>lisp file, , @t{core/gpu-arrays/buffer-backed.lisp}} (file)
@end table
@end deffn
@deffn {Function} {subseq-g-raw} ARRAY START END &key NEW-ELEMENT-TYPE
@anchor{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED<colon><colon>SUBSEQ-G-RAW function}@c
@functionsubindex{subseq-g-raw}@c

This function returns a `gpu-array` which contains a subset of the gpu-array
passed into this function optionally allowing you to change the element-type
of the resulting gpu-array.@*

It does not copy the foreign data, instead this array points to within the data
of the original array. This means these arrays now share data (like a displaced
array in standard CL.@*

Due to this you have to be very careful when freeing the underlying array as
this will affect any other array sharing that data.@*

Also you have to be careful that the new element-type you choose makes sense
given the data already in the arrays. For example taking an gpu-array of :vec4
and making an gpu-array of :float will give you sensible values, however making
a gpu-array of :int will give you garbage.@*

Unless you have a very specific use-case then it is best to use `subseq-g`@*

The reason that this arguably more dangerous behaviour is default is efficiency.
Mofidying gpu memory in performance critical applications should be done at
specific times so as not to get blocked by rendering commands. As such CEPL
tries not to allocate new memory when the function is not explicitly about that.
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED package, , @t{cepl.gpu-arrays.buffer-backed}}
@item Source
@ref{go to the cepl/core/gpu-arrays/buffer-backed<dot>lisp file, , @t{core/gpu-arrays/buffer-backed.lisp}} (file)
@end table
@end deffn
@deffn {Function} {supports-multiple-contexts-p} &rest ARGS &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>SUPPORTS-MULTIPLE-CONTEXTS-P function}@c
@functionsubindex{supports-multiple-contexts-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Function} {supports-multiple-surfaces-p} &rest ARGS &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>SUPPORTS-MULTIPLE-SURFACES-P function}@c
@functionsubindex{supports-multiple-surfaces-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Function} {surface-dimensions} SURFACE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>SURFACE-DIMENSIONS function}@c
@functionsubindex{surface-dimensions}@c
@deffnx {Function} {(setf surface-dimensions)} VALUE SURFACE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF SURFACE-DIMENSIONS) function}@c
@functionsubindex{(setf surface-dimensions)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/surface<dot>lisp file, , @t{core/context/surface.lisp}} (file)
@end table
@end deffn
@deffn {Function} {surface-fullscreen-p} SURFACE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>SURFACE-FULLSCREEN-P function}@c
@functionsubindex{surface-fullscreen-p}@c
@deffnx {Function} {(setf surface-fullscreen-p)} VALUE SURFACE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF SURFACE-FULLSCREEN-P) function}@c
@functionsubindex{(setf surface-fullscreen-p)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/surface<dot>lisp file, , @t{core/context/surface.lisp}} (file)
@end table
@end deffn
@deffn {Function} {surface-fullscreen-p} SURFACE &rest ARGS &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>SURFACE-FULLSCREEN-P function}@c
@functionsubindex{surface-fullscreen-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Function} {surface-resolution} SURFACE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>SURFACE-RESOLUTION function}@c
@functionsubindex{surface-resolution}@c
@deffnx {Function} {(setf surface-resolution)} VALUE SURFACE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF SURFACE-RESOLUTION) function}@c
@functionsubindex{(setf surface-resolution)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/surface<dot>lisp file, , @t{core/context/surface.lisp}} (file)
@end table
@end deffn
@deffn {Function} {surface-title} SURFACE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>SURFACE-TITLE function}@c
@functionsubindex{surface-title}@c
@deffnx {Function} {(setf surface-title)} VALUE SURFACE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF SURFACE-TITLE) function}@c
@functionsubindex{(setf surface-title)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/surface<dot>lisp file, , @t{core/context/surface.lisp}} (file)
@end table
@end deffn
@deffn {Function} {surface-title} SURFACE &rest ARGS &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>SURFACE-TITLE function}@c
@functionsubindex{surface-title}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Function} {surfaces} &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>SURFACES function}@c
@functionsubindex{surfaces}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {swap} &optional CONTEXT
@anchor{go to the CEPL<colon><colon>SWAP function}@c
@functionsubindex{swap}@c

Call this ask the host to swap the buffers of the default framebuffer.

We usually do this when we have finished drawing a given frame.
@table @strong
@item Package
@ref{go to the CEPL package, , @t{cepl}}
@item Source
@ref{go to the cepl/core/repl<dot>lisp file, , @t{core/repl.lisp}} (file)
@end table
@end deffn
@deffn {Function} {symb} &rest ARGS
@anchor{go to the CEPL-UTILS<colon><colon>SYMB function}@c
@functionsubindex{symb}@c
This takes a list of symbols (or strings) and outputs one
   symbol.@*
   If the input is symbol/s then the output is a regular symbol
   If the input is string/s, then the output is@*
   a |symbol like this|
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {symb-name=} A B
@anchor{go to the CEPL-UTILS<colon><colon>SYMB-NAME= function}@c
@functionsubindex{symb-name=}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {symb-package} PACKAGE &rest ARGS
@anchor{go to the CEPL-UTILS<colon><colon>SYMB-PACKAGE function}@c
@functionsubindex{symb-package}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {symbol-name-equal} A B
@anchor{go to the CEPL-UTILS<colon><colon>SYMBOL-NAME-EQUAL function}@c
@functionsubindex{symbol-name-equal}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {texref} TEXTURE &key MIPMAP-LEVEL LAYER CUBE-FACE
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>TEXREF function}@c
@functionsubindex{texref}@c

This function allows you to access a specific `gpu-array` from the `texture`.

:mipmap-level is invalid if the texture doesnt have mipmaps@*

:layer is invalid if the texture-type is not a 1d,2d or cube-map array-texture.

:cube-face is invalid if the texture is not a cube-map texture
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {texture-allocated-p} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TEXTURE-ALLOCATED-P function}@c
@functionsubindex{texture-allocated-p}@c
@deffnx {Function} {(setf texture-allocated-p)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF TEXTURE-ALLOCATED-P) function}@c
@functionsubindex{(setf texture-allocated-p)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {texture-base-dimensions} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TEXTURE-BASE-DIMENSIONS function}@c
@functionsubindex{texture-base-dimensions}@c

Returns the resolution of the `gpu-array` at the 'base-level' of the mipmap chain.
The base level is the largest one.
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF TEXTURE-BASE-DIMENSIONS) function, , @t{(setf texture-base-dimensions)}} (function)
@end table
@end deffn
@deffn {Function} {(setf texture-base-dimensions)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF TEXTURE-BASE-DIMENSIONS) function}@c
@functionsubindex{(setf texture-base-dimensions)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>TEXTURE-BASE-DIMENSIONS function, , @t{texture-base-dimensions}} (function)
@end table
@end deffn
@deffn {Function} {texture-cache-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TEXTURE-CACHE-ID function}@c
@functionsubindex{texture-cache-id}@c
@deffnx {Function} {(setf texture-cache-id)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF TEXTURE-CACHE-ID) function}@c
@functionsubindex{(setf texture-cache-id)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {texture-cubes-p} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TEXTURE-CUBES-P function}@c
@functionsubindex{texture-cubes-p}@c

This function returns t if the `texture` is a cube texture and nil otherwise
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF TEXTURE-CUBES-P) function, , @t{(setf texture-cubes-p)}} (function)
@end table
@end deffn
@deffn {Function} {(setf texture-cubes-p)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF TEXTURE-CUBES-P) function}@c
@functionsubindex{(setf texture-cubes-p)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>TEXTURE-CUBES-P function, , @t{texture-cubes-p}} (function)
@end table
@end deffn
@deffn {Function} {texture-element-type} TEXTURE
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>TEXTURE-ELEMENT-TYPE function}@c
@functionsubindex{texture-element-type}@c

This function returns the element-type of the given `texture`.@*

If the texture is a `buffer-texture` then the element-type will be a foreign lisp
type.@*

Otherwise it will be one of the image-formats@*

**-- Element Types Details --**@*

Unlike `c-array` and `gpu-array`s (which use foreign types for their elements)
textures have a different set of acceptable format. These are called@*
'image formats'.@*

The name may imply that these formats are only usable for image data but this
is not the case. Most of the types we are used to are there, but under unsual
names.@*

This would make this a ripe candidate for CEPL to clean up the naming.. but it
doesnt, why?@*

Well the answer to that is image-formats are damn confusing and if we change
too much of the naming it will be even more confusing when trying to google
information. Instead CEPL provides a number of functions for converting
between (foreign) lisp types and their image-format counterparts.@*

@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/def<dot>lisp file, , @t{core/textures/def.lisp}} (file)
@end table
@end deffn
@deffn {Function} {texture-fixed-sample-locations-p} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TEXTURE-FIXED-SAMPLE-LOCATIONS-P function}@c
@functionsubindex{texture-fixed-sample-locations-p}@c
@deffnx {Function} {(setf texture-fixed-sample-locations-p)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF TEXTURE-FIXED-SAMPLE-LOCATIONS-P) function}@c
@functionsubindex{(setf texture-fixed-sample-locations-p)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {texture-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TEXTURE-ID function}@c
@functionsubindex{texture-id}@c

This function returns the id of the GL Texture Object from the CEPL `texture`.

Don't use this unless you know what you are doing on the GL side.
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF TEXTURE-ID) function, , @t{(setf texture-id)}} (function)
@end table
@end deffn
@deffn {Function} {(setf texture-id)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF TEXTURE-ID) function}@c
@functionsubindex{(setf texture-id)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>TEXTURE-ID function, , @t{texture-id}} (function)
@end table
@end deffn
@deffn {Function} {texture-image-format} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TEXTURE-IMAGE-FORMAT function}@c
@functionsubindex{texture-image-format}@c
@deffnx {Function} {(setf texture-image-format)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF TEXTURE-IMAGE-FORMAT) function}@c
@functionsubindex{(setf texture-image-format)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {texture-last-sampler-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TEXTURE-LAST-SAMPLER-ID function}@c
@functionsubindex{texture-last-sampler-id}@c
@deffnx {Function} {(setf texture-last-sampler-id)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF TEXTURE-LAST-SAMPLER-ID) function}@c
@functionsubindex{(setf texture-last-sampler-id)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {texture-layer-count} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TEXTURE-LAYER-COUNT function}@c
@functionsubindex{texture-layer-count}@c

When called with a `texture` with one of the following texture-types:
:texture-1d-array@*
:texture-2d-array@*
:texture-cube-map-array@*

then this function returns the number of 'layers' in the texture.

For all other texture types this will return 0
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF TEXTURE-LAYER-COUNT) function, , @t{(setf texture-layer-count)}} (function)
@end table
@end deffn
@deffn {Function} {(setf texture-layer-count)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF TEXTURE-LAYER-COUNT) function}@c
@functionsubindex{(setf texture-layer-count)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>TEXTURE-LAYER-COUNT function, , @t{texture-layer-count}} (function)
@end table
@end deffn
@deffn {Function} {texture-mipmap-levels} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TEXTURE-MIPMAP-LEVELS function}@c
@functionsubindex{texture-mipmap-levels}@c

When called with a `texture` with mipmaps enabled this function returns the number
of 'mipmap levels' in the texture.@*

For all other texture types this will return 0
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF TEXTURE-MIPMAP-LEVELS) function, , @t{(setf texture-mipmap-levels)}} (function)
@end table
@end deffn
@deffn {Function} {(setf texture-mipmap-levels)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF TEXTURE-MIPMAP-LEVELS) function}@c
@functionsubindex{(setf texture-mipmap-levels)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>TEXTURE-MIPMAP-LEVELS function, , @t{texture-mipmap-levels}} (function)
@end table
@end deffn
@deffn {Function} {texture-mutable-p} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TEXTURE-MUTABLE-P function}@c
@functionsubindex{texture-mutable-p}@c

When called with a `texture` this function returns t if the texture was made with
mutable texture storage and nil otherwise.@*

Using immutable texture storage does not mean that the data inside the texture's
`gpu-array`s cannot be mutated.@*

Mutable texture storage allows you to redefine the 'nature' of the data stored
in the gpu-arrays after they are created, by that we mean things like the type
of the data, the resolution of the gpu-arrays.@*

As it is hard to change such things without creating an 'incomplete' texture[0]
CEPL opts to treat all textures as immutable textures.@*
When the OpenGL version doesnt support immutable texture storage CEPL makes uses
immutable storage, allocates all the memory at construction, and doesnt provide
abstractions over the opengl features that would modify the storage.@*

[0] - https://www.opengl.org/wiki/Immutable_Storage_Texture#Texture_completeness
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF TEXTURE-MUTABLE-P) function, , @t{(setf texture-mutable-p)}} (function)
@end table
@end deffn
@deffn {Function} {(setf texture-mutable-p)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF TEXTURE-MUTABLE-P) function}@c
@functionsubindex{(setf texture-mutable-p)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>TEXTURE-MUTABLE-P function, , @t{texture-mutable-p}} (function)
@end table
@end deffn
@deffn {Function} {texture-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TEXTURE-P function}@c
@functionsubindex{texture-p}@c

This function returns t if the given value is a `texture`, otherwise nil is
returned.
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {texture-type} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TEXTURE-TYPE function}@c
@functionsubindex{texture-type}@c

This function will return the type of the given `texture`.

The possible values are:@*

    :texture-1d@*
    :texture-2d@*
    :texture-3d@*
    :texture-rectangle@*
    :texture-buffer@*
    :texture-cube-map@*
    :texture-1d-array@*
    :texture-2d-array@*
    :texture-cube-map-array
    :texture-2d-multisample
    :texture-2d-multisample-array
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF TEXTURE-TYPE) function, , @t{(setf texture-type)}} (function)
@end table
@end deffn
@deffn {Function} {(setf texture-type)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF TEXTURE-TYPE) function}@c
@functionsubindex{(setf texture-type)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>TEXTURE-TYPE function, , @t{texture-type}} (function)
@end table
@end deffn
@deffn {Function} {transform-feedback-stream-arrays} TFS
@anchor{go to the CEPL<dot>TRANSFORM-FEEDBACK<colon><colon>TRANSFORM-FEEDBACK-STREAM-ARRAYS function}@c
@functionsubindex{transform-feedback-stream-arrays}@c
@deffnx {Function} {(setf transform-feedback-stream-arrays)} BUFFER-BACKED-GPU-ARRAYS TFS
@anchor{go to the CEPL<dot>TRANSFORM-FEEDBACK<colon><colon>(SETF TRANSFORM-FEEDBACK-STREAM-ARRAYS) function}@c
@functionsubindex{(setf transform-feedback-stream-arrays)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TRANSFORM-FEEDBACK package, , @t{cepl.transform-feedback}}
@item Source
@ref{go to the cepl/core/transform-feedback/transform-feedback<dot>lisp file, , @t{core/transform-feedback/transform-feedback.lisp}} (file)
@end table
@end deffn
@deffn {Function} {ubo-data} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>UBO-DATA function}@c
@functionsubindex{ubo-data}@c

Returns the `gpu-array` that contains the data presented by this `UBO`
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF UBO-DATA) function, , @t{(setf ubo-data)}} (function)
@end table
@end deffn
@deffn {Function} {(setf ubo-data)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF UBO-DATA) function}@c
@functionsubindex{(setf ubo-data)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>UBO-DATA function, , @t{ubo-data}} (function)
@end table
@end deffn
@deffn {Function} {ubo-data-type} UBO
@anchor{go to the CEPL<dot>UBOS<colon><colon>UBO-DATA-TYPE function}@c
@functionsubindex{ubo-data-type}@c

This function returns the type of the data that is contained in the `UBO`
@table @strong
@item Package
@ref{go to the CEPL<dot>UBOS package, , @t{cepl.ubos}}
@item Source
@ref{go to the cepl/core/ubos/ubo<dot>lisp file, , @t{core/ubos/ubo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {ubo-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>UBO-ID function}@c
@functionsubindex{ubo-id}@c

This function return the id of the GL UBO abstracted by this CEPL `UBO`.
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF UBO-ID) function, , @t{(setf ubo-id)}} (function)
@end table
@end deffn
@deffn {Function} {(setf ubo-id)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF UBO-ID) function}@c
@functionsubindex{(setf ubo-id)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>UBO-ID function, , @t{ubo-id}} (function)
@end table
@end deffn
@deffn {Function} {ubo-index} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>UBO-INDEX function}@c
@functionsubindex{ubo-index}@c

This function returns the index into the ubo-data where the element defined by
this `ubo` is located
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF UBO-INDEX) function, , @t{(setf ubo-index)}} (function)
@end table
@end deffn
@deffn {Function} {(setf ubo-index)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF UBO-INDEX) function}@c
@functionsubindex{(setf ubo-index)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>UBO-INDEX function, , @t{ubo-index}} (function)
@end table
@end deffn
@deffn {Function} {ubo-owns-gpu-array} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>UBO-OWNS-GPU-ARRAY function}@c
@functionsubindex{ubo-owns-gpu-array}@c

This function returns t if the `gpu-array` was created by `make-ubo` or nil if it is
using data from a gpu-array passed to make-ubo
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF UBO-OWNS-GPU-ARRAY) function, , @t{(setf ubo-owns-gpu-array)}} (function)
@end table
@end deffn
@deffn {Function} {(setf ubo-owns-gpu-array)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF UBO-OWNS-GPU-ARRAY) function}@c
@functionsubindex{(setf ubo-owns-gpu-array)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>UBO-OWNS-GPU-ARRAY function, , @t{ubo-owns-gpu-array}} (function)
@end table
@end deffn
@deffn {Function} {ubo-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>UBO-P function}@c
@functionsubindex{ubo-p}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uint-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>UINT-FROM-FOREIGN function}@c
@functionsubindex{uint-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uint-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>UINT-TO-FOREIGN function}@c
@functionsubindex{uint-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uint32-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>UINT32-FROM-FOREIGN function}@c
@functionsubindex{uint32-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uint32-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>UINT32-TO-FOREIGN function}@c
@functionsubindex{uint32-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uint8-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>UINT8-FROM-FOREIGN function}@c
@functionsubindex{uint8-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uint8-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>UINT8-TO-FOREIGN function}@c
@functionsubindex{uint8-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uint8-vec2-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>UINT8-VEC2-FROM-FOREIGN function}@c
@functionsubindex{uint8-vec2-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uint8-vec2-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>UINT8-VEC2-TO-FOREIGN function}@c
@functionsubindex{uint8-vec2-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uint8-vec3-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>UINT8-VEC3-FROM-FOREIGN function}@c
@functionsubindex{uint8-vec3-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uint8-vec3-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>UINT8-VEC3-TO-FOREIGN function}@c
@functionsubindex{uint8-vec3-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uint8-vec4-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>UINT8-VEC4-FROM-FOREIGN function}@c
@functionsubindex{uint8-vec4-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uint8-vec4-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>UINT8-VEC4-TO-FOREIGN function}@c
@functionsubindex{uint8-vec4-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uninitialized-p} ()
@anchor{go to the CEPL<dot>LIFECYCLE<colon><colon>UNINITIALIZED-P function}@c
@functionsubindex{uninitialized-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>LIFECYCLE package, , @t{cepl.lifecycle}}
@item Source
@ref{go to the cepl/core/lifecycle<dot>lisp file, , @t{core/lifecycle.lisp}} (file)
@end table
@end deffn
@deffn {Function} {unknown-gl-id-p} ID
@anchor{go to the %CEPL<dot>TYPES<colon><colon>UNKNOWN-GL-ID-P function}@c
@functionsubindex{unknown-gl-id-p}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {unpack-alignment} &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>UNPACK-ALIGNMENT function}@c
@functionsubindex{unpack-alignment}@c
@deffnx {Function} {(setf unpack-alignment)} ROW-ALIGNMENT &optional FORCE CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF UNPACK-ALIGNMENT) function}@c
@functionsubindex{(setf unpack-alignment)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/pixel-store/pixel-store<dot>lisp file, , @t{core/pixel-store/pixel-store.lisp}} (file)
@end table
@end deffn
@deffn {Function} {ushort-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>USHORT-FROM-FOREIGN function}@c
@functionsubindex{ushort-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {ushort-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>USHORT-TO-FOREIGN function}@c
@functionsubindex{ushort-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uvec2-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>UVEC2-FROM-FOREIGN function}@c
@functionsubindex{uvec2-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uvec2-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>UVEC2-TO-FOREIGN function}@c
@functionsubindex{uvec2-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uvec3-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>UVEC3-FROM-FOREIGN function}@c
@functionsubindex{uvec3-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uvec3-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>UVEC3-TO-FOREIGN function}@c
@functionsubindex{uvec3-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uvec4-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>UVEC4-FROM-FOREIGN function}@c
@functionsubindex{uvec4-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uvec4-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>UVEC4-TO-FOREIGN function}@c
@functionsubindex{uvec4-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {valid-image-format-for-buffer-backed-texturep} FORMAT
@anchor{go to the CEPL<dot>IMAGE-FORMATS<colon><colon>VALID-IMAGE-FORMAT-FOR-BUFFER-BACKED-TEXTUREP function}@c
@functionsubindex{valid-image-format-for-buffer-backed-texturep}@c

This function returns t if the value provided is a keyword that can be found in
*valid-image-formats-for-buffer-backed-texture*
@table @strong
@item Package
@ref{go to the CEPL<dot>IMAGE-FORMATS package, , @t{cepl.image-formats}}
@item Source
@ref{go to the cepl/core/types/image-format<dot>lisp file, , @t{core/types/image-format.lisp}} (file)
@end table
@end deffn
@deffn {Function} {vao-bound} CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>VAO-BOUND function}@c
@functionsubindex{vao-bound}@c
@deffnx {Function} {(setf vao-bound)} VAO CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF VAO-BOUND) function}@c
@functionsubindex{(setf vao-bound)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {vec2-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>VEC2-FROM-FOREIGN function}@c
@functionsubindex{vec2-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {vec2-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>VEC2-TO-FOREIGN function}@c
@functionsubindex{vec2-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {vec3-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>VEC3-FROM-FOREIGN function}@c
@functionsubindex{vec3-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {vec3-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>VEC3-TO-FOREIGN function}@c
@functionsubindex{vec3-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {vec4-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>VEC4-FROM-FOREIGN function}@c
@functionsubindex{vec4-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {vec4-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>VEC4-TO-FOREIGN function}@c
@functionsubindex{vec4-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {viewport-dimensions} VIEWPORT
@anchor{go to the CEPL<dot>VIEWPORTS<colon><colon>VIEWPORT-DIMENSIONS function}@c
@functionsubindex{viewport-dimensions}@c

This function returns the resolution of the `viewport` as a list of integers

If you call the generic function `dimensions` with a viewport you will get
this value.@*

If you need this value as a vec2 use `viewport-resolution` or just the
generic function `resolution`
@table @strong
@item Package
@ref{go to the CEPL<dot>VIEWPORTS package, , @t{cepl.viewports}}
@item Source
@ref{go to the cepl/core/viewports/viewport<dot>lisp file, , @t{core/viewports/viewport.lisp}} (file)
@item Writer
@ref{go to the CEPL<dot>VIEWPORTS<colon><colon>(SETF VIEWPORT-DIMENSIONS) function, , @t{(setf viewport-dimensions)}} (function)
@end table
@end deffn
@deffn {Function} {(setf viewport-dimensions)} VALUE VIEWPORT
@anchor{go to the CEPL<dot>VIEWPORTS<colon><colon>(SETF VIEWPORT-DIMENSIONS) function}@c
@functionsubindex{(setf viewport-dimensions)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>VIEWPORTS package, , @t{cepl.viewports}}
@item Source
@ref{go to the cepl/core/viewports/viewport<dot>lisp file, , @t{core/viewports/viewport.lisp}} (file)
@item Reader
@ref{go to the CEPL<dot>VIEWPORTS<colon><colon>VIEWPORT-DIMENSIONS function, , @t{viewport-dimensions}} (function)
@end table
@end deffn
@deffn {Function} {viewport-eql} V0 V1
@anchor{go to the CEPL<dot>VIEWPORTS<colon><colon>VIEWPORT-EQL function}@c
@functionsubindex{viewport-eql}@c

This function returns t if the two viewports have the same resolution and origin.
@table @strong
@item Package
@ref{go to the CEPL<dot>VIEWPORTS package, , @t{cepl.viewports}}
@item Source
@ref{go to the cepl/core/viewports/viewport<dot>lisp file, , @t{core/viewports/viewport.lisp}} (file)
@end table
@end deffn
@deffn {Function} {viewport-origin} VIEWPORT
@anchor{go to the CEPL<dot>VIEWPORTS<colon><colon>VIEWPORT-ORIGIN function}@c
@functionsubindex{viewport-origin}@c

This function returns the origin of the `viewport`.@*

This is the top-left corner of the rectangle within the surface that OpenGL (and
thus CEPL) will draw into
@table @strong
@item Package
@ref{go to the CEPL<dot>VIEWPORTS package, , @t{cepl.viewports}}
@item Source
@ref{go to the cepl/core/viewports/viewport<dot>lisp file, , @t{core/viewports/viewport.lisp}} (file)
@item Writer
@ref{go to the CEPL<dot>VIEWPORTS<colon><colon>(SETF VIEWPORT-ORIGIN) function, , @t{(setf viewport-origin)}} (function)
@end table
@end deffn
@deffn {Function} {(setf viewport-origin)} VALUE VIEWPORT
@anchor{go to the CEPL<dot>VIEWPORTS<colon><colon>(SETF VIEWPORT-ORIGIN) function}@c
@functionsubindex{(setf viewport-origin)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>VIEWPORTS package, , @t{cepl.viewports}}
@item Source
@ref{go to the cepl/core/viewports/viewport<dot>lisp file, , @t{core/viewports/viewport.lisp}} (file)
@item Reader
@ref{go to the CEPL<dot>VIEWPORTS<colon><colon>VIEWPORT-ORIGIN function, , @t{viewport-origin}} (function)
@end table
@end deffn
@deffn {Function} {viewport-origin-x} VIEWPORT
@anchor{go to the CEPL<dot>VIEWPORTS<colon><colon>VIEWPORT-ORIGIN-X function}@c
@functionsubindex{viewport-origin-x}@c

This function returns the x component of the resolution of the `viewport` as
a float.
@table @strong
@item Package
@ref{go to the CEPL<dot>VIEWPORTS package, , @t{cepl.viewports}}
@item Source
@ref{go to the cepl/core/viewports/viewport<dot>lisp file, , @t{core/viewports/viewport.lisp}} (file)
@end table
@end deffn
@deffn {Function} {viewport-origin-y} VIEWPORT
@anchor{go to the CEPL<dot>VIEWPORTS<colon><colon>VIEWPORT-ORIGIN-Y function}@c
@functionsubindex{viewport-origin-y}@c

This function returns the y component of the resolution of the `viewport` as
a float.
@table @strong
@item Package
@ref{go to the CEPL<dot>VIEWPORTS package, , @t{cepl.viewports}}
@item Source
@ref{go to the cepl/core/viewports/viewport<dot>lisp file, , @t{core/viewports/viewport.lisp}} (file)
@end table
@end deffn
@deffn {Function} {viewport-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>VIEWPORT-P function}@c
@functionsubindex{viewport-p}@c

This function will return t if the value given is a `viewport`, otherwise it will
return nil
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {viewport-params-to-vec4} &optional VIEWPORT
@anchor{go to the CEPL<dot>VIEWPORTS<colon><colon>VIEWPORT-PARAMS-TO-VEC4 function}@c
@functionsubindex{viewport-params-to-vec4}@c

Will return a vec4 packed with the origin and resolution. The format is as
follows:@*

    (v! origin-x origin-y resolution-x resolution-y)@*

If now viewport is provided the the `current-viewport` is used.
@table @strong
@item Package
@ref{go to the CEPL<dot>VIEWPORTS package, , @t{cepl.viewports}}
@item Source
@ref{go to the cepl/core/viewports/viewport<dot>lisp file, , @t{core/viewports/viewport.lisp}} (file)
@end table
@end deffn
@deffn {Function} {viewport-resolution} VIEWPORT
@anchor{go to the CEPL<dot>VIEWPORTS<colon><colon>VIEWPORT-RESOLUTION function}@c
@functionsubindex{viewport-resolution}@c

This function returns the resolution of the `viewport` as a vec2@*

If you call the generic function `resolution` with a viewport you will get
this value.@*

If you need this value as a list use `viewport-dimensions` or just the
generic function `dimensions`
@table @strong
@item Package
@ref{go to the CEPL<dot>VIEWPORTS package, , @t{cepl.viewports}}
@item Source
@ref{go to the cepl/core/viewports/viewport<dot>lisp file, , @t{core/viewports/viewport.lisp}} (file)
@item Writer
@ref{go to the CEPL<dot>VIEWPORTS<colon><colon>(SETF VIEWPORT-RESOLUTION) function, , @t{(setf viewport-resolution)}} (function)
@end table
@end deffn
@deffn {Function} {(setf viewport-resolution)} VALUE VIEWPORT
@anchor{go to the CEPL<dot>VIEWPORTS<colon><colon>(SETF VIEWPORT-RESOLUTION) function}@c
@functionsubindex{(setf viewport-resolution)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>VIEWPORTS package, , @t{cepl.viewports}}
@item Source
@ref{go to the cepl/core/viewports/viewport<dot>lisp file, , @t{core/viewports/viewport.lisp}} (file)
@item Reader
@ref{go to the CEPL<dot>VIEWPORTS<colon><colon>VIEWPORT-RESOLUTION function, , @t{viewport-resolution}} (function)
@end table
@end deffn
@deffn {Function} {viewport-resolution-x} VIEWPORT
@anchor{go to the CEPL<dot>VIEWPORTS<colon><colon>VIEWPORT-RESOLUTION-X function}@c
@functionsubindex{viewport-resolution-x}@c

This function returns the x component of the resolution of the `viewport` as
a float.
@table @strong
@item Package
@ref{go to the CEPL<dot>VIEWPORTS package, , @t{cepl.viewports}}
@item Source
@ref{go to the cepl/core/viewports/viewport<dot>lisp file, , @t{core/viewports/viewport.lisp}} (file)
@end table
@end deffn
@deffn {Function} {viewport-resolution-y} VIEWPORT
@anchor{go to the CEPL<dot>VIEWPORTS<colon><colon>VIEWPORT-RESOLUTION-Y function}@c
@functionsubindex{viewport-resolution-y}@c

This function returns the y component of the resolution of the `viewport` as
a float.
@table @strong
@item Package
@ref{go to the CEPL<dot>VIEWPORTS package, , @t{cepl.viewports}}
@item Source
@ref{go to the cepl/core/viewports/viewport<dot>lisp file, , @t{core/viewports/viewport.lisp}} (file)
@end table
@end deffn
@deffn {Function} {wait-on-gpu-fence} FENCE &optional TIMEOUT FLUSH
@anchor{go to the CEPL<dot>SYNC<colon><colon>WAIT-ON-GPU-FENCE function}@c
@functionsubindex{wait-on-gpu-fence}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SYNC package, , @t{cepl.sync}}
@item Source
@ref{go to the cepl/core/sync/sync<dot>lisp file, , @t{core/sync/sync.lisp}} (file)
@end table
@end deffn
@deffn {Function} {walk-replace} TO-REPLACE REPLACE-WITH FORM &key TEST
@anchor{go to the CEPL-UTILS<colon><colon>WALK-REPLACE function}@c
@functionsubindex{walk-replace}@c
This walks a list tree ('form') replacing all occurences of
   'to-replace' with 'replace-with'. This is pretty inefficent
   but will be fine for macros.
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {window-dimensions} WINDOW
@anchor{go to the CEPL<dot>INTERNALS<colon><colon>WINDOW-DIMENSIONS function}@c
@functionsubindex{window-dimensions}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>INTERNALS package, , @t{cepl.internals}}
@item Source
@ref{go to the cepl/core/internals<dot>lisp file, , @t{core/internals.lisp}} (file)
@end table
@end deffn
@deffn {Function} {window-resolution} WINDOW
@anchor{go to the CEPL<dot>INTERNALS<colon><colon>WINDOW-RESOLUTION function}@c
@functionsubindex{window-resolution}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>INTERNALS package, , @t{cepl.internals}}
@item Source
@ref{go to the cepl/core/internals<dot>lisp file, , @t{core/internals.lisp}} (file)
@end table
@end deffn
@deffn {Function} {window-size} WIN
@anchor{go to the CEPL<dot>HOST<colon><colon>WINDOW-SIZE function}@c
@functionsubindex{window-size}@c
When given the host-specific window handle will return the size of the window
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Function} {wrap} SAMPLER
@anchor{go to the %CEPL<dot>TYPES<colon><colon>WRAP function}@c
@functionsubindex{wrap}@c

This function sets the wrap parameter of the `texture` or `sampler` given.@*

When setf'ing this parameter you can provide either one approach to be used
for all 3 potential dimensions of the texture, or you can provide a vector
of the 3 approaches you want to used.@*


**-- Wrapping --**@*

When using normalized texture coordinates we are used to thinking about our
coordinate being between 0s0 and 1s0 and that value dictating where we are
sampling from.@*

However normalized texture coordinates are not limited to values between@*
0s0 and 1s0. They can be any floating-point number.@*

When a texture coordinate is not within the 0  1 range, some means must be
employed to decide what the color value will be.@*

The different approaches are as follows:@*

    :repeat: the texture coordinate wraps around the texture. so a texture
             coordinate of -0.2 becomes the equivalent of 0.8.@*

    :mirrored-repeat: the texture coordinate wraps around like a mirror.
                      -0.2 becomes 0.2, -1.2 becomes 0.8, etc.@*

    :clamp-to-edge: the texture coordinate is clamped to the 0  1 range.@*

    :clamp-to-border: the texture coordinate is clamped to the 0  1@*
                      range, but the edge texels are blended with a@*
                      constant border color.@*

    :mirror-clamp-to-edge: (only available with OpenGL 4.4 or
                           :arb-texture-mirror-clamp-to-edge) the texture@*
                           is clamped to the -1  1 range, but mirrors the
                           negative direction with the positive. Basically,
                           it acts as :clamp-to-edge, except that it@*
                           takes the absolute value of the texture
                           coordinates before clamping.@*

This also applies to Rectangle Textures, except that the range at which they
apply edge sampling is based on the texel width/height of the texture, not
the normalized 0  1 range.@*

This does not apply to Buffer Textures, as they must use the texelFetch sampling
functions and thus cannot sample outside of the texel range of the texture.@*

example:@*

    (setf (wrap texture-or-sampler)@*
          #(:clamp-to-edge :repeat-to-edge :clamp-to-edge))@*

    (setf (wrap texture-or-sampler) :clamp-to-edge)@*


@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF WRAP) function, , @t{(setf wrap)}} (function)
@end table
@end deffn
@deffn {Function} {(setf wrap)} VALUE SAMPLER
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF WRAP) function}@c
@functionsubindex{(setf wrap)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>WRAP function, , @t{wrap}} (function)
@end table
@end deffn
@deffn {Function} {zero} INCOMING-VAL STORED-VAL
@anchor{go to the CEPL<dot>DOCUMENTATION-FUNCTIONS<colon><colon>ZERO function}@c
@functionsubindex{zero}@c
Always returns 0
@table @strong
@item Package
@ref{go to the CEPL<dot>DOCUMENTATION-FUNCTIONS package, , @t{cepl.documentation-functions}}
@item Source
@ref{go to the cepl/core/context/documentation-functions<dot>lisp file, , @t{core/context/documentation-functions.lisp}} (file)
@end table
@end deffn
" :AFTER-MENU-CONTENTS NIL) :PREVIOUS #8# :UP #2# :CHILDREN NIL :BEFORE-MENU-CONTENTS "@deffn {Compiler Macro} {aref-c} C-ARRAY &rest SUBSCRIPTS
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>AREF-C compiler macro}@c
@compilermacrosubindex{aref-c}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/aref-c<dot>lisp file, , @t{core/c-arrays/aref-c.lisp}} (file)
@end table
@end deffn
@deffn {Compiler Macro} {assocr} ITEM ALIST &key KEY TEST TEST-NOT
@anchor{go to the CEPL-UTILS<colon><colon>ASSOCR compiler macro}@c
@compilermacrosubindex{assocr}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Compiler Macro} {cepl-context} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>CEPL-CONTEXT compiler macro}@c
@compilermacrosubindex{cepl-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Compiler Macro} {clear} &optional TARGET
@anchor{go to the CEPL<dot>FBOS<colon><colon>CLEAR compiler macro}@c
@compilermacrosubindex{clear}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Compiler Macro} {color-mask} INDEX &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>COLOR-MASK compiler macro}@c
@compilermacrosubindex{color-mask}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/color/color<dot>lisp file, , @t{core/color/color.lisp}} (file)
@end table
@end deffn
@deffn {Compiler Macro} {color-masks} &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>COLOR-MASKS compiler macro}@c
@compilermacrosubindex{color-masks}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/color/color<dot>lisp file, , @t{core/color/color.lisp}} (file)
@end table
@end deffn
@deffn {Compiler Macro} {cull-face} &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>CULL-FACE compiler macro}@c
@compilermacrosubindex{cull-face}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/face/face<dot>lisp file, , @t{core/face/face.lisp}} (file)
@end table
@end deffn
@deffn {Compiler Macro} {current-stencil-params} FACE &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>STENCIL<colon><colon>CURRENT-STENCIL-PARAMS compiler macro}@c
@compilermacrosubindex{current-stencil-params}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>STENCIL package, , @t{cepl.stencil}}
@item Source
@ref{go to the cepl/core/stencil/stencil<dot>lisp file, , @t{core/stencil/stencil.lisp}} (file)
@end table
@end deffn
@deffn {Compiler Macro} {depth-clamp} &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>DEPTH-CLAMP compiler macro}@c
@compilermacrosubindex{depth-clamp}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/depth/depth<dot>lisp file, , @t{core/depth/depth.lisp}} (file)
@end table
@end deffn
@deffn {Compiler Macro} {depth-mask} &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>DEPTH-MASK compiler macro}@c
@compilermacrosubindex{depth-mask}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/depth/depth<dot>lisp file, , @t{core/depth/depth.lisp}} (file)
@end table
@end deffn
@deffn {Compiler Macro} {depth-range-vec2} &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>DEPTH-RANGE-VEC2 compiler macro}@c
@compilermacrosubindex{depth-range-vec2}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/depth/depth<dot>lisp file, , @t{core/depth/depth.lisp}} (file)
@end table
@end deffn
@deffn {Compiler Macro} {depth-test-function} &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>DEPTH-TEST-FUNCTION compiler macro}@c
@compilermacrosubindex{depth-test-function}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/depth/depth<dot>lisp file, , @t{core/depth/depth.lisp}} (file)
@end table
@end deffn
@deffn {Compiler Macro} {ensure-vec-index} VEC INDEX NULL-ELEMENT &optional ELEMENT-TYPE
@anchor{go to the CEPL-UTILS<colon><colon>ENSURE-VEC-INDEX compiler macro}@c
@compilermacrosubindex{ensure-vec-index}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Compiler Macro} {front-face} &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>FRONT-FACE compiler macro}@c
@compilermacrosubindex{front-face}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/face/face<dot>lisp file, , @t{core/face/face.lisp}} (file)
@end table
@end deffn
@deffn {Compiler Macro} {gpu-buffer-bound} CTX TARGET
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>GPU-BUFFER-BOUND compiler macro}@c
@compilermacrosubindex{gpu-buffer-bound}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Compiler Macro} {pack-alignment} &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>PACK-ALIGNMENT compiler macro}@c
@compilermacrosubindex{pack-alignment}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/pixel-store/pixel-store<dot>lisp file, , @t{core/pixel-store/pixel-store.lisp}} (file)
@end table
@end deffn
@deffn {Compiler Macro} {per-attachment-blending-available-p} &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>FBOS<colon><colon>PER-ATTACHMENT-BLENDING-AVAILABLE-P compiler macro}@c
@compilermacrosubindex{per-attachment-blending-available-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@end table
@end deffn
@deffn {Compiler Macro} {ptr-index} C-ARRAY &optional X Y Z W
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>PTR-INDEX compiler macro}@c
@compilermacrosubindex{ptr-index}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/aref-c<dot>lisp file, , @t{core/c-arrays/aref-c.lisp}} (file)
@end table
@end deffn
@deffn {Compiler Macro} {scissor-viewport} &optional INDEX CEPL-CONTEXT
@anchor{go to the CEPL<dot>SCISSOR<colon><colon>SCISSOR-VIEWPORT compiler macro}@c
@compilermacrosubindex{scissor-viewport}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SCISSOR package, , @t{cepl.scissor}}
@item Source
@ref{go to the cepl/core/scissor/scissor<dot>lisp file, , @t{core/scissor/scissor.lisp}} (file)
@end table
@end deffn
@deffn {Compiler Macro} {stencil-mask} FACE &optional CEPL-CONTEXT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>STENCIL-MASK compiler macro}@c
@compilermacrosubindex{stencil-mask}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/stencil/mask<dot>lisp file, , @t{core/stencil/mask.lisp}} (file)
@end table
@end deffn
@deffn {Compiler Macro} {unpack-alignment} &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>UNPACK-ALIGNMENT compiler macro}@c
@compilermacrosubindex{unpack-alignment}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/pixel-store/pixel-store<dot>lisp file, , @t{core/pixel-store/pixel-store.lisp}} (file)
@end table
@end deffn
" :AFTER-MENU-CONTENTS NIL) #10# #11# #12=#S(NET.DIDIERVERNA.DECLT::NODE :NAME "Exported conditions" :SYNOPSIS NIL :SECTION-TYPE :NUMBERED :SECTION-NAME "Conditions" :NEXT #13=#S(NET.DIDIERVERNA.DECLT::NODE :NAME "Exported structures" :SYNOPSIS NIL :SECTION-TYPE :NUMBERED :SECTION-NAME "Structures" :NEXT #14=# :PREVIOUS #12# :UP #2# :CHILDREN NIL :BEFORE-MENU-CONTENTS "@deftp {Structure} {any-samples-passed-conservative-query} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>ANY-SAMPLES-PASSED-CONSERVATIVE-QUERY structure}@c
@structuresubindex{any-samples-passed-conservative-query}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@ref{go to the %CEPL<dot>TYPES<colon><colon>SCOPED-GPU-QUERY structure, , @t{scoped-gpu-query}} (structure)
@item Direct slots
@defvr {Slot} enum
@slotsubindex{enum}@c
@table @strong
@item Type
@t{(and (signed-byte 32) (signed-byte 32))}
@item Initform
@t{36202}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>ANY-SAMPLES-PASSED-CONSERVATIVE-QUERY-ENUM function, , @t{any-samples-passed-conservative-query-enum}} (function)
@item Writers
@t{(setf any-samples-passed-conservative-query-enum)} (function)
@end table
@end defvr
@defvr {Slot} cache-id
@slotsubindex{cache-id}@c
@table @strong
@item Type
@t{(and (integer 0 7) (integer 0 7))}
@item Initform
@t{3}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>ANY-SAMPLES-PASSED-CONSERVATIVE-QUERY-CACHE-ID function, , @t{any-samples-passed-conservative-query-cache-id}} (function)
@item Writers
@t{(setf any-samples-passed-conservative-query-cache-id)} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {any-samples-passed-query} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>ANY-SAMPLES-PASSED-QUERY structure}@c
@structuresubindex{any-samples-passed-query}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@ref{go to the %CEPL<dot>TYPES<colon><colon>SCOPED-GPU-QUERY structure, , @t{scoped-gpu-query}} (structure)
@item Direct slots
@defvr {Slot} enum
@slotsubindex{enum}@c
@table @strong
@item Type
@t{(and (signed-byte 32) (signed-byte 32))}
@item Initform
@t{35887}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>ANY-SAMPLES-PASSED-QUERY-ENUM function, , @t{any-samples-passed-query-enum}} (function)
@item Writers
@t{(setf any-samples-passed-query-enum)} (function)
@end table
@end defvr
@defvr {Slot} cache-id
@slotsubindex{cache-id}@c
@table @strong
@item Type
@t{(and (integer 0 7) (integer 0 7))}
@item Initform
@t{2}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>ANY-SAMPLES-PASSED-QUERY-CACHE-ID function, , @t{any-samples-passed-query-cache-id}} (function)
@item Writers
@t{(setf any-samples-passed-query-cache-id)} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {arrays-indirect-command} ()
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ARRAYS-INDIRECT-COMMAND structure}@c
@structuresubindex{arrays-indirect-command}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/multi-draw<dot>lisp file, , @t{core/pipelines/multi-draw.lisp}} (file)
@item Direct superclasses
@ref{go to the CEPL<dot>TYPES<colon><colon>BASE-GSTRUCT-WRAPPER structure, , @t{base-gstruct-wrapper}} (structure)
@item Direct methods
@itemize @bullet
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PUSH-G COMMON-LISP<colon><colon>LIST CEPL<dot>PIPELINES<colon><colon>ARRAYS-INDIRECT-COMMAND method, , @t{push-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PULL1-G CEPL<dot>PIPELINES<colon><colon>ARRAYS-INDIRECT-COMMAND method, , @t{pull1-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PULL-G CEPL<dot>PIPELINES<colon><colon>ARRAYS-INDIRECT-COMMAND method, , @t{pull-g}} (method)
@item
@ref{go to the CEPL<dot>INTERNALS<colon><colon>POPULATE CEPL<dot>PIPELINES<colon><colon>ARRAYS-INDIRECT-COMMAND COMMON-LISP<colon><colon>T method, , @t{populate}} (method)
@item
@t{print-object} (method)
@end itemize
@end table
@end deftp
@deftp {Structure} {att} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>ATT structure}@c
@structuresubindex{att}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@t{structure-object} (structure)
@item Direct slots
@defvr {Slot} array
@slotsubindex{array}@c
@table @strong
@item Type
@t{(or null %cepl.types:gpu-array-t %cepl.types:render-buffer)}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>ATT-ARRAY function, , @t{att-array}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF ATT-ARRAY) function, , @t{(setf att-array)}} (function)
@end table
@end defvr
@defvr {Slot} blend
@slotsubindex{blend}@c
@table @strong
@item Type
@t{boolean}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>ATT-BLEND function, , @t{att-blend}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF ATT-BLEND) function, , @t{(setf att-blend)}} (function)
@end table
@end defvr
@defvr {Slot} bparams
@slotsubindex{bparams}@c
@table @strong
@item Type
@t{(or null %cepl.types:blending-params)}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>ATT-BPARAMS function, , @t{att-bparams}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF ATT-BPARAMS) function, , @t{(setf att-bparams)}} (function)
@end table
@end defvr
@defvr {Slot} owned-p
@slotsubindex{owned-p}@c
@table @strong
@item Type
@t{boolean}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>ATT-OWNED-P function, , @t{att-owned-p}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF ATT-OWNED-P) function, , @t{(setf att-owned-p)}} (function)
@end table
@end defvr
@defvr {Slot} viewport
@slotsubindex{viewport}@c
@table @strong
@item Type
@t{(or null %cepl.types:viewport)}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>ATT-VIEWPORT function, , @t{att-viewport}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF ATT-VIEWPORT) function, , @t{(setf att-viewport)}} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {blending-params} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BLENDING-PARAMS structure}@c
@structuresubindex{blending-params}@c

Blending Parameters dictate how a color is written into an `FBO`'s attachment if
there is already a color there.@*

Blending Parameters (or `blending-params`) can be applied in CEPL in 3 places:@*

- On an FBO:@*
  This sets the rules for all attachments in the FBO@*

- On an FBO Attachment:@*
  This overrides the rules set on the FBO but only for the one attachment.@*
  This is only supported on some versions of OpenGL.@*

- On a blending-params object:@*
  This object can then be applied using with-blending@*
  (see with-blending's docstring for more info)@*


The interaction between the options in the blending-params is fairly complex@*
so whilst we seek to give an introduction here, some cases will be best covered@*
in other documentation.@*


**-- The Parameters --**@*

There are 3 pairs of parameters that work together to tell GL how to compute@*
the final color.@*

In all cases below 'source' means the color coming from the pipeline that needs@*
to be written into the FBO, and 'destination' means the color already in the FBO@*

Conceptually what is happening is that `source-rgb`, `source-alpha`, `destination-rgb`
and `destination-alpha` all name functions that will be called on their respective
values. This will result in new source-rgb, source-alpha, destinations-rgb and
destination-alpha values.@*

Those new values are then given to the `mode-rgb` and `mode-alpha` functions which
compute the final color.@*

So in pseudo-code it would look this this:@*

    (defun compute-final-color (blend-params src-rgb src-alpha@*
                                dest-rgb dest-alpha)@*
      (let ((new-src-rgb@*
             (funcall (blend-params-source-rgb blend-params)
                      src-rgb@*
                      dest-rgb))@*
            (new-dest-rgb@*
             (funcall (blend-params-destination-rgb blend-params)
                      src-rgb@*
                      dest-rgb))@*
            (new-src-alpha@*
             (funcall (blend-params-source-alpha blend-params)
                      src-alpha@*
                      dest-alpha))@*
            (new-dest-alpha@*
             (funcall (blend-params-destination-alpha blend-params)
                      src-alpha@*
                      dest-alpha)))@*
        ;; compute final colors@*
        (values (funcall (blend-params-mode-rgb blend-params)
                         new-src-rgb@*
                         new-dest-rgb)@*
                (funcall (blend-params-mode-alpha blend-params)
                         new-src-alpha@*
                         new-dest-alpha))))@*


**-- :source-rgb, :source-alpha, :destination-rgb & :destination-alpha --**@*

This is the list of operations and what they do to the *-rgb or *alpha values
given.@*

    Parameter                 | RGB Factor                      | Alpha Factor
    --------------------------------------------------------------------------
    :zero                     | (v! 0 0 0)                      | 0@*
    :one                      | (v! 1 1 1)                      | 1@*
    :src-color                | (v! rs0 gs0 bs0)                | as0
    :one-minus-src-color      | (- (v! 1 1 1) (v! rs0 gs0 bs0)) | 1 - as0
    :dst-color                | (v! rd gd bd)                   | ad
    :one-minus-dst-color      | (- (v! 1 1 1) (v! rd gd bd))    | 1 - ad
    :src-alpha                | (v! as0 as0 as0)                | as0
    :one-minus-src-alpha      | (- (v! 1 1 1) (v! as0 as0 as0)) | 1 - as0
    :dst-alpha                | (v! ad ad ad)                   | ad
    :one-minus-dst-alpha      | (- (v! 1 1 1) (v! ad ad ad))    | ad
    :constant-color           | (v! rc gc bc)                   | ac
    :one-minus-constant-color | (- (v! 1 1 1) (v! rc gc bc))    | 1 - ac
    :constant-alpha           | (v! ac ac ac)                   | ac
    :one-minus-constant-alpha | (- (v! 1 1 1) (v! ac ac ac))    | 1 - ac
    :src-alpha-saturate       | (v! i i i)                      | 1@*
    :src1-color               | (v! rs1 gs1 bs1)                | as1
    :one-minus-src1-color     | (- (v! 1 1 1) (v! rs1 gs1 bs1)) | 1 - as1
    :src1-alpha               | (v! as1 as1 as1)                | as1
    :one-minus-src1-alpha     | (- (v! 1 1 1) (v! as1 as1 as1)) | 1 - as1@*


**-- :mode-rgb & :mode-alpha --**@*

As mentioned above, to compute the final color two equations are used:@*
one for the RGB portion of the color, and one for the alpha of the color.@*
This is useful if you want treat rgb and alpha differently when producing the@*
end result.@*

The equations available are:@*

:func-add - The source and destination colors are added to each other.@*
            O = sS + dD. The s and d are blending parameters that are@*
            multiplied into each of S and D before the addition.@*

:func-subtract - Subtracts the destination from the source. O = sS - dD.@*
                 The source and dest are again multiplied by blending
                 parameters.@*

:func-reverse-subtract - Subtracts the source from the destination.@*
                         O = sD - dS. The source and dest are multiplied by
                         blending parameters.@*

:min - The output color is the component-wise minimum value of the source@*
       and dest colors. So performing :min in the RGB equation means that@*
       Or = min(Sr, Dr), Og = min(Sg, Dg), and so forth.@*
       The parameters s and d are ignored for this equation.@*

:max - The output color is the component-wise maximum value of the source and@*
       dest colors. The parameters s and d are ignored for this equation.@*


**-- Precision --**@*

Despite the apparent precision of the above equations, blending arithmetic is@*
not exactly specified, because blending operates with imprecise integer color
values.@*
However, a blend factor that should be equal to 1 is guaranteed not to modify@*
its multiplicand, and a blend factor equal to 0 reduces its multiplicand to 0.@*

For example, when:@*

- srcRGB is GL_SRC_ALPHA@*
- dstRGB is GL_ONE_MINUS_SRC_ALPHA,@*
- As0 is equal to 1@*

the equations reduce to simple replacement:@*

> todo
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@t{structure-object} (structure)
@item Direct slots
@defvr {Slot} mode-rgb
@slotsubindex{mode-rgb}@c
@table @strong
@item Type
@t{keyword}
@item Initform
@t{:func-add}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>BLENDING-PARAMS-MODE-RGB function, , @t{blending-params-mode-rgb}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF BLENDING-PARAMS-MODE-RGB) function, , @t{(setf blending-params-mode-rgb)}} (function)
@end table
@end defvr
@defvr {Slot} mode-alpha
@slotsubindex{mode-alpha}@c
@table @strong
@item Type
@t{keyword}
@item Initform
@t{:func-add}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>BLENDING-PARAMS-MODE-ALPHA function, , @t{blending-params-mode-alpha}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF BLENDING-PARAMS-MODE-ALPHA) function, , @t{(setf blending-params-mode-alpha)}} (function)
@end table
@end defvr
@defvr {Slot} source-rgb
@slotsubindex{source-rgb}@c
@table @strong
@item Type
@t{keyword}
@item Initform
@t{:src-alpha}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>BLENDING-PARAMS-SOURCE-RGB function, , @t{blending-params-source-rgb}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF BLENDING-PARAMS-SOURCE-RGB) function, , @t{(setf blending-params-source-rgb)}} (function)
@end table
@end defvr
@defvr {Slot} source-alpha
@slotsubindex{source-alpha}@c
@table @strong
@item Type
@t{keyword}
@item Initform
@t{:src-alpha}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>BLENDING-PARAMS-SOURCE-ALPHA function, , @t{blending-params-source-alpha}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF BLENDING-PARAMS-SOURCE-ALPHA) function, , @t{(setf blending-params-source-alpha)}} (function)
@end table
@end defvr
@defvr {Slot} destination-rgb
@slotsubindex{destination-rgb}@c
@table @strong
@item Type
@t{keyword}
@item Initform
@t{:one-minus-src-alpha}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>BLENDING-PARAMS-DESTINATION-RGB function, , @t{blending-params-destination-rgb}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF BLENDING-PARAMS-DESTINATION-RGB) function, , @t{(setf blending-params-destination-rgb)}} (function)
@end table
@end defvr
@defvr {Slot} destination-alpha
@slotsubindex{destination-alpha}@c
@table @strong
@item Type
@t{keyword}
@item Initform
@t{:one-minus-src-alpha}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>BLENDING-PARAMS-DESTINATION-ALPHA function, , @t{blending-params-destination-alpha}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF BLENDING-PARAMS-DESTINATION-ALPHA) function, , @t{(setf blending-params-destination-alpha)}} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {buffer-stream} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM structure}@c
@structuresubindex{buffer-stream}@c

A buffer-stream is a structure that represents stream of gpu-data composed from
gpu-array and/or gpu-buffers.@*

To render in CEPL we map a buffer-stream over a gpu-pipeline. The buffer-stream
contains data (usually geometry) that is passed to the vertex-shader.@*

A buffer-stream composes various sources of gpu-data together. So if, for example,
the vertex shader took 3 arguments of types :vec2 :vec3 :float. Then you could
make a stream that composes 3 gpu-arrays with element-types :vec2 :vec3 :float
and map this over the pipeline.@*

Naturally, as we are talking about buffer-stream, only buffer-backed gpu-arrays
can be composed with buffer-streams.@*

Info for people used to OpenGL:@*
A buffer-stream is basically a VAO with some extra metadata such as the 'range'
of data to draw the 'style' of drawing & the 'primitive' the data represents .
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@t{structure-object} (structure)
@item Direct methods
@itemize @bullet
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>FREE %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM method, , @t{free}} (method)
@item
@t{print-object} (method)
@item
@ref{go to the %CEPL<dot>TYPES<colon><colon>CAN-BE-SHARED-BETWEEN-CONTEXTS-P %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM method, , @t{can-be-shared-between-contexts-p}} (method)
@end itemize
@item Direct slots
@defvr {Slot} vao
@slotsubindex{vao}@c
@table @strong
@item Type
@t{%cepl.types:gl-id}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-VAO function, , @t{buffer-stream-vao}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-VAO) function, , @t{(setf buffer-stream-vao)}} (function)
@end table
@end defvr
@defvr {Slot} %start
@slotsubindex{%start}@c
@table @strong
@item Type
@t{(unsigned-byte 64)}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-%START function, , @t{buffer-stream-%start}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-%START) function, , @t{(setf buffer-stream-%start)}} (function)
@end table
@end defvr
@defvr {Slot} %start-byte
@slotsubindex{%start-byte}@c
@table @strong
@item Type
@t{(unsigned-byte 64)}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-%START-BYTE function, , @t{buffer-stream-%start-byte}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-%START-BYTE) function, , @t{(setf buffer-stream-%start-byte)}} (function)
@end table
@end defvr
@defvr {Slot} base-vertex
@slotsubindex{base-vertex}@c
@table @strong
@item Type
@t{(unsigned-byte 32)}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-BASE-VERTEX function, , @t{buffer-stream-base-vertex}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-BASE-VERTEX) function, , @t{(setf buffer-stream-base-vertex)}} (function)
@end table
@end defvr
@defvr {Slot} length
@slotsubindex{length}@c
@table @strong
@item Type
@t{unsigned-byte}
@item Initform
@t{1}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-LENGTH function, , @t{buffer-stream-length}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-LENGTH) function, , @t{(setf buffer-stream-length)}} (function)
@end table
@end defvr
@defvr {Slot} %index-type-enum
@slotsubindex{%index-type-enum}@c
@table @strong
@item Type
@t{%cepl.types:gl-enum-value}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-%INDEX-TYPE-ENUM function, , @t{buffer-stream-%index-type-enum}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-%INDEX-TYPE-ENUM) function, , @t{(setf buffer-stream-%index-type-enum)}} (function)
@end table
@end defvr
@defvr {Slot} %index-type-size
@slotsubindex{%index-type-size}@c
@table @strong
@item Type
@t{(unsigned-byte 8)}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-%INDEX-TYPE-SIZE function, , @t{buffer-stream-%index-type-size}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-%INDEX-TYPE-SIZE) function, , @t{(setf buffer-stream-%index-type-size)}} (function)
@end table
@end defvr
@defvr {Slot} gpu-arrays
@slotsubindex{gpu-arrays}@c
@table @strong
@item Type
@t{list}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-GPU-ARRAYS function, , @t{buffer-stream-gpu-arrays}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-GPU-ARRAYS) function, , @t{(setf buffer-stream-gpu-arrays)}} (function)
@end table
@end defvr
@defvr {Slot} %primitive
@slotsubindex{%primitive}@c
@table @strong
@item Type
@t{symbol}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-%PRIMITIVE function, , @t{buffer-stream-%primitive}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-%PRIMITIVE) function, , @t{(setf buffer-stream-%primitive)}} (function)
@end table
@end defvr
@defvr {Slot} primitive-group-id
@slotsubindex{primitive-group-id}@c
@table @strong
@item Type
@t{(unsigned-byte 8)}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-PRIMITIVE-GROUP-ID function, , @t{buffer-stream-primitive-group-id}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-PRIMITIVE-GROUP-ID) function, , @t{(setf buffer-stream-primitive-group-id)}} (function)
@end table
@end defvr
@defvr {Slot} draw-mode-val
@slotsubindex{draw-mode-val}@c
@table @strong
@item Type
@t{(unsigned-byte 32)}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-DRAW-MODE-VAL function, , @t{buffer-stream-draw-mode-val}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-DRAW-MODE-VAL) function, , @t{(setf buffer-stream-draw-mode-val)}} (function)
@end table
@end defvr
@defvr {Slot} patch-length
@slotsubindex{patch-length}@c
@table @strong
@item Type
@t{(unsigned-byte 8)}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-PATCH-LENGTH function, , @t{buffer-stream-patch-length}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-PATCH-LENGTH) function, , @t{(setf buffer-stream-patch-length)}} (function)
@end table
@end defvr
@defvr {Slot} managed
@slotsubindex{managed}@c
@table @strong
@item Type
@t{boolean}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-MANAGED function, , @t{buffer-stream-managed}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-MANAGED) function, , @t{(setf buffer-stream-managed)}} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {buffer-texture} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-TEXTURE structure}@c
@structuresubindex{buffer-texture}@c

`Buffer-texture`s are a special kind of `texture` where the data resides, not in
texture memory, but in buffer memory.@*

This means that when you call texref on this texture you will recieve a
buffer-backed texture instead of the usual texture-backed ones.@*

buffer-textures are created by calling `make-texture` with the :buffer key
argument set to t.@*

Buffer textures have limitations over regular textures:@*

- cannot be mipmapped@*
- can only only have one `gpu-array`@*
- that gpu-array must be one dimensional@*
- can only be accessed in shaders with #'texel-fetch@*
- can have a more limited number of valid element-types[0] to choose from
  see *valid-image-formats-for-buffer-backed-texture* for details@*

[0] OpenGL calls the element-types of textures 'image-formats' or sometimes
    'internal-formats'. Even though the name implies they are only useful
    for image data we keep the name as the subject of image-formats is
    complicated enough without us adding more things to think about
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@t{texture} (structure)
@item Direct methods
@itemize @bullet
@item
@ref{go to the CEPL<dot>TEXTURES<colon><colon>FREE-TEXTURE %CEPL<dot>TYPES<colon><colon>BUFFER-TEXTURE method, , @t{free-texture}} (method)
@item
@t{print-object} (method)
@end itemize
@item Direct slots
@defvr {Slot} backing-array
@slotsubindex{backing-array}@c
@table @strong
@item Type
@t{%cepl.types:gpu-array-bb}
@item Initform
@t{(error \"\")}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-TEXTURE-BACKING-ARRAY function, , @t{buffer-texture-backing-array}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-TEXTURE-BACKING-ARRAY) function, , @t{(setf buffer-texture-backing-array)}} (function)
@end table
@end defvr
@defvr {Slot} owns-array
@slotsubindex{owns-array}@c
@table @strong
@item Type
@t{boolean}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-TEXTURE-OWNS-ARRAY function, , @t{buffer-texture-owns-array}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-TEXTURE-OWNS-ARRAY) function, , @t{(setf buffer-texture-owns-array)}} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {c-array} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY structure}@c
@structuresubindex{c-array}@c

`C-ARRAY` is a structure that represents an array in foreign memory.

CEPL keeps not only the pointer to the foreign data in this structure
but also metadata that makes moving this data to (and from) the gpu or
lisp much easier.
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@t{structure-object} (structure)
@item Direct methods
@itemize @bullet
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G %CEPL<dot>TYPES<colon><colon>C-ARRAY %CEPL<dot>TYPES<colon><colon>SSBO method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PUSH-G %CEPL<dot>TYPES<colon><colon>C-ARRAY %CEPL<dot>TYPES<colon><colon>SSBO method, , @t{push-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G %CEPL<dot>TYPES<colon><colon>C-ARRAY %CEPL<dot>TYPES<colon><colon>UBO method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PUSH-G %CEPL<dot>TYPES<colon><colon>C-ARRAY %CEPL<dot>TYPES<colon><colon>UBO method, , @t{push-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G %CEPL<dot>TYPES<colon><colon>C-ARRAY %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PUSH-G %CEPL<dot>TYPES<colon><colon>C-ARRAY %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB method, , @t{push-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T %CEPL<dot>TYPES<colon><colon>C-ARRAY method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G %CEPL<dot>TYPES<colon><colon>C-ARRAY %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PUSH-G %CEPL<dot>TYPES<colon><colon>C-ARRAY %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T method, , @t{push-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PUSH-G %CEPL<dot>TYPES<colon><colon>C-ARRAY GLSL-SYMBOLS<dot>FUNCTIONS<colon><colon>TEXTURE method, , @t{push-g}} (method)
@item
@ref{go to the CEPL<dot>TEXTURES<colon><colon>PIXEL-FORMAT-FROM-ARRAY %CEPL<dot>TYPES<colon><colon>C-ARRAY method, , @t{pixel-format-from-array}} (method)
@item
@ref{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED<colon><colon>MAKE-GPU-ARRAY %CEPL<dot>TYPES<colon><colon>C-ARRAY method, , @t{make-gpu-array}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G %CEPL<dot>TYPES<colon><colon>C-ARRAY (eql KEYWORD<colon><colon>LISP) method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G COMMON-LISP<colon><colon>ARRAY %CEPL<dot>TYPES<colon><colon>C-ARRAY method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G COMMON-LISP<colon><colon>LIST %CEPL<dot>TYPES<colon><colon>C-ARRAY method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PUSH-G COMMON-LISP<colon><colon>T %CEPL<dot>TYPES<colon><colon>C-ARRAY method, , @t{push-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PULL-G %CEPL<dot>TYPES<colon><colon>C-ARRAY method, , @t{pull-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PULL1-G %CEPL<dot>TYPES<colon><colon>C-ARRAY method, , @t{pull1-g}} (method)
@item
@ref{go to the CEPL-UTILS<colon><colon>PRINT-MEM %CEPL<dot>TYPES<colon><colon>C-ARRAY method, , @t{print-mem}} (method)
@item
@t{print-object} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>FREE %CEPL<dot>TYPES<colon><colon>C-ARRAY method, , @t{free}} (method)
@item
@ref{go to the CEPL<dot>TYPES<colon><colon>ELEMENT-BYTE-SIZE %CEPL<dot>TYPES<colon><colon>C-ARRAY method, , @t{element-byte-size}} (method)
@item
@ref{go to the CEPL<dot>TYPES<colon><colon>ELEMENT-TYPE %CEPL<dot>TYPES<colon><colon>C-ARRAY method, , @t{element-type}} (method)
@item
@ref{go to the CEPL<dot>MEASUREMENTS<colon><colon>DIMENSIONS %CEPL<dot>TYPES<colon><colon>C-ARRAY method, , @t{dimensions}} (method)
@item
@ref{go to the CEPL<dot>C-ARRAYS<colon><colon>POINTER %CEPL<dot>TYPES<colon><colon>C-ARRAY method, , @t{pointer}} (method)
@end itemize
@item Direct slots
@defvr {Slot} pointer
@slotsubindex{pointer}@c
@table @strong
@item Type
@t{cffi-sys:foreign-pointer}
@item Initform
@t{(error \"cepl: c-array must be created with a pointer\")}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY-POINTER function, , @t{c-array-pointer}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF C-ARRAY-POINTER) function, , @t{(setf c-array-pointer)}} (function)
@end table
@end defvr
@defvr {Slot} dimensions
@slotsubindex{dimensions}@c
@table @strong
@item Type
@t{list}
@item Initform
@t{(error \"cepl: c-array must be created with dimensions\")}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY-DIMENSIONS function, , @t{c-array-dimensions}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF C-ARRAY-DIMENSIONS) function, , @t{(setf c-array-dimensions)}} (function)
@end table
@end defvr
@defvr {Slot} total-size
@slotsubindex{total-size}@c
@table @strong
@item Type
@t{%cepl.types:c-array-index}
@item Initform
@t{(error \"cepl: c-array must be created with total-size\")}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY-TOTAL-SIZE function, , @t{c-array-total-size}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF C-ARRAY-TOTAL-SIZE) function, , @t{(setf c-array-total-size)}} (function)
@end table
@end defvr
@defvr {Slot} element-type
@slotsubindex{element-type}@c
@table @strong
@item Type
@t{symbol}
@item Initform
@t{(error \"cepl: c-array must be created with an element-type\")}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY-ELEMENT-TYPE function, , @t{c-array-element-type}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF C-ARRAY-ELEMENT-TYPE) function, , @t{(setf c-array-element-type)}} (function)
@end table
@end defvr
@defvr {Slot} sizes
@slotsubindex{sizes}@c
@table @strong
@item Type
@t{(simple-array %cepl.types:c-array-index (4))}
@item Initform
@t{(error \"cepl (bug): c-array created without internal sizes\")}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY-SIZES function, , @t{c-array-sizes}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF C-ARRAY-SIZES) function, , @t{(setf c-array-sizes)}} (function)
@end table
@end defvr
@defvr {Slot} row-alignment
@slotsubindex{row-alignment}@c
@table @strong
@item Type
@t{(integer 1 8)}
@item Initform
@t{(error \"cepl: c-array must be created with a row-alignment\")}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY-ROW-ALIGNMENT function, , @t{c-array-row-alignment}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF C-ARRAY-ROW-ALIGNMENT) function, , @t{(setf c-array-row-alignment)}} (function)
@end table
@end defvr
@defvr {Slot} struct-element-typep
@slotsubindex{struct-element-typep}@c
@table @strong
@item Type
@t{boolean}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY-STRUCT-ELEMENT-TYPEP function, , @t{c-array-struct-element-typep}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF C-ARRAY-STRUCT-ELEMENT-TYPEP) function, , @t{(setf c-array-struct-element-typep)}} (function)
@end table
@end defvr
@defvr {Slot} element-pixel-format
@slotsubindex{element-pixel-format}@c
@table @strong
@item Type
@t{(or null %cepl.types:pixel-format)}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY-ELEMENT-PIXEL-FORMAT function, , @t{c-array-element-pixel-format}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF C-ARRAY-ELEMENT-PIXEL-FORMAT) function, , @t{(setf c-array-element-pixel-format)}} (function)
@end table
@end defvr
@defvr {Slot} element-from-foreign
@slotsubindex{element-from-foreign}@c
@table @strong
@item Type
@t{(function (cffi-sys:foreign-pointer) t)}
@item Initform
@t{(error \"cepl: c-array must be created with a from-foreign function\")}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY-ELEMENT-FROM-FOREIGN function, , @t{c-array-element-from-foreign}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF C-ARRAY-ELEMENT-FROM-FOREIGN) function, , @t{(setf c-array-element-from-foreign)}} (function)
@end table
@end defvr
@defvr {Slot} element-to-foreign
@slotsubindex{element-to-foreign}@c
@table @strong
@item Type
@t{(function (cffi-sys:foreign-pointer t) t)}
@item Initform
@t{(error \"cepl: c-array must be created with a to-foreign function\")}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY-ELEMENT-TO-FOREIGN function, , @t{c-array-element-to-foreign}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF C-ARRAY-ELEMENT-TO-FOREIGN) function, , @t{(setf c-array-element-to-foreign)}} (function)
@end table
@end defvr
@defvr {Slot} free
@slotsubindex{free}@c
@table @strong
@item Type
@t{function}
@item Initform
@t{(function cffi-sys:foreign-free)}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY-FREE function, , @t{c-array-free}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF C-ARRAY-FREE) function, , @t{(setf c-array-free)}} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {cepl-context} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>CEPL-CONTEXT structure}@c
@structuresubindex{cepl-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@item Direct superclasses
@t{structure-object} (structure)
@item Direct methods
@itemize @bullet
@item
@ref{go to the CEPL<dot>CONTEXT<colon><colon>VERSION-FLOAT CEPL<dot>CONTEXT<colon><colon>CEPL-CONTEXT method, , @t{version-float}} (method)
@item
@t{print-object} (method)
@end itemize
@item Direct slots
@defvr {Slot} id
@slotsubindex{id}@c
@table @strong
@item Type
@t{cepl.context:context-id}
@item Initform
@t{(error \"context missing an id\")}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-ID function, , @t{%cepl-context-id}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-ID) function, , @t{(setf %cepl-context-id)}} (function)
@end table
@end defvr
@defvr {Slot} gl-context
@slotsubindex{gl-context}@c
@table @strong
@item Type
@t{(or null cepl.context:gl-context)}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-GL-CONTEXT function, , @t{%cepl-context-gl-context}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-GL-CONTEXT) function, , @t{(setf %cepl-context-gl-context)}} (function)
@end table
@end defvr
@defvr {Slot} requested-gl-version
@slotsubindex{requested-gl-version}@c
@table @strong
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-REQUESTED-GL-VERSION function, , @t{%cepl-context-requested-gl-version}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-REQUESTED-GL-VERSION) function, , @t{(setf %cepl-context-requested-gl-version)}} (function)
@end table
@end defvr
@defvr {Slot} gl-version-float
@slotsubindex{gl-version-float}@c
@table @strong
@item Type
@t{single-float}
@item Initform
@t{0.0}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-GL-VERSION-FLOAT function, , @t{%cepl-context-gl-version-float}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-GL-VERSION-FLOAT) function, , @t{(setf %cepl-context-gl-version-float)}} (function)
@end table
@end defvr
@defvr {Slot} bound-thread
@slotsubindex{bound-thread}@c
@table @strong
@item Type
@t{(or null bordeaux-threads:thread)}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-BOUND-THREAD function, , @t{%cepl-context-bound-thread}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-BOUND-THREAD) function, , @t{(setf %cepl-context-bound-thread)}} (function)
@end table
@end defvr
@defvr {Slot} uninitialized-resources
@slotsubindex{uninitialized-resources}@c
@table @strong
@item Type
@t{list}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-UNINITIALIZED-RESOURCES function, , @t{%cepl-context-uninitialized-resources}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-UNINITIALIZED-RESOURCES) function, , @t{(setf %cepl-context-uninitialized-resources)}} (function)
@end table
@end defvr
@defvr {Slot} shared
@slotsubindex{shared}@c
@table @strong
@item Type
@t{(array cepl.context:cepl-context (*))}
@item Initform
@t{(error \"context must be initialized via #'make-context\")}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-SHARED function, , @t{%cepl-context-shared}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-SHARED) function, , @t{(setf %cepl-context-shared)}} (function)
@end table
@end defvr
@defvr {Slot} surfaces
@slotsubindex{surfaces}@c
@table @strong
@item Type
@t{list}
@item Initform
@t{(error \"context must be initialized via #'make-context\")}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-SURFACES function, , @t{%cepl-context-surfaces}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-SURFACES) function, , @t{(setf %cepl-context-surfaces)}} (function)
@end table
@end defvr
@defvr {Slot} current-program
@slotsubindex{current-program}@c
@table @strong
@item Type
@t{%cepl.types:gl-id}
@item Initform
@t{%cepl.types:+unknown-gl-id+}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-CURRENT-PROGRAM function, , @t{%cepl-context-current-program}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-CURRENT-PROGRAM) function, , @t{(setf %cepl-context-current-program)}} (function)
@end table
@end defvr
@defvr {Slot} current-tfs
@slotsubindex{current-tfs}@c
@table @strong
@item Type
@t{(or null %cepl.types:transform-feedback-stream)}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-CURRENT-TFS function, , @t{%cepl-context-current-tfs}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-CURRENT-TFS) function, , @t{(setf %cepl-context-current-tfs)}} (function)
@end table
@end defvr
@defvr {Slot} current-surface
@slotsubindex{current-surface}@c
@table @strong
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-CURRENT-SURFACE function, , @t{%cepl-context-current-surface}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-CURRENT-SURFACE) function, , @t{(setf %cepl-context-current-surface)}} (function)
@end table
@end defvr
@defvr {Slot} vao-binding-id
@slotsubindex{vao-binding-id}@c
@table @strong
@item Type
@t{%cepl.types:vao-id}
@item Initform
@t{%cepl.types:+unknown-gl-id+}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-VAO-BINDING-ID function, , @t{%cepl-context-vao-binding-id}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-VAO-BINDING-ID) function, , @t{(setf %cepl-context-vao-binding-id)}} (function)
@end table
@end defvr
@defvr {Slot} current-viewport
@slotsubindex{current-viewport}@c
@table @strong
@item Type
@t{(or null %cepl.types:viewport)}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-CURRENT-VIEWPORT function, , @t{%cepl-context-current-viewport}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-CURRENT-VIEWPORT) function, , @t{(setf %cepl-context-current-viewport)}} (function)
@end table
@end defvr
@defvr {Slot} default-viewport
@slotsubindex{default-viewport}@c
@table @strong
@item Type
@t{(or null %cepl.types:viewport)}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-DEFAULT-VIEWPORT function, , @t{%cepl-context-default-viewport}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-DEFAULT-VIEWPORT) function, , @t{(setf %cepl-context-default-viewport)}} (function)
@end table
@end defvr
@defvr {Slot} current-scissor-viewports
@slotsubindex{current-scissor-viewports}@c
@table @strong
@item Type
@t{(simple-array (or null %cepl.types:viewport) (32))}
@item Initform
@t{(make-array 32 :element-type (quote (or null %cepl.types:viewport)) :initial-element nil)}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-CURRENT-SCISSOR-VIEWPORTS function, , @t{%cepl-context-current-scissor-viewports}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-CURRENT-SCISSOR-VIEWPORTS) function, , @t{(setf %cepl-context-current-scissor-viewports)}} (function)
@end table
@end defvr
@defvr {Slot} default-framebuffer
@slotsubindex{default-framebuffer}@c
@table @strong
@item Type
@t{(or null %cepl.types:fbo)}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-DEFAULT-FRAMEBUFFER function, , @t{%cepl-context-default-framebuffer}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-DEFAULT-FRAMEBUFFER) function, , @t{(setf %cepl-context-default-framebuffer)}} (function)
@end table
@end defvr
@defvr {Slot} read-fbo-binding
@slotsubindex{read-fbo-binding}@c
@table @strong
@item Type
@t{(or null %cepl.types:fbo)}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-READ-FBO-BINDING function, , @t{%cepl-context-read-fbo-binding}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-READ-FBO-BINDING) function, , @t{(setf %cepl-context-read-fbo-binding)}} (function)
@end table
@end defvr
@defvr {Slot} draw-fbo-binding
@slotsubindex{draw-fbo-binding}@c
@table @strong
@item Type
@t{(or null %cepl.types:fbo)}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-DRAW-FBO-BINDING function, , @t{%cepl-context-draw-fbo-binding}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-DRAW-FBO-BINDING) function, , @t{(setf %cepl-context-draw-fbo-binding)}} (function)
@end table
@end defvr
@defvr {Slot} current-stencil-params-front
@slotsubindex{current-stencil-params-front}@c
@table @strong
@item Type
@t{(or null %cepl.types:stencil-params)}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-CURRENT-STENCIL-PARAMS-FRONT function, , @t{%cepl-context-current-stencil-params-front}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-CURRENT-STENCIL-PARAMS-FRONT) function, , @t{(setf %cepl-context-current-stencil-params-front)}} (function)
@end table
@end defvr
@defvr {Slot} current-stencil-params-back
@slotsubindex{current-stencil-params-back}@c
@table @strong
@item Type
@t{(or null %cepl.types:stencil-params)}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-CURRENT-STENCIL-PARAMS-BACK function, , @t{%cepl-context-current-stencil-params-back}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-CURRENT-STENCIL-PARAMS-BACK) function, , @t{(setf %cepl-context-current-stencil-params-back)}} (function)
@end table
@end defvr
@defvr {Slot} current-stencil-mask-front
@slotsubindex{current-stencil-mask-front}@c
@table @strong
@item Type
@t{%cepl.types:stencil-mask}
@item Initform
@t{255}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-CURRENT-STENCIL-MASK-FRONT function, , @t{%cepl-context-current-stencil-mask-front}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-CURRENT-STENCIL-MASK-FRONT) function, , @t{(setf %cepl-context-current-stencil-mask-front)}} (function)
@end table
@end defvr
@defvr {Slot} current-stencil-mask-back
@slotsubindex{current-stencil-mask-back}@c
@table @strong
@item Type
@t{%cepl.types:stencil-mask}
@item Initform
@t{255}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-CURRENT-STENCIL-MASK-BACK function, , @t{%cepl-context-current-stencil-mask-back}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-CURRENT-STENCIL-MASK-BACK) function, , @t{(setf %cepl-context-current-stencil-mask-back)}} (function)
@end table
@end defvr
@defvr {Slot} current-blend-params
@slotsubindex{current-blend-params}@c
@table @strong
@item Type
@t{(or null %cepl.types:blending-params)}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-CURRENT-BLEND-PARAMS function, , @t{%cepl-context-current-blend-params}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-CURRENT-BLEND-PARAMS) function, , @t{(setf %cepl-context-current-blend-params)}} (function)
@end table
@end defvr
@defvr {Slot} fbos
@slotsubindex{fbos}@c
@table @strong
@item Type
@t{(array %cepl.types:fbo (*))}
@item Initform
@t{(make-array 0 :element-type (quote %cepl.types:fbo) :initial-element %cepl.types:+null-fbo+ :adjustable t :fill-pointer 0)}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-FBOS function, , @t{%cepl-context-fbos}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-FBOS) function, , @t{(setf %cepl-context-fbos)}} (function)
@end table
@end defvr
@defvr {Slot} array-of-bound-gpu-buffers
@slotsubindex{array-of-bound-gpu-buffers}@c
@table @strong
@item Type
@t{(simple-array (or %cepl.types:gpu-buffer null) (12))}
@item Initform
@t{(make-array 12 :element-type (quote (or %cepl.types:gpu-buffer null)) :initial-element nil)}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-ARRAY-OF-BOUND-GPU-BUFFERS function, , @t{%cepl-context-array-of-bound-gpu-buffers}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-ARRAY-OF-BOUND-GPU-BUFFERS) function, , @t{(setf %cepl-context-array-of-bound-gpu-buffers)}} (function)
@end table
@end defvr
@defvr {Slot} array-of-gpu-buffers
@slotsubindex{array-of-gpu-buffers}@c
@table @strong
@item Type
@t{(array %cepl.types:gpu-buffer (*))}
@item Initform
@t{(make-array 0 :element-type (quote %cepl.types:gpu-buffer) :initial-element %cepl.types:+null-gpu-buffer+ :adjustable t :fill-pointer 0)}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-ARRAY-OF-GPU-BUFFERS function, , @t{%cepl-context-array-of-gpu-buffers}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-ARRAY-OF-GPU-BUFFERS) function, , @t{(setf %cepl-context-array-of-gpu-buffers)}} (function)
@end table
@end defvr
@defvr {Slot} array-of-ubo-bindings-buffer-ids
@slotsubindex{array-of-ubo-bindings-buffer-ids}@c
@table @strong
@item Type
@t{(array %cepl.types:gl-id (*))}
@item Initform
@t{(make-array 0 :element-type (quote %cepl.types:gl-id) :initial-element %cepl.types:+null-gl-id+ :adjustable t :fill-pointer 0)}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-ARRAY-OF-UBO-BINDINGS-BUFFER-IDS function, , @t{%cepl-context-array-of-ubo-bindings-buffer-ids}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-ARRAY-OF-UBO-BINDINGS-BUFFER-IDS) function, , @t{(setf %cepl-context-array-of-ubo-bindings-buffer-ids)}} (function)
@end table
@end defvr
@defvr {Slot} array-of-ubo-binding-ranges
@slotsubindex{array-of-ubo-binding-ranges}@c
@table @strong
@item Type
@t{(array (unsigned-byte 32) (*))}
@item Initform
@t{(make-array 0 :element-type (quote (unsigned-byte 32)) :initial-element 0 :adjustable t :fill-pointer 0)}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-ARRAY-OF-UBO-BINDING-RANGES function, , @t{%cepl-context-array-of-ubo-binding-ranges}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-ARRAY-OF-UBO-BINDING-RANGES) function, , @t{(setf %cepl-context-array-of-ubo-binding-ranges)}} (function)
@end table
@end defvr
@defvr {Slot} array-of-ssbo-bindings-buffer-ids
@slotsubindex{array-of-ssbo-bindings-buffer-ids}@c
@table @strong
@item Type
@t{(array %cepl.types:gl-id (*))}
@item Initform
@t{(make-array 0 :element-type (quote %cepl.types:gl-id) :initial-element %cepl.types:+null-gl-id+ :adjustable t :fill-pointer 0)}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-ARRAY-OF-SSBO-BINDINGS-BUFFER-IDS function, , @t{%cepl-context-array-of-ssbo-bindings-buffer-ids}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-ARRAY-OF-SSBO-BINDINGS-BUFFER-IDS) function, , @t{(setf %cepl-context-array-of-ssbo-bindings-buffer-ids)}} (function)
@end table
@end defvr
@defvr {Slot} array-of-ssbo-binding-ranges
@slotsubindex{array-of-ssbo-binding-ranges}@c
@table @strong
@item Type
@t{(array (unsigned-byte 32) (*))}
@item Initform
@t{(make-array 0 :element-type (quote (unsigned-byte 32)) :initial-element 0 :adjustable t :fill-pointer 0)}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-ARRAY-OF-SSBO-BINDING-RANGES function, , @t{%cepl-context-array-of-ssbo-binding-ranges}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-ARRAY-OF-SSBO-BINDING-RANGES) function, , @t{(setf %cepl-context-array-of-ssbo-binding-ranges)}} (function)
@end table
@end defvr
@defvr {Slot} array-of-transform-feedback-bindings-buffer-ids
@slotsubindex{array-of-transform-feedback-bindings-buffer-ids}@c
@table @strong
@item Type
@t{(array %cepl.types:gl-id (*))}
@item Initform
@t{(make-array 0 :element-type (quote %cepl.types:gl-id) :initial-element %cepl.types:+null-gl-id+ :adjustable t :fill-pointer 0)}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-ARRAY-OF-TRANSFORM-FEEDBACK-BINDINGS-BUFFER-IDS function, , @t{%cepl-context-array-of-transform-feedback-bindings-buffer-ids}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-ARRAY-OF-TRANSFORM-FEEDBACK-BINDINGS-BUFFER-IDS) function, , @t{(setf %cepl-context-array-of-transform-feedback-bindings-buffer-ids)}} (function)
@end table
@end defvr
@defvr {Slot} array-of-bound-samplers
@slotsubindex{array-of-bound-samplers}@c
@table @strong
@item Type
@t{(simple-array (or null %cepl.types:sampler) (*))}
@item Initform
@t{(make-array 0 :element-type (quote (or null %cepl.types:sampler)) :initial-element nil)}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-ARRAY-OF-BOUND-SAMPLERS function, , @t{%cepl-context-array-of-bound-samplers}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-ARRAY-OF-BOUND-SAMPLERS) function, , @t{(setf %cepl-context-array-of-bound-samplers)}} (function)
@end table
@end defvr
@defvr {Slot} array-of-bound-queries
@slotsubindex{array-of-bound-queries}@c
@table @strong
@item Type
@t{(simple-array (or null %cepl.types:gpu-query) (7))}
@item Initform
@t{(make-array 7 :element-type (quote (or null %cepl.types:gpu-query)) :initial-element nil)}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-ARRAY-OF-BOUND-QUERIES function, , @t{%cepl-context-array-of-bound-queries}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-ARRAY-OF-BOUND-QUERIES) function, , @t{(setf %cepl-context-array-of-bound-queries)}} (function)
@end table
@end defvr
@defvr {Slot} array-of-textures
@slotsubindex{array-of-textures}@c
@table @strong
@item Type
@t{(array glsl-symbols.functions:texture (*))}
@item Initform
@t{(make-array 0 :element-type (quote glsl-symbols.functions:texture) :initial-element %cepl.types:+null-texture+ :adjustable t :fill-pointer 0)}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-ARRAY-OF-TEXTURES function, , @t{%cepl-context-array-of-textures}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-ARRAY-OF-TEXTURES) function, , @t{(setf %cepl-context-array-of-textures)}} (function)
@end table
@end defvr
@defvr {Slot} depth-func
@slotsubindex{depth-func}@c
@table @strong
@item Type
@t{(or symbol function)}
@item Initform
@t{:unknown}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-DEPTH-FUNC function, , @t{%cepl-context-depth-func}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-DEPTH-FUNC) function, , @t{(setf %cepl-context-depth-func)}} (function)
@end table
@end defvr
@defvr {Slot} depth-mask
@slotsubindex{depth-mask}@c
@table @strong
@item Type
@t{boolean}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-DEPTH-MASK function, , @t{%cepl-context-depth-mask}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-DEPTH-MASK) function, , @t{(setf %cepl-context-depth-mask)}} (function)
@end table
@end defvr
@defvr {Slot} color-masks
@slotsubindex{color-masks}@c
@table @strong
@item Type
@t{(simple-array (simple-array boolean (4)) (*))}
@item Initform
@t{(make-array 0 :element-type (quote (simple-array boolean (4))))}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-COLOR-MASKS function, , @t{%cepl-context-color-masks}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-COLOR-MASKS) function, , @t{(setf %cepl-context-color-masks)}} (function)
@end table
@end defvr
@defvr {Slot} depth-range
@slotsubindex{depth-range}@c
@table @strong
@item Type
@t{glsl-symbols.types:vec2}
@item Initform
@t{(glsl-symbols.types:vec2 0.0 1.0)}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-DEPTH-RANGE function, , @t{%cepl-context-depth-range}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-DEPTH-RANGE) function, , @t{(setf %cepl-context-depth-range)}} (function)
@end table
@end defvr
@defvr {Slot} depth-clamp
@slotsubindex{depth-clamp}@c
@table @strong
@item Type
@t{boolean}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-DEPTH-CLAMP function, , @t{%cepl-context-depth-clamp}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-DEPTH-CLAMP) function, , @t{(setf %cepl-context-depth-clamp)}} (function)
@end table
@end defvr
@defvr {Slot} cull-face
@slotsubindex{cull-face}@c
@table @strong
@item Type
@t{(or symbol function)}
@item Initform
@t{:unknown}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-CULL-FACE function, , @t{%cepl-context-cull-face}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-CULL-FACE) function, , @t{(setf %cepl-context-cull-face)}} (function)
@end table
@end defvr
@defvr {Slot} front-face
@slotsubindex{front-face}@c
@table @strong
@item Type
@t{symbol}
@item Initform
@t{:unknown}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-FRONT-FACE function, , @t{%cepl-context-front-face}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-FRONT-FACE) function, , @t{(setf %cepl-context-front-face)}} (function)
@end table
@end defvr
@defvr {Slot} clear-color
@slotsubindex{clear-color}@c
@table @strong
@item Type
@t{glsl-symbols.types:vec4}
@item Initform
@t{(glsl-symbols.types:vec4 0.0 0.0 0.0 0.0)}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-CLEAR-COLOR function, , @t{%cepl-context-clear-color}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-CLEAR-COLOR) function, , @t{(setf %cepl-context-clear-color)}} (function)
@end table
@end defvr
@defvr {Slot} pack-alignment
@slotsubindex{pack-alignment}@c
@table @strong
@item Type
@t{(integer 1 8)}
@item Initform
@t{4}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-PACK-ALIGNMENT function, , @t{%cepl-context-pack-alignment}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-PACK-ALIGNMENT) function, , @t{(setf %cepl-context-pack-alignment)}} (function)
@end table
@end defvr
@defvr {Slot} unpack-alignment
@slotsubindex{unpack-alignment}@c
@table @strong
@item Type
@t{(integer 1 8)}
@item Initform
@t{4}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-UNPACK-ALIGNMENT function, , @t{%cepl-context-unpack-alignment}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-UNPACK-ALIGNMENT) function, , @t{(setf %cepl-context-unpack-alignment)}} (function)
@end table
@end defvr
@defvr {Slot} max-draw-buffer-count
@slotsubindex{max-draw-buffer-count}@c
@table @strong
@item Type
@t{(unsigned-byte 16)}
@item Initform
@t{0}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-MAX-DRAW-BUFFER-COUNT function, , @t{%cepl-context-max-draw-buffer-count}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-MAX-DRAW-BUFFER-COUNT) function, , @t{(setf %cepl-context-max-draw-buffer-count)}} (function)
@end table
@end defvr
@defvr {Slot} instance-count
@slotsubindex{instance-count}@c
@table @strong
@item Type
@t{%cepl.types:c-array-index}
@item Initform
@t{1}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-INSTANCE-COUNT function, , @t{%cepl-context-instance-count}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-INSTANCE-COUNT) function, , @t{(setf %cepl-context-instance-count)}} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {compile-context} ()
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>COMPILE-CONTEXT structure}@c
@structuresubindex{compile-context}@c

In the `lambda-list` for a `gpu-function`, glsl-stage or gpu lambda you can
include the `&context` symbol which indicates that the remaining forms in the
lambda-list are information about the context for the gpu-function to be
compiled in.@*

In pipelines (either defiend by `defpipeline-g` or `pipeline-g`) there is a
context parameter which is a list of forms which represent information about
the context for the pipeline to be compiled in.@*

### The Data@*

The `compile-context` holds a few pieces of information:@*

- GLSL Versions@*
 - in the case of `gpu-function`s and glsl stages this is used to specify what
   GLSL versions this is valid for.@*
 - in the case of pipelines this is used to specify what version of GLSL will
   be used to compile this pipeline.@*
- Primitive@*
 - in the case of gpu-functions and glsl-stages this is used to specify what
   primitive is valid. This can be used to ensure that a specific
   `gpu-function` or glsl-stage that works on `:lines` is never used in a
   `pipeline` processing `:triangles`.@*
 - in the case of pipelines this is used to specify what primitive this
   pipeline takes. Any `buffer-stream` passed to this pipeline will be checked
   to ensure it contains the correct primitive. To specify this please refer
   to the  :primitive argument in `make-buffer-stream` or the
   `buffer-stream-primitive` function.@*
- Stage Restrictive@*
 - Not valid for pipelines. This lets the you declare what stage the
   gpu-function or glsl stage is valid for.@*
- Static@*
 - For all targets this tells CEPL that the function, glsl stage or@*
   pipeline is never going to be modified again. This allows CEPL to statically
   define some types and also elide the code that would usually cause
   recompilation when a gpu-function this is used by this
   pipeline/stage/function is recompiled.@*

Most compile-context information is optional and the following defaults are used
if the data is not provided:@*

- GLSL Versions@*
 - gpu-function/glsl-stage: When checking for errors CEPL will allow
   functions/types/etc from any glsl version to be used.@*
 - pipeline: CEPL will look at the GL version of the context to determine the
   most recent version of GLSL that it can used.@*
- Primitive@*
 - gpu-function/glsl-stage: By default there is no restriction applied@*
 - pipeline: By default :triangles are assumed@*
- Stage@*
 - pipelines/gpu-functions: Always NIL by default@*
 - glsl-stages: Mandatory@*
- Static@*
 - Always NIL by default@*

### How it is specified@*

The context designations are:@*

Static:@*

The symbol :static can appear at most once in the context list@*

Versions:@*

0 or more of the following can appear in the context list@*

- :140@*
- :150@*
- :330@*
- :400@*
- :410@*
- :420@*
- :430@*
- :440@*
- :450@*
- :460@*

Stage:@*

At most 1 of the following:@*
- :vertex@*
- :tessellation-control@*
- :tessellation-evaluation@*
- :geometry@*
- :fragment@*
- :compute@*

Primitive:@*

At most 1 of the following can appear in the context list@*
- :dynamic@*
- :points@*
- :lines@*
- :iso-lines@*
- :line-loop@*
- :line-strip@*
- :lines-adjacency@*
- :line-strip-adjacency@*
- :triangles@*
- :triangle-fan@*
- :triangle-strip@*
- :triangles-adjacency@*
- :triangle-strip-adjacency@*
- (:patch <patch length>)@*

Note: :dynamic is special. It means that the pipeline will take the primitive
kind from the buffer-stream being mapped over. This won't work for with
pipelines with geometry or tessellation stages, but it otherwise can be useful.

### Example@*

    (defpipeline-g draw-sphere ((:patch 3) :440 :static)@*
      :vertex (sphere-vert g-pnt)@*
      :tessellation-control (sphere-tess-con (:vec3 3))
      :tessellation-evaluation (sphere-tess-eval (:vec3 3))@*
      :geometry (sphere-geom (:vec3 3) (:vec3 3))@*
      :fragment (sphere-frag :vec3 :vec3 :vec3))@*

This pipeline takes 3 component patches, requires at least GLSL 440 and has
declared that it will not be recompiled (and as such will not take part in
live recompilation).@*

    (defun-g saturate ((val :dvec4) &context :410 :420 :430 :440 :450 :460)
      (clamp val 0d0 1d0))@*

This gpu-function is restricted to only work on version of GLSL between@*
410 & 460@*

    (def-glsl-stage frag-glsl ((\"color_in\" :vec4) &context :330 :fragment)
      \"void main() @lbracechar{}@*
           color_out = v_in.color_in;@*
       @rbracechar{}\"@*
      ((\"color_out\" :vec4)))@*

This glsl-stage has stated it is to be used as a fragment stage as it only
valid for GLSL version 330.
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/compile-context<dot>lisp file, , @t{core/pipelines/compile-context.lisp}} (file)
@item Direct superclasses
@t{structure-object} (structure)
@item Direct methods
@t{make-load-form} (method)
@item Direct slots
@defvr {Slot} primitive
@slotsubindex{primitive}@c
@table @strong
@item Initform
@t{(error \"bug: context without primitive\")}
@item Readers
@ref{go to the CEPL<dot>PIPELINES<colon><colon>COMPILE-CONTEXT-PRIMITIVE function, , @t{compile-context-primitive}} (function)
@item Writers
@ref{go to the CEPL<dot>PIPELINES<colon><colon>(SETF COMPILE-CONTEXT-PRIMITIVE) function, , @t{(setf compile-context-primitive)}} (function)
@end table
@end defvr
@defvr {Slot} versions
@slotsubindex{versions}@c
@table @strong
@item Initform
@t{(error \"bug: context without versions\")}
@item Readers
@ref{go to the CEPL<dot>PIPELINES<colon><colon>COMPILE-CONTEXT-VERSIONS function, , @t{compile-context-versions}} (function)
@item Writers
@ref{go to the CEPL<dot>PIPELINES<colon><colon>(SETF COMPILE-CONTEXT-VERSIONS) function, , @t{(setf compile-context-versions)}} (function)
@end table
@end defvr
@defvr {Slot} stage
@slotsubindex{stage}@c
@table @strong
@item Initform
@t{(error \"bug: context without stage\")}
@item Readers
@ref{go to the CEPL<dot>PIPELINES<colon><colon>COMPILE-CONTEXT-STAGE function, , @t{compile-context-stage}} (function)
@item Writers
@ref{go to the CEPL<dot>PIPELINES<colon><colon>(SETF COMPILE-CONTEXT-STAGE) function, , @t{(setf compile-context-stage)}} (function)
@end table
@end defvr
@defvr {Slot} static-p
@slotsubindex{static-p}@c
@table @strong
@item Initform
@t{(error \"bug: context without 'static' boolean\")}
@item Readers
@ref{go to the CEPL<dot>PIPELINES<colon><colon>COMPILE-CONTEXT-STATIC-P function, , @t{compile-context-static-p}} (function)
@item Writers
@ref{go to the CEPL<dot>PIPELINES<colon><colon>(SETF COMPILE-CONTEXT-STATIC-P) function, , @t{(setf compile-context-static-p)}} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {compute-space} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COMPUTE-SPACE structure}@c
@structuresubindex{compute-space}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@t{structure-object} (structure)
@item Direct methods
@itemize @bullet
@item
@t{dimensions} (method)
@item
@ref{go to the CEPL<dot>MEASUREMENTS<colon><colon>DIMENSIONS %CEPL<dot>TYPES<colon><colon>COMPUTE-SPACE method, , @t{dimensions}} (method)
@end itemize
@item Direct slots
@defvr {Slot} size-x
@slotsubindex{size-x}@c
@table @strong
@item Type
@t{(unsigned-byte 32)}
@item Initform
@t{1}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>COMPUTE-SPACE-SIZE-X function, , @t{compute-space-size-x}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF COMPUTE-SPACE-SIZE-X) function, , @t{(setf compute-space-size-x)}} (function)
@end table
@end defvr
@defvr {Slot} size-y
@slotsubindex{size-y}@c
@table @strong
@item Type
@t{(unsigned-byte 32)}
@item Initform
@t{1}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>COMPUTE-SPACE-SIZE-Y function, , @t{compute-space-size-y}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF COMPUTE-SPACE-SIZE-Y) function, , @t{(setf compute-space-size-y)}} (function)
@end table
@end defvr
@defvr {Slot} size-z
@slotsubindex{size-z}@c
@table @strong
@item Type
@t{(unsigned-byte 32)}
@item Initform
@t{1}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>COMPUTE-SPACE-SIZE-Z function, , @t{compute-space-size-z}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF COMPUTE-SPACE-SIZE-Z) function, , @t{(setf compute-space-size-z)}} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {elements-indirect-command} ()
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ELEMENTS-INDIRECT-COMMAND structure}@c
@structuresubindex{elements-indirect-command}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/multi-draw<dot>lisp file, , @t{core/pipelines/multi-draw.lisp}} (file)
@item Direct superclasses
@ref{go to the CEPL<dot>TYPES<colon><colon>BASE-GSTRUCT-WRAPPER structure, , @t{base-gstruct-wrapper}} (structure)
@item Direct methods
@itemize @bullet
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PUSH-G COMMON-LISP<colon><colon>LIST CEPL<dot>PIPELINES<colon><colon>ELEMENTS-INDIRECT-COMMAND method, , @t{push-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PULL1-G CEPL<dot>PIPELINES<colon><colon>ELEMENTS-INDIRECT-COMMAND method, , @t{pull1-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PULL-G CEPL<dot>PIPELINES<colon><colon>ELEMENTS-INDIRECT-COMMAND method, , @t{pull-g}} (method)
@item
@ref{go to the CEPL<dot>INTERNALS<colon><colon>POPULATE CEPL<dot>PIPELINES<colon><colon>ELEMENTS-INDIRECT-COMMAND COMMON-LISP<colon><colon>T method, , @t{populate}} (method)
@item
@t{print-object} (method)
@end itemize
@end table
@end deftp
@deftp {Structure} {empty-fbo-params} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>EMPTY-FBO-PARAMS structure}@c
@structuresubindex{empty-fbo-params}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@t{structure-object} (structure)
@item Direct methods
@t{print-object} (method)
@item Direct slots
@defvr {Slot} fbo
@slotsubindex{fbo}@c
@table @strong
@item Type
@t{(or null %cepl.types:fbo)}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%EMPTY-FBO-PARAMS-FBO function, , @t{%empty-fbo-params-fbo}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %EMPTY-FBO-PARAMS-FBO) function, , @t{(setf %empty-fbo-params-fbo)}} (function)
@end table
@end defvr
@defvr {Slot} dimensions
@slotsubindex{dimensions}@c
@table @strong
@item Type
@t{list}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%EMPTY-FBO-PARAMS-DIMENSIONS function, , @t{%empty-fbo-params-dimensions}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %EMPTY-FBO-PARAMS-DIMENSIONS) function, , @t{(setf %empty-fbo-params-dimensions)}} (function)
@end table
@end defvr
@defvr {Slot} viewport
@slotsubindex{viewport}@c
@table @strong
@item Type
@t{%cepl.types:viewport}
@item Initform
@t{(%cepl.types:%make-viewport)}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%EMPTY-FBO-PARAMS-VIEWPORT function, , @t{%empty-fbo-params-viewport}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %EMPTY-FBO-PARAMS-VIEWPORT) function, , @t{(setf %empty-fbo-params-viewport)}} (function)
@end table
@end defvr
@defvr {Slot} layer-count
@slotsubindex{layer-count}@c
@table @strong
@item Type
@t{unsigned-byte}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%EMPTY-FBO-PARAMS-LAYER-COUNT function, , @t{%empty-fbo-params-layer-count}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %EMPTY-FBO-PARAMS-LAYER-COUNT) function, , @t{(setf %empty-fbo-params-layer-count)}} (function)
@end table
@end defvr
@defvr {Slot} samples
@slotsubindex{samples}@c
@table @strong
@item Type
@t{unsigned-byte}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%EMPTY-FBO-PARAMS-SAMPLES function, , @t{%empty-fbo-params-samples}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %EMPTY-FBO-PARAMS-SAMPLES) function, , @t{(setf %empty-fbo-params-samples)}} (function)
@end table
@end defvr
@defvr {Slot} fixed-sample-locations-p
@slotsubindex{fixed-sample-locations-p}@c
@table @strong
@item Type
@t{boolean}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%EMPTY-FBO-PARAMS-FIXED-SAMPLE-LOCATIONS-P function, , @t{%empty-fbo-params-fixed-sample-locations-p}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %EMPTY-FBO-PARAMS-FIXED-SAMPLE-LOCATIONS-P) function, , @t{(setf %empty-fbo-params-fixed-sample-locations-p)}} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {fbo} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>FBO structure}@c
@structuresubindex{fbo}@c

A framebuffer object (`FBO`) is a structure that can be rendered into.@*

When a FBO is rendered into the data from the pipeline is written into one or
more of the `attachment`s of the FBO@*

An FBO attachment is a slot where a texture-backed `gpu-array` can be attached.
When the gpu-array is attached the data from a pipeline rendering into the fbo
is written into that gpu-array.@*

This is the heart of how multi-pass rendering is done in OpenGL. One pipeline
writes data into `texture`s that are then used as inputs to another pipeline[0].

A FBO can have:@*
- 0 or more 'color attachments'@*
- 0 or 1 'depth attachment'@*
- 0 or 1 'stencil attachment'@*
- 0 or 1 'depth-stencil attachment'@*

Let's look at these in more detail:@*

**-- Color Attachments --**@*

Color attachments can only contain gpu-arrays whose element-type can be found in
the *color-renderable-formats* list.@*

Note that while OpenGL terminology mentions 'color' and 'image' a lot you are
not limitted to only using textures or fbos for pictures. It is perfectly
valid (and incredibly useful) to return data meaning all kinds of things other
than colors.@*

**-- Depth Attachments --**@*

The depth attachment (when used) can only contain a gpu-array whos element-type
can be found in *depth-formats*@*

*Usage Tip:* Even if you don't plan on reading from this depth_attachment, any
fbo that will be rendered to should have a depth attachment.@*

**-- Stencil Attachments (NOT SUPPORTED IN CURRENT CEPL VERSION) --**@*

The stencil attachment (when used) can only contain a gpu-array whos
element-type can be found in *stencil-formats*@*

**-- Depth-Stencil Attachments (NOT SUPPORTED IN CURRENT CEPL VERSION) --**@*

The depth-stencil attachment (when used) can only contain a gpu-array whos
element-type can be found in *depth-stencil-formats*@*

This attachment is shorthand for 'both depth and stencil'. The gpu-array
attached here becomes both the depth and stencil attachment.@*


**-- Choosing which attachment to render into --**@*

Making these choices is done with the `with-fbo-bound` macro. See its docstring
for further details@*

[0] WARNING:@*

It is possible to bind a texture to an FBO, bind that same texture to a shader,
and then try to sample from it at the same time. You will get undefined results.

This means it may do what you want, the sampler may get old data, the sampler
may get half old and half new data, or it may get garbage data. Any of these are
possible outcomes.@*

Do Not Do This!
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@t{structure-object} (structure)
@item Direct methods
@itemize @bullet
@item
@t{print-object} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>FREE %CEPL<dot>TYPES<colon><colon>FBO method, , @t{free}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>INITIALIZED-P %CEPL<dot>TYPES<colon><colon>FBO method, , @t{initialized-p}} (method)
@item
@ref{go to the %CEPL<dot>TYPES<colon><colon>CAN-BE-SHARED-BETWEEN-CONTEXTS-P %CEPL<dot>TYPES<colon><colon>FBO method, , @t{can-be-shared-between-contexts-p}} (method)
@end itemize
@item Direct slots
@defvr {Slot} id
@slotsubindex{id}@c
@table @strong
@item Type
@t{%cepl.types:gl-id}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%FBO-ID function, , @t{%fbo-id}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %FBO-ID) function, , @t{(setf %fbo-id)}} (function)
@end table
@end defvr
@defvr {Slot} empty-params
@slotsubindex{empty-params}@c
@table @strong
@item Type
@t{(or null %cepl.types:empty-fbo-params)}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%FBO-EMPTY-PARAMS function, , @t{%fbo-empty-params}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %FBO-EMPTY-PARAMS) function, , @t{(setf %fbo-empty-params)}} (function)
@end table
@end defvr
@defvr {Slot} color-arrays
@slotsubindex{color-arrays}@c
@table @strong
@item Type
@t{(array %cepl.types:att *)}
@item Initform
@t{(make-array 0 :element-type (quote %cepl.types:att) :initial-element (symbol-value (quote %cepl.types::+null-att+)) :adjustable t :fill-pointer 0)}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%FBO-COLOR-ARRAYS function, , @t{%fbo-color-arrays}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %FBO-COLOR-ARRAYS) function, , @t{(setf %fbo-color-arrays)}} (function)
@end table
@end defvr
@defvr {Slot} depth-array
@slotsubindex{depth-array}@c
@table @strong
@item Type
@t{%cepl.types:att}
@item Initform
@t{(%cepl.types:make-att)}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%FBO-DEPTH-ARRAY function, , @t{%fbo-depth-array}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %FBO-DEPTH-ARRAY) function, , @t{(setf %fbo-depth-array)}} (function)
@end table
@end defvr
@defvr {Slot} stencil-array
@slotsubindex{stencil-array}@c
@table @strong
@item Type
@t{%cepl.types:att}
@item Initform
@t{(%cepl.types:make-att)}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%FBO-STENCIL-ARRAY function, , @t{%fbo-stencil-array}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %FBO-STENCIL-ARRAY) function, , @t{(setf %fbo-stencil-array)}} (function)
@end table
@end defvr
@defvr {Slot} draw-buffer-map
@slotsubindex{draw-buffer-map}@c
@table @strong
@item Initform
@t{(error \"draw-buffer array must be provided when initializing an fbo\")}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%FBO-DRAW-BUFFER-MAP function, , @t{%fbo-draw-buffer-map}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %FBO-DRAW-BUFFER-MAP) function, , @t{(setf %fbo-draw-buffer-map)}} (function)
@end table
@end defvr
@defvr {Slot} clear-mask
@slotsubindex{clear-mask}@c
@table @strong
@item Type
@t{fixnum}
@item Initform
@t{(cffi:foreign-bitfield-value (quote cl-opengl-bindings:clearbuffermask) (quote (:color-buffer-bit)))}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%FBO-CLEAR-MASK function, , @t{%fbo-clear-mask}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %FBO-CLEAR-MASK) function, , @t{(setf %fbo-clear-mask)}} (function)
@end table
@end defvr
@defvr {Slot} is-default
@slotsubindex{is-default}@c
@table @strong
@item Type
@t{boolean}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%FBO-IS-DEFAULT function, , @t{%fbo-is-default}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %FBO-IS-DEFAULT) function, , @t{(setf %fbo-is-default)}} (function)
@end table
@end defvr
@defvr {Slot} attachment-count
@slotsubindex{attachment-count}@c
@table @strong
@item Type
@t{(unsigned-byte 8)}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%FBO-ATTACHMENT-COUNT function, , @t{%fbo-attachment-count}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %FBO-ATTACHMENT-COUNT) function, , @t{(setf %fbo-attachment-count)}} (function)
@end table
@end defvr
@defvr {Slot} blending-params
@slotsubindex{blending-params}@c
@table @strong
@item Type
@t{%cepl.types:blending-params}
@item Initform
@t{(%cepl.types:make-blending-params :mode-rgb :func-add :mode-alpha :func-add :source-rgb :one :source-alpha :one :destination-rgb :zero :destination-alpha :zero)}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%FBO-BLENDING-PARAMS function, , @t{%fbo-blending-params}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %FBO-BLENDING-PARAMS) function, , @t{(setf %fbo-blending-params)}} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {g-pc} ()
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PC structure}@c
@structuresubindex{g-pc}@c

g-pc is a CEPL gpu struct with the following slots:

  position: of type vec3 with an accessor method: pos
  color: of type vec4 with an accessor method: col
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@item Direct superclasses
@ref{go to the CEPL<dot>TYPES<colon><colon>BASE-GSTRUCT-WRAPPER structure, , @t{base-gstruct-wrapper}} (structure)
@item Direct methods
@itemize @bullet
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PUSH-G COMMON-LISP<colon><colon>LIST CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PC method, , @t{push-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PULL1-G CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PC method, , @t{pull1-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PULL-G CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PC method, , @t{pull-g}} (method)
@item
@ref{go to the CEPL<dot>INTERNALS<colon><colon>POPULATE CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PC COMMON-LISP<colon><colon>T method, , @t{populate}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>(SETF COL) COMMON-LISP<colon><colon>T CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PC method, , @t{(setf col)}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>(SETF POS) COMMON-LISP<colon><colon>T CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PC method, , @t{(setf pos)}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>COL CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PC method, , @t{col}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>POS CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PC method, , @t{pos}} (method)
@item
@t{print-object} (method)
@end itemize
@end table
@end deftp
@deftp {Structure} {g-pn} ()
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PN structure}@c
@structuresubindex{g-pn}@c

g-pn is a CEPL gpu struct with the following slots:

  position: of type vec3 with an accessor method: pos
  normal: of type vec3 with an accessor method: norm
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@item Direct superclasses
@ref{go to the CEPL<dot>TYPES<colon><colon>BASE-GSTRUCT-WRAPPER structure, , @t{base-gstruct-wrapper}} (structure)
@item Direct methods
@itemize @bullet
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PUSH-G COMMON-LISP<colon><colon>LIST CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PN method, , @t{push-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PULL1-G CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PN method, , @t{pull1-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PULL-G CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PN method, , @t{pull-g}} (method)
@item
@ref{go to the CEPL<dot>INTERNALS<colon><colon>POPULATE CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PN COMMON-LISP<colon><colon>T method, , @t{populate}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>(SETF NORM) COMMON-LISP<colon><colon>T CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PN method, , @t{(setf norm)}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>(SETF POS) COMMON-LISP<colon><colon>T CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PN method, , @t{(setf pos)}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>NORM CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PN method, , @t{norm}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>POS CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PN method, , @t{pos}} (method)
@item
@t{print-object} (method)
@end itemize
@end table
@end deftp
@deftp {Structure} {g-pnc} ()
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNC structure}@c
@structuresubindex{g-pnc}@c

g-pnc is a CEPL gpu struct with the following slots:

  position: of type vec3 with an accessor method: pos
  normal: of type vec3 with an accessor method: norm
  color: of type vec4 with an accessor method: col
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@item Direct superclasses
@ref{go to the CEPL<dot>TYPES<colon><colon>BASE-GSTRUCT-WRAPPER structure, , @t{base-gstruct-wrapper}} (structure)
@item Direct methods
@itemize @bullet
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PUSH-G COMMON-LISP<colon><colon>LIST CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNC method, , @t{push-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PULL1-G CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNC method, , @t{pull1-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PULL-G CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNC method, , @t{pull-g}} (method)
@item
@ref{go to the CEPL<dot>INTERNALS<colon><colon>POPULATE CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNC COMMON-LISP<colon><colon>T method, , @t{populate}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>(SETF COL) COMMON-LISP<colon><colon>T CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNC method, , @t{(setf col)}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>(SETF NORM) COMMON-LISP<colon><colon>T CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNC method, , @t{(setf norm)}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>(SETF POS) COMMON-LISP<colon><colon>T CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNC method, , @t{(setf pos)}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>COL CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNC method, , @t{col}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>NORM CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNC method, , @t{norm}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>POS CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNC method, , @t{pos}} (method)
@item
@t{print-object} (method)
@end itemize
@end table
@end deftp
@deftp {Structure} {g-pnt} ()
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNT structure}@c
@structuresubindex{g-pnt}@c

g-pnt is a CEPL gpu struct with the following slots:

  position: of type vec3 with an accessor method: pos
  normal: of type vec3 with an accessor method: norm
  texture: of type vec2 with an accessor method: tex
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@item Direct superclasses
@ref{go to the CEPL<dot>TYPES<colon><colon>BASE-GSTRUCT-WRAPPER structure, , @t{base-gstruct-wrapper}} (structure)
@item Direct methods
@itemize @bullet
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PUSH-G COMMON-LISP<colon><colon>LIST CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNT method, , @t{push-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PULL1-G CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNT method, , @t{pull1-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PULL-G CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNT method, , @t{pull-g}} (method)
@item
@ref{go to the CEPL<dot>INTERNALS<colon><colon>POPULATE CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNT COMMON-LISP<colon><colon>T method, , @t{populate}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>(SETF TEX) COMMON-LISP<colon><colon>T CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNT method, , @t{(setf tex)}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>(SETF NORM) COMMON-LISP<colon><colon>T CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNT method, , @t{(setf norm)}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>(SETF POS) COMMON-LISP<colon><colon>T CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNT method, , @t{(setf pos)}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>TEX CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNT method, , @t{tex}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>NORM CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNT method, , @t{norm}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>POS CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNT method, , @t{pos}} (method)
@item
@t{print-object} (method)
@end itemize
@end table
@end deftp
@deftp {Structure} {g-pntc} ()
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNTC structure}@c
@structuresubindex{g-pntc}@c

g-pntc is a CEPL gpu struct with the following slots:

  position: of type vec3 with an accessor method: pos
  normal: of type vec3 with an accessor method: norm
  texture: of type vec2 with an accessor method: tex
  color: of type vec4 with an accessor method: col
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@item Direct superclasses
@ref{go to the CEPL<dot>TYPES<colon><colon>BASE-GSTRUCT-WRAPPER structure, , @t{base-gstruct-wrapper}} (structure)
@item Direct methods
@itemize @bullet
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PUSH-G COMMON-LISP<colon><colon>LIST CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNTC method, , @t{push-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PULL1-G CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNTC method, , @t{pull1-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PULL-G CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNTC method, , @t{pull-g}} (method)
@item
@ref{go to the CEPL<dot>INTERNALS<colon><colon>POPULATE CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNTC COMMON-LISP<colon><colon>T method, , @t{populate}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>(SETF COL) COMMON-LISP<colon><colon>T CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNTC method, , @t{(setf col)}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>(SETF TEX) COMMON-LISP<colon><colon>T CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNTC method, , @t{(setf tex)}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>(SETF NORM) COMMON-LISP<colon><colon>T CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNTC method, , @t{(setf norm)}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>(SETF POS) COMMON-LISP<colon><colon>T CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNTC method, , @t{(setf pos)}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>COL CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNTC method, , @t{col}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>TEX CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNTC method, , @t{tex}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>NORM CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNTC method, , @t{norm}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>POS CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNTC method, , @t{pos}} (method)
@item
@t{print-object} (method)
@end itemize
@end table
@end deftp
@deftp {Structure} {g-pt} ()
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PT structure}@c
@structuresubindex{g-pt}@c

g-pt is a CEPL gpu struct with the following slots:

  position: of type vec3 with an accessor method: pos
  texture: of type vec2 with an accessor method: tex
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@item Direct superclasses
@ref{go to the CEPL<dot>TYPES<colon><colon>BASE-GSTRUCT-WRAPPER structure, , @t{base-gstruct-wrapper}} (structure)
@item Direct methods
@itemize @bullet
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PUSH-G COMMON-LISP<colon><colon>LIST CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PT method, , @t{push-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PULL1-G CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PT method, , @t{pull1-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PULL-G CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PT method, , @t{pull-g}} (method)
@item
@ref{go to the CEPL<dot>INTERNALS<colon><colon>POPULATE CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PT COMMON-LISP<colon><colon>T method, , @t{populate}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>(SETF TEX) COMMON-LISP<colon><colon>T CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PT method, , @t{(setf tex)}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>(SETF POS) COMMON-LISP<colon><colon>T CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PT method, , @t{(setf pos)}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>TEX CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PT method, , @t{tex}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>POS CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PT method, , @t{pos}} (method)
@item
@t{print-object} (method)
@end itemize
@end table
@end deftp
@deftp {Structure} {gpu-array} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY structure}@c
@structuresubindex{gpu-array}@c

`GPU-ARRAY` is a structure that represents an array in gpu-memory.@*

Depending on how the array was created it is said that the gpu-array is either
'buffer-backed' or 'texture-backed'.@*

- buffer-backed: Means it was created with `make-gpu-array` or `make-gpu-arrays`
                 The data is stored in a gpu-buffer.@*
- texture-backed: Means it was created along with a `texture`. `Texture`s are
                  structures that contain some number of gpu-arrays.@*
                  The data is stored in `texture` memory.@*
                  See `texture` for more details.@*

Both have different use cases and allow different element types, however they
are both an ordered block of typed data. They can have multiple dimensions and
you can `push-g` and `pull-g` data to and from them.@*

Note for folks who are used to OpenGL:@*
texture-backed gpu-arrays are what opengl would normally call 'images'. This is
a pretty terrible name for them as it implies they only can hold image data, or
that they are 2d only. In fact 'images' can have 1 to 3 dimensions, can have
elements that are single bytes, floats, vectors of either or a large number of
other types.@*
'image' belies this nature and so CEPL chooses 'array'@*

This also matches how the GLWiki chooses to explain them:@*
> an image is defined as a single array of pixels of a certain@*
> dimensionality (1D, 2D, or 3D), with a particular size, and a specific format.
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@t{structure-object} (structure)
@item Direct subclasses
@itemize @bullet
@item
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB structure, , @t{gpu-array-bb}} (structure)
@item
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T structure, , @t{gpu-array-t}} (structure)
@end itemize
@item Direct methods
@itemize @bullet
@item
@ref{go to the CEPL<dot>MEASUREMENTS<colon><colon>DIMENSIONS %CEPL<dot>TYPES<colon><colon>GPU-ARRAY method, , @t{dimensions}} (method)
@item
@ref{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED<colon><colon>FREE-GPU-ARRAY %CEPL<dot>TYPES<colon><colon>GPU-ARRAY method, , @t{free-gpu-array}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>FREE %CEPL<dot>TYPES<colon><colon>GPU-ARRAY method, , @t{free}} (method)
@item
@t{print-object} (method)
@item
@ref{go to the %CEPL<dot>TYPES<colon><colon>CAN-BE-SHARED-BETWEEN-CONTEXTS-P %CEPL<dot>TYPES<colon><colon>GPU-ARRAY method, , @t{can-be-shared-between-contexts-p}} (method)
@end itemize
@item Direct slots
@defvr {Slot} dimensions
@slotsubindex{dimensions}@c
@table @strong
@item Type
@t{list}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-DIMENSIONS function, , @t{gpu-array-dimensions}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-DIMENSIONS) function, , @t{(setf gpu-array-dimensions)}} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {gpu-array-bb} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB structure}@c
@structuresubindex{gpu-array-bb}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY structure, , @t{gpu-array}} (structure)
@item Direct methods
@itemize @bullet
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB (eql KEYWORD<colon><colon>LISP) method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB (eql KEYWORD<colon><colon>C-ARRAY) method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G %CEPL<dot>TYPES<colon><colon>C-ARRAY %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G COMMON-LISP<colon><colon>ARRAY %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G COMMON-LISP<colon><colon>LIST %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PULL-G %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB method, , @t{pull-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PULL1-G %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB method, , @t{pull1-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PUSH-G %CEPL<dot>TYPES<colon><colon>C-ARRAY %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB method, , @t{push-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PUSH-G COMMON-LISP<colon><colon>LIST %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB method, , @t{push-g}} (method)
@item
@ref{go to the CEPL-UTILS<colon><colon>PRINT-MEM %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB method, , @t{print-mem}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>TEXTURES<colon><colon>PIXEL-FORMAT-FROM-ARRAY %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB method, , @t{pixel-format-from-array}} (method)
@item
@ref{go to the CEPL<dot>TYPES<colon><colon>ELEMENT-TYPE %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB method, , @t{element-type}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>INITIALIZED-P %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB method, , @t{initialized-p}} (method)
@end itemize
@item Direct slots
@defvr {Slot} buffer
@slotsubindex{buffer}@c
@table @strong
@item Type
@t{%cepl.types:gpu-buffer}
@item Initform
@t{(error \"\")}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB-BUFFER function, , @t{gpu-array-bb-buffer}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-BB-BUFFER) function, , @t{(setf gpu-array-bb-buffer)}} (function)
@end table
@end defvr
@defvr {Slot} access-style
@slotsubindex{access-style}@c
@table @strong
@item Type
@t{symbol}
@item Initform
@t{:static-draw}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB-ACCESS-STYLE function, , @t{gpu-array-bb-access-style}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-BB-ACCESS-STYLE) function, , @t{(setf gpu-array-bb-access-style)}} (function)
@end table
@end defvr
@defvr {Slot} element-type
@slotsubindex{element-type}@c
@table @strong
@item Type
@t{symbol}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB-ELEMENT-TYPE function, , @t{gpu-array-bb-element-type}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-BB-ELEMENT-TYPE) function, , @t{(setf gpu-array-bb-element-type)}} (function)
@end table
@end defvr
@defvr {Slot} byte-size
@slotsubindex{byte-size}@c
@table @strong
@item Type
@t{%cepl.types::gbuf-byte-size}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB-BYTE-SIZE function, , @t{gpu-array-bb-byte-size}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-BB-BYTE-SIZE) function, , @t{(setf gpu-array-bb-byte-size)}} (function)
@end table
@end defvr
@defvr {Slot} element-byte-size
@slotsubindex{element-byte-size}@c
@table @strong
@item Type
@t{%cepl.types::elem-byte-size}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB-ELEMENT-BYTE-SIZE function, , @t{gpu-array-bb-element-byte-size}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-BB-ELEMENT-BYTE-SIZE) function, , @t{(setf gpu-array-bb-element-byte-size)}} (function)
@end table
@end defvr
@defvr {Slot} offset-in-bytes-into-buffer
@slotsubindex{offset-in-bytes-into-buffer}@c
@table @strong
@item Type
@t{%cepl.types::gbuf-byte-size}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB-OFFSET-IN-BYTES-INTO-BUFFER function, , @t{gpu-array-bb-offset-in-bytes-into-buffer}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-BB-OFFSET-IN-BYTES-INTO-BUFFER) function, , @t{(setf gpu-array-bb-offset-in-bytes-into-buffer)}} (function)
@end table
@end defvr
@defvr {Slot} element-pixel-format
@slotsubindex{element-pixel-format}@c
@table @strong
@item Type
@t{(or null %cepl.types:pixel-format)}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB-ELEMENT-PIXEL-FORMAT function, , @t{gpu-array-bb-element-pixel-format}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-BB-ELEMENT-PIXEL-FORMAT) function, , @t{(setf gpu-array-bb-element-pixel-format)}} (function)
@end table
@end defvr
@defvr {Slot} row-alignment
@slotsubindex{row-alignment}@c
@table @strong
@item Type
@t{(integer 1 8)}
@item Initform
@t{1}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB-ROW-ALIGNMENT function, , @t{gpu-array-bb-row-alignment}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-BB-ROW-ALIGNMENT) function, , @t{(setf gpu-array-bb-row-alignment)}} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {gpu-array-t} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T structure}@c
@structuresubindex{gpu-array-t}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY structure, , @t{gpu-array}} (structure)
@item Direct methods
@itemize @bullet
@item
@ref{go to the CEPL<dot>MEASUREMENTS<colon><colon>RESOLUTION %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T method, , @t{resolution}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T (eql KEYWORD<colon><colon>GPU-ARRAY-BB) method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T (eql KEYWORD<colon><colon>LISP) method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T (eql KEYWORD<colon><colon>C-ARRAY) method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T %CEPL<dot>TYPES<colon><colon>C-ARRAY method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G COMMON-LISP<colon><colon>ARRAY %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G COMMON-LISP<colon><colon>LIST %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G %CEPL<dot>TYPES<colon><colon>C-ARRAY %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PULL1-G %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T method, , @t{pull1-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PULL-G %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T method, , @t{pull-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PUSH-G COMMON-LISP<colon><colon>ARRAY %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T method, , @t{push-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PUSH-G COMMON-LISP<colon><colon>LIST %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T method, , @t{push-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PUSH-G %CEPL<dot>TYPES<colon><colon>C-ARRAY %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T method, , @t{push-g}} (method)
@item
@ref{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED<colon><colon>FREE-GPU-ARRAY %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T method, , @t{free-gpu-array}} (method)
@item
@ref{go to the CEPL<dot>TYPES<colon><colon>ELEMENT-TYPE %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T method, , @t{element-type}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>FREE %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T method, , @t{free}} (method)
@item
@t{print-object} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>INITIALIZED-P %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T method, , @t{initialized-p}} (method)
@end itemize
@item Direct slots
@defvr {Slot} texture
@slotsubindex{texture}@c
@table @strong
@item Type
@t{glsl-symbols.functions:texture}
@item Initform
@t{(error \"\")}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T-TEXTURE function, , @t{gpu-array-t-texture}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-T-TEXTURE) function, , @t{(setf gpu-array-t-texture)}} (function)
@end table
@end defvr
@defvr {Slot} texture-type
@slotsubindex{texture-type}@c
@table @strong
@item Type
@t{symbol}
@item Initform
@t{(error \"\")}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T-TEXTURE-TYPE function, , @t{gpu-array-t-texture-type}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-T-TEXTURE-TYPE) function, , @t{(setf gpu-array-t-texture-type)}} (function)
@end table
@end defvr
@defvr {Slot} level-num
@slotsubindex{level-num}@c
@table @strong
@item Type
@t{(unsigned-byte 16)}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T-LEVEL-NUM function, , @t{gpu-array-t-level-num}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-T-LEVEL-NUM) function, , @t{(setf gpu-array-t-level-num)}} (function)
@end table
@end defvr
@defvr {Slot} layer-num
@slotsubindex{layer-num}@c
@table @strong
@item Type
@t{(unsigned-byte 16)}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T-LAYER-NUM function, , @t{gpu-array-t-layer-num}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-T-LAYER-NUM) function, , @t{(setf gpu-array-t-layer-num)}} (function)
@end table
@end defvr
@defvr {Slot} face-num
@slotsubindex{face-num}@c
@table @strong
@item Type
@t{(integer 0 5)}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T-FACE-NUM function, , @t{gpu-array-t-face-num}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-T-FACE-NUM) function, , @t{(setf gpu-array-t-face-num)}} (function)
@end table
@end defvr
@defvr {Slot} image-format
@slotsubindex{image-format}@c
@table @strong
@item Type
@t{symbol}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T-IMAGE-FORMAT function, , @t{gpu-array-t-image-format}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-T-IMAGE-FORMAT) function, , @t{(setf gpu-array-t-image-format)}} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {gpu-buffer} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-BUFFER structure}@c
@structuresubindex{gpu-buffer}@c

`gpu-buffer` is a struct that abstracts a OpenGL 'Buffer Object'@*

Along with the the ID of the GL Object itself it stores the unformatted data
as an array of `gpu-array`s.@*

Every `gpu-array` in the buffer will have an element-type of :uint8, even if this
buffer was created for a `gpu-array` with a different element-type.@*

For example:@*

    (make-gpu-array '(.1 .2 .3 .4))@*

will make a `gpu-array` of 4 floats. However the buffer backing this `gpu-array`
will contain a single array with element-type :uint8 and a length of 16.@*

It is not expected that users will be using `gpu-buffer`s directly. Instead they
are ususal interacted with via CEPL's `gpu-array` and ubo features.
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@t{structure-object} (structure)
@item Direct methods
@itemize @bullet
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>FREE %CEPL<dot>TYPES<colon><colon>GPU-BUFFER method, , @t{free}} (method)
@item
@t{print-object} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>INITIALIZED-P %CEPL<dot>TYPES<colon><colon>GPU-BUFFER method, , @t{initialized-p}} (method)
@item
@ref{go to the %CEPL<dot>TYPES<colon><colon>CAN-BE-SHARED-BETWEEN-CONTEXTS-P %CEPL<dot>TYPES<colon><colon>GPU-BUFFER method, , @t{can-be-shared-between-contexts-p}} (method)
@end itemize
@item Direct slots
@defvr {Slot} id
@slotsubindex{id}@c
@table @strong
@item Type
@t{%cepl.types:gl-id}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-BUFFER-ID function, , @t{gpu-buffer-id}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-BUFFER-ID) function, , @t{(setf gpu-buffer-id)}} (function)
@end table
@end defvr
@defvr {Slot} cache-id
@slotsubindex{cache-id}@c
@table @strong
@item Type
@t{(integer 0 13)}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-BUFFER-CACHE-ID function, , @t{gpu-buffer-cache-id}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-BUFFER-CACHE-ID) function, , @t{(setf gpu-buffer-cache-id)}} (function)
@end table
@end defvr
@defvr {Slot} arrays
@slotsubindex{arrays}@c
@table @strong
@item Type
@t{(array %cepl.types:gpu-array-bb (*))}
@item Initform
@t{(error \"\")}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-BUFFER-ARRAYS function, , @t{gpu-buffer-arrays}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-BUFFER-ARRAYS) function, , @t{(setf gpu-buffer-arrays)}} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {gpu-fence} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-FENCE structure}@c
@structuresubindex{gpu-fence}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@t{structure-object} (structure)
@item Direct methods
@ref{go to the CEPL<dot>MEMORY<colon><colon>FREE %CEPL<dot>TYPES<colon><colon>GPU-FENCE method, , @t{free}} (method)
@item Direct slots
@defvr {Slot} obj
@slotsubindex{obj}@c
@table @strong
@item Type
@t{cffi-sys:foreign-pointer}
@item Initform
@t{(cffi-sys:null-pointer)}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%GPU-FENCE-OBJ function, , @t{%gpu-fence-obj}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %GPU-FENCE-OBJ) function, , @t{(setf %gpu-fence-obj)}} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {gpu-query} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-QUERY structure}@c
@structuresubindex{gpu-query}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@t{structure-object} (structure)
@item Direct subclasses
@itemize @bullet
@item
@ref{go to the %CEPL<dot>TYPES<colon><colon>TIMESTAMP-QUERY structure, , @t{timestamp-query}} (structure)
@item
@ref{go to the %CEPL<dot>TYPES<colon><colon>SCOPED-GPU-QUERY structure, , @t{scoped-gpu-query}} (structure)
@end itemize
@item Direct slots
@defvr {Slot} id
@slotsubindex{id}@c
@table @strong
@item Type
@t{%cepl.types:gl-id}
@item Initform
@t{(%cepl.types::gen-query-id)}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-QUERY-ID function, , @t{gpu-query-id}} (function)
@item Writers
@t{(setf gpu-query-id)} (function)
@end table
@end defvr
@defvr {Slot} enum
@slotsubindex{enum}@c
@table @strong
@item Type
@t{(signed-byte 32)}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-QUERY-ENUM function, , @t{gpu-query-enum}} (function)
@item Writers
@t{(setf gpu-query-enum)} (function)
@end table
@end defvr
@defvr {Slot} cache-id
@slotsubindex{cache-id}@c
@table @strong
@item Type
@t{(integer 0 7)}
@item Initform
@t{7}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-QUERY-CACHE-ID function, , @t{gpu-query-cache-id}} (function)
@item Writers
@t{(setf gpu-query-cache-id)} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {pixel-format} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>PIXEL-FORMAT structure}@c
@structuresubindex{pixel-format}@c

`pixel-format`s exist to aid the handling and conversion of types in CEPL.@*

OpenGL does not make it easy to understand the types involved with textures.

First there is the name of the type you would use in lisp (or C)@*

Then there is the image-format (sometimes called internal-format) which
specifies the format on the GPU@*

Then there are the types and formats that must be specified when uploading or
downloading data to/from a texture (or rather a texture-backed gpu-array).@*

CEPL's pixel-fromat pulls together enough metadata that conversions to and from
these various representations is easy.@*

Technically you shouldnt need to use this directly as it will be handled by CEPL
however if you ever have to deal with the formats directly, this type can be a
boon.@*

It doesnt cover every combination yet, but will in time. Anything missing is
considered a bug, so please report it on Github so it can be added to the todo
list.@*


@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@t{structure-object} (structure)
@item Direct slots
@defvr {Slot} components
@slotsubindex{components}@c
@table @strong
@item Type
@t{symbol}
@item Initform
@t{(error \"\")}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>PIXEL-FORMAT-COMPONENTS function, , @t{pixel-format-components}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF PIXEL-FORMAT-COMPONENTS) function, , @t{(setf pixel-format-components)}} (function)
@end table
@end defvr
@defvr {Slot} type
@slotsubindex{type}@c
@table @strong
@item Type
@t{symbol}
@item Initform
@t{(error \"\")}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>PIXEL-FORMAT-TYPE function, , @t{pixel-format-type}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF PIXEL-FORMAT-TYPE) function, , @t{(setf pixel-format-type)}} (function)
@end table
@end defvr
@defvr {Slot} normalize
@slotsubindex{normalize}@c
@table @strong
@item Type
@t{boolean}
@item Initform
@t{t}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>PIXEL-FORMAT-NORMALIZE function, , @t{pixel-format-normalize}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF PIXEL-FORMAT-NORMALIZE) function, , @t{(setf pixel-format-normalize)}} (function)
@end table
@end defvr
@defvr {Slot} sizes
@slotsubindex{sizes}@c
@table @strong
@item Type
@t{list}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>PIXEL-FORMAT-SIZES function, , @t{pixel-format-sizes}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF PIXEL-FORMAT-SIZES) function, , @t{(setf pixel-format-sizes)}} (function)
@end table
@end defvr
@defvr {Slot} reversed
@slotsubindex{reversed}@c
@table @strong
@item Type
@t{boolean}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>PIXEL-FORMAT-REVERSED function, , @t{pixel-format-reversed}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF PIXEL-FORMAT-REVERSED) function, , @t{(setf pixel-format-reversed)}} (function)
@end table
@end defvr
@defvr {Slot} comp-length
@slotsubindex{comp-length}@c
@table @strong
@item Type
@t{(unsigned-byte 8)}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>PIXEL-FORMAT-COMP-LENGTH function, , @t{pixel-format-comp-length}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF PIXEL-FORMAT-COMP-LENGTH) function, , @t{(setf pixel-format-comp-length)}} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {primitives-generated-query} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>PRIMITIVES-GENERATED-QUERY structure}@c
@structuresubindex{primitives-generated-query}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@ref{go to the %CEPL<dot>TYPES<colon><colon>SCOPED-GPU-QUERY structure, , @t{scoped-gpu-query}} (structure)
@item Direct slots
@defvr {Slot} enum
@slotsubindex{enum}@c
@table @strong
@item Type
@t{(and (signed-byte 32) (signed-byte 32))}
@item Initform
@t{35975}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>PRIMITIVES-GENERATED-QUERY-ENUM function, , @t{primitives-generated-query-enum}} (function)
@item Writers
@t{(setf primitives-generated-query-enum)} (function)
@end table
@end defvr
@defvr {Slot} cache-id
@slotsubindex{cache-id}@c
@table @strong
@item Type
@t{(and (integer 0 7) (integer 0 7))}
@item Initform
@t{4}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>PRIMITIVES-GENERATED-QUERY-CACHE-ID function, , @t{primitives-generated-query-cache-id}} (function)
@item Writers
@t{(setf primitives-generated-query-cache-id)} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {render-buffer} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>RENDER-BUFFER structure}@c
@structuresubindex{render-buffer}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@t{structure-object} (structure)
@item Direct methods
@t{print-object} (method)
@item Direct slots
@defvr {Slot} id
@slotsubindex{id}@c
@table @strong
@item Type
@t{%cepl.types:gl-id}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%RENDER-BUFFER-ID function, , @t{%render-buffer-id}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %RENDER-BUFFER-ID) function, , @t{(setf %render-buffer-id)}} (function)
@end table
@end defvr
@defvr {Slot} image-format
@slotsubindex{image-format}@c
@table @strong
@item Type
@t{symbol}
@item Initform
@t{(error \"bug\")}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%RENDER-BUFFER-IMAGE-FORMAT function, , @t{%render-buffer-image-format}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %RENDER-BUFFER-IMAGE-FORMAT) function, , @t{(setf %render-buffer-image-format)}} (function)
@end table
@end defvr
@defvr {Slot} resolution
@slotsubindex{resolution}@c
@table @strong
@item Type
@t{glsl-symbols.types:vec2}
@item Initform
@t{(error \"bug: render-buffer resolution not provided\")}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%RENDER-BUFFER-RESOLUTION function, , @t{%render-buffer-resolution}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %RENDER-BUFFER-RESOLUTION) function, , @t{(setf %render-buffer-resolution)}} (function)
@end table
@end defvr
@defvr {Slot} multisample-p
@slotsubindex{multisample-p}@c
@table @strong
@item Type
@t{boolean}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%RENDER-BUFFER-MULTISAMPLE-P function, , @t{%render-buffer-multisample-p}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %RENDER-BUFFER-MULTISAMPLE-P) function, , @t{(setf %render-buffer-multisample-p)}} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {sampler} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>SAMPLER structure}@c
@structuresubindex{sampler}@c

As `sampler` is a structure which we pass to the a gpu-pipeline to specify how the
pipeline should read from a particular `texture` (also known as sampling the
texture).@*

They are created by calling `sample` on a texture. You can then modify the
various parameters and the pass the sampler to a pipeline as a uniform.@*

Sampling Parameters cover four main aspects of how the values are read:@*

- Wrapping@*
- Filtering@*
- LOD@*
- Comparison@*


We will dive into these topics below.@*

**-- Note for beginners --**@*

This area of GL can be incredibly confusing so don't worry if you don't grasp
it immediately. Lots can be done without messing with these values, tackle each
one when you have a usecase for it.@*


**-- Wrapping --**@*

When using normalized texture coordinates we are used to thinking about our
coordinate being between 0s0 and 1s0 and that value dictating where we are
sampling from.@*

However normalized texture coordinates are not limited to values between@*
0s0 and 1s0. They can be any floating-point number.@*

When a texture coordinate is not within the 0  1 range, some means must be
employed to decide what the color value will be.@*

The different approaches are as follows:@*

    :repeat: the texture coordinate wraps around the texture. so a texture
             coordinate of -0.2 becomes the equivalent of 0.8.@*

    :mirrored-repeat: the texture coordinate wraps around like a mirror.@*
                      -0.2 becomes 0.2, -1.2 becomes 0.8, etc.@*

    :clamp-to-edge: the texture coordinate is clamped to the 0  1 range.@*

    :clamp-to-border: the texture coordinate is clamped to the 0  1@*
                      range, but the edge texels are blended with a@*
                      constant border color.@*

    :mirror-clamp-to-edge: (only available with OpenGL 4.4 or
                           :arb-texture-mirror-clamp-to-edge) the texture@*
                           is clamped to the -1  1 range, but mirrors the
                           negative direction with the positive. Basically,@*
                           it acts as :clamp-to-edge, except that it@*
                           takes the absolute value of the texture@*
                           coordinates before clamping.@*

This also applies to Rectangle Textures, except that the range at which they
apply edge sampling is based on the texel width/height of the texture, not@*
the normalized 0  1 range.@*

This does not apply to Buffer Textures, as they must use the texelFetch sampling
functions and thus cannot sample outside of the texel range of the texture.@*

example:@*

    (setf (wrap texture-or-sampler)@*
          #(:clamp-to-edge :repeat-to-edge :clamp-to-edge))@*

    (setf (wrap texture-or-sampler) :clamp-to-edge)@*



**-- Filtering --**@*

Filtering is the process of accessing a particular sample from a `texture`.@*

There are two cases when filtering is relevant: minification and magnification.

Magnification means that the area of the fragment in texture space is smaller
than a texel, and minification means that the area of the fragment in texture
space is larger than a texel.@*

Filtering for these two cases can be set independently.@*

The magnification filter is controlled by the :magnify-filter texture parameter.
This value can be :linear or :nearest.@*

If :nearest is used, then the implementation will select the texel nearest the
texture coordinate; this is commonly called 'point sampling').@*

If :linear is used, the implementation will perform a weighted linear blend
between the nearest adjacent samples.@*

    (setf (magnify-filter tex-or-sampler) :linear)@*
    (setf (magnify-filter tex-or-sampler) :nearest)@*


The minification filter is controlled by the :texture-min-filter texture
parameter. To understand these values better, it is important to discuss what
the particular options are. Here is the full list:@*

    :nearest                 :linear@*
    :nearest-mipmap-nearest  :nearest-mipmap-linear@*
    :linear-mipmap-nearest   :linear-mipmap-linear@*

When doing minification, you can choose to use mipmapping or not. Using
mipmapping means selecting between multiple mipmaps based on the angle and size
of the texture relative to the screen. Whether you use mipmapping or not,@*
you can still select between linear blending of the particular layer or nearest.
And if you do use mipmapping, you can choose to either select a single mipmap to
sample from, or you can sample the two adjacent mipmaps and linearly blend the
resulting values to get the final result.@*

The OpenGL minification settings for these are as follows:@*

    Param Setting            Lin within mip-level@*
    :nearest                 No@*
    :linear                  Yes@*
    :nearest-mipmap-nearest  No@*
    :linear-mipmap-nearest   Yes@*
    :nearest-mipmap-linear   No@*
    :linear-mipmap-linear    Yes@*

    Param Setting            Has mipmapping@*
    :nearest                 No@*
    :linear                  No@*
    :nearest-mipmap-nearest  Yes@*
    :linear-mipmap-nearest   Yes@*
    :nearest-mipmap-linear   Yes@*
    :linear-mipmap-linear    Yes@*

    Param Setting            Linear between mip-levels@*
    :nearest                 -@*
    :linear                  -@*
    :nearest-mipmap-nearest  No@*
    :linear-mipmap-nearest   No@*
    :nearest-mipmap-linear   Yes@*
    :linear-mipmap-linear    Yes@*

Remembering these combinations can be annoying so CEPL provides an additional
function called #'set-minify-filter see the docstring for details@*

examples:@*

    (setf (minify-filter tex-or-sampler) :linear)@*
    (setf (minify-filter tex-or-sampler) :nearest-mipmap-nearest)
    (setf-minify-filter tex-or-sampler :nearest :nearest)@*


**-- LOD --**@*

There is a pair of sampling parameters that affect the mipmap image selection:
:max-lod and :min-lod (floating-point values).@*

The way these work in mipmap selection is quite complicated; the specification
goes into full detail about it.@*

example:@*

    (setf (min-lod texture-or-sampler) value)@*
    (setf (max-lod texture-or-sampler) value)@*


LOD bias:@*
The mipmap image selection process can be adjusted coarsely by using the
:lod-bias sampling parameter. This bias will be added to the mipmap@*
LOD calculation (as well as added to the bias specified in one of the `texture`
accessing functions in GLSL), which is used to select the image. A positive bias
means that larger mipmaps will be selected even when the texture is viewed from
farther away. This can cause visual aliasing, but in small quantities it can
make textures a bit more sharp.@*

    (setf (lod-bias texture-or-sampler) value)@*


**-- Comparison --**@*

-WARNING-@*

This feature is currently unsupported until shadow samplers are more fully
tested in CEPL. Use at your own risk@*


Depth `texture`s (textures that have a depth component image format) can be
sampled in one of two ways. They can be sampled as a normal texture, which
simply retrieves the depth value (with filtering applied). This will return a
vec4 containing a single floating-point value.@*

They can also be fetched in comparison mode. This means that sampling from@*
the texture requires a value to compare to those pulled from the texture;@*
this value is called the reference value. The result of the comparison@*
depends on the comparison function set in the texture. If the function
succeeds, the resulting value is 1s0; if it fails, it is 0s0.@*

When linear filtering is used, the actual returned value is
implementation-defined. However, the value will be on the range 0  1 and@*
will be proportional to the number of neighboring texels that pass the
comparison based on the single given value.@*

If the texture is a normalized integer depth format, then the reference value
is clamped to 0  1, to match the values from the texture. Otherwise, the value
is not clamped.@*

Using this mode requires two special settings. First, the `sampler` used in GLSL
must be a shadow sampler. Second, the texture used in that sampler must have
activated depth comparison mode. Attempting to use a texture without comparison
with a shadow sampler, or vice-versa, will result in an error upon rendering.@*

To set the texture to comparison mode, set the :texture-compare-mode@*
texture parameter to :compare-ref-to-texture. The comparison function to@*
use when comparing the reference to the texture is set with the
:texture-compare-func texture parameter. Acceptable values are:@*

    :never (always fails)@*
    :always (always succeeds)@*
    :less@*
    :lequal@*
    :equal,@*
    :not-equal@*
    :gequal@*
    :greater@*

The comparison works as follows:@*

    (funcall operator ref texture)@*

Where ref is the reference value given to the texture lookup function by@*
GLSL, and texture is the value fetched from the texture. So :LESS will be@*
true if the reference value is strictly less than the value pulled from the
texture.
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@t{structure-object} (structure)
@item Direct methods
@itemize @bullet
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>FREE %CEPL<dot>TYPES<colon><colon>SAMPLER method, , @t{free}} (method)
@item
@t{print-object} (method)
@item
@ref{go to the %CEPL<dot>TYPES<colon><colon>CAN-BE-SHARED-BETWEEN-CONTEXTS-P %CEPL<dot>TYPES<colon><colon>SAMPLER method, , @t{can-be-shared-between-contexts-p}} (method)
@end itemize
@item Direct slots
@defvr {Slot} context-id
@slotsubindex{context-id}@c
@table @strong
@item Type
@t{%cepl.types:gl-id}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-CONTEXT-ID function, , @t{%sampler-context-id}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-CONTEXT-ID) function, , @t{(setf %sampler-context-id)}} (function)
@end table
@end defvr
@defvr {Slot} id-box
@slotsubindex{id-box}@c
@table @strong
@item Type
@t{%cepl.types:sampler-id-box}
@item Initform
@t{(%cepl.types:make-sampler-id-box)}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-ID-BOX function, , @t{%sampler-id-box}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-ID-BOX) function, , @t{(setf %sampler-id-box)}} (function)
@end table
@end defvr
@defvr {Slot} type
@slotsubindex{type}@c
@table @strong
@item Type
@t{symbol}
@item Initform
@t{(error \"\")}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-TYPE function, , @t{%sampler-type}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-TYPE) function, , @t{(setf %sampler-type)}} (function)
@end table
@end defvr
@defvr {Slot} texture
@slotsubindex{texture}@c
@table @strong
@item Type
@t{glsl-symbols.functions:texture}
@item Initform
@t{(error \"\")}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-TEXTURE function, , @t{%sampler-texture}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-TEXTURE) function, , @t{(setf %sampler-texture)}} (function)
@end table
@end defvr
@defvr {Slot} lod-bias
@slotsubindex{lod-bias}@c
@table @strong
@item Type
@t{single-float}
@item Initform
@t{0.0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-LOD-BIAS function, , @t{%sampler-lod-bias}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-LOD-BIAS) function, , @t{(setf %sampler-lod-bias)}} (function)
@end table
@end defvr
@defvr {Slot} min-lod
@slotsubindex{min-lod}@c
@table @strong
@item Type
@t{single-float}
@item Initform
@t{-1000.0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-MIN-LOD function, , @t{%sampler-min-lod}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-MIN-LOD) function, , @t{(setf %sampler-min-lod)}} (function)
@end table
@end defvr
@defvr {Slot} max-lod
@slotsubindex{max-lod}@c
@table @strong
@item Type
@t{single-float}
@item Initform
@t{1000.0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-MAX-LOD function, , @t{%sampler-max-lod}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-MAX-LOD) function, , @t{(setf %sampler-max-lod)}} (function)
@end table
@end defvr
@defvr {Slot} border-color
@slotsubindex{border-color}@c
@table @strong
@item Type
@t{glsl-symbols.types:vec4}
@item Initform
@t{(glsl-symbols.types:vec4 0.0 0.0 0.0 0.0)}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-BORDER-COLOR function, , @t{%sampler-border-color}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-BORDER-COLOR) function, , @t{(setf %sampler-border-color)}} (function)
@end table
@end defvr
@defvr {Slot} expects-mipmap
@slotsubindex{expects-mipmap}@c
@table @strong
@item Type
@t{boolean}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-EXPECTS-MIPMAP function, , @t{%sampler-expects-mipmap}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-EXPECTS-MIPMAP) function, , @t{(setf %sampler-expects-mipmap)}} (function)
@end table
@end defvr
@defvr {Slot} minify-filter
@slotsubindex{minify-filter}@c
@table @strong
@item Type
@t{keyword}
@item Initform
@t{:linear}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-MINIFY-FILTER function, , @t{%sampler-minify-filter}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-MINIFY-FILTER) function, , @t{(setf %sampler-minify-filter)}} (function)
@end table
@end defvr
@defvr {Slot} magnify-filter
@slotsubindex{magnify-filter}@c
@table @strong
@item Type
@t{keyword}
@item Initform
@t{:linear}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-MAGNIFY-FILTER function, , @t{%sampler-magnify-filter}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-MAGNIFY-FILTER) function, , @t{(setf %sampler-magnify-filter)}} (function)
@end table
@end defvr
@defvr {Slot} wrap
@slotsubindex{wrap}@c
@table @strong
@item Type
@t{vector}
@item Initform
@t{#(:repeat :repeat :repeat)}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-WRAP function, , @t{%sampler-wrap}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-WRAP) function, , @t{(setf %sampler-wrap)}} (function)
@end table
@end defvr
@defvr {Slot} expects-depth
@slotsubindex{expects-depth}@c
@table @strong
@item Type
@t{boolean}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-EXPECTS-DEPTH function, , @t{%sampler-expects-depth}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-EXPECTS-DEPTH) function, , @t{(setf %sampler-expects-depth)}} (function)
@end table
@end defvr
@defvr {Slot} compare
@slotsubindex{compare}@c
@table @strong
@item Type
@t{symbol}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-COMPARE function, , @t{%sampler-compare}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-COMPARE) function, , @t{(setf %sampler-compare)}} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {sampler-id-box} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>SAMPLER-ID-BOX structure}@c
@structuresubindex{sampler-id-box}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@t{structure-object} (structure)
@item Direct slots
@defvr {Slot} id
@slotsubindex{id}@c
@table @strong
@item Type
@t{(signed-byte 32)}
@item Initform
@t{-1}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>SAMPLER-ID-BOX-ID function, , @t{sampler-id-box-id}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF SAMPLER-ID-BOX-ID) function, , @t{(setf sampler-id-box-id)}} (function)
@end table
@end defvr
@defvr {Slot} shared-p
@slotsubindex{shared-p}@c
@table @strong
@item Type
@t{boolean}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>SAMPLER-ID-BOX-SHARED-P function, , @t{sampler-id-box-shared-p}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF SAMPLER-ID-BOX-SHARED-P) function, , @t{(setf sampler-id-box-shared-p)}} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {samples-passed-query} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>SAMPLES-PASSED-QUERY structure}@c
@structuresubindex{samples-passed-query}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@ref{go to the %CEPL<dot>TYPES<colon><colon>SCOPED-GPU-QUERY structure, , @t{scoped-gpu-query}} (structure)
@item Direct slots
@defvr {Slot} enum
@slotsubindex{enum}@c
@table @strong
@item Type
@t{(and (signed-byte 32) (signed-byte 32))}
@item Initform
@t{35092}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>SAMPLES-PASSED-QUERY-ENUM function, , @t{samples-passed-query-enum}} (function)
@item Writers
@t{(setf samples-passed-query-enum)} (function)
@end table
@end defvr
@defvr {Slot} cache-id
@slotsubindex{cache-id}@c
@table @strong
@item Type
@t{(and (integer 0 7) (integer 0 7))}
@item Initform
@t{1}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>SAMPLES-PASSED-QUERY-CACHE-ID function, , @t{samples-passed-query-cache-id}} (function)
@item Writers
@t{(setf samples-passed-query-cache-id)} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {scoped-gpu-query} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>SCOPED-GPU-QUERY structure}@c
@structuresubindex{scoped-gpu-query}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-QUERY structure, , @t{gpu-query}} (structure)
@item Direct subclasses
@itemize @bullet
@item
@ref{go to the %CEPL<dot>TYPES<colon><colon>SAMPLES-PASSED-QUERY structure, , @t{samples-passed-query}} (structure)
@item
@ref{go to the %CEPL<dot>TYPES<colon><colon>ANY-SAMPLES-PASSED-QUERY structure, , @t{any-samples-passed-query}} (structure)
@item
@ref{go to the %CEPL<dot>TYPES<colon><colon>ANY-SAMPLES-PASSED-CONSERVATIVE-QUERY structure, , @t{any-samples-passed-conservative-query}} (structure)
@item
@ref{go to the %CEPL<dot>TYPES<colon><colon>PRIMITIVES-GENERATED-QUERY structure, , @t{primitives-generated-query}} (structure)
@item
@ref{go to the %CEPL<dot>TYPES<colon><colon>TRANSFORM-FEEDBACK-PRIMITIVES-WRITTEN-QUERY structure, , @t{transform-feedback-primitives-written-query}} (structure)
@item
@ref{go to the %CEPL<dot>TYPES<colon><colon>TIME-ELAPSED-QUERY structure, , @t{time-elapsed-query}} (structure)
@end itemize
@item Direct slots
@defvr {Slot} active-p
@slotsubindex{active-p}@c
@table @strong
@item Type
@t{boolean}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>SCOPED-GPU-QUERY-ACTIVE-P function, , @t{scoped-gpu-query-active-p}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF SCOPED-GPU-QUERY-ACTIVE-P) function, , @t{(setf scoped-gpu-query-active-p)}} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {ssbo} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>SSBO structure}@c
@structuresubindex{ssbo}@c

`SSBO` is a structure that abstracts an OpenGL Shader Storage Buffer Object

An SSBO is chunk of data stored in a `gpu-buffer`, which can be used in shader
pipelines. They are very similar to UBOs and are used in pretty much the same
way. The big differences between them are:@*


- SSBOs can be much larger. The OpenGL spec guarantees that UBOs can@*
  be up to 16KB in size (implementations can allow them to be@*
  bigger). The spec guarantees that SSBOs can be up to 128MB. Most
  implementations will let you allocate a size up to the limit of GPU
  memory.@*

- SSBOs are writable (even atomically) whereas UBOs are not.@*
  Be aware that SSBOs reads and writes use incoherent memory accesses,@*
  so they need the appropriate barriers.@*

- SSBO access, all things being equal, will likely be slower than UBO
  access. SSBOs generally are accesses like buffer textures, while UBO
  data is accessed through internal shader-accessible memory reads. At@*
  the very least, UBOs will be no slower than SSBOs.@*

- *Not yet supported in CEPL*@*
  SSBOs can have variable storage, up to whatever buffer range was@*
  bound for that particular buffer; UBOs must have a specific, fixed
  storage size. This means that you can have an array of arbitrary@*
  length in an SSBO (at the end, rather). The actual size of the@*
  array, based on the range of the buffer bound, can be queried at@*
  runtime in the shader using the length function on the unbounded@*
  array variable.
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@t{structure-object} (structure)
@item Direct methods
@itemize @bullet
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>FREE %CEPL<dot>TYPES<colon><colon>SSBO method, , @t{free}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G %CEPL<dot>TYPES<colon><colon>SSBO (eql KEYWORD<colon><colon>LISP) method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G COMMON-LISP<colon><colon>ARRAY %CEPL<dot>TYPES<colon><colon>SSBO method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G COMMON-LISP<colon><colon>LIST %CEPL<dot>TYPES<colon><colon>SSBO method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G %CEPL<dot>TYPES<colon><colon>C-ARRAY %CEPL<dot>TYPES<colon><colon>SSBO method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PULL-G %CEPL<dot>TYPES<colon><colon>SSBO method, , @t{pull-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PUSH-G COMMON-LISP<colon><colon>ARRAY %CEPL<dot>TYPES<colon><colon>SSBO method, , @t{push-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PUSH-G COMMON-LISP<colon><colon>LIST %CEPL<dot>TYPES<colon><colon>SSBO method, , @t{push-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PUSH-G %CEPL<dot>TYPES<colon><colon>C-ARRAY %CEPL<dot>TYPES<colon><colon>SSBO method, , @t{push-g}} (method)
@item
@t{print-object} (method)
@end itemize
@item Direct slots
@defvr {Slot} id
@slotsubindex{id}@c
@table @strong
@item Type
@t{%cepl.types:gl-id}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>SSBO-ID function, , @t{ssbo-id}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF SSBO-ID) function, , @t{(setf ssbo-id)}} (function)
@end table
@end defvr
@defvr {Slot} data
@slotsubindex{data}@c
@table @strong
@item Type
@t{%cepl.types:gpu-array-bb}
@item Initform
@t{(error \"gpu-array must be provided when making ssbo\")}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>SSBO-DATA function, , @t{ssbo-data}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF SSBO-DATA) function, , @t{(setf ssbo-data)}} (function)
@end table
@end defvr
@defvr {Slot} index
@slotsubindex{index}@c
@table @strong
@item Type
@t{%cepl.types:c-array-index}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>SSBO-INDEX function, , @t{ssbo-index}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF SSBO-INDEX) function, , @t{(setf ssbo-index)}} (function)
@end table
@end defvr
@defvr {Slot} owns-gpu-array
@slotsubindex{owns-gpu-array}@c
@table @strong
@item Type
@t{boolean}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>SSBO-OWNS-GPU-ARRAY function, , @t{ssbo-owns-gpu-array}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF SSBO-OWNS-GPU-ARRAY) function, , @t{(setf ssbo-owns-gpu-array)}} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {stencil-params} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>STENCIL-PARAMS structure}@c
@structuresubindex{stencil-params}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@t{structure-object} (structure)
@item Direct methods
@t{print-object} (method)
@item Direct slots
@defvr {Slot} test
@slotsubindex{test}@c
@table @strong
@item Type
@t{(signed-byte 32)}
@item Initform
@t{512}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%STENCIL-PARAMS-TEST function, , @t{%stencil-params-test}} (function)
@item Writers
@t{(setf %stencil-params-test)} (function)
@end table
@end defvr
@defvr {Slot} value
@slotsubindex{value}@c
@table @strong
@item Type
@t{%cepl.types:stencil-mask}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%STENCIL-PARAMS-VALUE function, , @t{%stencil-params-value}} (function)
@item Writers
@t{(setf %stencil-params-value)} (function)
@end table
@end defvr
@defvr {Slot} mask
@slotsubindex{mask}@c
@table @strong
@item Type
@t{%cepl.types:stencil-mask}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%STENCIL-PARAMS-MASK function, , @t{%stencil-params-mask}} (function)
@item Writers
@t{(setf %stencil-params-mask)} (function)
@end table
@end defvr
@defvr {Slot} on-stencil-test-fail
@slotsubindex{on-stencil-test-fail}@c
@table @strong
@item Type
@t{(signed-byte 32)}
@item Initform
@t{7680}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%STENCIL-PARAMS-ON-STENCIL-TEST-FAIL function, , @t{%stencil-params-on-stencil-test-fail}} (function)
@item Writers
@t{(setf %stencil-params-on-stencil-test-fail)} (function)
@end table
@end defvr
@defvr {Slot} on-stencil-pass-depth-test-fail
@slotsubindex{on-stencil-pass-depth-test-fail}@c
@table @strong
@item Type
@t{(signed-byte 32)}
@item Initform
@t{7680}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%STENCIL-PARAMS-ON-STENCIL-PASS-DEPTH-TEST-FAIL function, , @t{%stencil-params-on-stencil-pass-depth-test-fail}} (function)
@item Writers
@t{(setf %stencil-params-on-stencil-pass-depth-test-fail)} (function)
@end table
@end defvr
@defvr {Slot} on-stencil-pass-depth-test-pass
@slotsubindex{on-stencil-pass-depth-test-pass}@c
@table @strong
@item Type
@t{(signed-byte 32)}
@item Initform
@t{7680}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%STENCIL-PARAMS-ON-STENCIL-PASS-DEPTH-TEST-PASS function, , @t{%stencil-params-on-stencil-pass-depth-test-pass}} (function)
@item Writers
@t{(setf %stencil-params-on-stencil-pass-depth-test-pass)} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {time-elapsed-query} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TIME-ELAPSED-QUERY structure}@c
@structuresubindex{time-elapsed-query}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@ref{go to the %CEPL<dot>TYPES<colon><colon>SCOPED-GPU-QUERY structure, , @t{scoped-gpu-query}} (structure)
@item Direct slots
@defvr {Slot} enum
@slotsubindex{enum}@c
@table @strong
@item Type
@t{(and (signed-byte 32) (signed-byte 32))}
@item Initform
@t{35007}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>TIME-ELAPSED-QUERY-ENUM function, , @t{time-elapsed-query-enum}} (function)
@item Writers
@t{(setf time-elapsed-query-enum)} (function)
@end table
@end defvr
@defvr {Slot} cache-id
@slotsubindex{cache-id}@c
@table @strong
@item Type
@t{(and (integer 0 7) (integer 0 7))}
@item Initform
@t{6}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>TIME-ELAPSED-QUERY-CACHE-ID function, , @t{time-elapsed-query-cache-id}} (function)
@item Writers
@t{(setf time-elapsed-query-cache-id)} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {timestamp-query} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TIMESTAMP-QUERY structure}@c
@structuresubindex{timestamp-query}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-QUERY structure, , @t{gpu-query}} (structure)
@item Direct slots
@defvr {Slot} enum
@slotsubindex{enum}@c
@table @strong
@item Type
@t{(and (signed-byte 32) (signed-byte 32))}
@item Initform
@t{36392}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>TIMESTAMP-QUERY-ENUM function, , @t{timestamp-query-enum}} (function)
@item Writers
@t{(setf timestamp-query-enum)} (function)
@end table
@end defvr
@defvr {Slot} cache-id
@slotsubindex{cache-id}@c
@table @strong
@item Type
@t{(and (integer 0 7) (integer 0 7))}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>TIMESTAMP-QUERY-CACHE-ID function, , @t{timestamp-query-cache-id}} (function)
@item Writers
@t{(setf timestamp-query-cache-id)} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {transform-feedback-primitives-written-query} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TRANSFORM-FEEDBACK-PRIMITIVES-WRITTEN-QUERY structure}@c
@structuresubindex{transform-feedback-primitives-written-query}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@ref{go to the %CEPL<dot>TYPES<colon><colon>SCOPED-GPU-QUERY structure, , @t{scoped-gpu-query}} (structure)
@item Direct slots
@defvr {Slot} enum
@slotsubindex{enum}@c
@table @strong
@item Type
@t{(and (signed-byte 32) (signed-byte 32))}
@item Initform
@t{35976}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>TRANSFORM-FEEDBACK-PRIMITIVES-WRITTEN-QUERY-ENUM function, , @t{transform-feedback-primitives-written-query-enum}} (function)
@item Writers
@t{(setf transform-feedback-primitives-written-query-enum)} (function)
@end table
@end defvr
@defvr {Slot} cache-id
@slotsubindex{cache-id}@c
@table @strong
@item Type
@t{(and (integer 0 7) (integer 0 7))}
@item Initform
@t{5}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>TRANSFORM-FEEDBACK-PRIMITIVES-WRITTEN-QUERY-CACHE-ID function, , @t{transform-feedback-primitives-written-query-cache-id}} (function)
@item Writers
@t{(setf transform-feedback-primitives-written-query-cache-id)} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {transform-feedback-stream} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TRANSFORM-FEEDBACK-STREAM structure}@c
@structuresubindex{transform-feedback-stream}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@t{structure-object} (structure)
@item Direct methods
@itemize @bullet
@item
@t{print-object} (method)
@item
@ref{go to the %CEPL<dot>TYPES<colon><colon>CAN-BE-SHARED-BETWEEN-CONTEXTS-P %CEPL<dot>TYPES<colon><colon>TRANSFORM-FEEDBACK-STREAM method, , @t{can-be-shared-between-contexts-p}} (method)
@end itemize
@item Direct slots
@defvr {Slot} arrays
@slotsubindex{arrays}@c
@table @strong
@item Type
@t{(or null (array %cepl.types:gpu-array-bb (*)))}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%TFS-ARRAYS function, , @t{%tfs-arrays}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %TFS-ARRAYS) function, , @t{(setf %tfs-arrays)}} (function)
@end table
@end defvr
@defvr {Slot} pending-arrays
@slotsubindex{pending-arrays}@c
@table @strong
@item Type
@t{(or null (array %cepl.types:gpu-array-bb (*)))}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%TFS-PENDING-ARRAYS function, , @t{%tfs-pending-arrays}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %TFS-PENDING-ARRAYS) function, , @t{(setf %tfs-pending-arrays)}} (function)
@end table
@end defvr
@defvr {Slot} bound
@slotsubindex{bound}@c
@table @strong
@item Type
@t{boolean}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%TFS-BOUND function, , @t{%tfs-bound}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %TFS-BOUND) function, , @t{(setf %tfs-bound)}} (function)
@end table
@end defvr
@defvr {Slot} current-prog-id
@slotsubindex{current-prog-id}@c
@table @strong
@item Type
@t{%cepl.types:gl-id}
@item Initform
@t{%cepl.types:+unknown-gl-id+}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%TFS-CURRENT-PROG-ID function, , @t{%tfs-current-prog-id}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %TFS-CURRENT-PROG-ID) function, , @t{(setf %tfs-current-prog-id)}} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {ubo} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>UBO structure}@c
@structuresubindex{ubo}@c

A `UBO` is a structure that abstracts an OpenGL Uniform Buffer Object@*

A Ubo is chunk of data stored in a `gpu-buffer`, which can be used as a uniform
in shader pipelines.@*

The advantage of using a UBO over just passing the data as regular unforms is
that UBOs can be used to share uniforms between different programs, as well as
quickly change between sets of uniforms for the same pipeline.@*

Let's expand on that a little:@*

Switching between uniform buffer bindings is typically faster than switching
dozens of uniforms in a pipeline.@*

Also, uniform buffer objects can typically store more data than non-buffered
uniforms. So they can be used to store and access larger blocks of data than
unbuffered uniform values.@*

Lastly, they can be used to share information between different programs.@*
So modifying a single buffer can effectively allow uniforms in multiple programs
to be updated.
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@t{structure-object} (structure)
@item Direct methods
@itemize @bullet
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>FREE %CEPL<dot>TYPES<colon><colon>UBO method, , @t{free}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G %CEPL<dot>TYPES<colon><colon>UBO (eql KEYWORD<colon><colon>LISP) method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G COMMON-LISP<colon><colon>ARRAY %CEPL<dot>TYPES<colon><colon>UBO method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G COMMON-LISP<colon><colon>LIST %CEPL<dot>TYPES<colon><colon>UBO method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G %CEPL<dot>TYPES<colon><colon>C-ARRAY %CEPL<dot>TYPES<colon><colon>UBO method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PULL-G %CEPL<dot>TYPES<colon><colon>UBO method, , @t{pull-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PUSH-G COMMON-LISP<colon><colon>ARRAY %CEPL<dot>TYPES<colon><colon>UBO method, , @t{push-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PUSH-G COMMON-LISP<colon><colon>LIST %CEPL<dot>TYPES<colon><colon>UBO method, , @t{push-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PUSH-G %CEPL<dot>TYPES<colon><colon>C-ARRAY %CEPL<dot>TYPES<colon><colon>UBO method, , @t{push-g}} (method)
@item
@t{print-object} (method)
@end itemize
@item Direct slots
@defvr {Slot} id
@slotsubindex{id}@c
@table @strong
@item Type
@t{%cepl.types:gl-id}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>UBO-ID function, , @t{ubo-id}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF UBO-ID) function, , @t{(setf ubo-id)}} (function)
@end table
@end defvr
@defvr {Slot} data
@slotsubindex{data}@c
@table @strong
@item Type
@t{%cepl.types:gpu-array-bb}
@item Initform
@t{(error \"gpu-array must be provided when making ubo\")}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>UBO-DATA function, , @t{ubo-data}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF UBO-DATA) function, , @t{(setf ubo-data)}} (function)
@end table
@end defvr
@defvr {Slot} index
@slotsubindex{index}@c
@table @strong
@item Type
@t{%cepl.types:c-array-index}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>UBO-INDEX function, , @t{ubo-index}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF UBO-INDEX) function, , @t{(setf ubo-index)}} (function)
@end table
@end defvr
@defvr {Slot} owns-gpu-array
@slotsubindex{owns-gpu-array}@c
@table @strong
@item Type
@t{boolean}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>UBO-OWNS-GPU-ARRAY function, , @t{ubo-owns-gpu-array}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF UBO-OWNS-GPU-ARRAY) function, , @t{(setf ubo-owns-gpu-array)}} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {viewport} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>VIEWPORT structure}@c
@structuresubindex{viewport}@c

`Viewport` is a structure that represents a retangular region of the surface
that CEPL can draw into.@*

There is always a viewport current when rendering. If one of your own is not
current then CEPL will use its default viewport, the resolution of which is the
same as that of the surface when it was created.@*

The default viewport can be modified, so feel free to update the resolution if
the surface size changes.
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@t{structure-object} (structure)
@item Direct methods
@itemize @bullet
@item
@t{origin} (method)
@item
@ref{go to the CEPL<dot>MEASUREMENTS<colon><colon>ORIGIN %CEPL<dot>TYPES<colon><colon>VIEWPORT method, , @t{origin}} (method)
@item
@t{resolution} (method)
@item
@ref{go to the CEPL<dot>MEASUREMENTS<colon><colon>RESOLUTION %CEPL<dot>TYPES<colon><colon>VIEWPORT method, , @t{resolution}} (method)
@item
@t{dimensions} (method)
@item
@ref{go to the CEPL<dot>MEASUREMENTS<colon><colon>DIMENSIONS %CEPL<dot>TYPES<colon><colon>VIEWPORT method, , @t{dimensions}} (method)
@end itemize
@item Direct slots
@defvr {Slot} resolution-x
@slotsubindex{resolution-x}@c
@table @strong
@item Type
@t{(unsigned-byte 16)}
@item Initform
@t{320}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%VIEWPORT-RESOLUTION-X function, , @t{%viewport-resolution-x}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %VIEWPORT-RESOLUTION-X) function, , @t{(setf %viewport-resolution-x)}} (function)
@end table
@end defvr
@defvr {Slot} resolution-y
@slotsubindex{resolution-y}@c
@table @strong
@item Type
@t{(unsigned-byte 16)}
@item Initform
@t{240}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%VIEWPORT-RESOLUTION-Y function, , @t{%viewport-resolution-y}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %VIEWPORT-RESOLUTION-Y) function, , @t{(setf %viewport-resolution-y)}} (function)
@end table
@end defvr
@defvr {Slot} origin-x
@slotsubindex{origin-x}@c
@table @strong
@item Type
@t{(unsigned-byte 16)}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%VIEWPORT-ORIGIN-X function, , @t{%viewport-origin-x}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %VIEWPORT-ORIGIN-X) function, , @t{(setf %viewport-origin-x)}} (function)
@end table
@end defvr
@defvr {Slot} origin-y
@slotsubindex{origin-y}@c
@table @strong
@item Type
@t{(unsigned-byte 16)}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%VIEWPORT-ORIGIN-Y function, , @t{%viewport-origin-y}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %VIEWPORT-ORIGIN-Y) function, , @t{(setf %viewport-origin-y)}} (function)
@end table
@end defvr
@end table
@end deftp
" :AFTER-MENU-CONTENTS NIL) :PREVIOUS #11# :UP #2# :CHILDREN NIL :BEFORE-MENU-CONTENTS "@deftp {Condition} {adjust-gpu-array-mismatched-dimensions} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>ADJUST-GPU-ARRAY-MISMATCHED-DIMENSIONS condition}@c
@conditionsubindex{adjust-gpu-array-mismatched-dimensions}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} current-dim
@slotsubindex{current-dim}@c
@table @strong
@item Initargs
@t{:current-dim}
@end table
@end defvr
@defvr {Slot} new-dim
@slotsubindex{new-dim}@c
@table @strong
@item Initargs
@t{:new-dim}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {adjust-gpu-array-shared-buffer} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>ADJUST-GPU-ARRAY-SHARED-BUFFER condition}@c
@conditionsubindex{adjust-gpu-array-shared-buffer}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} array
@slotsubindex{array}@c
@table @strong
@item Initargs
@t{:array}
@end table
@end defvr
@defvr {Slot} shared-count
@slotsubindex{shared-count}@c
@table @strong
@item Initargs
@t{:shared-count}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {another-query-is-active} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>ANOTHER-QUERY-IS-ACTIVE condition}@c
@conditionsubindex{another-query-is-active}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} query
@slotsubindex{query}@c
@table @strong
@item Initargs
@t{:query}
@end table
@end defvr
@defvr {Slot} current
@slotsubindex{current}@c
@table @strong
@item Initargs
@t{:current}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {attachment-viewport-empty-fbo} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>ATTACHMENT-VIEWPORT-EMPTY-FBO condition}@c
@conditionsubindex{attachment-viewport-empty-fbo}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} fbo
@slotsubindex{fbo}@c
@table @strong
@item Initargs
@t{:fbo}
@end table
@end defvr
@defvr {Slot} attachment
@slotsubindex{attachment}@c
@table @strong
@item Initargs
@t{:attachment}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {attachments-with-different-sizes} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>ATTACHMENTS-WITH-DIFFERENT-SIZES condition}@c
@conditionsubindex{attachments-with-different-sizes}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} args
@slotsubindex{args}@c
@table @strong
@item Initargs
@t{:args}
@end table
@end defvr
@defvr {Slot} sizes
@slotsubindex{sizes}@c
@table @strong
@item Initargs
@t{:sizes}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {bad-c-array-element} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>BAD-C-ARRAY-ELEMENT condition}@c
@conditionsubindex{bad-c-array-element}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} incorrect-type
@slotsubindex{incorrect-type}@c
@table @strong
@item Initargs
@t{:incorrect-type}
@end table
@end defvr
@defvr {Slot} correct-type
@slotsubindex{correct-type}@c
@table @strong
@item Initargs
@t{:correct-type}
@end table
@end defvr
@defvr {Slot} elem
@slotsubindex{elem}@c
@table @strong
@item Initargs
@t{:elem}
@end table
@end defvr
@defvr {Slot} initial-contents
@slotsubindex{initial-contents}@c
@table @strong
@item Initargs
@t{:initial-contents}
@end table
@end defvr
@defvr {Slot} extra-info-string
@slotsubindex{extra-info-string}@c
@table @strong
@item Initargs
@t{:extra-info-string}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {bad-type-for-buffer-stream-data} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>BAD-TYPE-FOR-BUFFER-STREAM-DATA condition}@c
@conditionsubindex{bad-type-for-buffer-stream-data}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} type
@slotsubindex{type}@c
@table @strong
@item Initargs
@t{:type}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {bake-invalid-pipeling-arg} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>BAKE-INVALID-PIPELING-ARG condition}@c
@conditionsubindex{bake-invalid-pipeling-arg}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} invalid-arg
@slotsubindex{invalid-arg}@c
@table @strong
@item Initargs
@t{:invalid-arg}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {bake-invalid-uniform-name} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>BAKE-INVALID-UNIFORM-NAME condition}@c
@conditionsubindex{bake-invalid-uniform-name}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} proposed
@slotsubindex{proposed}@c
@table @strong
@item Initargs
@t{:proposed}
@end table
@end defvr
@defvr {Slot} invalid
@slotsubindex{invalid}@c
@table @strong
@item Initargs
@t{:invalid}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {bake-uniform-invalid-values} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>BAKE-UNIFORM-INVALID-VALUES condition}@c
@conditionsubindex{bake-uniform-invalid-values}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} proposed
@slotsubindex{proposed}@c
@table @strong
@item Initargs
@t{:proposed}
@end table
@end defvr
@defvr {Slot} invalid
@slotsubindex{invalid}@c
@table @strong
@item Initargs
@t{:invalid}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {buffer-backed-texture-establish-image-format} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>BUFFER-BACKED-TEXTURE-ESTABLISH-IMAGE-FORMAT condition}@c
@conditionsubindex{buffer-backed-texture-establish-image-format}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} type-name
@slotsubindex{type-name}@c
@table @strong
@item Initargs
@t{:type-name}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {buffer-backed-texture-invalid-args} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>BUFFER-BACKED-TEXTURE-INVALID-ARGS condition}@c
@conditionsubindex{buffer-backed-texture-invalid-args}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@end table
@end deftp
@deftp {Condition} {buffer-backed-texture-invalid-image-format} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>BUFFER-BACKED-TEXTURE-INVALID-IMAGE-FORMAT condition}@c
@conditionsubindex{buffer-backed-texture-invalid-image-format}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} type-name
@slotsubindex{type-name}@c
@table @strong
@item Initargs
@t{:type-name}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {buffer-backed-texture-invalid-samplers} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>BUFFER-BACKED-TEXTURE-INVALID-SAMPLERS condition}@c
@conditionsubindex{buffer-backed-texture-invalid-samplers}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@end table
@end deftp
@deftp {Condition} {buffer-stream-has-invalid-primitive-for-stream} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>BUFFER-STREAM-HAS-INVALID-PRIMITIVE-FOR-STREAM condition}@c
@conditionsubindex{buffer-stream-has-invalid-primitive-for-stream}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} name
@slotsubindex{name}@c
@table @strong
@item Initargs
@t{:name}
@end table
@end defvr
@defvr {Slot} pline-prim
@slotsubindex{pline-prim}@c
@table @strong
@item Initargs
@t{:pline-prim}
@end table
@end defvr
@defvr {Slot} stream-prim
@slotsubindex{stream-prim}@c
@table @strong
@item Initargs
@t{:stream-prim}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {c-array-total-size-type-error} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>C-ARRAY-TOTAL-SIZE-TYPE-ERROR condition}@c
@conditionsubindex{c-array-total-size-type-error}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} size
@slotsubindex{size}@c
@table @strong
@item Initargs
@t{:size}
@end table
@end defvr
@defvr {Slot} required-type
@slotsubindex{required-type}@c
@table @strong
@item Initargs
@t{:required-type}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {cannot-extract-stream-length-from-layouts} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>CANNOT-EXTRACT-STREAM-LENGTH-FROM-LAYOUTS condition}@c
@conditionsubindex{cannot-extract-stream-length-from-layouts}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} layouts
@slotsubindex{layouts}@c
@table @strong
@item Initargs
@t{:layouts}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {cannot-keep-data-when-uploading} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>CANNOT-KEEP-DATA-WHEN-UPLOADING condition}@c
@conditionsubindex{cannot-keep-data-when-uploading}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} data
@slotsubindex{data}@c
@table @strong
@item Initargs
@t{:data}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {compile-g-missing-requested-feature} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>COMPILE-G-MISSING-REQUESTED-FEATURE condition}@c
@conditionsubindex{compile-g-missing-requested-feature}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} form
@slotsubindex{form}@c
@table @strong
@item Initargs
@t{:form}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {compute-pipeline-must-be-single-stage} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>COMPUTE-PIPELINE-MUST-BE-SINGLE-STAGE condition}@c
@conditionsubindex{compute-pipeline-must-be-single-stage}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} name
@slotsubindex{name}@c
@table @strong
@item Initargs
@t{:name}
@end table
@end defvr
@defvr {Slot} stages
@slotsubindex{stages}@c
@table @strong
@item Initargs
@t{:stages}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {could-not-layout-type} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>COULD-NOT-LAYOUT-TYPE condition}@c
@conditionsubindex{could-not-layout-type}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} type
@slotsubindex{type}@c
@table @strong
@item Initargs
@t{:type}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {delete-multi-func-error} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>DELETE-MULTI-FUNC-ERROR condition}@c
@conditionsubindex{delete-multi-func-error}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} name
@slotsubindex{name}@c
@table @strong
@item Initargs
@t{:name}
@end table
@end defvr
@defvr {Slot} choices
@slotsubindex{choices}@c
@table @strong
@item Initargs
@t{:choices}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {dispatch-called-outside-of-map-g} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>DISPATCH-CALLED-OUTSIDE-OF-MAP-G condition}@c
@conditionsubindex{dispatch-called-outside-of-map-g}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} name
@slotsubindex{name}@c
@table @strong
@item Initargs
@t{:name}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {dont-define-space-to-self} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>DONT-DEFINE-SPACE-TO-SELF condition}@c
@conditionsubindex{dont-define-space-to-self}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} space
@slotsubindex{space}@c
@table @strong
@item Initargs
@t{:space}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {failed-to-test-compile-gpu-func} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>FAILED-TO-TEST-COMPILE-GPU-FUNC condition}@c
@conditionsubindex{failed-to-test-compile-gpu-func}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{warning} (condition)
@item Direct slots
@defvr {Slot} gfunc-name
@slotsubindex{gfunc-name}@c
@table @strong
@item Initargs
@t{:gfunc-name}
@end table
@end defvr
@defvr {Slot} missing-func-names
@slotsubindex{missing-func-names}@c
@table @strong
@item Initargs
@t{:missing-func-names}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {fbo-binding-missing} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>FBO-BINDING-MISSING condition}@c
@conditionsubindex{fbo-binding-missing}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} kind
@slotsubindex{kind}@c
@table @strong
@item Initargs
@t{:kind}
@end table
@end defvr
@defvr {Slot} current-surface
@slotsubindex{current-surface}@c
@table @strong
@item Initargs
@t{:current-surface}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {fbo-target-not-valid-constant} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>FBO-TARGET-NOT-VALID-CONSTANT condition}@c
@conditionsubindex{fbo-target-not-valid-constant}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} target
@slotsubindex{target}@c
@table @strong
@item Initargs
@t{:target}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {func-keyed-pipeline-not-found} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>FUNC-KEYED-PIPELINE-NOT-FOUND condition}@c
@conditionsubindex{func-keyed-pipeline-not-found}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{warning} (condition)
@item Direct slots
@defvr {Slot} callee
@slotsubindex{callee}@c
@table @strong
@item Initargs
@t{:callee}
@end table
@end defvr
@defvr {Slot} func
@slotsubindex{func}@c
@table @strong
@item Initargs
@t{:func}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {functions-in-non-uniform-args} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>FUNCTIONS-IN-NON-UNIFORM-ARGS condition}@c
@conditionsubindex{functions-in-non-uniform-args}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} name
@slotsubindex{name}@c
@table @strong
@item Initargs
@t{:name}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {gfun-invalid-arg-format} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>GFUN-INVALID-ARG-FORMAT condition}@c
@conditionsubindex{gfun-invalid-arg-format}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} gfun-name
@slotsubindex{gfun-name}@c
@table @strong
@item Initargs
@t{:gfun-name}
@end table
@end defvr
@defvr {Slot} invalid-pair
@slotsubindex{invalid-pair}@c
@table @strong
@item Initargs
@t{:invalid-pair}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {gl-context-initialized-from-incorrect-thread} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>GL-CONTEXT-INITIALIZED-FROM-INCORRECT-THREAD condition}@c
@conditionsubindex{gl-context-initialized-from-incorrect-thread}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} ctx-thread
@slotsubindex{ctx-thread}@c
@table @strong
@item Initargs
@t{:ctx-thread}
@end table
@end defvr
@defvr {Slot} init-thread
@slotsubindex{init-thread}@c
@table @strong
@item Initargs
@t{:init-thread}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {glsl-geom-stage-no-out-layout} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>GLSL-GEOM-STAGE-NO-OUT-LAYOUT condition}@c
@conditionsubindex{glsl-geom-stage-no-out-layout}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} glsl-body
@slotsubindex{glsl-body}@c
@table @strong
@item Initargs
@t{:glsl-body}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {glsl-version-conflict} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>GLSL-VERSION-CONFLICT condition}@c
@conditionsubindex{glsl-version-conflict}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} issue
@slotsubindex{issue}@c
@table @strong
@item Initargs
@t{:issue}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {glsl-version-conflict-in-gpu-func} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>GLSL-VERSION-CONFLICT-IN-GPU-FUNC condition}@c
@conditionsubindex{glsl-version-conflict-in-gpu-func}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} name
@slotsubindex{name}@c
@table @strong
@item Initargs
@t{:name}
@end table
@end defvr
@defvr {Slot} context
@slotsubindex{context}@c
@table @strong
@item Initargs
@t{:context}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {gpu-array-from-buffer-missing-args} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>GPU-ARRAY-FROM-BUFFER-MISSING-ARGS condition}@c
@conditionsubindex{gpu-array-from-buffer-missing-args}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} element-type
@slotsubindex{element-type}@c
@table @strong
@item Initargs
@t{:element-type}
@end table
@end defvr
@defvr {Slot} dimensions
@slotsubindex{dimensions}@c
@table @strong
@item Initargs
@t{:dimensions}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {gpu-array-from-id-missing-args} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>GPU-ARRAY-FROM-ID-MISSING-ARGS condition}@c
@conditionsubindex{gpu-array-from-id-missing-args}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} element-type
@slotsubindex{element-type}@c
@table @strong
@item Initargs
@t{:element-type}
@end table
@end defvr
@defvr {Slot} dimensions
@slotsubindex{dimensions}@c
@table @strong
@item Initargs
@t{:dimensions}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {gpu-func-spec-not-found} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>GPU-FUNC-SPEC-NOT-FOUND condition}@c
@conditionsubindex{gpu-func-spec-not-found}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} name
@slotsubindex{name}@c
@table @strong
@item Initargs
@t{:name}
@end table
@end defvr
@defvr {Slot} types
@slotsubindex{types}@c
@table @strong
@item Initargs
@t{:types}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {gpu-func-symbol-name} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>GPU-FUNC-SYMBOL-NAME condition}@c
@conditionsubindex{gpu-func-symbol-name}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} name
@slotsubindex{name}@c
@table @strong
@item Initargs
@t{:name}
@end table
@end defvr
@defvr {Slot} alternatives
@slotsubindex{alternatives}@c
@table @strong
@item Initargs
@t{:alternatives}
@end table
@end defvr
@defvr {Slot} env
@slotsubindex{env}@c
@table @strong
@item Initargs
@t{:env}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {image-format->lisp-type-failed} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>IMAGE-FORMAT->LISP-TYPE-FAILED condition}@c
@conditionsubindex{image-format->lisp-type-failed}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} type-name
@slotsubindex{type-name}@c
@table @strong
@item Initargs
@t{:type-name}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {image-format->pixel-format-failed} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>IMAGE-FORMAT->PIXEL-FORMAT-FAILED condition}@c
@conditionsubindex{image-format->pixel-format-failed}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} type-name
@slotsubindex{type-name}@c
@table @strong
@item Initargs
@t{:type-name}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {inconsistent-struct-layout} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>INCONSISTENT-STRUCT-LAYOUT condition}@c
@conditionsubindex{inconsistent-struct-layout}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} name
@slotsubindex{name}@c
@table @strong
@item Initargs
@t{:name}
@end table
@end defvr
@defvr {Slot} target
@slotsubindex{target}@c
@table @strong
@item Initargs
@t{:target}
@end table
@end defvr
@defvr {Slot} slots
@slotsubindex{slots}@c
@table @strong
@item Initargs
@t{:slots}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {incorrect-number-of-arrays-in-tfs} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>INCORRECT-NUMBER-OF-ARRAYS-IN-TFS condition}@c
@conditionsubindex{incorrect-number-of-arrays-in-tfs}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} tfs
@slotsubindex{tfs}@c
@table @strong
@item Initargs
@t{:tfs}
@end table
@end defvr
@defvr {Slot} tfs-count
@slotsubindex{tfs-count}@c
@table @strong
@item Initargs
@t{:tfs-count}
@end table
@end defvr
@defvr {Slot} count
@slotsubindex{count}@c
@table @strong
@item Initargs
@t{:count}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {index-layout-with-unknown-length} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>INDEX-LAYOUT-WITH-UNKNOWN-LENGTH condition}@c
@conditionsubindex{index-layout-with-unknown-length}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} layout
@slotsubindex{layout}@c
@table @strong
@item Initargs
@t{:layout}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {index-on-buffer-stream-with-no-gpu-arrays} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>INDEX-ON-BUFFER-STREAM-WITH-NO-GPU-ARRAYS condition}@c
@conditionsubindex{index-on-buffer-stream-with-no-gpu-arrays}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@end table
@end deftp
@deftp {Condition} {index-on-buffer-stream-with-no-gpu-layouts} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>INDEX-ON-BUFFER-STREAM-WITH-NO-GPU-LAYOUTS condition}@c
@conditionsubindex{index-on-buffer-stream-with-no-gpu-layouts}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@end table
@end deftp
@deftp {Condition} {invalid-args-in-make-tfs} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>INVALID-ARGS-IN-MAKE-TFS condition}@c
@conditionsubindex{invalid-args-in-make-tfs}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} args
@slotsubindex{args}@c
@table @strong
@item Initargs
@t{:args}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {invalid-attachments-for-empty-fbo} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>INVALID-ATTACHMENTS-FOR-EMPTY-FBO condition}@c
@conditionsubindex{invalid-attachments-for-empty-fbo}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} args
@slotsubindex{args}@c
@table @strong
@item Initargs
@t{:args}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {invalid-compose-gpipe-form} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>INVALID-COMPOSE-GPIPE-FORM condition}@c
@conditionsubindex{invalid-compose-gpipe-form}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} pipeline-name
@slotsubindex{pipeline-name}@c
@table @strong
@item Initargs
@t{:pipeline-name}
@end table
@end defvr
@defvr {Slot} clauses
@slotsubindex{clauses}@c
@table @strong
@item Initargs
@t{:clauses}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {invalid-context-for-assert-gpipe} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>INVALID-CONTEXT-FOR-ASSERT-GPIPE condition}@c
@conditionsubindex{invalid-context-for-assert-gpipe}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} context
@slotsubindex{context}@c
@table @strong
@item Initargs
@t{:context}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {invalid-context-for-assert-options} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>INVALID-CONTEXT-FOR-ASSERT-OPTIONS condition}@c
@conditionsubindex{invalid-context-for-assert-options}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} context
@slotsubindex{context}@c
@table @strong
@item Initargs
@t{:context}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {invalid-cube-fbo-args} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>INVALID-CUBE-FBO-ARGS condition}@c
@conditionsubindex{invalid-cube-fbo-args}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} args
@slotsubindex{args}@c
@table @strong
@item Initargs
@t{:args}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {invalid-data-layout-specifier} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>INVALID-DATA-LAYOUT-SPECIFIER condition}@c
@conditionsubindex{invalid-data-layout-specifier}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} specifier
@slotsubindex{specifier}@c
@table @strong
@item Initargs
@t{:specifier}
@end table
@end defvr
@defvr {Slot} valid-specifiers
@slotsubindex{valid-specifiers}@c
@table @strong
@item Initargs
@t{:valid-specifiers}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {invalid-defpipeline-options} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>INVALID-DEFPIPELINE-OPTIONS condition}@c
@conditionsubindex{invalid-defpipeline-options}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} pipeline-name
@slotsubindex{pipeline-name}@c
@table @strong
@item Initargs
@t{:pipeline-name}
@end table
@end defvr
@defvr {Slot} invalid-options
@slotsubindex{invalid-options}@c
@table @strong
@item Initargs
@t{:invalid-options}
@end table
@end defvr
@defvr {Slot} valid-options
@slotsubindex{valid-options}@c
@table @strong
@item Initargs
@t{:valid-options}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {invalid-empty-fbo-declaration} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>INVALID-EMPTY-FBO-DECLARATION condition}@c
@conditionsubindex{invalid-empty-fbo-declaration}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} decl
@slotsubindex{decl}@c
@table @strong
@item Initargs
@t{:decl}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {invalid-gpu-arrays-layout} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>INVALID-GPU-ARRAYS-LAYOUT condition}@c
@conditionsubindex{invalid-gpu-arrays-layout}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} layout
@slotsubindex{layout}@c
@table @strong
@item Initargs
@t{:layout}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {invalid-gpu-buffer-layout} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>INVALID-GPU-BUFFER-LAYOUT condition}@c
@conditionsubindex{invalid-gpu-buffer-layout}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} layout
@slotsubindex{layout}@c
@table @strong
@item Initargs
@t{:layout}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {invalid-inline-glsl-stage-arg-layout} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>INVALID-INLINE-GLSL-STAGE-ARG-LAYOUT condition}@c
@conditionsubindex{invalid-inline-glsl-stage-arg-layout}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} name
@slotsubindex{name}@c
@table @strong
@item Initargs
@t{:name}
@end table
@end defvr
@defvr {Slot} arg
@slotsubindex{arg}@c
@table @strong
@item Initargs
@t{:arg}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {invalid-keywords-for-shader-gpipe-args} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>INVALID-KEYWORDS-FOR-SHADER-GPIPE-ARGS condition}@c
@conditionsubindex{invalid-keywords-for-shader-gpipe-args}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} pipeline-name
@slotsubindex{pipeline-name}@c
@table @strong
@item Initargs
@t{:pipeline-name}
@end table
@end defvr
@defvr {Slot} keys
@slotsubindex{keys}@c
@table @strong
@item Initargs
@t{:keys}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {invalid-layout-for-inargs} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>INVALID-LAYOUT-FOR-INARGS condition}@c
@conditionsubindex{invalid-layout-for-inargs}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} name
@slotsubindex{name}@c
@table @strong
@item Initargs
@t{:name}
@end table
@end defvr
@defvr {Slot} type-name
@slotsubindex{type-name}@c
@table @strong
@item Initargs
@t{:type-name}
@end table
@end defvr
@defvr {Slot} layout
@slotsubindex{layout}@c
@table @strong
@item Initargs
@t{:layout}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {invalid-layout-for-uniform} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>INVALID-LAYOUT-FOR-UNIFORM condition}@c
@conditionsubindex{invalid-layout-for-uniform}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} name
@slotsubindex{name}@c
@table @strong
@item Initargs
@t{:name}
@end table
@end defvr
@defvr {Slot} type-name
@slotsubindex{type-name}@c
@table @strong
@item Initargs
@t{:type-name}
@end table
@end defvr
@defvr {Slot} layout
@slotsubindex{layout}@c
@table @strong
@item Initargs
@t{:layout}
@end table
@end defvr
@defvr {Slot} func-p
@slotsubindex{func-p}@c
@table @strong
@item Initargs
@t{:func-p}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {invalid-options-for-texture} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>INVALID-OPTIONS-FOR-TEXTURE condition}@c
@conditionsubindex{invalid-options-for-texture}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} buffer-storage
@slotsubindex{buffer-storage}@c
@table @strong
@item Initargs
@t{:buffer-storage}
@end table
@end defvr
@defvr {Slot} cubes
@slotsubindex{cubes}@c
@table @strong
@item Initargs
@t{:cubes}
@end table
@end defvr
@defvr {Slot} dimensions
@slotsubindex{dimensions}@c
@table @strong
@item Initargs
@t{:dimensions}
@end table
@end defvr
@defvr {Slot} layer-count
@slotsubindex{layer-count}@c
@table @strong
@item Initargs
@t{:layer-count}
@end table
@end defvr
@defvr {Slot} mipmap
@slotsubindex{mipmap}@c
@table @strong
@item Initargs
@t{:mipmap}
@end table
@end defvr
@defvr {Slot} multisample
@slotsubindex{multisample}@c
@table @strong
@item Initargs
@t{:multisample}
@end table
@end defvr
@defvr {Slot} rectangle
@slotsubindex{rectangle}@c
@table @strong
@item Initargs
@t{:rectangle}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {invalid-sampler-wrap-value} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>INVALID-SAMPLER-WRAP-VALUE condition}@c
@conditionsubindex{invalid-sampler-wrap-value}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} sampler
@slotsubindex{sampler}@c
@table @strong
@item Initargs
@t{:sampler}
@end table
@end defvr
@defvr {Slot} value
@slotsubindex{value}@c
@table @strong
@item Initargs
@t{:value}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {invalid-shader-gpipe-form} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>INVALID-SHADER-GPIPE-FORM condition}@c
@conditionsubindex{invalid-shader-gpipe-form}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} pipeline-name
@slotsubindex{pipeline-name}@c
@table @strong
@item Initargs
@t{:pipeline-name}
@end table
@end defvr
@defvr {Slot} valid-forms
@slotsubindex{valid-forms}@c
@table @strong
@item Initargs
@t{:valid-forms}
@end table
@end defvr
@defvr {Slot} invalid-forms
@slotsubindex{invalid-forms}@c
@table @strong
@item Initargs
@t{:invalid-forms}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {invalid-shader-gpipe-stage-keys} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>INVALID-SHADER-GPIPE-STAGE-KEYS condition}@c
@conditionsubindex{invalid-shader-gpipe-stage-keys}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} pipeline-name
@slotsubindex{pipeline-name}@c
@table @strong
@item Initargs
@t{:pipeline-name}
@end table
@end defvr
@defvr {Slot} keys
@slotsubindex{keys}@c
@table @strong
@item Initargs
@t{:keys}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {invalid-sizes-in-make-tfs} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>INVALID-SIZES-IN-MAKE-TFS condition}@c
@conditionsubindex{invalid-sizes-in-make-tfs}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} args
@slotsubindex{args}@c
@table @strong
@item Initargs
@t{:args}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {invalid-stage-for-single-stage-pipeline} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>INVALID-STAGE-FOR-SINGLE-STAGE-PIPELINE condition}@c
@conditionsubindex{invalid-stage-for-single-stage-pipeline}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} kind
@slotsubindex{kind}@c
@table @strong
@item Initargs
@t{:kind}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {invalid-stream-layout} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>INVALID-STREAM-LAYOUT condition}@c
@conditionsubindex{invalid-stream-layout}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} layout
@slotsubindex{layout}@c
@table @strong
@item Initargs
@t{:layout}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {lisp-type->image-format-failed} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>LISP-TYPE->IMAGE-FORMAT-FAILED condition}@c
@conditionsubindex{lisp-type->image-format-failed}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} type-name
@slotsubindex{type-name}@c
@table @strong
@item Initargs
@t{:type-name}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {make-arrays-layout-count-mismatch} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>MAKE-ARRAYS-LAYOUT-COUNT-MISMATCH condition}@c
@conditionsubindex{make-arrays-layout-count-mismatch}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} current-count
@slotsubindex{current-count}@c
@table @strong
@item Initargs
@t{:current-count}
@end table
@end defvr
@defvr {Slot} layouts
@slotsubindex{layouts}@c
@table @strong
@item Initargs
@t{:layouts}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {make-arrays-layout-mismatch} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>MAKE-ARRAYS-LAYOUT-MISMATCH condition}@c
@conditionsubindex{make-arrays-layout-mismatch}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} current-sizes
@slotsubindex{current-sizes}@c
@table @strong
@item Initargs
@t{:current-sizes}
@end table
@end defvr
@defvr {Slot} requested-sizes
@slotsubindex{requested-sizes}@c
@table @strong
@item Initargs
@t{:requested-sizes}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {make-gpu-array-from-c-array-mismatched-dimensions} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>MAKE-GPU-ARRAY-FROM-C-ARRAY-MISMATCHED-DIMENSIONS condition}@c
@conditionsubindex{make-gpu-array-from-c-array-mismatched-dimensions}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} c-arr-dimensions
@slotsubindex{c-arr-dimensions}@c
@table @strong
@item Initargs
@t{:c-arr-dimensions}
@end table
@end defvr
@defvr {Slot} provided-dimensions
@slotsubindex{provided-dimensions}@c
@table @strong
@item Initargs
@t{:provided-dimensions}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {make-gpu-buffer-from-id-clashing-keys} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>MAKE-GPU-BUFFER-FROM-ID-CLASHING-KEYS condition}@c
@conditionsubindex{make-gpu-buffer-from-id-clashing-keys}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} args
@slotsubindex{args}@c
@table @strong
@item Initargs
@t{:args}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {make-tex-array-not-match-type} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>MAKE-TEX-ARRAY-NOT-MATCH-TYPE condition}@c
@conditionsubindex{make-tex-array-not-match-type}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} element-type
@slotsubindex{element-type}@c
@table @strong
@item Initargs
@t{:element-type}
@end table
@end defvr
@defvr {Slot} pixel-format
@slotsubindex{pixel-format}@c
@table @strong
@item Initargs
@t{:pixel-format}
@end table
@end defvr
@defvr {Slot} supposed-type
@slotsubindex{supposed-type}@c
@table @strong
@item Initargs
@t{:supposed-type}
@end table
@end defvr
@defvr {Slot} array-type
@slotsubindex{array-type}@c
@table @strong
@item Initargs
@t{:array-type}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {make-tex-array-not-match-type2} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>MAKE-TEX-ARRAY-NOT-MATCH-TYPE2 condition}@c
@conditionsubindex{make-tex-array-not-match-type2}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} element-type
@slotsubindex{element-type}@c
@table @strong
@item Initargs
@t{:element-type}
@end table
@end defvr
@defvr {Slot} initial-contents
@slotsubindex{initial-contents}@c
@table @strong
@item Initargs
@t{:initial-contents}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {make-tex-no-content-no-type} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>MAKE-TEX-NO-CONTENT-NO-TYPE condition}@c
@conditionsubindex{make-tex-no-content-no-type}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@end table
@end deftp
@deftp {Condition} {mapping-over-partial-pipeline} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>MAPPING-OVER-PARTIAL-PIPELINE condition}@c
@conditionsubindex{mapping-over-partial-pipeline}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} name
@slotsubindex{name}@c
@table @strong
@item Initargs
@t{:name}
@end table
@end defvr
@defvr {Slot} args
@slotsubindex{args}@c
@table @strong
@item Initargs
@t{:args}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {max-context-count-reached} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>MAX-CONTEXT-COUNT-REACHED condition}@c
@conditionsubindex{max-context-count-reached}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} max
@slotsubindex{max}@c
@table @strong
@item Initargs
@t{:max}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {mixed-pipelines-in-with-tb} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>MIXED-PIPELINES-IN-WITH-TB condition}@c
@conditionsubindex{mixed-pipelines-in-with-tb}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@end table
@end deftp
@deftp {Condition} {multi-func-error} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>MULTI-FUNC-ERROR condition}@c
@conditionsubindex{multi-func-error}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} name
@slotsubindex{name}@c
@table @strong
@item Initargs
@t{:name}
@end table
@end defvr
@defvr {Slot} choices
@slotsubindex{choices}@c
@table @strong
@item Initargs
@t{:choices}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {nested-with-transform-feedback} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>NESTED-WITH-TRANSFORM-FEEDBACK condition}@c
@conditionsubindex{nested-with-transform-feedback}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@end table
@end deftp
@deftp {Condition} {no-named-stages} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>NO-NAMED-STAGES condition}@c
@conditionsubindex{no-named-stages}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} stages
@slotsubindex{stages}@c
@table @strong
@item Initargs
@t{:stages}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {non-consecutive-feedback-groups} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>NON-CONSECUTIVE-FEEDBACK-GROUPS condition}@c
@conditionsubindex{non-consecutive-feedback-groups}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} groups
@slotsubindex{groups}@c
@table @strong
@item Initargs
@t{:groups}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {not-a-gpu-lambda} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>NOT-A-GPU-LAMBDA condition}@c
@conditionsubindex{not-a-gpu-lambda}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} thing
@slotsubindex{thing}@c
@table @strong
@item Initargs
@t{:thing}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {not-enough-args-for-implicit-gpipe-stages} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>NOT-ENOUGH-ARGS-FOR-IMPLICIT-GPIPE-STAGES condition}@c
@conditionsubindex{not-enough-args-for-implicit-gpipe-stages}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} pipeline-name
@slotsubindex{pipeline-name}@c
@table @strong
@item Initargs
@t{:pipeline-name}
@end table
@end defvr
@defvr {Slot} clauses
@slotsubindex{clauses}@c
@table @strong
@item Initargs
@t{:clauses}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {one-stage-non-explicit} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>ONE-STAGE-NON-EXPLICIT condition}@c
@conditionsubindex{one-stage-non-explicit}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@end table
@end deftp
@deftp {Condition} {partial-lambda-pipeline} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>PARTIAL-LAMBDA-PIPELINE condition}@c
@conditionsubindex{partial-lambda-pipeline}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} partial-stages
@slotsubindex{partial-stages}@c
@table @strong
@item Initargs
@t{:partial-stages}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {pipeline-recompile-in-tfb-scope} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>PIPELINE-RECOMPILE-IN-TFB-SCOPE condition}@c
@conditionsubindex{pipeline-recompile-in-tfb-scope}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} name
@slotsubindex{name}@c
@table @strong
@item Initargs
@t{:name}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {pixel-format->image-format-failed} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>PIXEL-FORMAT->IMAGE-FORMAT-FAILED condition}@c
@conditionsubindex{pixel-format->image-format-failed}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} type-name
@slotsubindex{type-name}@c
@table @strong
@item Initargs
@t{:type-name}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {pixel-format-in-bb-texture} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>PIXEL-FORMAT-IN-BB-TEXTURE condition}@c
@conditionsubindex{pixel-format-in-bb-texture}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} pixel-format
@slotsubindex{pixel-format}@c
@table @strong
@item Initargs
@t{:pixel-format}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {pull*-g-not-enabled} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>PULL*-G-NOT-ENABLED condition}@c
@conditionsubindex{pull*-g-not-enabled}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@end table
@end deftp
@deftp {Condition} {pull-g-not-cached} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>PULL-G-NOT-CACHED condition}@c
@conditionsubindex{pull-g-not-cached}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{warning} (condition)
@item Direct slots
@defvr {Slot} asset-name
@slotsubindex{asset-name}@c
@table @strong
@item Initargs
@t{:asset-name}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {query-is-active-bug} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>QUERY-IS-ACTIVE-BUG condition}@c
@conditionsubindex{query-is-active-bug}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} query
@slotsubindex{query}@c
@table @strong
@item Initargs
@t{:query}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {query-is-already-active} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>QUERY-IS-ALREADY-ACTIVE condition}@c
@conditionsubindex{query-is-already-active}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} query
@slotsubindex{query}@c
@table @strong
@item Initargs
@t{:query}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {query-not-active} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>QUERY-NOT-ACTIVE condition}@c
@conditionsubindex{query-not-active}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} query
@slotsubindex{query}@c
@table @strong
@item Initargs
@t{:query}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {quote-in-buffer-layout} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>QUOTE-IN-BUFFER-LAYOUT condition}@c
@conditionsubindex{quote-in-buffer-layout}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} layout
@slotsubindex{layout}@c
@table @strong
@item Initargs
@t{:layout}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {quote-symbol-found-in-fbo-dimensions} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>QUOTE-SYMBOL-FOUND-IN-FBO-DIMENSIONS condition}@c
@conditionsubindex{quote-symbol-found-in-fbo-dimensions}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} form
@slotsubindex{form}@c
@table @strong
@item Initargs
@t{:form}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {shader-pipeline-non-null-args} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>SHADER-PIPELINE-NON-NULL-ARGS condition}@c
@conditionsubindex{shader-pipeline-non-null-args}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} pipeline-name
@slotsubindex{pipeline-name}@c
@table @strong
@item Initargs
@t{:pipeline-name}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {shared-context-created-from-incorrect-thread} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>SHARED-CONTEXT-CREATED-FROM-INCORRECT-THREAD condition}@c
@conditionsubindex{shared-context-created-from-incorrect-thread}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} ctx-thread
@slotsubindex{ctx-thread}@c
@table @strong
@item Initargs
@t{:ctx-thread}
@end table
@end defvr
@defvr {Slot} init-thread
@slotsubindex{init-thread}@c
@table @strong
@item Initargs
@t{:init-thread}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {stage-in-context-only-valid-for-glsl-stages} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>STAGE-IN-CONTEXT-ONLY-VALID-FOR-GLSL-STAGES condition}@c
@conditionsubindex{stage-in-context-only-valid-for-glsl-stages}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} name
@slotsubindex{name}@c
@table @strong
@item Initargs
@t{:name}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {stage-not-found} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>STAGE-NOT-FOUND condition}@c
@conditionsubindex{stage-not-found}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} designator
@slotsubindex{designator}@c
@table @strong
@item Initargs
@t{:designator}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {stage-not-valid-for-function-restriction} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>STAGE-NOT-VALID-FOR-FUNCTION-RESTRICTION condition}@c
@conditionsubindex{stage-not-valid-for-function-restriction}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} name
@slotsubindex{name}@c
@table @strong
@item Initargs
@t{:name}
@end table
@end defvr
@defvr {Slot} stage
@slotsubindex{stage}@c
@table @strong
@item Initargs
@t{:stage}
@end table
@end defvr
@defvr {Slot} func-stage
@slotsubindex{func-stage}@c
@table @strong
@item Initargs
@t{:func-stage}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {state-restore-limitation-blending} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>STATE-RESTORE-LIMITATION-BLENDING condition}@c
@conditionsubindex{state-restore-limitation-blending}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@end table
@end deftp
@deftp {Condition} {state-restore-limitation-transform-feedback} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>STATE-RESTORE-LIMITATION-TRANSFORM-FEEDBACK condition}@c
@conditionsubindex{state-restore-limitation-transform-feedback}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@end table
@end deftp
@deftp {Condition} {struct-in-glsl-stage-args} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>STRUCT-IN-GLSL-STAGE-ARGS condition}@c
@conditionsubindex{struct-in-glsl-stage-args}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} arg-names
@slotsubindex{arg-names}@c
@table @strong
@item Initargs
@t{:arg-names}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {symbol-stage-designator} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>SYMBOL-STAGE-DESIGNATOR condition}@c
@conditionsubindex{symbol-stage-designator}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} designator
@slotsubindex{designator}@c
@table @strong
@item Initargs
@t{:designator}
@end table
@end defvr
@defvr {Slot} possible-choices
@slotsubindex{possible-choices}@c
@table @strong
@item Initargs
@t{:possible-choices}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {symbol-stage-designators} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>SYMBOL-STAGE-DESIGNATORS condition}@c
@conditionsubindex{symbol-stage-designators}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} designator-choice-pairs
@slotsubindex{designator-choice-pairs}@c
@table @strong
@item Initargs
@t{:designator-choice-pairs}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {texture-dimensions-lequal-zero} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>TEXTURE-DIMENSIONS-LEQUAL-ZERO condition}@c
@conditionsubindex{texture-dimensions-lequal-zero}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} dimensions
@slotsubindex{dimensions}@c
@table @strong
@item Initargs
@t{:dimensions}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {tfs-setf-arrays-whilst-bound} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>TFS-SETF-ARRAYS-WHILST-BOUND condition}@c
@conditionsubindex{tfs-setf-arrays-whilst-bound}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{warning} (condition)
@end table
@end deftp
@deftp {Condition} {tried-to-make-context-on-thread-that-already-has-one} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>TRIED-TO-MAKE-CONTEXT-ON-THREAD-THAT-ALREADY-HAS-ONE condition}@c
@conditionsubindex{tried-to-make-context-on-thread-that-already-has-one}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} context
@slotsubindex{context}@c
@table @strong
@item Initargs
@t{:context}
@end table
@end defvr
@defvr {Slot} thread
@slotsubindex{thread}@c
@table @strong
@item Initargs
@t{:thread}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {unknown-stage-kind} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>UNKNOWN-STAGE-KIND condition}@c
@conditionsubindex{unknown-stage-kind}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} stage
@slotsubindex{stage}@c
@table @strong
@item Initargs
@t{:stage}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {unknown-symbols-in-pipeline-context} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>UNKNOWN-SYMBOLS-IN-PIPELINE-CONTEXT condition}@c
@conditionsubindex{unknown-symbols-in-pipeline-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} name
@slotsubindex{name}@c
@table @strong
@item Initargs
@t{:name}
@end table
@end defvr
@defvr {Slot} full
@slotsubindex{full}@c
@table @strong
@item Initargs
@t{:full}
@end table
@end defvr
@defvr {Slot} issue
@slotsubindex{issue}@c
@table @strong
@item Initargs
@t{:issue}
@end table
@end defvr
@defvr {Slot} for
@slotsubindex{for}@c
@table @strong
@item Initargs
@t{:for}
@end table
@end defvr
@end table
@end deftp
" :AFTER-MENU-CONTENTS NIL) #13# #14# #S(NET.DIDIERVERNA.DECLT::NODE :NAME "Exported types" :SYNOPSIS NIL :SECTION-TYPE :NUMBERED :SECTION-NAME "Types" :NEXT NIL :PREVIOUS #14# :UP #2# :CHILDREN NIL :BEFORE-MENU-CONTENTS "@deftp {Type} {array-index} ()
@anchor{go to the CEPL-UTILS<colon><colon>ARRAY-INDEX type}@c
@typesubindex{array-index}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deftp
@deftp {Type} {attachment-name} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>ATTACHMENT-NAME type}@c
@typesubindex{attachment-name}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deftp
@deftp {Type} {attachment-num} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>ATTACHMENT-NUM type}@c
@typesubindex{attachment-num}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deftp
@deftp {Type} {c-array-index} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY-INDEX type}@c
@typesubindex{c-array-index}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deftp
@deftp {Type} {context-id} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>CONTEXT-ID type}@c
@typesubindex{context-id}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deftp
@deftp {Type} {gl-enum-value} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GL-ENUM-VALUE type}@c
@typesubindex{gl-enum-value}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deftp
@deftp {Type} {gl-id} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GL-ID type}@c
@typesubindex{gl-id}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deftp
@deftp {Type} {gl-sizei} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GL-SIZEI type}@c
@typesubindex{gl-sizei}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deftp
@deftp {Type} {stencil-mask} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>STENCIL-MASK type}@c
@typesubindex{stencil-mask}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deftp
@deftp {Type} {tex-unit} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TEX-UNIT type}@c
@typesubindex{tex-unit}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deftp
@deftp {Type} {uploadable-lisp-seq} ()
@anchor{go to the CEPL<dot>INTERNALS<colon><colon>UPLOADABLE-LISP-SEQ type}@c
@typesubindex{uploadable-lisp-seq}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>INTERNALS package, , @t{cepl.internals}}
@item Source
@ref{go to the cepl/core/internals<dot>lisp file, , @t{core/internals.lisp}} (file)
@end table
@end deftp
@deftp {Type} {vao-id} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>VAO-ID type}@c
@typesubindex{vao-id}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deftp
" :AFTER-MENU-CONTENTS NIL)) :BEFORE-MENU-CONTENTS NIL :AFTER-MENU-CONTENTS NIL) :UP #3# :CHILDREN (#15=#S(NET.DIDIERVERNA.DECLT::NODE :NAME "Internal constants" :SYNOPSIS NIL :SECTION-TYPE :NUMBERED :SECTION-NAME "Constants" :NEXT #16=#S(NET.DIDIERVERNA.DECLT::NODE :NAME "Internal special variables" :SYNOPSIS NIL :SECTION-TYPE :NUMBERED :SECTION-NAME "Special variables" :NEXT #17=#S(NET.DIDIERVERNA.DECLT::NODE :NAME "Internal macros" :SYNOPSIS NIL :SECTION-TYPE :NUMBERED :SECTION-NAME "Macros" :NEXT #18=# :PREVIOUS #16# :UP #1# :CHILDREN NIL :BEFORE-MENU-CONTENTS "@deffn {Macro} {%with-blending} FBO PATTERN EXPLICIT-BLEND-PARAMS &body BODY
@anchor{go to the CEPL<dot>BLENDING<colon><colon>%WITH-BLENDING macro}@c
@macrosubindex{%with-blending}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {%with-cepl-context-slots} SLOTS CONTEXT &body BODY
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%WITH-CEPL-CONTEXT-SLOTS macro}@c
@macrosubindex{%with-cepl-context-slots}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {%with-scratch-texture-bound} TEXTURE &body BODY
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>%WITH-SCRATCH-TEXTURE-BOUND macro}@c
@macrosubindex{%with-scratch-texture-bound}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/def<dot>lisp file, , @t{core/textures/def.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {---block-doc---} DOC-STRING &body BODY
@anchor{go to the CEPL-UTILS<colon><colon>---BLOCK-DOC--- macro}@c
@macrosubindex{---block-doc---}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {define-context-func} NAME ARGS RET-TYPE CONTEXT-SLOTS &body BODY
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>DEFINE-CONTEXT-FUNC macro}@c
@macrosubindex{define-context-func}@c
This simple encodes a pattern I was writing too many times.@*
   Basically we want to have the call to #'cepl-context inline@*
   at the callsite as then a surrounding with-cepl-context block@*
   will be able to replace it with a local version (improving performance)
   the way we have taken to doing this 
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {if-gl-context} INIT-FUNC-CALL PRE-CONTEXT-FORM &optional DEPENDS-ON
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>IF-GL-CONTEXT macro}@c
@macrosubindex{if-gl-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/delayed-resource-init<dot>lisp file, , @t{core/context/delayed-resource-init.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {l-identity} CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>L-IDENTITY macro}@c
@macrosubindex{l-identity}@c
An identity macro. Exists so it can be shadowed in certain contexts
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {make-typed-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<colon><colon>MAKE-TYPED-FROM-FOREIGN macro}@c
@macrosubindex{make-typed-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {map-g-into*} (FBO &key WITH-VIEWPORT ATTACHMENT-FOR-SIZE WITH-BLENDING) PIPELINE-FUNC STREAM &rest UNIFORMS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>MAP-G-INTO* macro}@c
@macrosubindex{map-g-into*}@c

The `map-g-into*` macro is a variant of `map-g-into` which differs in that you have
more control over how the `fbo` is bound.@*

Like map-g-into, map-g-into* maps a `buffer-stream` over our pipeline and the
results of the pipeline are fed into the supplied fbo.@*

This is how we run our pipelines and thus is how we render in CEPL.@*

The arguments to map-g-into* are going to depend on what gpu-functions were
composed in the pipeline you are calling. However the layout is always as
follows.@*

- fbo: This is where the results of the pipeline will be written.@*

- with-viewport: If with-viewport is t then `with-fbo-bound` adds a
                 `with-fbo-viewport` that uses this fbo to this scope. This means
                 that the `current-viewport` within this scope will be set to the
                 equivalent of:@*

                     (make-viewport dimensions-of-fbo '(0 0))@*

                 See the docstruct with-fbo-viewport for details on this
                 behavior.@*

                 One last detail is that you may want to take the `dimensions` of
                 the `viewport` from an attachment other than attachment-0.@*
                 To do this use the 'attachment-for-size argument and give the
                 index of the color-attachment to use.@*

- with-blending: If with-blending is t then with-fbo-bound adds a with-blending
                 that uses this fbo to this scope.@*
                 This means that the blending parameters from your fbo will be
                 used while rendering. For the details and version specific
                 behaviours check out the docstring for with-blending@*

- attachment-for-size: see above@*

- the pipeline function: The first argument is always the pipeline you wish to
  map the data over.@*

- The stream: The next argument will be the buffer-stream which will be used as the
  inputs to the vertex-shader of the pipeline. The type of the buffer-stream  must
  be mappable onto types of the non uniform args of the gpu-function being used
  as the vertex-shader.@*

- Uniform args: Next you must provide the uniform arguments. These are passed in
  the same fashion as regular &key arguments.@*

CEPL will then run the pipeline with the given args and the results will be fed
into the specified FBO. The value/s from the fragment shader will be@*
written into the attachments of the FBO. If you need to control this in the
fashion usualy provided by with-fbo-bound then please see the doc-string for
 `map-g-into*`.@*

The default behaviour is that each of the multiple returns values from the
gpu-function used as the fragment shader will be written into the respective
attachments of the `FBO` (first value to first attachment, second value to
second attachment, etc)@*

Internally map-g-into* wraps call to `map-g` in with-fbo-bound. The with-fbo-bound
has its default configuration which means that:
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/map-g<dot>lisp file, , @t{core/pipelines/map-g.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {with-blending-param-slots} BLENDING-PARAMS &body BODY
@anchor{go to the CEPL<dot>BLENDING<colon><colon>WITH-BLENDING-PARAM-SLOTS macro}@c
@macrosubindex{with-blending-param-slots}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {with-buffer-range-mapped} (P TARGET OFFSET LENGTH ACCESS) &body BODY
@anchor{go to the CEPL<dot>GPU-ARRAYS<colon><colon>WITH-BUFFER-RANGE-MAPPED macro}@c
@macrosubindex{with-buffer-range-mapped}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS package, , @t{cepl.gpu-arrays}}
@item Source
@ref{go to the cepl/core/gpu-arrays/with-and-push<dot>lisp file, , @t{core/gpu-arrays/with-and-push.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {with-fbo-slots} ATTACHMENT-BINDINGS EXPRESSION &body BODY
@anchor{go to the CEPL<dot>FBOS<colon><colon>WITH-FBO-SLOTS macro}@c
@macrosubindex{with-fbo-slots}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {with-glsl-stage-spec} GLSL-STAGE-SPEC &body BODY
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>WITH-GLSL-STAGE-SPEC macro}@c
@macrosubindex{with-glsl-stage-spec}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {with-gpu-array-t} GPU-ARRAY-T &body BODY
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>WITH-GPU-ARRAY-T macro}@c
@macrosubindex{with-gpu-array-t}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/def<dot>lisp file, , @t{core/textures/def.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {with-gpu-func-spec} FUNC-SPEC &body BODY
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>WITH-GPU-FUNC-SPEC macro}@c
@macrosubindex{with-gpu-func-spec}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
" :AFTER-MENU-CONTENTS NIL) :PREVIOUS #15# :UP #1# :CHILDREN NIL :BEFORE-MENU-CONTENTS "@defvr {Special Variable} *active-listeners*
@anchor{go to the CEPL<dot>LIFECYCLE<colon><colon>*ACTIVE-LISTENERS* special variable}@c
@specialsubindex{*active-listeners*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>LIFECYCLE package, , @t{cepl.lifecycle}}
@item Source
@ref{go to the cepl/core/lifecycle<dot>lisp file, , @t{core/lifecycle.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *api-0-context-singleton*
@anchor{go to the CEPL<dot>HOST<colon><colon>*API-0-CONTEXT-SINGLETON* special variable}@c
@specialsubindex{*api-0-context-singleton*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-0<dot>lisp file, , @t{host/api-0.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *api-0-make-context-called*
@anchor{go to the CEPL<dot>HOST<colon><colon>*API-0-MAKE-CONTEXT-CALLED* special variable}@c
@specialsubindex{*api-0-make-context-called*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-0<dot>lisp file, , @t{host/api-0.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *api-0-make-window-called*
@anchor{go to the CEPL<dot>HOST<colon><colon>*API-0-MAKE-WINDOW-CALLED* special variable}@c
@specialsubindex{*api-0-make-window-called*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-0<dot>lisp file, , @t{host/api-0.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *api-0-window-singleton*
@anchor{go to the CEPL<dot>HOST<colon><colon>*API-0-WINDOW-SINGLETON* special variable}@c
@specialsubindex{*api-0-window-singleton*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-0<dot>lisp file, , @t{host/api-0.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *cache-last-compile-result*
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>*CACHE-LAST-COMPILE-RESULT* special variable}@c
@specialsubindex{*cache-last-compile-result*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *cepl-context*
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>*CEPL-CONTEXT* special variable}@c
@specialsubindex{*cepl-context*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *cepl-release-mode*
@anchor{go to the CEPL<dot>BUILD<colon><colon>*CEPL-RELEASE-MODE* special variable}@c
@specialsubindex{*cepl-release-mode*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>BUILD package, , @t{cepl.build}}
@item Source
@ref{go to the cepl<dot>build/build/build<dot>lisp file, , @t{build/build.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *contexts*
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>*CONTEXTS* special variable}@c
@specialsubindex{*contexts*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *contexts-lock*
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>*CONTEXTS-LOCK* special variable}@c
@specialsubindex{*contexts-lock*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *current-host*
@anchor{go to the CEPL<dot>HOST<colon><colon>*CURRENT-HOST* special variable}@c
@specialsubindex{*current-host*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-api<dot>lisp file, , @t{host/api-api.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *declared-host*
@anchor{go to the CEPL<dot>HOST<colon><colon>*DECLARED-HOST* special variable}@c
@specialsubindex{*declared-host*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-api<dot>lisp file, , @t{host/api-api.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *default-sampler-id-box*
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>*DEFAULT-SAMPLER-ID-BOX* special variable}@c
@specialsubindex{*default-sampler-id-box*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *dependent-gpu-functions*
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>*DEPENDENT-GPU-FUNCTIONS* special variable}@c
@specialsubindex{*dependent-gpu-functions*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *dependent-gpu-functions-lock*
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>*DEPENDENT-GPU-FUNCTIONS-LOCK* special variable}@c
@specialsubindex{*dependent-gpu-functions-lock*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *expand-fbo-pattern-to-c-array*
@anchor{go to the CEPL<dot>FBOS<colon><colon>*EXPAND-FBO-PATTERN-TO-C-ARRAY* special variable}@c
@specialsubindex{*expand-fbo-pattern-to-c-array*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *extra-cffi-type-equivalents*
@anchor{go to the CEPL<dot>TYPES<colon><colon>*EXTRA-CFFI-TYPE-EQUIVALENTS* special variable}@c
@specialsubindex{*extra-cffi-type-equivalents*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *fake-sampler-id*
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>*FAKE-SAMPLER-ID* special variable}@c
@specialsubindex{*fake-sampler-id*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *fake-sampler-id-lock*
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>*FAKE-SAMPLER-ID-LOCK* special variable}@c
@specialsubindex{*fake-sampler-id-lock*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *free-context-ids*
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>*FREE-CONTEXT-IDS* special variable}@c
@specialsubindex{*free-context-ids*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *free-context-ids-lock*
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>*FREE-CONTEXT-IDS-LOCK* special variable}@c
@specialsubindex{*free-context-ids-lock*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *freed-ssbo-id*
@anchor{go to the CEPL<dot>SSBOS<colon><colon>*FREED-SSBO-ID* special variable}@c
@specialsubindex{*freed-ssbo-id*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SSBOS package, , @t{cepl.ssbos}}
@item Source
@ref{go to the cepl/core/ssbos/ssbos<dot>lisp file, , @t{core/ssbos/ssbos.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *freed-ubo-id*
@anchor{go to the CEPL<dot>UBOS<colon><colon>*FREED-UBO-ID* special variable}@c
@specialsubindex{*freed-ubo-id*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>UBOS package, , @t{cepl.ubos}}
@item Source
@ref{go to the cepl/core/ubos/ubo<dot>lisp file, , @t{core/ubos/ubo.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *get-gpu-lambda-state*
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>*GET-GPU-LAMBDA-STATE* special variable}@c
@specialsubindex{*get-gpu-lambda-state*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-lambda<dot>lisp file, , @t{core/pipelines/gpu-lambda.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *gpu-func-diff-tag*
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>*GPU-FUNC-DIFF-TAG* special variable}@c
@specialsubindex{*gpu-func-diff-tag*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *gpu-func-specs*
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>*GPU-FUNC-SPECS* special variable}@c
@specialsubindex{*gpu-func-specs*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *gpu-func-specs-lock*
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>*GPU-FUNC-SPECS-LOCK* special variable}@c
@specialsubindex{*gpu-func-specs-lock*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *gpu-pipeline-specs*
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>*GPU-PIPELINE-SPECS* special variable}@c
@specialsubindex{*gpu-pipeline-specs*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *gpu-pipeline-specs-lock*
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>*GPU-PIPELINE-SPECS-LOCK* special variable}@c
@specialsubindex{*gpu-pipeline-specs-lock*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *init-pipeline-lock*
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>*INIT-PIPELINE-LOCK* special variable}@c
@specialsubindex{*init-pipeline-lock*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *lifecycle-state*
@anchor{go to the CEPL<dot>LIFECYCLE<colon><colon>*LIFECYCLE-STATE* special variable}@c
@specialsubindex{*lifecycle-state*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>LIFECYCLE package, , @t{cepl.lifecycle}}
@item Source
@ref{go to the cepl/core/lifecycle<dot>lisp file, , @t{core/lifecycle.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *lowest-unused-ssbo-id*
@anchor{go to the CEPL<dot>SSBOS<colon><colon>*LOWEST-UNUSED-SSBO-ID* special variable}@c
@specialsubindex{*lowest-unused-ssbo-id*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SSBOS package, , @t{cepl.ssbos}}
@item Source
@ref{go to the cepl/core/ssbos/ssbos<dot>lisp file, , @t{core/ssbos/ssbos.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *lowest-unused-ubo-id*
@anchor{go to the CEPL<dot>UBOS<colon><colon>*LOWEST-UNUSED-UBO-ID* special variable}@c
@specialsubindex{*lowest-unused-ubo-id*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>UBOS package, , @t{cepl.ubos}}
@item Source
@ref{go to the cepl/core/ubos/ubo<dot>lisp file, , @t{core/ubos/ubo.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *map-of-pipeline-names-to-gl-ids*
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>*MAP-OF-PIPELINE-NAMES-TO-GL-IDS* special variable}@c
@specialsubindex{*map-of-pipeline-names-to-gl-ids*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *map-of-pipeline-names-to-gl-ids-lock*
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>*MAP-OF-PIPELINE-NAMES-TO-GL-IDS-LOCK* special variable}@c
@specialsubindex{*map-of-pipeline-names-to-gl-ids-lock*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *pipeline-body-context-var*
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>*PIPELINE-BODY-CONTEXT-VAR* special variable}@c
@specialsubindex{*pipeline-body-context-var*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/mapg-context<dot>lisp file, , @t{core/pipelines/mapg-context.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *post-context-init*
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>*POST-CONTEXT-INIT* special variable}@c
@specialsubindex{*post-context-init*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/delayed-resource-init<dot>lisp file, , @t{core/context/delayed-resource-init.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *primary-context*
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>*PRIMARY-CONTEXT* special variable}@c
@specialsubindex{*primary-context*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *print-gpu-function-subscriptions*
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>*PRINT-GPU-FUNCTION-SUBSCRIPTIONS* special variable}@c
@specialsubindex{*print-gpu-function-subscriptions*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *samplers-available*
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>*SAMPLERS-AVAILABLE* special variable}@c
@specialsubindex{*samplers-available*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *shutting-down-listeners*
@anchor{go to the CEPL<dot>LIFECYCLE<colon><colon>*SHUTTING-DOWN-LISTENERS* special variable}@c
@specialsubindex{*shutting-down-listeners*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>LIFECYCLE package, , @t{cepl.lifecycle}}
@item Source
@ref{go to the cepl/core/lifecycle<dot>lisp file, , @t{core/lifecycle.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *ssbo-id-lock*
@anchor{go to the CEPL<dot>SSBOS<colon><colon>*SSBO-ID-LOCK* special variable}@c
@specialsubindex{*ssbo-id-lock*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SSBOS package, , @t{cepl.ssbos}}
@item Source
@ref{go to the cepl/core/ssbos/ssbos<dot>lisp file, , @t{core/ssbos/ssbos.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *standard-declarations*
@anchor{go to the CEPL<dot>DEFN<colon><colon>*STANDARD-DECLARATIONS* special variable}@c
@specialsubindex{*standard-declarations*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>DEFN package, , @t{cepl.defn}}
@item Source
@ref{go to the cepl<dot>build/defn/defn<dot>lisp file, , @t{defn/defn.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *struct-slot-defs*
@anchor{go to the CEPL<dot>TYPES<colon><colon>*STRUCT-SLOT-DEFS* special variable}@c
@specialsubindex{*struct-slot-defs*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *suppress-upload-message*
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>*SUPPRESS-UPLOAD-MESSAGE* special variable}@c
@specialsubindex{*suppress-upload-message*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *suspended-listeners*
@anchor{go to the CEPL<dot>LIFECYCLE<colon><colon>*SUSPENDED-LISTENERS* special variable}@c
@specialsubindex{*suspended-listeners*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>LIFECYCLE package, , @t{cepl.lifecycle}}
@item Source
@ref{go to the cepl/core/lifecycle<dot>lisp file, , @t{core/lifecycle.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *template-dir*
@anchor{go to the CEPL<colon><colon>*TEMPLATE-DIR* special variable}@c
@specialsubindex{*template-dir*}@c
@table @strong
@item Package
@ref{go to the CEPL package, , @t{cepl}}
@item Source
@ref{go to the cepl/project<dot>lisp file, , @t{project.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *ubo-id-lock*
@anchor{go to the CEPL<dot>UBOS<colon><colon>*UBO-ID-LOCK* special variable}@c
@specialsubindex{*ubo-id-lock*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>UBOS package, , @t{cepl.ubos}}
@item Source
@ref{go to the cepl/core/ubos/ubo<dot>lisp file, , @t{core/ubos/ubo.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *valid-layout-specifiers*
@anchor{go to the %CEPL<dot>TYPES<colon><colon>*VALID-LAYOUT-SPECIFIERS* special variable}@c
@specialsubindex{*valid-layout-specifiers*}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/layout<dot>lisp file, , @t{core/types/layout.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *warn-when-cant-test-compile*
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>*WARN-WHEN-CANT-TEST-COMPILE* special variable}@c
@specialsubindex{*warn-when-cant-test-compile*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} +null-att+
@anchor{go to the %CEPL<dot>TYPES<colon><colon>+NULL-ATT+ special variable}@c
@specialsubindex{+null-att+}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/nulls-and-uninitialized<dot>lisp file, , @t{core/types/nulls-and-uninitialized.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} +uninitialized-buffer-array+
@anchor{go to the %CEPL<dot>TYPES<colon><colon>+UNINITIALIZED-BUFFER-ARRAY+ special variable}@c
@specialsubindex{+uninitialized-buffer-array+}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/nulls-and-uninitialized<dot>lisp file, , @t{core/types/nulls-and-uninitialized.lisp}} (file)
@end table
@end defvr
" :AFTER-MENU-CONTENTS NIL) :PREVIOUS NIL :UP #1# :CHILDREN NIL :BEFORE-MENU-CONTENTS "@defvr {Constant} +cpu->gpu-vec-mappings+
@anchor{go to the CEPL<dot>TYPES<colon><colon>+CPU->GPU-VEC-MAPPINGS+ constant}@c
@constantsubindex{+cpu->gpu-vec-mappings+}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end defvr
@defvr {Constant} +cube-face-order+
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>+CUBE-FACE-ORDER+ constant}@c
@constantsubindex{+cube-face-order+}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end defvr
@defvr {Constant} +cube-face-order-enums+
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>+CUBE-FACE-ORDER-ENUMS+ constant}@c
@constantsubindex{+cube-face-order-enums+}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end defvr
@defvr {Constant} +gl-enum-size+
@anchor{go to the CEPL-UTILS<colon><colon>+GL-ENUM-SIZE+ constant}@c
@constantsubindex{+gl-enum-size+}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/early<dot>lisp file, , @t{core/early.lisp}} (file)
@end table
@end defvr
@defvr {Constant} +gl-integral-pixel-types+
@anchor{go to the CEPL<dot>PIXEL-FORMATS<colon><colon>+GL-INTEGRAL-PIXEL-TYPES+ constant}@c
@constantsubindex{+gl-integral-pixel-types+}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIXEL-FORMATS package, , @t{cepl.pixel-formats}}
@item Source
@ref{go to the cepl/core/types/pixel-format<dot>lisp file, , @t{core/types/pixel-format.lisp}} (file)
@end table
@end defvr
@defvr {Constant} +gl-pixel-to-internal-map+
@anchor{go to the CEPL<dot>PIXEL-FORMATS<colon><colon>+GL-PIXEL-TO-INTERNAL-MAP+ constant}@c
@constantsubindex{+gl-pixel-to-internal-map+}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIXEL-FORMATS package, , @t{cepl.pixel-formats}}
@item Source
@ref{go to the cepl/core/types/pixel-format<dot>lisp file, , @t{core/types/pixel-format.lisp}} (file)
@end table
@end defvr
@defvr {Constant} +lifecycle-states+
@anchor{go to the CEPL<dot>LIFECYCLE<colon><colon>+LIFECYCLE-STATES+ constant}@c
@constantsubindex{+lifecycle-states+}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>LIFECYCLE package, , @t{cepl.lifecycle}}
@item Source
@ref{go to the cepl/core/lifecycle<dot>lisp file, , @t{core/lifecycle.lisp}} (file)
@end table
@end defvr
@defvr {Constant} +possible-texture-keys+
@anchor{go to the CEPL<dot>FBOS<colon><colon>+POSSIBLE-TEXTURE-KEYS+ constant}@c
@constantsubindex{+possible-texture-keys+}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end defvr
@defvr {Constant} +sampler-types+
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>+SAMPLER-TYPES+ constant}@c
@constantsubindex{+sampler-types+}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end defvr
@defvr {Constant} +unknown-uniform-int-id+
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>+UNKNOWN-UNIFORM-INT-ID+ constant}@c
@constantsubindex{+unknown-uniform-int-id+}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end defvr
@defvr {Constant} +unknown-uniform-uint-id+
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>+UNKNOWN-UNIFORM-UINT-ID+ constant}@c
@constantsubindex{+unknown-uniform-uint-id+}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end defvr
@defvr {Constant} +valid-fbo-targets+
@anchor{go to the CEPL<dot>FBOS<colon><colon>+VALID-FBO-TARGETS+ constant}@c
@constantsubindex{+valid-fbo-targets+}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end defvr
@defvr {Constant} +valid-pixel-components+
@anchor{go to the CEPL<dot>PIXEL-FORMATS<colon><colon>+VALID-PIXEL-COMPONENTS+ constant}@c
@constantsubindex{+valid-pixel-components+}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIXEL-FORMATS package, , @t{cepl.pixel-formats}}
@item Source
@ref{go to the cepl/core/types/pixel-format<dot>lisp file, , @t{core/types/pixel-format.lisp}} (file)
@end table
@end defvr
@defvr {Constant} +valid-pixel-packed-sizes+
@anchor{go to the CEPL<dot>PIXEL-FORMATS<colon><colon>+VALID-PIXEL-PACKED-SIZES+ constant}@c
@constantsubindex{+valid-pixel-packed-sizes+}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIXEL-FORMATS package, , @t{cepl.pixel-formats}}
@item Source
@ref{go to the cepl/core/types/pixel-format<dot>lisp file, , @t{core/types/pixel-format.lisp}} (file)
@end table
@end defvr
@defvr {Constant} +valid-pixel-types+
@anchor{go to the CEPL<dot>PIXEL-FORMATS<colon><colon>+VALID-PIXEL-TYPES+ constant}@c
@constantsubindex{+valid-pixel-types+}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIXEL-FORMATS package, , @t{cepl.pixel-formats}}
@item Source
@ref{go to the cepl/core/types/pixel-format<dot>lisp file, , @t{core/types/pixel-format.lisp}} (file)
@end table
@end defvr
@defvr {Constant} +valid-stencil-tests+
@anchor{go to the CEPL<dot>STENCIL<colon><colon>+VALID-STENCIL-TESTS+ constant}@c
@constantsubindex{+valid-stencil-tests+}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>STENCIL package, , @t{cepl.stencil}}
@item Source
@ref{go to the cepl/core/stencil/stencil<dot>lisp file, , @t{core/stencil/stencil.lisp}} (file)
@end table
@end defvr
@defvr {Constant} +valid-texture-storage-options+
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>+VALID-TEXTURE-STORAGE-OPTIONS+ constant}@c
@constantsubindex{+valid-texture-storage-options+}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end defvr
@defvr {Constant} +valid-texture-subset+
@anchor{go to the CEPL<dot>FBOS<colon><colon>+VALID-TEXTURE-SUBSET+ constant}@c
@constantsubindex{+valid-texture-subset+}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end defvr
" :AFTER-MENU-CONTENTS NIL) #16# #17# #18# #19=#S(NET.DIDIERVERNA.DECLT::NODE :NAME "Internal functions" :SYNOPSIS NIL :SECTION-TYPE :NUMBERED :SECTION-NAME "Functions" :NEXT #20=#S(NET.DIDIERVERNA.DECLT::NODE :NAME "Internal generic functions" :SYNOPSIS NIL :SECTION-TYPE :NUMBERED :SECTION-NAME "Generic functions" :NEXT #21=#S(NET.DIDIERVERNA.DECLT::NODE :NAME "Internal conditions" :SYNOPSIS NIL :SECTION-TYPE :NUMBERED :SECTION-NAME "Conditions" :NEXT #22=# :PREVIOUS #20# :UP #1# :CHILDREN NIL :BEFORE-MENU-CONTENTS "@deftp {Condition} {c-array-4d-limit} ()
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>C-ARRAY-4D-LIMIT condition}@c
@conditionsubindex{c-array-4d-limit}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/aref-c<dot>lisp file, , @t{core/c-arrays/aref-c.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} dimensions
@slotsubindex{dimensions}@c
@table @strong
@item Initargs
@t{:dimensions}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {c-array-4d-limit-aref} ()
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>C-ARRAY-4D-LIMIT-AREF condition}@c
@conditionsubindex{c-array-4d-limit-aref}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/aref-c<dot>lisp file, , @t{core/c-arrays/aref-c.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} c-arr
@slotsubindex{c-arr}@c
@table @strong
@item Initargs
@t{:c-arr}
@end table
@end defvr
@defvr {Slot} indices
@slotsubindex{indices}@c
@table @strong
@item Initargs
@t{:indices}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {gl-version-too-low-for-empty-fbos} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>GL-VERSION-TOO-LOW-FOR-EMPTY-FBOS condition}@c
@conditionsubindex{gl-version-too-low-for-empty-fbos}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} version
@slotsubindex{version}@c
@table @strong
@item Initargs
@t{:version}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {invalid-fbo-args} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>INVALID-FBO-ARGS condition}@c
@conditionsubindex{invalid-fbo-args}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} args
@slotsubindex{args}@c
@table @strong
@item Initargs
@t{:args}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {make-project-needs-quickproject} ()
@anchor{go to the CEPL<colon><colon>MAKE-PROJECT-NEEDS-QUICKPROJECT condition}@c
@conditionsubindex{make-project-needs-quickproject}@c
@table @strong
@item Package
@ref{go to the CEPL package, , @t{cepl}}
@item Source
@ref{go to the cepl/project<dot>lisp file, , @t{project.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@end table
@end deftp
@deftp {Condition} {make-project-no-such-dir} ()
@anchor{go to the CEPL<colon><colon>MAKE-PROJECT-NO-SUCH-DIR condition}@c
@conditionsubindex{make-project-no-such-dir}@c
@table @strong
@item Package
@ref{go to the CEPL package, , @t{cepl}}
@item Source
@ref{go to the cepl/project<dot>lisp file, , @t{project.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} dir
@slotsubindex{dir}@c
@table @strong
@item Initargs
@t{:dir}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {make-ssbo-from-array-bad-type} ()
@anchor{go to the CEPL<dot>SSBOS<colon><colon>MAKE-SSBO-FROM-ARRAY-BAD-TYPE condition}@c
@conditionsubindex{make-ssbo-from-array-bad-type}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SSBOS package, , @t{cepl.ssbos}}
@item Source
@ref{go to the cepl/core/ssbos/ssbos<dot>lisp file, , @t{core/ssbos/ssbos.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} data
@slotsubindex{data}@c
@table @strong
@item Initargs
@t{:data}
@end table
@end defvr
@defvr {Slot} element-type
@slotsubindex{element-type}@c
@table @strong
@item Initargs
@t{:element-type}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {make-ubo-from-array-bad-type} ()
@anchor{go to the CEPL<dot>UBOS<colon><colon>MAKE-UBO-FROM-ARRAY-BAD-TYPE condition}@c
@conditionsubindex{make-ubo-from-array-bad-type}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>UBOS package, , @t{cepl.ubos}}
@item Source
@ref{go to the cepl/core/ubos/ubo<dot>lisp file, , @t{core/ubos/ubo.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} data
@slotsubindex{data}@c
@table @strong
@item Initargs
@t{:data}
@end table
@end defvr
@defvr {Slot} element-type
@slotsubindex{element-type}@c
@table @strong
@item Initargs
@t{:element-type}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {state-restore-limitation-queries} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>STATE-RESTORE-LIMITATION-QUERIES condition}@c
@conditionsubindex{state-restore-limitation-queries}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@end table
@end deftp
" :AFTER-MENU-CONTENTS NIL) :PREVIOUS #19# :UP #1# :CHILDREN NIL :BEFORE-MENU-CONTENTS "@deffn {Generic Function} {%destroy-surface} HOST SURFACE &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%DESTROY-SURFACE generic function}@c
@genericsubindex{%destroy-surface}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-generics<dot>lisp file, , @t{host/api-generics.lisp}} (file)
@item Methods
@deffn {Method} {%destroy-surface} HOST SURFACE &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%DESTROY-SURFACE COMMON-LISP<colon><colon>T COMMON-LISP<colon><colon>T method}@c
@methodsubindex{%destroy-surface}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Method} {%destroy-surface} (HOST @t{api-1}) SURFACE &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%DESTROY-SURFACE CEPL<dot>HOST<colon><colon>API-1 COMMON-LISP<colon><colon>T method}@c
@methodsubindex{%destroy-surface}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-1<dot>lisp file, , @t{host/api-1.lisp}} (file)
@end table
@end deffn
@deffn {Method} {%destroy-surface} (HOST @t{api-0}) SURFACE &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%DESTROY-SURFACE CEPL<dot>HOST<colon><colon>API-0 COMMON-LISP<colon><colon>T method}@c
@methodsubindex{%destroy-surface}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-0<dot>lisp file, , @t{host/api-0.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {%funcs-this-func-uses} KEY &optional DEPTH
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%FUNCS-THIS-FUNC-USES generic function}@c
@genericsubindex{%funcs-this-func-uses}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/generics<dot>lisp file, , @t{core/pipelines/generics.lisp}} (file)
@item Methods
@deffn {Method} {%funcs-this-func-uses} (KEY @t{func-key}) &optional DEPTH
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%FUNCS-THIS-FUNC-USES CEPL<dot>PIPELINES<colon><colon>FUNC-KEY method}@c
@methodsubindex{%funcs-this-func-uses}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {%gpu-function} NAME
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%GPU-FUNCTION generic function}@c
@genericsubindex{%gpu-function}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/generics<dot>lisp file, , @t{core/pipelines/generics.lisp}} (file)
@item Methods
@deffn {Method} {%gpu-function} (NAME @t{list})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%GPU-FUNCTION COMMON-LISP<colon><colon>LIST method}@c
@methodsubindex{%gpu-function}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Method} {%gpu-function} (NAME @t{null})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%GPU-FUNCTION COMMON-LISP<colon><colon>NULL method}@c
@methodsubindex{%gpu-function}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Method} {%gpu-function} (NAME @t{symbol})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%GPU-FUNCTION COMMON-LISP<colon><colon>SYMBOL method}@c
@methodsubindex{%gpu-function}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {%init} HOST ARGS
@anchor{go to the CEPL<dot>HOST<colon><colon>%INIT generic function}@c
@genericsubindex{%init}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-generics<dot>lisp file, , @t{host/api-generics.lisp}} (file)
@item Methods
@deffn {Method} {%init} (HOST @t{api-1}) (ARGS @t{list})
@anchor{go to the CEPL<dot>HOST<colon><colon>%INIT CEPL<dot>HOST<colon><colon>API-1 COMMON-LISP<colon><colon>LIST method}@c
@methodsubindex{%init}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-1<dot>lisp file, , @t{host/api-1.lisp}} (file)
@end table
@end deffn
@deffn {Method} {%init} (HOST @t{api-0}) (ARGS @t{list})
@anchor{go to the CEPL<dot>HOST<colon><colon>%INIT CEPL<dot>HOST<colon><colon>API-0 COMMON-LISP<colon><colon>LIST method}@c
@methodsubindex{%init}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-0<dot>lisp file, , @t{host/api-0.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {%make-gl-context} HOST &key SURFACE VERSION DOUBLE-BUFFER ALPHA-SIZE RED-SIZE GREEN-SIZE BLUE-SIZE DEPTH-SIZE STENCIL-SIZE BUFFER-SIZE &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%MAKE-GL-CONTEXT generic function}@c
@genericsubindex{%make-gl-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-generics<dot>lisp file, , @t{host/api-generics.lisp}} (file)
@item Methods
@deffn {Method} {%make-gl-context} (HOST @t{api-1}) &key SURFACE VERSION DOUBLE-BUFFER ALPHA-SIZE RED-SIZE GREEN-SIZE BLUE-SIZE DEPTH-SIZE STENCIL-SIZE BUFFER-SIZE &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%MAKE-GL-CONTEXT CEPL<dot>HOST<colon><colon>API-1 method}@c
@methodsubindex{%make-gl-context}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-1<dot>lisp file, , @t{host/api-1.lisp}} (file)
@end table
@end deffn
@deffn {Method} {%make-gl-context} (HOST @t{api-0}) &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%MAKE-GL-CONTEXT CEPL<dot>HOST<colon><colon>API-0 method}@c
@methodsubindex{%make-gl-context}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-0<dot>lisp file, , @t{host/api-0.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {%make-gl-context-shared-with-current-context} HOST &key CURRENT-GL-CONTEXT SURFACE VERSION DOUBLE-BUFFER ALPHA-SIZE RED-SIZE GREEN-SIZE BLUE-SIZE DEPTH-SIZE STENCIL-SIZE BUFFER-SIZE &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%MAKE-GL-CONTEXT-SHARED-WITH-CURRENT-CONTEXT generic function}@c
@genericsubindex{%make-gl-context-shared-with-current-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-generics<dot>lisp file, , @t{host/api-generics.lisp}} (file)
@item Methods
@deffn {Method} {%make-gl-context-shared-with-current-context} (HOST @t{api-2}) &key CURRENT-GL-CONTEXT SURFACE VERSION DOUBLE-BUFFER ALPHA-SIZE RED-SIZE GREEN-SIZE BLUE-SIZE DEPTH-SIZE STENCIL-SIZE BUFFER-SIZE &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%MAKE-GL-CONTEXT-SHARED-WITH-CURRENT-CONTEXT CEPL<dot>HOST<colon><colon>API-2 method}@c
@methodsubindex{%make-gl-context-shared-with-current-context}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-2<dot>lisp file, , @t{host/api-2.lisp}} (file)
@end table
@end deffn
@deffn {Method} {%make-gl-context-shared-with-current-context} (HOST @t{api-1}) &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%MAKE-GL-CONTEXT-SHARED-WITH-CURRENT-CONTEXT CEPL<dot>HOST<colon><colon>API-1 method}@c
@methodsubindex{%make-gl-context-shared-with-current-context}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-1<dot>lisp file, , @t{host/api-1.lisp}} (file)
@end table
@end deffn
@deffn {Method} {%make-gl-context-shared-with-current-context} (HOST @t{api-0}) &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%MAKE-GL-CONTEXT-SHARED-WITH-CURRENT-CONTEXT CEPL<dot>HOST<colon><colon>API-0 method}@c
@methodsubindex{%make-gl-context-shared-with-current-context}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-0<dot>lisp file, , @t{host/api-0.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {%make-surface} HOST &rest ARGS &key WIDTH HEIGHT TITLE FULLSCREEN NO-FRAME ALPHA-SIZE RED-SIZE GREEN-SIZE BLUE-SIZE DEPTH-SIZE STENCIL-SIZE BUFFER-SIZE DOUBLE-BUFFER HIDDEN RESIZABLE &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%MAKE-SURFACE generic function}@c
@genericsubindex{%make-surface}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-generics<dot>lisp file, , @t{host/api-generics.lisp}} (file)
@item Methods
@deffn {Method} {%make-surface} (HOST @t{api-1}) &key WIDTH HEIGHT TITLE FULLSCREEN NO-FRAME ALPHA-SIZE RED-SIZE GREEN-SIZE BLUE-SIZE DEPTH-SIZE STENCIL-SIZE BUFFER-SIZE DOUBLE-BUFFER HIDDEN RESIZABLE &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%MAKE-SURFACE CEPL<dot>HOST<colon><colon>API-1 method}@c
@methodsubindex{%make-surface}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-1<dot>lisp file, , @t{host/api-1.lisp}} (file)
@end table
@end deffn
@deffn {Method} {%make-surface} (HOST @t{api-0}) &rest ARGS &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%MAKE-SURFACE CEPL<dot>HOST<colon><colon>API-0 method}@c
@methodsubindex{%make-surface}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-0<dot>lisp file, , @t{host/api-0.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {%recompile-gpu-function-and-pipelines} KEY
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%RECOMPILE-GPU-FUNCTION-AND-PIPELINES generic function}@c
@genericsubindex{%recompile-gpu-function-and-pipelines}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/generics<dot>lisp file, , @t{core/pipelines/generics.lisp}} (file)
@item Methods
@deffn {Method} {%recompile-gpu-function-and-pipelines} (KEY @t{func-key})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%RECOMPILE-GPU-FUNCTION-AND-PIPELINES CEPL<dot>PIPELINES<colon><colon>FUNC-KEY method}@c
@methodsubindex{%recompile-gpu-function-and-pipelines}@c
Recompile all pipelines that depend on the named gpu function or any other
   gpu function that depends on the named gpu function. It does this by doing
   the following:@*

   [0] Recursively call this function on all gpu functions that use the
       gpu function named in the argument@*

   [1] Trigger a recompile on all pipelines that depend on this gpu function
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Method} {%recompile-gpu-function-and-pipelines} KEY
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%RECOMPILE-GPU-FUNCTION-AND-PIPELINES COMMON-LISP<colon><colon>T method}@c
@methodsubindex{%recompile-gpu-function-and-pipelines}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {%set-surface-fullscreen} HOST SURFACE STATE &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SET-SURFACE-FULLSCREEN generic function}@c
@genericsubindex{%set-surface-fullscreen}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-generics<dot>lisp file, , @t{host/api-generics.lisp}} (file)
@item Methods
@deffn {Method} {%set-surface-fullscreen} HOST SURFACE STATE &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SET-SURFACE-FULLSCREEN COMMON-LISP<colon><colon>T COMMON-LISP<colon><colon>T COMMON-LISP<colon><colon>T method}@c
@methodsubindex{%set-surface-fullscreen}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Method} {%set-surface-fullscreen} (HOST @t{api-1}) SURFACE STATE &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SET-SURFACE-FULLSCREEN CEPL<dot>HOST<colon><colon>API-1 COMMON-LISP<colon><colon>T COMMON-LISP<colon><colon>T method}@c
@methodsubindex{%set-surface-fullscreen}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-1<dot>lisp file, , @t{host/api-1.lisp}} (file)
@end table
@end deffn
@deffn {Method} {%set-surface-fullscreen} (HOST @t{api-0}) SURFACE STATE &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SET-SURFACE-FULLSCREEN CEPL<dot>HOST<colon><colon>API-0 COMMON-LISP<colon><colon>T COMMON-LISP<colon><colon>T method}@c
@methodsubindex{%set-surface-fullscreen}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-0<dot>lisp file, , @t{host/api-0.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {%set-surface-size} HOST SURFACE WIDTH HEIGHT &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SET-SURFACE-SIZE generic function}@c
@genericsubindex{%set-surface-size}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-generics<dot>lisp file, , @t{host/api-generics.lisp}} (file)
@item Methods
@deffn {Method} {%set-surface-size} HOST SURFACE WIDTH HEIGHT &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SET-SURFACE-SIZE COMMON-LISP<colon><colon>T COMMON-LISP<colon><colon>T COMMON-LISP<colon><colon>T COMMON-LISP<colon><colon>T method}@c
@methodsubindex{%set-surface-size}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Method} {%set-surface-size} (HOST @t{api-1}) SURFACE WIDTH HEIGHT &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SET-SURFACE-SIZE CEPL<dot>HOST<colon><colon>API-1 COMMON-LISP<colon><colon>T COMMON-LISP<colon><colon>T COMMON-LISP<colon><colon>T method}@c
@methodsubindex{%set-surface-size}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-1<dot>lisp file, , @t{host/api-1.lisp}} (file)
@end table
@end deffn
@deffn {Method} {%set-surface-size} (HOST @t{api-0}) SURFACE WIDTH HEIGHT &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SET-SURFACE-SIZE CEPL<dot>HOST<colon><colon>API-0 COMMON-LISP<colon><colon>T COMMON-LISP<colon><colon>T COMMON-LISP<colon><colon>T method}@c
@methodsubindex{%set-surface-size}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-0<dot>lisp file, , @t{host/api-0.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {%set-surface-title} HOST SURFACE TITLE &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SET-SURFACE-TITLE generic function}@c
@genericsubindex{%set-surface-title}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-generics<dot>lisp file, , @t{host/api-generics.lisp}} (file)
@item Methods
@deffn {Method} {%set-surface-title} HOST SURFACE TITLE &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SET-SURFACE-TITLE COMMON-LISP<colon><colon>T COMMON-LISP<colon><colon>T COMMON-LISP<colon><colon>T method}@c
@methodsubindex{%set-surface-title}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Method} {%set-surface-title} (HOST @t{api-1}) SURFACE TITLE &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SET-SURFACE-TITLE CEPL<dot>HOST<colon><colon>API-1 COMMON-LISP<colon><colon>T COMMON-LISP<colon><colon>T method}@c
@methodsubindex{%set-surface-title}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-1<dot>lisp file, , @t{host/api-1.lisp}} (file)
@end table
@end deffn
@deffn {Method} {%set-surface-title} (HOST @t{api-0}) SURFACE TITLE &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SET-SURFACE-TITLE CEPL<dot>HOST<colon><colon>API-0 COMMON-LISP<colon><colon>T COMMON-LISP<colon><colon>T method}@c
@methodsubindex{%set-surface-title}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-0<dot>lisp file, , @t{host/api-0.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {%shutdown} HOST &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SHUTDOWN generic function}@c
@genericsubindex{%shutdown}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-generics<dot>lisp file, , @t{host/api-generics.lisp}} (file)
@item Methods
@deffn {Method} {%shutdown} (HOST @t{api-1}) &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SHUTDOWN CEPL<dot>HOST<colon><colon>API-1 method}@c
@methodsubindex{%shutdown}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-1<dot>lisp file, , @t{host/api-1.lisp}} (file)
@end table
@end deffn
@deffn {Method} {%shutdown} (HOST @t{api-0}) &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SHUTDOWN CEPL<dot>HOST<colon><colon>API-0 method}@c
@methodsubindex{%shutdown}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-0<dot>lisp file, , @t{host/api-0.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {%subscribe-to-gpu-func} FUNC SUBSCRIBE-TO
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%SUBSCRIBE-TO-GPU-FUNC generic function}@c
@genericsubindex{%subscribe-to-gpu-func}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/generics<dot>lisp file, , @t{core/pipelines/generics.lisp}} (file)
@item Methods
@deffn {Method} {%subscribe-to-gpu-func} FUNC SUBSCRIBE-TO
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%SUBSCRIBE-TO-GPU-FUNC COMMON-LISP<colon><colon>T COMMON-LISP<colon><colon>T method}@c
@methodsubindex{%subscribe-to-gpu-func}@c
As the name would suggest this makes one function dependent on another
   It is used by #'%test-&-process-spec via #'%update-gpu-function-data 
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {%supports-multiple-contexts-p} HOST &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SUPPORTS-MULTIPLE-CONTEXTS-P generic function}@c
@genericsubindex{%supports-multiple-contexts-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-generics<dot>lisp file, , @t{host/api-generics.lisp}} (file)
@item Methods
@deffn {Method} {%supports-multiple-contexts-p} HOST &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SUPPORTS-MULTIPLE-CONTEXTS-P COMMON-LISP<colon><colon>T method}@c
@methodsubindex{%supports-multiple-contexts-p}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Method} {%supports-multiple-contexts-p} (HOST @t{api-1}) &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SUPPORTS-MULTIPLE-CONTEXTS-P CEPL<dot>HOST<colon><colon>API-1 method}@c
@methodsubindex{%supports-multiple-contexts-p}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-1<dot>lisp file, , @t{host/api-1.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {%supports-multiple-surfaces-p} HOST &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SUPPORTS-MULTIPLE-SURFACES-P generic function}@c
@genericsubindex{%supports-multiple-surfaces-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-generics<dot>lisp file, , @t{host/api-generics.lisp}} (file)
@item Methods
@deffn {Method} {%supports-multiple-surfaces-p} HOST &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SUPPORTS-MULTIPLE-SURFACES-P COMMON-LISP<colon><colon>T method}@c
@methodsubindex{%supports-multiple-surfaces-p}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Method} {%supports-multiple-surfaces-p} (HOST @t{api-1}) &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SUPPORTS-MULTIPLE-SURFACES-P CEPL<dot>HOST<colon><colon>API-1 method}@c
@methodsubindex{%supports-multiple-surfaces-p}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-1<dot>lisp file, , @t{host/api-1.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {%surface-fullscreen-p} HOST SURFACE &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SURFACE-FULLSCREEN-P generic function}@c
@genericsubindex{%surface-fullscreen-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-generics<dot>lisp file, , @t{host/api-generics.lisp}} (file)
@item Methods
@deffn {Method} {%surface-fullscreen-p} HOST SURFACE &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SURFACE-FULLSCREEN-P COMMON-LISP<colon><colon>T COMMON-LISP<colon><colon>T method}@c
@methodsubindex{%surface-fullscreen-p}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Method} {%surface-fullscreen-p} (HOST @t{api-1}) SURFACE &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SURFACE-FULLSCREEN-P CEPL<dot>HOST<colon><colon>API-1 COMMON-LISP<colon><colon>T method}@c
@methodsubindex{%surface-fullscreen-p}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-1<dot>lisp file, , @t{host/api-1.lisp}} (file)
@end table
@end deffn
@deffn {Method} {%surface-fullscreen-p} (HOST @t{api-0}) SURFACE &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SURFACE-FULLSCREEN-P CEPL<dot>HOST<colon><colon>API-0 COMMON-LISP<colon><colon>T method}@c
@methodsubindex{%surface-fullscreen-p}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-0<dot>lisp file, , @t{host/api-0.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {%surface-title} HOST SURFACE &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SURFACE-TITLE generic function}@c
@genericsubindex{%surface-title}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-generics<dot>lisp file, , @t{host/api-generics.lisp}} (file)
@item Methods
@deffn {Method} {%surface-title} HOST SURFACE &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SURFACE-TITLE COMMON-LISP<colon><colon>T COMMON-LISP<colon><colon>T method}@c
@methodsubindex{%surface-title}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Method} {%surface-title} (HOST @t{api-1}) SURFACE &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SURFACE-TITLE CEPL<dot>HOST<colon><colon>API-1 COMMON-LISP<colon><colon>T method}@c
@methodsubindex{%surface-title}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-1<dot>lisp file, , @t{host/api-1.lisp}} (file)
@end table
@end deffn
@deffn {Method} {%surface-title} (HOST @t{api-0}) SURFACE &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SURFACE-TITLE CEPL<dot>HOST<colon><colon>API-0 COMMON-LISP<colon><colon>T method}@c
@methodsubindex{%surface-title}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-0<dot>lisp file, , @t{host/api-0.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {%unsubscibe-from-all} SPEC
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%UNSUBSCIBE-FROM-ALL generic function}@c
@genericsubindex{%unsubscibe-from-all}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/generics<dot>lisp file, , @t{core/pipelines/generics.lisp}} (file)
@item Methods
@deffn {Method} {%unsubscibe-from-all} (FUNC-KEY @t{func-key})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%UNSUBSCIBE-FROM-ALL CEPL<dot>PIPELINES<colon><colon>FUNC-KEY method}@c
@methodsubindex{%unsubscibe-from-all}@c
As the name would suggest this removes one function's dependency on another
   It is used by #'%test-&-process-spec via #'%update-gpu-function-data
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Method} {%unsubscibe-from-all} SPEC
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%UNSUBSCIBE-FROM-ALL COMMON-LISP<colon><colon>T method}@c
@methodsubindex{%unsubscibe-from-all}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {always-uploadp} OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ALWAYS-UPLOADP generic function}@c
@genericsubindex{always-uploadp}@c
@deffnx {Generic Function} {(setf always-uploadp)} NEW-VALUE OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF ALWAYS-UPLOADP) generic function}@c
@genericsubindex{(setf always-uploadp)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Methods
@deffn {Method} {always-uploadp} (ASSIGNER @t{assigner})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ALWAYS-UPLOADP CEPL<dot>PIPELINES<colon><colon>ASSIGNER method}@c
@methodsubindex{always-uploadp}@c
automatically generated reader method
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Method} {(setf always-uploadp)} NEW-VALUE (ASSIGNER @t{assigner})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF ALWAYS-UPLOADP) COMMON-LISP<colon><colon>T CEPL<dot>PIPELINES<colon><colon>ASSIGNER method}@c
@methodsubindex{(setf always-uploadp)}@c
automatically generated writer method
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {arg-name} OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ARG-NAME generic function}@c
@genericsubindex{arg-name}@c
@deffnx {Generic Function} {(setf arg-name)} NEW-VALUE OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF ARG-NAME) generic function}@c
@genericsubindex{(setf arg-name)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Methods
@deffn {Method} {arg-name} (ASSIGNER @t{assigner})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ARG-NAME CEPL<dot>PIPELINES<colon><colon>ASSIGNER method}@c
@methodsubindex{arg-name}@c
automatically generated reader method
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Method} {(setf arg-name)} NEW-VALUE (ASSIGNER @t{assigner})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF ARG-NAME) COMMON-LISP<colon><colon>T CEPL<dot>PIPELINES<colon><colon>ASSIGNER method}@c
@methodsubindex{(setf arg-name)}@c
automatically generated writer method
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {assigner-body} OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ASSIGNER-BODY generic function}@c
@genericsubindex{assigner-body}@c
@deffnx {Generic Function} {(setf assigner-body)} NEW-VALUE OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF ASSIGNER-BODY) generic function}@c
@genericsubindex{(setf assigner-body)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Methods
@deffn {Method} {assigner-body} (ASSIGNER-LET-FORM @t{assigner-let-form})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ASSIGNER-BODY CEPL<dot>PIPELINES<colon><colon>ASSIGNER-LET-FORM method}@c
@methodsubindex{assigner-body}@c
automatically generated reader method
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Method} {(setf assigner-body)} NEW-VALUE (ASSIGNER-LET-FORM @t{assigner-let-form})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF ASSIGNER-BODY) COMMON-LISP<colon><colon>T CEPL<dot>PIPELINES<colon><colon>ASSIGNER-LET-FORM method}@c
@methodsubindex{(setf assigner-body)}@c
automatically generated writer method
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {assigner-index} OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ASSIGNER-INDEX generic function}@c
@genericsubindex{assigner-index}@c
@deffnx {Generic Function} {(setf assigner-index)} NEW-VALUE OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF ASSIGNER-INDEX) generic function}@c
@genericsubindex{(setf assigner-index)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Methods
@deffn {Method} {assigner-index} (ASSIGNER-LET-FORM @t{assigner-let-form})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ASSIGNER-INDEX CEPL<dot>PIPELINES<colon><colon>ASSIGNER-LET-FORM method}@c
@methodsubindex{assigner-index}@c
automatically generated reader method
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Method} {(setf assigner-index)} NEW-VALUE (ASSIGNER-LET-FORM @t{assigner-let-form})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF ASSIGNER-INDEX) COMMON-LISP<colon><colon>T CEPL<dot>PIPELINES<colon><colon>ASSIGNER-LET-FORM method}@c
@methodsubindex{(setf assigner-index)}@c
automatically generated writer method
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {assigner-name} OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ASSIGNER-NAME generic function}@c
@genericsubindex{assigner-name}@c
@deffnx {Generic Function} {(setf assigner-name)} NEW-VALUE OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF ASSIGNER-NAME) generic function}@c
@genericsubindex{(setf assigner-name)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Methods
@deffn {Method} {assigner-name} (ASSIGNER-LET-FORM @t{assigner-let-form})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ASSIGNER-NAME CEPL<dot>PIPELINES<colon><colon>ASSIGNER-LET-FORM method}@c
@methodsubindex{assigner-name}@c
automatically generated reader method
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Method} {(setf assigner-name)} NEW-VALUE (ASSIGNER-LET-FORM @t{assigner-let-form})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF ASSIGNER-NAME) COMMON-LISP<colon><colon>T CEPL<dot>PIPELINES<colon><colon>ASSIGNER-LET-FORM method}@c
@methodsubindex{(setf assigner-name)}@c
automatically generated writer method
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {assigner-type} OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ASSIGNER-TYPE generic function}@c
@genericsubindex{assigner-type}@c
@deffnx {Generic Function} {(setf assigner-type)} NEW-VALUE OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF ASSIGNER-TYPE) generic function}@c
@genericsubindex{(setf assigner-type)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Methods
@deffn {Method} {assigner-type} (ASSIGNER-LET-FORM @t{assigner-let-form})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ASSIGNER-TYPE CEPL<dot>PIPELINES<colon><colon>ASSIGNER-LET-FORM method}@c
@methodsubindex{assigner-type}@c
automatically generated reader method
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Method} {(setf assigner-type)} NEW-VALUE (ASSIGNER-LET-FORM @t{assigner-let-form})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF ASSIGNER-TYPE) COMMON-LISP<colon><colon>T CEPL<dot>PIPELINES<colon><colon>ASSIGNER-LET-FORM method}@c
@methodsubindex{(setf assigner-type)}@c
automatically generated writer method
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {check-host} HOST
@anchor{go to the CEPL<dot>HOST<colon><colon>CHECK-HOST generic function}@c
@genericsubindex{check-host}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-api<dot>lisp file, , @t{host/api-api.lisp}} (file)
@item Methods
@deffn {Method} {check-host} (HOST @t{api-2})
@anchor{go to the CEPL<dot>HOST<colon><colon>CHECK-HOST CEPL<dot>HOST<colon><colon>API-2 method}@c
@methodsubindex{check-host}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-2<dot>lisp file, , @t{host/api-2.lisp}} (file)
@end table
@end deffn
@deffn {Method} {check-host} (HOST @t{api-1})
@anchor{go to the CEPL<dot>HOST<colon><colon>CHECK-HOST CEPL<dot>HOST<colon><colon>API-1 method}@c
@methodsubindex{check-host}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-1<dot>lisp file, , @t{host/api-1.lisp}} (file)
@end table
@end deffn
@deffn {Method} {check-host} (HOST @t{api-0})
@anchor{go to the CEPL<dot>HOST<colon><colon>CHECK-HOST CEPL<dot>HOST<colon><colon>API-0 method}@c
@methodsubindex{check-host}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-0<dot>lisp file, , @t{host/api-0.lisp}} (file)
@end table
@end deffn
@deffn {Method} {check-host} HOST
@anchor{go to the CEPL<dot>HOST<colon><colon>CHECK-HOST COMMON-LISP<colon><colon>T method}@c
@methodsubindex{check-host}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {check-mipmap-level-count-valid} LEVEL-COUNT DIMENSIONS
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>CHECK-MIPMAP-LEVEL-COUNT-VALID generic function}@c
@genericsubindex{check-mipmap-level-count-valid}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@item Methods
@deffn {Method} {check-mipmap-level-count-valid} (LEVEL-COUNT @t{integer}) (DIMENSIONS @t{list})
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>CHECK-MIPMAP-LEVEL-COUNT-VALID COMMON-LISP<colon><colon>INTEGER COMMON-LISP<colon><colon>LIST method}@c
@methodsubindex{check-mipmap-level-count-valid}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {cleanup} OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>CLEANUP generic function}@c
@genericsubindex{cleanup}@c
@deffnx {Generic Function} {(setf cleanup)} NEW-VALUE OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF CLEANUP) generic function}@c
@genericsubindex{(setf cleanup)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Methods
@deffn {Method} {cleanup} (ASSIGNER @t{assigner})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>CLEANUP CEPL<dot>PIPELINES<colon><colon>ASSIGNER method}@c
@methodsubindex{cleanup}@c
automatically generated reader method
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Method} {(setf cleanup)} NEW-VALUE (ASSIGNER @t{assigner})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF CLEANUP) COMMON-LISP<colon><colon>T CEPL<dot>PIPELINES<colon><colon>ASSIGNER method}@c
@methodsubindex{(setf cleanup)}@c
automatically generated writer method
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {delete-func-spec} FUNC-KEY
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>DELETE-FUNC-SPEC generic function}@c
@genericsubindex{delete-func-spec}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@item Methods
@deffn {Method} {delete-func-spec} FUNC-KEY
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>DELETE-FUNC-SPEC COMMON-LISP<colon><colon>T method}@c
@methodsubindex{delete-func-spec}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {draw-buffer-i} CONTEXT BUFFER-NUM
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>DRAW-BUFFER-I generic function}@c
@genericsubindex{draw-buffer-i}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/gl-context<dot>lisp file, , @t{core/context/gl-context.lisp}} (file)
@item Methods
@deffn {Method} {draw-buffer-i} (CONTEXT @t{gl-context}) (BUFFER-NUM @t{integer})
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>DRAW-BUFFER-I CEPL<dot>CONTEXT<colon><colon>GL-CONTEXT COMMON-LISP<colon><colon>INTEGER method}@c
@methodsubindex{draw-buffer-i}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {func-key} SOURCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>FUNC-KEY generic function}@c
@genericsubindex{func-key}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/generics<dot>lisp file, , @t{core/pipelines/generics.lisp}} (file)
@item Methods
@deffn {Method} {func-key} (KEY @t{func-key})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>FUNC-KEY CEPL<dot>PIPELINES<colon><colon>FUNC-KEY method}@c
@methodsubindex{func-key}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Method} {func-key} (SPEC @t{external-function})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>FUNC-KEY VARJO<dot>INTERNALS<colon><colon>EXTERNAL-FUNCTION method}@c
@methodsubindex{func-key}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Method} {func-key} (SPEC @t{gpu-func-spec})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>FUNC-KEY CEPL<dot>PIPELINES<colon><colon>GPU-FUNC-SPEC method}@c
@methodsubindex{func-key}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {func-key->name} KEY
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>FUNC-KEY->NAME generic function}@c
@genericsubindex{func-key->name}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/generics<dot>lisp file, , @t{core/pipelines/generics.lisp}} (file)
@item Methods
@deffn {Method} {func-key->name} (KEY @t{func-key})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>FUNC-KEY->NAME CEPL<dot>PIPELINES<colon><colon>FUNC-KEY method}@c
@methodsubindex{func-key->name}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {func-key=} X Y
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>FUNC-KEY= generic function}@c
@genericsubindex{func-key=}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/generics<dot>lisp file, , @t{core/pipelines/generics.lisp}} (file)
@item Methods
@deffn {Method} {func-key=} X Y
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>FUNC-KEY= COMMON-LISP<colon><colon>T COMMON-LISP<colon><colon>T method}@c
@methodsubindex{func-key=}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Method} {func-key=} (X @t{func-key}) Y
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>FUNC-KEY= CEPL<dot>PIPELINES<colon><colon>FUNC-KEY COMMON-LISP<colon><colon>T method}@c
@methodsubindex{func-key=}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Method} {func-key=} X (Y @t{func-key})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>FUNC-KEY= COMMON-LISP<colon><colon>T CEPL<dot>PIPELINES<colon><colon>FUNC-KEY method}@c
@methodsubindex{func-key=}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Method} {func-key=} (X @t{func-key}) (Y @t{func-key})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>FUNC-KEY= CEPL<dot>PIPELINES<colon><colon>FUNC-KEY CEPL<dot>PIPELINES<colon><colon>FUNC-KEY method}@c
@methodsubindex{func-key=}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {funcs-that-use-this-func} KEY
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>FUNCS-THAT-USE-THIS-FUNC generic function}@c
@genericsubindex{funcs-that-use-this-func}@c
@deffnx {Generic Function} {(setf funcs-that-use-this-func)} VALUE KEY
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF FUNCS-THAT-USE-THIS-FUNC) generic function}@c
@genericsubindex{(setf funcs-that-use-this-func)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/generics<dot>lisp file, , @t{core/pipelines/generics.lisp}} (file)
@item Methods
@deffn {Method} {funcs-that-use-this-func} (KEY @t{func-key})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>FUNCS-THAT-USE-THIS-FUNC CEPL<dot>PIPELINES<colon><colon>FUNC-KEY method}@c
@methodsubindex{funcs-that-use-this-func}@c
@deffnx {Method} {(setf funcs-that-use-this-func)} VALUE (KEY @t{func-key})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF FUNCS-THAT-USE-THIS-FUNC) COMMON-LISP<colon><colon>T CEPL<dot>PIPELINES<colon><colon>FUNC-KEY method}@c
@methodsubindex{(setf funcs-that-use-this-func)}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Method} {funcs-that-use-this-func} KEY
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>FUNCS-THAT-USE-THIS-FUNC COMMON-LISP<colon><colon>T method}@c
@methodsubindex{funcs-that-use-this-func}@c
@deffnx {Method} {(setf funcs-that-use-this-func)} VALUE KEY
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF FUNCS-THAT-USE-THIS-FUNC) COMMON-LISP<colon><colon>T COMMON-LISP<colon><colon>T method}@c
@methodsubindex{(setf funcs-that-use-this-func)}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {gen-cleanup-block} ASSIGNERS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GEN-CLEANUP-BLOCK generic function}@c
@genericsubindex{gen-cleanup-block}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/generics<dot>lisp file, , @t{core/pipelines/generics.lisp}} (file)
@item Methods
@deffn {Method} {gen-cleanup-block} (ASSIGNER @t{assigner})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GEN-CLEANUP-BLOCK CEPL<dot>PIPELINES<colon><colon>ASSIGNER method}@c
@methodsubindex{gen-cleanup-block}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {gen-uploaders-block} ASSIGNERS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GEN-UPLOADERS-BLOCK generic function}@c
@genericsubindex{gen-uploaders-block}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/generics<dot>lisp file, , @t{core/pipelines/generics.lisp}} (file)
@item Methods
@deffn {Method} {gen-uploaders-block} (ASSIGNER @t{assigner})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GEN-UPLOADERS-BLOCK CEPL<dot>PIPELINES<colon><colon>ASSIGNER method}@c
@methodsubindex{gen-uploaders-block}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {gpu-func-spec} KEY &optional ERROR-IF-MISSING
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GPU-FUNC-SPEC generic function}@c
@genericsubindex{gpu-func-spec}@c
@deffnx {Generic Function} {(setf gpu-func-spec)} VALUE FUNC-KEY &optional ERROR-IF-MISSING
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF GPU-FUNC-SPEC) generic function}@c
@genericsubindex{(setf gpu-func-spec)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/generics<dot>lisp file, , @t{core/pipelines/generics.lisp}} (file)
@item Methods
@deffn {Method} {gpu-func-spec} (FUNC-KEY @t{func-key}) &optional ERROR-IF-MISSING
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GPU-FUNC-SPEC CEPL<dot>PIPELINES<colon><colon>FUNC-KEY method}@c
@methodsubindex{gpu-func-spec}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Method} {gpu-func-spec} (FUNC-KEY @t{gpu-func-spec}) &optional ERROR-IF-MISSING
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GPU-FUNC-SPEC CEPL<dot>PIPELINES<colon><colon>GPU-FUNC-SPEC method}@c
@methodsubindex{gpu-func-spec}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Method} {gpu-func-spec} KEY &optional ERROR-IF-MISSING
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GPU-FUNC-SPEC COMMON-LISP<colon><colon>T method}@c
@methodsubindex{gpu-func-spec}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Method} {(setf gpu-func-spec)} VALUE (KEY @t{func-key}) &optional ERROR-IF-MISSING
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF GPU-FUNC-SPEC) COMMON-LISP<colon><colon>T CEPL<dot>PIPELINES<colon><colon>FUNC-KEY method}@c
@methodsubindex{(setf gpu-func-spec)}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Method} {(setf gpu-func-spec)} VALUE KEY &optional ERROR-IF-MISSING
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF GPU-FUNC-SPEC) COMMON-LISP<colon><colon>T COMMON-LISP<colon><colon>T method}@c
@methodsubindex{(setf gpu-func-spec)}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {handle} OBJECT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>HANDLE generic function}@c
@genericsubindex{handle}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Methods
@deffn {Method} {handle} (GL-CONTEXT @t{gl-context})
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>HANDLE CEPL<dot>CONTEXT<colon><colon>GL-CONTEXT method}@c
@methodsubindex{handle}@c
automatically generated reader method
@table @strong
@item Source
@ref{go to the cepl/core/context/gl-context<dot>lisp file, , @t{core/context/gl-context.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {handle-defn-declaration} NAME %FUNC-NAME ARGS
@anchor{go to the CEPL<dot>DEFN<colon><colon>HANDLE-DEFN-DECLARATION generic function}@c
@genericsubindex{handle-defn-declaration}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>DEFN package, , @t{cepl.defn}}
@item Source
@ref{go to the cepl<dot>build/defn/defn<dot>lisp file, , @t{defn/defn.lisp}} (file)
@item Methods
@deffn {Method} {handle-defn-declaration} NAME %FUNC-NAME ARGS
@anchor{go to the CEPL<dot>DEFN<colon><colon>HANDLE-DEFN-DECLARATION COMMON-LISP<colon><colon>T COMMON-LISP<colon><colon>T COMMON-LISP<colon><colon>T method}@c
@methodsubindex{handle-defn-declaration}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {in-args} OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>IN-ARGS generic function}@c
@genericsubindex{in-args}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Methods
@deffn {Method} {in-args} (FUNC-KEY @t{func-key})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>IN-ARGS CEPL<dot>PIPELINES<colon><colon>FUNC-KEY method}@c
@methodsubindex{in-args}@c
automatically generated reader method
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {infer-implicit-uniform-type} THING
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>INFER-IMPLICIT-UNIFORM-TYPE generic function}@c
@genericsubindex{infer-implicit-uniform-type}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@item Methods
@deffn {Method} {infer-implicit-uniform-type} THING
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>INFER-IMPLICIT-UNIFORM-TYPE COMMON-LISP<colon><colon>T method}@c
@methodsubindex{infer-implicit-uniform-type}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {lambda-g->func-spec} LAMBDA-G
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>LAMBDA-G->FUNC-SPEC generic function}@c
@genericsubindex{lambda-g->func-spec}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/generics<dot>lisp file, , @t{core/pipelines/generics.lisp}} (file)
@item Methods
@deffn {Method} {lambda-g->func-spec} (LAMBDA-G @t{function})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>LAMBDA-G->FUNC-SPEC COMMON-LISP<colon><colon>FUNCTION method}@c
@methodsubindex{lambda-g->func-spec}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-lambda<dot>lisp file, , @t{core/pipelines/gpu-lambda.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {let-forms} OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>LET-FORMS generic function}@c
@genericsubindex{let-forms}@c
@deffnx {Generic Function} {(setf let-forms)} NEW-VALUE OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF LET-FORMS) generic function}@c
@genericsubindex{(setf let-forms)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Methods
@deffn {Method} {let-forms} (ASSIGNER @t{assigner})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>LET-FORMS CEPL<dot>PIPELINES<colon><colon>ASSIGNER method}@c
@methodsubindex{let-forms}@c
automatically generated reader method
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Method} {(setf let-forms)} NEW-VALUE (ASSIGNER @t{assigner})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF LET-FORMS) COMMON-LISP<colon><colon>T CEPL<dot>PIPELINES<colon><colon>ASSIGNER method}@c
@methodsubindex{(setf let-forms)}@c
automatically generated writer method
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {local-arg-name} OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>LOCAL-ARG-NAME generic function}@c
@genericsubindex{local-arg-name}@c
@deffnx {Generic Function} {(setf local-arg-name)} NEW-VALUE OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF LOCAL-ARG-NAME) generic function}@c
@genericsubindex{(setf local-arg-name)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Methods
@deffn {Method} {local-arg-name} (ASSIGNER @t{assigner})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>LOCAL-ARG-NAME CEPL<dot>PIPELINES<colon><colon>ASSIGNER method}@c
@methodsubindex{local-arg-name}@c
automatically generated reader method
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Method} {(setf local-arg-name)} NEW-VALUE (ASSIGNER @t{assigner})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF LOCAL-ARG-NAME) COMMON-LISP<colon><colon>T CEPL<dot>PIPELINES<colon><colon>ASSIGNER method}@c
@methodsubindex{(setf local-arg-name)}@c
automatically generated writer method
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {pipeline-stage-pairs} SPEC
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>PIPELINE-STAGE-PAIRS generic function}@c
@genericsubindex{pipeline-stage-pairs}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/generics<dot>lisp file, , @t{core/pipelines/generics.lisp}} (file)
@item Methods
@deffn {Method} {pipeline-stage-pairs} (SPEC @t{pipeline-spec-base})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>PIPELINE-STAGE-PAIRS CEPL<dot>PIPELINES<colon><colon>PIPELINE-SPEC-BASE method}@c
@methodsubindex{pipeline-stage-pairs}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {pipeline-stages} SPEC
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>PIPELINE-STAGES generic function}@c
@genericsubindex{pipeline-stages}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/generics<dot>lisp file, , @t{core/pipelines/generics.lisp}} (file)
@item Methods
@deffn {Method} {pipeline-stages} (SPEC @t{pipeline-spec-base})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>PIPELINE-STAGES CEPL<dot>PIPELINES<colon><colon>PIPELINE-SPEC-BASE method}@c
@methodsubindex{pipeline-stages}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {pipelines-that-use-this-as-a-stage} FUNC-KEY
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>PIPELINES-THAT-USE-THIS-AS-A-STAGE generic function}@c
@genericsubindex{pipelines-that-use-this-as-a-stage}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/generics<dot>lisp file, , @t{core/pipelines/generics.lisp}} (file)
@end table
@end deffn
@deffn {Generic Function} {pixel-format-from-array} ARRAY
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>PIXEL-FORMAT-FROM-ARRAY generic function}@c
@genericsubindex{pixel-format-from-array}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@item Methods
@deffn {Method} {pixel-format-from-array} (ARR @t{c-array})
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>PIXEL-FORMAT-FROM-ARRAY %CEPL<dot>TYPES<colon><colon>C-ARRAY method}@c
@methodsubindex{pixel-format-from-array}@c
@end deffn
@deffn {Method} {pixel-format-from-array} (ARR @t{gpu-array-bb})
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>PIXEL-FORMAT-FROM-ARRAY %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB method}@c
@methodsubindex{pixel-format-from-array}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {pointer-arg} OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>POINTER-ARG generic function}@c
@genericsubindex{pointer-arg}@c
@deffnx {Generic Function} {(setf pointer-arg)} NEW-VALUE OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF POINTER-ARG) generic function}@c
@genericsubindex{(setf pointer-arg)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Methods
@deffn {Method} {pointer-arg} (ASSIGNER @t{assigner})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>POINTER-ARG CEPL<dot>PIPELINES<colon><colon>ASSIGNER method}@c
@methodsubindex{pointer-arg}@c
automatically generated reader method
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Method} {(setf pointer-arg)} NEW-VALUE (ASSIGNER @t{assigner})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF POINTER-ARG) COMMON-LISP<colon><colon>T CEPL<dot>PIPELINES<colon><colon>ASSIGNER method}@c
@methodsubindex{(setf pointer-arg)}@c
automatically generated writer method
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {recompile-pipelines-that-use-this-as-a-stage} KEY
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>RECOMPILE-PIPELINES-THAT-USE-THIS-AS-A-STAGE generic function}@c
@genericsubindex{recompile-pipelines-that-use-this-as-a-stage}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/generics<dot>lisp file, , @t{core/pipelines/generics.lisp}} (file)
@item Methods
@deffn {Method} {recompile-pipelines-that-use-this-as-a-stage} (KEY @t{func-key})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>RECOMPILE-PIPELINES-THAT-USE-THIS-AS-A-STAGE CEPL<dot>PIPELINES<colon><colon>FUNC-KEY method}@c
@methodsubindex{recompile-pipelines-that-use-this-as-a-stage}@c
Recompile all pipelines that depend on the named gpu function or any other
   gpu function that depends on the named gpu function. It does this by
   triggering a recompile on all pipelines that depend on this glsl-stage
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {s-arrayp} OBJECT
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-ARRAYP generic function}@c
@genericsubindex{s-arrayp}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@item Methods
@deffn {Method} {s-arrayp} (OBJECT @t{gl-struct-slot})
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-ARRAYP CEPL<dot>TYPES<colon><colon>GL-STRUCT-SLOT method}@c
@methodsubindex{s-arrayp}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {s-def} OBJECT
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-DEF generic function}@c
@genericsubindex{s-def}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@item Methods
@deffn {Method} {s-def} (OBJECT @t{gl-struct-slot})
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-DEF CEPL<dot>TYPES<colon><colon>GL-STRUCT-SLOT method}@c
@methodsubindex{s-def}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {s-dimensions} OBJECT
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-DIMENSIONS generic function}@c
@genericsubindex{s-dimensions}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Methods
@deffn {Method} {s-dimensions} (GL-STRUCT-SLOT @t{gl-struct-slot})
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-DIMENSIONS CEPL<dot>TYPES<colon><colon>GL-STRUCT-SLOT method}@c
@methodsubindex{s-dimensions}@c
automatically generated reader method
@table @strong
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {s-element-type} OBJECT
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-ELEMENT-TYPE generic function}@c
@genericsubindex{s-element-type}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Methods
@deffn {Method} {s-element-type} (GL-STRUCT-SLOT @t{gl-struct-slot})
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-ELEMENT-TYPE CEPL<dot>TYPES<colon><colon>GL-STRUCT-SLOT method}@c
@methodsubindex{s-element-type}@c
automatically generated reader method
@table @strong
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {s-foreign-name} OBJECT
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-FOREIGN-NAME generic function}@c
@genericsubindex{s-foreign-name}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Methods
@deffn {Method} {s-foreign-name} (CEPL-STRUCT-DEFINITION @t{cepl-struct-definition})
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-FOREIGN-NAME CEPL<dot>TYPES<colon><colon>CEPL-STRUCT-DEFINITION method}@c
@methodsubindex{s-foreign-name}@c
automatically generated reader method
@table @strong
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {s-layout} OBJECT
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-LAYOUT generic function}@c
@genericsubindex{s-layout}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Methods
@deffn {Method} {s-layout} (GL-STRUCT-SLOT @t{gl-struct-slot})
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-LAYOUT CEPL<dot>TYPES<colon><colon>GL-STRUCT-SLOT method}@c
@methodsubindex{s-layout}@c
automatically generated reader method
@table @strong
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Method} {s-layout} (CEPL-STRUCT-DEFINITION @t{cepl-struct-definition})
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-LAYOUT CEPL<dot>TYPES<colon><colon>CEPL-STRUCT-DEFINITION method}@c
@methodsubindex{s-layout}@c
automatically generated reader method
@table @strong
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {s-name} OBJECT
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-NAME generic function}@c
@genericsubindex{s-name}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Methods
@deffn {Method} {s-name} (GL-STRUCT-SLOT @t{gl-struct-slot})
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-NAME CEPL<dot>TYPES<colon><colon>GL-STRUCT-SLOT method}@c
@methodsubindex{s-name}@c
automatically generated reader method
@table @strong
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Method} {s-name} (CEPL-STRUCT-DEFINITION @t{cepl-struct-definition})
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-NAME CEPL<dot>TYPES<colon><colon>CEPL-STRUCT-DEFINITION method}@c
@methodsubindex{s-name}@c
automatically generated reader method
@table @strong
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {s-normalizedp} OBJECT
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-NORMALIZEDP generic function}@c
@genericsubindex{s-normalizedp}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Methods
@deffn {Method} {s-normalizedp} (GL-STRUCT-SLOT @t{gl-struct-slot})
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-NORMALIZEDP CEPL<dot>TYPES<colon><colon>GL-STRUCT-SLOT method}@c
@methodsubindex{s-normalizedp}@c
automatically generated reader method
@table @strong
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {s-parent-ffi-name} OBJECT
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-PARENT-FFI-NAME generic function}@c
@genericsubindex{s-parent-ffi-name}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Methods
@deffn {Method} {s-parent-ffi-name} (GL-STRUCT-SLOT @t{gl-struct-slot})
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-PARENT-FFI-NAME CEPL<dot>TYPES<colon><colon>GL-STRUCT-SLOT method}@c
@methodsubindex{s-parent-ffi-name}@c
automatically generated reader method
@table @strong
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {s-reader} OBJECT
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-READER generic function}@c
@genericsubindex{s-reader}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Methods
@deffn {Method} {s-reader} (GL-STRUCT-SLOT @t{gl-struct-slot})
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-READER CEPL<dot>TYPES<colon><colon>GL-STRUCT-SLOT method}@c
@methodsubindex{s-reader}@c
automatically generated reader method
@table @strong
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {s-slot-args} SLOT ARGS
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-SLOT-ARGS generic function}@c
@genericsubindex{s-slot-args}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@item Methods
@deffn {Method} {s-slot-args} (SLOT @t{gl-struct-slot}) (ARGS @t{list})
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-SLOT-ARGS CEPL<dot>TYPES<colon><colon>GL-STRUCT-SLOT COMMON-LISP<colon><colon>LIST method}@c
@methodsubindex{s-slot-args}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {s-slots} OBJECT
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-SLOTS generic function}@c
@genericsubindex{s-slots}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Methods
@deffn {Method} {s-slots} (CEPL-STRUCT-DEFINITION @t{cepl-struct-definition})
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-SLOTS CEPL<dot>TYPES<colon><colon>CEPL-STRUCT-DEFINITION method}@c
@methodsubindex{s-slots}@c
automatically generated reader method
@table @strong
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {s-type} OBJECT
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-TYPE generic function}@c
@genericsubindex{s-type}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Methods
@deffn {Method} {s-type} (GL-STRUCT-SLOT @t{gl-struct-slot})
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-TYPE CEPL<dot>TYPES<colon><colon>GL-STRUCT-SLOT method}@c
@methodsubindex{s-type}@c
automatically generated reader method
@table @strong
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {s-uses-method-p} OBJECT
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-USES-METHOD-P generic function}@c
@genericsubindex{s-uses-method-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Methods
@deffn {Method} {s-uses-method-p} (GL-STRUCT-SLOT @t{gl-struct-slot})
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-USES-METHOD-P CEPL<dot>TYPES<colon><colon>GL-STRUCT-SLOT method}@c
@methodsubindex{s-uses-method-p}@c
automatically generated reader method
@table @strong
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {s-writer} OBJECT
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-WRITER generic function}@c
@genericsubindex{s-writer}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Methods
@deffn {Method} {s-writer} (GL-STRUCT-SLOT @t{gl-struct-slot})
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-WRITER CEPL<dot>TYPES<colon><colon>GL-STRUCT-SLOT method}@c
@methodsubindex{s-writer}@c
automatically generated reader method
@table @strong
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {set-primary-thread-and-run} FUNC &rest ARGS
@anchor{go to the CEPL<dot>HOST<colon><colon>SET-PRIMARY-THREAD-AND-RUN generic function}@c
@genericsubindex{set-primary-thread-and-run}@c
This will be called from the UI thread (if required by the OS)
    Implement and use this if you need to do some setup from that thread
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-0<dot>lisp file, , @t{host/api-0.lisp}} (file)
@end table
@end deffn
@deffn {Generic Function} {spec->func-key} SPEC
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>SPEC->FUNC-KEY generic function}@c
@genericsubindex{spec->func-key}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/generics<dot>lisp file, , @t{core/pipelines/generics.lisp}} (file)
@item Methods
@deffn {Method} {spec->func-key} (SPEC @t{func-key})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>SPEC->FUNC-KEY CEPL<dot>PIPELINES<colon><colon>FUNC-KEY method}@c
@methodsubindex{spec->func-key}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Method} {spec->func-key} (SPEC @t{gpu-func-spec})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>SPEC->FUNC-KEY CEPL<dot>PIPELINES<colon><colon>GPU-FUNC-SPEC method}@c
@methodsubindex{spec->func-key}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {unpack-arrayd-assigner} ASSIGNER
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>UNPACK-ARRAYD-ASSIGNER generic function}@c
@genericsubindex{unpack-arrayd-assigner}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/generics<dot>lisp file, , @t{core/pipelines/generics.lisp}} (file)
@item Methods
@deffn {Method} {unpack-arrayd-assigner} (ASSIGNER @t{assigner})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>UNPACK-ARRAYD-ASSIGNER CEPL<dot>PIPELINES<colon><colon>ASSIGNER method}@c
@methodsubindex{unpack-arrayd-assigner}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {uploaders} OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>UPLOADERS generic function}@c
@genericsubindex{uploaders}@c
@deffnx {Generic Function} {(setf uploaders)} NEW-VALUE OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF UPLOADERS) generic function}@c
@genericsubindex{(setf uploaders)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Methods
@deffn {Method} {uploaders} (ASSIGNER @t{assigner})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>UPLOADERS CEPL<dot>PIPELINES<colon><colon>ASSIGNER method}@c
@methodsubindex{uploaders}@c
automatically generated reader method
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Method} {(setf uploaders)} NEW-VALUE (ASSIGNER @t{assigner})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF UPLOADERS) COMMON-LISP<colon><colon>T CEPL<dot>PIPELINES<colon><colon>ASSIGNER method}@c
@methodsubindex{(setf uploaders)}@c
automatically generated writer method
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
" :AFTER-MENU-CONTENTS NIL) :PREVIOUS #18# :UP #1# :CHILDREN NIL :BEFORE-MENU-CONTENTS "@deffn {Function} {%across-c-1d} FUNC ARR
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>%ACROSS-C-1D function}@c
@functionsubindex{%across-c-1d}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/map<dot>lisp file, , @t{core/c-arrays/map.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%across-c-2d} FUNC ARR
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>%ACROSS-C-2D function}@c
@functionsubindex{%across-c-2d}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/map<dot>lisp file, , @t{core/c-arrays/map.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%across-c-3d} FUNC ARR
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>%ACROSS-C-3D function}@c
@functionsubindex{%across-c-3d}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/map<dot>lisp file, , @t{core/c-arrays/map.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%across-c-4d} FUNC ARR
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>%ACROSS-C-4D function}@c
@functionsubindex{%across-c-4d}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/map<dot>lisp file, , @t{core/c-arrays/map.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%across-c-ptr-1d} FUNC ARR
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>%ACROSS-C-PTR-1D function}@c
@functionsubindex{%across-c-ptr-1d}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/map<dot>lisp file, , @t{core/c-arrays/map.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%across-c-ptr-2d} FUNC ARR
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>%ACROSS-C-PTR-2D function}@c
@functionsubindex{%across-c-ptr-2d}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/map<dot>lisp file, , @t{core/c-arrays/map.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%across-c-ptr-3d} FUNC ARR
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>%ACROSS-C-PTR-3D function}@c
@functionsubindex{%across-c-ptr-3d}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/map<dot>lisp file, , @t{core/c-arrays/map.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%across-c-ptr-4d} FUNC ARR
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>%ACROSS-C-PTR-4D function}@c
@functionsubindex{%across-c-ptr-4d}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/map<dot>lisp file, , @t{core/c-arrays/map.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%api-0-populate-singletons} &key WIDTH HEIGHT TITLE FULLSCREEN NO-FRAME ALPHA-SIZE DEPTH-SIZE STENCIL-SIZE RED-SIZE GREEN-SIZE BLUE-SIZE BUFFER-SIZE DOUBLE-BUFFER HIDDEN RESIZABLE GL-VERSION &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%API-0-POPULATE-SINGLETONS function}@c
@functionsubindex{%api-0-populate-singletons}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-0<dot>lisp file, , @t{host/api-0.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%apply-stencil-mask} FACE MASK CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%APPLY-STENCIL-MASK function}@c
@functionsubindex{%apply-stencil-mask}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/stencil/mask<dot>lisp file, , @t{core/stencil/mask.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%apply-stencil-params} FACE PARAMS CEPL-CONTEXT
@anchor{go to the CEPL<dot>STENCIL<colon><colon>%APPLY-STENCIL-PARAMS function}@c
@functionsubindex{%apply-stencil-params}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>STENCIL package, , @t{cepl.stencil}}
@item Source
@ref{go to the cepl/core/stencil/stencil<dot>lisp file, , @t{core/stencil/stencil.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%attachment} FBO ATTACHMENT-NAME
@anchor{go to the CEPL<dot>FBOS<colon><colon>%ATTACHMENT function}@c
@functionsubindex{%attachment}@c
@deffnx {Function} {(setf %attachment)} VALUE FBO ATTACHMENT-NAME
@anchor{go to the CEPL<dot>FBOS<colon><colon>(SETF %ATTACHMENT) function}@c
@functionsubindex{(setf %attachment)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%bind-fbo} FBO TARGET
@anchor{go to the CEPL<dot>FBOS<colon><colon>%BIND-FBO function}@c
@functionsubindex{%bind-fbo}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%bind-ssbo} SSBO
@anchor{go to the CEPL<dot>SSBOS<colon><colon>%BIND-SSBO function}@c
@functionsubindex{%bind-ssbo}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SSBOS package, , @t{cepl.ssbos}}
@item Source
@ref{go to the cepl/core/ssbos/ssbos<dot>lisp file, , @t{core/ssbos/ssbos.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%bind-tfs-arrays} CTX TFS
@anchor{go to the CEPL<dot>TRANSFORM-FEEDBACK<colon><colon>%BIND-TFS-ARRAYS function}@c
@functionsubindex{%bind-tfs-arrays}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TRANSFORM-FEEDBACK package, , @t{cepl.transform-feedback}}
@item Source
@ref{go to the cepl/core/transform-feedback/transform-feedback<dot>lisp file, , @t{core/transform-feedback/transform-feedback.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%bind-ubo} UBO
@anchor{go to the CEPL<dot>UBOS<colon><colon>%BIND-UBO function}@c
@functionsubindex{%bind-ubo}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>UBOS package, , @t{cepl.ubos}}
@item Source
@ref{go to the cepl/core/ubos/ubo<dot>lisp file, , @t{core/ubos/ubo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%blend-fbo} FBO
@anchor{go to the CEPL<dot>BLENDING<colon><colon>%BLEND-FBO function}@c
@functionsubindex{%blend-fbo}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%blend-i} PARAMS I
@anchor{go to the CEPL<dot>BLENDING<colon><colon>%BLEND-I function}@c
@functionsubindex{%blend-i}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%blend-using-params} PARAMS
@anchor{go to the CEPL<dot>BLENDING<colon><colon>%BLEND-USING-PARAMS function}@c
@functionsubindex{%blend-using-params}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%calc-image-format-with-declared-format} ELEMENT-TYPE IMAGE-FORMAT INITIAL-CONTENTS
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>%CALC-IMAGE-FORMAT-WITH-DECLARED-FORMAT function}@c
@functionsubindex{%calc-image-format-with-declared-format}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%calc-image-format-with-lisp-type} ELEMENT-TYPE INITIAL-CONTENTS
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>%CALC-IMAGE-FORMAT-WITH-LISP-TYPE function}@c
@functionsubindex{%calc-image-format-with-lisp-type}@c
Convert the lisp type to an internal format and delegate to
   %calc-image-format
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%calc-image-format-with-pixel-format} PIXEL-FORMAT INITIAL-CONTENTS
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>%CALC-IMAGE-FORMAT-WITH-PIXEL-FORMAT function}@c
@functionsubindex{%calc-image-format-with-pixel-format}@c
Convert the pixel-format to an internal format and delegate to
   %calc-image-format
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%calc-image-format-without-declared-format} INITIAL-CONTENTS
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>%CALC-IMAGE-FORMAT-WITHOUT-DECLARED-FORMAT function}@c
@functionsubindex{%calc-image-format-without-declared-format}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-array-of-bound-gpu-buffers} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-ARRAY-OF-BOUND-GPU-BUFFERS function}@c
@functionsubindex{%cepl-context-array-of-bound-gpu-buffers}@c
@deffnx {Function} {(setf %cepl-context-array-of-bound-gpu-buffers)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-ARRAY-OF-BOUND-GPU-BUFFERS) function}@c
@functionsubindex{(setf %cepl-context-array-of-bound-gpu-buffers)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-array-of-bound-queries} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-ARRAY-OF-BOUND-QUERIES function}@c
@functionsubindex{%cepl-context-array-of-bound-queries}@c
@deffnx {Function} {(setf %cepl-context-array-of-bound-queries)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-ARRAY-OF-BOUND-QUERIES) function}@c
@functionsubindex{(setf %cepl-context-array-of-bound-queries)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-array-of-bound-samplers} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-ARRAY-OF-BOUND-SAMPLERS function}@c
@functionsubindex{%cepl-context-array-of-bound-samplers}@c
@deffnx {Function} {(setf %cepl-context-array-of-bound-samplers)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-ARRAY-OF-BOUND-SAMPLERS) function}@c
@functionsubindex{(setf %cepl-context-array-of-bound-samplers)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-array-of-gpu-buffers} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-ARRAY-OF-GPU-BUFFERS function}@c
@functionsubindex{%cepl-context-array-of-gpu-buffers}@c
@deffnx {Function} {(setf %cepl-context-array-of-gpu-buffers)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-ARRAY-OF-GPU-BUFFERS) function}@c
@functionsubindex{(setf %cepl-context-array-of-gpu-buffers)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-array-of-ssbo-binding-ranges} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-ARRAY-OF-SSBO-BINDING-RANGES function}@c
@functionsubindex{%cepl-context-array-of-ssbo-binding-ranges}@c
@deffnx {Function} {(setf %cepl-context-array-of-ssbo-binding-ranges)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-ARRAY-OF-SSBO-BINDING-RANGES) function}@c
@functionsubindex{(setf %cepl-context-array-of-ssbo-binding-ranges)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-array-of-ssbo-bindings-buffer-ids} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-ARRAY-OF-SSBO-BINDINGS-BUFFER-IDS function}@c
@functionsubindex{%cepl-context-array-of-ssbo-bindings-buffer-ids}@c
@deffnx {Function} {(setf %cepl-context-array-of-ssbo-bindings-buffer-ids)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-ARRAY-OF-SSBO-BINDINGS-BUFFER-IDS) function}@c
@functionsubindex{(setf %cepl-context-array-of-ssbo-bindings-buffer-ids)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-array-of-textures} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-ARRAY-OF-TEXTURES function}@c
@functionsubindex{%cepl-context-array-of-textures}@c
@deffnx {Function} {(setf %cepl-context-array-of-textures)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-ARRAY-OF-TEXTURES) function}@c
@functionsubindex{(setf %cepl-context-array-of-textures)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-array-of-transform-feedback-bindings-buffer-ids} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-ARRAY-OF-TRANSFORM-FEEDBACK-BINDINGS-BUFFER-IDS function}@c
@functionsubindex{%cepl-context-array-of-transform-feedback-bindings-buffer-ids}@c
@deffnx {Function} {(setf %cepl-context-array-of-transform-feedback-bindings-buffer-ids)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-ARRAY-OF-TRANSFORM-FEEDBACK-BINDINGS-BUFFER-IDS) function}@c
@functionsubindex{(setf %cepl-context-array-of-transform-feedback-bindings-buffer-ids)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-array-of-ubo-binding-ranges} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-ARRAY-OF-UBO-BINDING-RANGES function}@c
@functionsubindex{%cepl-context-array-of-ubo-binding-ranges}@c
@deffnx {Function} {(setf %cepl-context-array-of-ubo-binding-ranges)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-ARRAY-OF-UBO-BINDING-RANGES) function}@c
@functionsubindex{(setf %cepl-context-array-of-ubo-binding-ranges)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-array-of-ubo-bindings-buffer-ids} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-ARRAY-OF-UBO-BINDINGS-BUFFER-IDS function}@c
@functionsubindex{%cepl-context-array-of-ubo-bindings-buffer-ids}@c
@deffnx {Function} {(setf %cepl-context-array-of-ubo-bindings-buffer-ids)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-ARRAY-OF-UBO-BINDINGS-BUFFER-IDS) function}@c
@functionsubindex{(setf %cepl-context-array-of-ubo-bindings-buffer-ids)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-bound-thread} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-BOUND-THREAD function}@c
@functionsubindex{%cepl-context-bound-thread}@c
@deffnx {Function} {(setf %cepl-context-bound-thread)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-BOUND-THREAD) function}@c
@functionsubindex{(setf %cepl-context-bound-thread)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-clear-color} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-CLEAR-COLOR function}@c
@functionsubindex{%cepl-context-clear-color}@c
@deffnx {Function} {(setf %cepl-context-clear-color)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-CLEAR-COLOR) function}@c
@functionsubindex{(setf %cepl-context-clear-color)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-color-masks} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-COLOR-MASKS function}@c
@functionsubindex{%cepl-context-color-masks}@c
@deffnx {Function} {(setf %cepl-context-color-masks)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-COLOR-MASKS) function}@c
@functionsubindex{(setf %cepl-context-color-masks)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-cull-face} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-CULL-FACE function}@c
@functionsubindex{%cepl-context-cull-face}@c
@deffnx {Function} {(setf %cepl-context-cull-face)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-CULL-FACE) function}@c
@functionsubindex{(setf %cepl-context-cull-face)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-current-blend-params} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-CURRENT-BLEND-PARAMS function}@c
@functionsubindex{%cepl-context-current-blend-params}@c
@deffnx {Function} {(setf %cepl-context-current-blend-params)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-CURRENT-BLEND-PARAMS) function}@c
@functionsubindex{(setf %cepl-context-current-blend-params)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-current-program} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-CURRENT-PROGRAM function}@c
@functionsubindex{%cepl-context-current-program}@c
@deffnx {Function} {(setf %cepl-context-current-program)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-CURRENT-PROGRAM) function}@c
@functionsubindex{(setf %cepl-context-current-program)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-current-scissor-viewports} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-CURRENT-SCISSOR-VIEWPORTS function}@c
@functionsubindex{%cepl-context-current-scissor-viewports}@c
@deffnx {Function} {(setf %cepl-context-current-scissor-viewports)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-CURRENT-SCISSOR-VIEWPORTS) function}@c
@functionsubindex{(setf %cepl-context-current-scissor-viewports)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-current-stencil-mask-back} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-CURRENT-STENCIL-MASK-BACK function}@c
@functionsubindex{%cepl-context-current-stencil-mask-back}@c
@deffnx {Function} {(setf %cepl-context-current-stencil-mask-back)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-CURRENT-STENCIL-MASK-BACK) function}@c
@functionsubindex{(setf %cepl-context-current-stencil-mask-back)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-current-stencil-mask-front} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-CURRENT-STENCIL-MASK-FRONT function}@c
@functionsubindex{%cepl-context-current-stencil-mask-front}@c
@deffnx {Function} {(setf %cepl-context-current-stencil-mask-front)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-CURRENT-STENCIL-MASK-FRONT) function}@c
@functionsubindex{(setf %cepl-context-current-stencil-mask-front)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-current-stencil-params-back} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-CURRENT-STENCIL-PARAMS-BACK function}@c
@functionsubindex{%cepl-context-current-stencil-params-back}@c
@deffnx {Function} {(setf %cepl-context-current-stencil-params-back)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-CURRENT-STENCIL-PARAMS-BACK) function}@c
@functionsubindex{(setf %cepl-context-current-stencil-params-back)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-current-stencil-params-front} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-CURRENT-STENCIL-PARAMS-FRONT function}@c
@functionsubindex{%cepl-context-current-stencil-params-front}@c
@deffnx {Function} {(setf %cepl-context-current-stencil-params-front)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-CURRENT-STENCIL-PARAMS-FRONT) function}@c
@functionsubindex{(setf %cepl-context-current-stencil-params-front)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-current-surface} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-CURRENT-SURFACE function}@c
@functionsubindex{%cepl-context-current-surface}@c
@deffnx {Function} {(setf %cepl-context-current-surface)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-CURRENT-SURFACE) function}@c
@functionsubindex{(setf %cepl-context-current-surface)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-current-tfs} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-CURRENT-TFS function}@c
@functionsubindex{%cepl-context-current-tfs}@c
@deffnx {Function} {(setf %cepl-context-current-tfs)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-CURRENT-TFS) function}@c
@functionsubindex{(setf %cepl-context-current-tfs)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-current-viewport} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-CURRENT-VIEWPORT function}@c
@functionsubindex{%cepl-context-current-viewport}@c
@deffnx {Function} {(setf %cepl-context-current-viewport)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-CURRENT-VIEWPORT) function}@c
@functionsubindex{(setf %cepl-context-current-viewport)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-default-framebuffer} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-DEFAULT-FRAMEBUFFER function}@c
@functionsubindex{%cepl-context-default-framebuffer}@c
@deffnx {Function} {(setf %cepl-context-default-framebuffer)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-DEFAULT-FRAMEBUFFER) function}@c
@functionsubindex{(setf %cepl-context-default-framebuffer)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-default-viewport} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-DEFAULT-VIEWPORT function}@c
@functionsubindex{%cepl-context-default-viewport}@c
@deffnx {Function} {(setf %cepl-context-default-viewport)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-DEFAULT-VIEWPORT) function}@c
@functionsubindex{(setf %cepl-context-default-viewport)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-depth-clamp} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-DEPTH-CLAMP function}@c
@functionsubindex{%cepl-context-depth-clamp}@c
@deffnx {Function} {(setf %cepl-context-depth-clamp)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-DEPTH-CLAMP) function}@c
@functionsubindex{(setf %cepl-context-depth-clamp)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-depth-func} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-DEPTH-FUNC function}@c
@functionsubindex{%cepl-context-depth-func}@c
@deffnx {Function} {(setf %cepl-context-depth-func)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-DEPTH-FUNC) function}@c
@functionsubindex{(setf %cepl-context-depth-func)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-depth-mask} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-DEPTH-MASK function}@c
@functionsubindex{%cepl-context-depth-mask}@c
@deffnx {Function} {(setf %cepl-context-depth-mask)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-DEPTH-MASK) function}@c
@functionsubindex{(setf %cepl-context-depth-mask)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-depth-range} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-DEPTH-RANGE function}@c
@functionsubindex{%cepl-context-depth-range}@c
@deffnx {Function} {(setf %cepl-context-depth-range)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-DEPTH-RANGE) function}@c
@functionsubindex{(setf %cepl-context-depth-range)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-draw-fbo-binding} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-DRAW-FBO-BINDING function}@c
@functionsubindex{%cepl-context-draw-fbo-binding}@c
@deffnx {Function} {(setf %cepl-context-draw-fbo-binding)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-DRAW-FBO-BINDING) function}@c
@functionsubindex{(setf %cepl-context-draw-fbo-binding)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-fbos} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-FBOS function}@c
@functionsubindex{%cepl-context-fbos}@c
@deffnx {Function} {(setf %cepl-context-fbos)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-FBOS) function}@c
@functionsubindex{(setf %cepl-context-fbos)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-front-face} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-FRONT-FACE function}@c
@functionsubindex{%cepl-context-front-face}@c
@deffnx {Function} {(setf %cepl-context-front-face)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-FRONT-FACE) function}@c
@functionsubindex{(setf %cepl-context-front-face)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-gl-context} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-GL-CONTEXT function}@c
@functionsubindex{%cepl-context-gl-context}@c
@deffnx {Function} {(setf %cepl-context-gl-context)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-GL-CONTEXT) function}@c
@functionsubindex{(setf %cepl-context-gl-context)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-gl-version-float} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-GL-VERSION-FLOAT function}@c
@functionsubindex{%cepl-context-gl-version-float}@c
@deffnx {Function} {(setf %cepl-context-gl-version-float)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-GL-VERSION-FLOAT) function}@c
@functionsubindex{(setf %cepl-context-gl-version-float)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-id} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-ID function}@c
@functionsubindex{%cepl-context-id}@c
@deffnx {Function} {(setf %cepl-context-id)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-ID) function}@c
@functionsubindex{(setf %cepl-context-id)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-instance-count} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-INSTANCE-COUNT function}@c
@functionsubindex{%cepl-context-instance-count}@c
@deffnx {Function} {(setf %cepl-context-instance-count)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-INSTANCE-COUNT) function}@c
@functionsubindex{(setf %cepl-context-instance-count)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-max-draw-buffer-count} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-MAX-DRAW-BUFFER-COUNT function}@c
@functionsubindex{%cepl-context-max-draw-buffer-count}@c
@deffnx {Function} {(setf %cepl-context-max-draw-buffer-count)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-MAX-DRAW-BUFFER-COUNT) function}@c
@functionsubindex{(setf %cepl-context-max-draw-buffer-count)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-pack-alignment} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-PACK-ALIGNMENT function}@c
@functionsubindex{%cepl-context-pack-alignment}@c
@deffnx {Function} {(setf %cepl-context-pack-alignment)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-PACK-ALIGNMENT) function}@c
@functionsubindex{(setf %cepl-context-pack-alignment)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-read-fbo-binding} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-READ-FBO-BINDING function}@c
@functionsubindex{%cepl-context-read-fbo-binding}@c
@deffnx {Function} {(setf %cepl-context-read-fbo-binding)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-READ-FBO-BINDING) function}@c
@functionsubindex{(setf %cepl-context-read-fbo-binding)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-requested-gl-version} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-REQUESTED-GL-VERSION function}@c
@functionsubindex{%cepl-context-requested-gl-version}@c
@deffnx {Function} {(setf %cepl-context-requested-gl-version)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-REQUESTED-GL-VERSION) function}@c
@functionsubindex{(setf %cepl-context-requested-gl-version)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-shared} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-SHARED function}@c
@functionsubindex{%cepl-context-shared}@c
@deffnx {Function} {(setf %cepl-context-shared)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-SHARED) function}@c
@functionsubindex{(setf %cepl-context-shared)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-surfaces} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-SURFACES function}@c
@functionsubindex{%cepl-context-surfaces}@c
@deffnx {Function} {(setf %cepl-context-surfaces)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-SURFACES) function}@c
@functionsubindex{(setf %cepl-context-surfaces)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-uninitialized-resources} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-UNINITIALIZED-RESOURCES function}@c
@functionsubindex{%cepl-context-uninitialized-resources}@c
@deffnx {Function} {(setf %cepl-context-uninitialized-resources)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-UNINITIALIZED-RESOURCES) function}@c
@functionsubindex{(setf %cepl-context-uninitialized-resources)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-unpack-alignment} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-UNPACK-ALIGNMENT function}@c
@functionsubindex{%cepl-context-unpack-alignment}@c
@deffnx {Function} {(setf %cepl-context-unpack-alignment)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-UNPACK-ALIGNMENT) function}@c
@functionsubindex{(setf %cepl-context-unpack-alignment)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-vao-binding-id} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-VAO-BINDING-ID function}@c
@functionsubindex{%cepl-context-vao-binding-id}@c
@deffnx {Function} {(setf %cepl-context-vao-binding-id)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-VAO-BINDING-ID) function}@c
@functionsubindex{(setf %cepl-context-vao-binding-id)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cffi-type->gl-enum} CFFI-TYPE-NAME
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%CFFI-TYPE->GL-ENUM function}@c
@functionsubindex{%cffi-type->gl-enum}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%color-mask} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%COLOR-MASK function}@c
@functionsubindex{%color-mask}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/color/color<dot>lisp file, , @t{core/color/color.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%color-masks} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%COLOR-MASKS function}@c
@functionsubindex{%color-masks}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/color/color<dot>lisp file, , @t{core/color/color.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%compile-closure} CODE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%COMPILE-CLOSURE function}@c
@functionsubindex{%compile-closure}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%compile-link-and-upload} NAME PRIMITIVE STAGE-PAIRS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%COMPILE-LINK-AND-UPLOAD function}@c
@functionsubindex{%compile-link-and-upload}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%copy-compile-context} INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%COPY-COMPILE-CONTEXT function}@c
@functionsubindex{%copy-compile-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/compile-context<dot>lisp file, , @t{core/pipelines/compile-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%create-implicit-uniform-uploader} COMPILED-STAGES UNIFORM-NAMES
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%CREATE-IMPLICIT-UNIFORM-UPLOADER function}@c
@functionsubindex{%create-implicit-uniform-uploader}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cull-face} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CULL-FACE function}@c
@functionsubindex{%cull-face}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/face/face<dot>lisp file, , @t{core/face/face.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%current-blend-params} ()
@anchor{go to the CEPL<dot>BLENDING<colon><colon>%CURRENT-BLEND-PARAMS function}@c
@functionsubindex{%current-blend-params}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%current-stencil-params} FACE CEPL-CONTEXT
@anchor{go to the CEPL<dot>STENCIL<colon><colon>%CURRENT-STENCIL-PARAMS function}@c
@functionsubindex{%current-stencil-params}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>STENCIL package, , @t{cepl.stencil}}
@item Source
@ref{go to the cepl/core/stencil/stencil<dot>lisp file, , @t{core/stencil/stencil.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%current-viewport} CEPL-CONTEXT
@anchor{go to the CEPL<dot>VIEWPORTS<colon><colon>%CURRENT-VIEWPORT function}@c
@functionsubindex{%current-viewport}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>VIEWPORTS package, , @t{cepl.viewports}}
@item Source
@ref{go to the cepl/core/viewports/viewport<dot>lisp file, , @t{core/viewports/viewport.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%def-complete-pipeline} NAME ORIGINAL-GPIPE-ARGS STAGE-PAIRS AGGREGATE-ACTUAL-UNIFORMS AGGREGATE-PUBLIC-UNIFORMS POST RAW-CONTEXT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%DEF-COMPLETE-PIPELINE function}@c
@functionsubindex{%def-complete-pipeline}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%def-gpu-function} NAME IN-ARGS UNIFORMS BODY SHARED DOC-STRING EQUIV RAW-CONTEXT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%DEF-GPU-FUNCTION function}@c
@functionsubindex{%def-gpu-function}@c
This is the meat of defun-g. it is broken down as follows:@*

   [0] makes a gpu-func-spec that will be populated a stored later.@*

   [1] Adds a external function definition to varjo also make sure it will be
       called on load@*

   [2] %test-&-process-spec compiles the code to check for errors and log
       dependencies. (this is called at runtime)@*

   [3] %make-gpu-func-spec is called at expand time to write a lisp function
       with the same signature as the gpu-function. This gives code hinting and
       also a decent error message if you try calling it from the cpu.@*
       We don't do this when using defun-g-equiv as we want to shadow the lisp
       function.@*

   [4] the purpose of %recompile-gpu-function-and-pipelines is to recompile and
       functions or pipelines that depend on this gpu function. It does this
       by calling %recompile-gpu-function-and-pipelines on all the gpu function
       that depend on this func and then the recompile-function for all
       pipelines that depend on this gpu function. To this end it walks depth
       first too all affected pipelines.@*

   [5] At runtime this looks for any gpu function that listed this function as
       one of its missing dependencies and calls %test-&-process-spec on them.
       Note that this will (possibly) update the spec but will not trigger a
       recompile in the pipelines.
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%def-partial-pipeline} NAME FUNC-SPECS STAGE-PAIRS AGGREGATE-ACTUAL-UNIFORMS RAW-CONTEXT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%DEF-PARTIAL-PIPELINE function}@c
@functionsubindex{%def-partial-pipeline}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%defn} NAME TYPED-ARGS RESULT-TYPES INLINABLE-P INLINE-P BODY
@anchor{go to the CEPL<dot>DEFN<colon><colon>%DEFN function}@c
@functionsubindex{%defn}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>DEFN package, , @t{cepl.defn}}
@item Source
@ref{go to the cepl<dot>build/defn/defn<dot>lisp file, , @t{defn/defn.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%defpipeline-gfuncs} NAME GPIPE-ARGS CONTEXT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%DEFPIPELINE-GFUNCS function}@c
@functionsubindex{%defpipeline-gfuncs}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%delete-sampler} SAMPLER
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>%DELETE-SAMPLER function}@c
@functionsubindex{%delete-sampler}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%depth-clamp} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%DEPTH-CLAMP function}@c
@functionsubindex{%depth-clamp}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/depth/depth<dot>lisp file, , @t{core/depth/depth.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%depth-mask} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%DEPTH-MASK function}@c
@functionsubindex{%depth-mask}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/depth/depth<dot>lisp file, , @t{core/depth/depth.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%depth-range-vec2} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%DEPTH-RANGE-VEC2 function}@c
@functionsubindex{%depth-range-vec2}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/depth/depth<dot>lisp file, , @t{core/depth/depth.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%depth-test-function} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%DEPTH-TEST-FUNCTION function}@c
@functionsubindex{%depth-test-function}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/depth/depth<dot>lisp file, , @t{core/depth/depth.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%fbo-draw-buffers} FBO
@anchor{go to the CEPL<dot>FBOS<colon><colon>%FBO-DRAW-BUFFERS function}@c
@functionsubindex{%fbo-draw-buffers}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%fbo-owns} FBO ATTACHMENT-NAME
@anchor{go to the CEPL<dot>FBOS<colon><colon>%FBO-OWNS function}@c
@functionsubindex{%fbo-owns}@c
@deffnx {Function} {(setf %fbo-owns)} VALUE FBO ATTACHMENT-NAME
@anchor{go to the CEPL<dot>FBOS<colon><colon>(SETF %FBO-OWNS) function}@c
@functionsubindex{(setf %fbo-owns)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%find-tex-image-format} ELEMENT-FORMAT
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>%FIND-TEX-IMAGE-FORMAT function}@c
@functionsubindex{%find-tex-image-format}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%force-depth-test-function} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%FORCE-DEPTH-TEST-FUNCTION function}@c
@functionsubindex{%force-depth-test-function}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/depth/depth<dot>lisp file, , @t{core/depth/depth.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%front-face} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%FRONT-FACE function}@c
@functionsubindex{%front-face}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/face/face<dot>lisp file, , @t{core/face/face.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%gen-attachment-blend} ATTACHMENTS FBO BODY
@anchor{go to the CEPL<dot>BLENDING<colon><colon>%GEN-ATTACHMENT-BLEND function}@c
@functionsubindex{%gen-attachment-blend}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%gen-pass-key} ()
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%GEN-PASS-KEY function}@c
@functionsubindex{%gen-pass-key}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%gen-texture} PATTERN
@anchor{go to the CEPL<dot>FBOS<colon><colon>%GEN-TEXTURE function}@c
@functionsubindex{%gen-texture}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%get-default-texture-format} ATTACHMENT
@anchor{go to the CEPL<dot>FBOS<colon><colon>%GET-DEFAULT-TEXTURE-FORMAT function}@c
@functionsubindex{%get-default-texture-format}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%get-id} ()
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>%GET-ID function}@c
@functionsubindex{%get-id}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%gl-calc-byte-size} ELEM-SIZE DIMENSIONS ROW-ALIGNMENT
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>%GL-CALC-BYTE-SIZE function}@c
@functionsubindex{%gl-calc-byte-size}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/populate<dot>lisp file, , @t{core/c-arrays/populate.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%gl-make-shader-from-varjo} COMPILED-STAGE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%GL-MAKE-SHADER-FROM-VARJO function}@c
@functionsubindex{%gl-make-shader-from-varjo}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%implicit-uniforms-dont-have-type-mismatches} UNIFORMS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%IMPLICIT-UNIFORMS-DONT-HAVE-TYPE-MISMATCHES function}@c
@functionsubindex{%implicit-uniforms-dont-have-type-mismatches}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%inner-with-context} VAR-NAME CEPL-CONTEXT FORGO-LET BODY CTX-VAR
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%INNER-WITH-CONTEXT function}@c
@functionsubindex{%inner-with-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%loop-setting-per-attachment-blend-params} FBO
@anchor{go to the CEPL<dot>BLENDING<colon><colon>%LOOP-SETTING-PER-ATTACHMENT-BLEND-PARAMS function}@c
@functionsubindex{%loop-setting-per-attachment-blend-params}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%make-buffer-stream} &key (VAO VAO) (%START %START) (%START-BYTE %START-BYTE) (BASE-VERTEX BASE-VERTEX) (LENGTH LENGTH) (%INDEX-TYPE-ENUM %INDEX-TYPE-ENUM) (%INDEX-TYPE-SIZE %INDEX-TYPE-SIZE) (GPU-ARRAYS GPU-ARRAYS) (%PRIMITIVE %PRIMITIVE) (PRIMITIVE-GROUP-ID PRIMITIVE-GROUP-ID) (DRAW-MODE-VAL DRAW-MODE-VAL) (PATCH-LENGTH PATCH-LENGTH) (MANAGED MANAGED)
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%MAKE-BUFFER-STREAM function}@c
@functionsubindex{%make-buffer-stream}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%make-buffer-texture} TEX-OBJ DIMENSIONS IMAGE-FORMAT MIPMAP LAYER-COUNT CUBES RECTANGLE MULTISAMPLE IMMUTABLE INITIAL-CONTENTS PIXEL-FORMAT
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>%MAKE-BUFFER-TEXTURE function}@c
@functionsubindex{%make-buffer-texture}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%make-cepl-context} &key (ID ID) (GL-CONTEXT GL-CONTEXT) (REQUESTED-GL-VERSION REQUESTED-GL-VERSION) (GL-VERSION-FLOAT GL-VERSION-FLOAT) (BOUND-THREAD BOUND-THREAD) (UNINITIALIZED-RESOURCES UNINITIALIZED-RESOURCES) (SHARED SHARED) (SURFACES SURFACES) (CURRENT-PROGRAM CURRENT-PROGRAM) (CURRENT-TFS CURRENT-TFS) (CURRENT-SURFACE CURRENT-SURFACE) (VAO-BINDING-ID VAO-BINDING-ID) (CURRENT-VIEWPORT CURRENT-VIEWPORT) (DEFAULT-VIEWPORT DEFAULT-VIEWPORT) (CURRENT-SCISSOR-VIEWPORTS CURRENT-SCISSOR-VIEWPORTS) (DEFAULT-FRAMEBUFFER DEFAULT-FRAMEBUFFER) (READ-FBO-BINDING READ-FBO-BINDING) (DRAW-FBO-BINDING DRAW-FBO-BINDING) (CURRENT-STENCIL-PARAMS-FRONT CURRENT-STENCIL-PARAMS-FRONT) (CURRENT-STENCIL-PARAMS-BACK CURRENT-STENCIL-PARAMS-BACK) (CURRENT-STENCIL-MASK-FRONT CURRENT-STENCIL-MASK-FRONT) (CURRENT-STENCIL-MASK-BACK CURRENT-STENCIL-MASK-BACK) (CURRENT-BLEND-PARAMS CURRENT-BLEND-PARAMS) (FBOS FBOS) (ARRAY-OF-BOUND-GPU-BUFFERS ARRAY-OF-BOUND-GPU-BUFFERS) (ARRAY-OF-GPU-BUFFERS ARRAY-OF-GPU-BUFFERS) (ARRAY-OF-UBO-BINDINGS-BUFFER-IDS ARRAY-OF-UBO-BINDINGS-BUFFER-IDS) (ARRAY-OF-UBO-BINDING-RANGES ARRAY-OF-UBO-BINDING-RANGES) (ARRAY-OF-SSBO-BINDINGS-BUFFER-IDS ARRAY-OF-SSBO-BINDINGS-BUFFER-IDS) (ARRAY-OF-SSBO-BINDING-RANGES ARRAY-OF-SSBO-BINDING-RANGES) (ARRAY-OF-TRANSFORM-FEEDBACK-BINDINGS-BUFFER-IDS ARRAY-OF-TRANSFORM-FEEDBACK-BINDINGS-BUFFER-IDS) (ARRAY-OF-BOUND-SAMPLERS ARRAY-OF-BOUND-SAMPLERS) (ARRAY-OF-BOUND-QUERIES ARRAY-OF-BOUND-QUERIES) (ARRAY-OF-TEXTURES ARRAY-OF-TEXTURES) (DEPTH-FUNC DEPTH-FUNC) (DEPTH-MASK DEPTH-MASK) (COLOR-MASKS COLOR-MASKS) (DEPTH-RANGE DEPTH-RANGE) (DEPTH-CLAMP DEPTH-CLAMP) (CULL-FACE CULL-FACE) (FRONT-FACE FRONT-FACE) (CLEAR-COLOR CLEAR-COLOR) (PACK-ALIGNMENT PACK-ALIGNMENT) (UNPACK-ALIGNMENT UNPACK-ALIGNMENT) (MAX-DRAW-BUFFER-COUNT MAX-DRAW-BUFFER-COUNT) (INSTANCE-COUNT INSTANCE-COUNT)
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%MAKE-CEPL-CONTEXT function}@c
@functionsubindex{%make-cepl-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%make-cube-texture} TEX-OBJ DIMENSIONS MIPMAP LAYER-COUNT CUBES BUFFER-STORAGE RECTANGLE IMMUTABLE INITIAL-CONTENTS IMAGE-FORMAT PIXEL-FORMAT GENERATE-MIPMAPS SAMPLES FIXED-SAMPLE-LOCATIONS
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>%MAKE-CUBE-TEXTURE function}@c
@functionsubindex{%make-cube-texture}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%make-default-framebuffer} DIMENSIONS &optional DOUBLE-BUFFERING DEPTH
@anchor{go to the CEPL<dot>FBOS<colon><colon>%MAKE-DEFAULT-FRAMEBUFFER function}@c
@functionsubindex{%make-default-framebuffer}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%make-glsl-stage-spec} NAME IN-ARGS UNIFORMS CONTEXT BODY-STRING COMPILED
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%MAKE-GLSL-STAGE-SPEC function}@c
@functionsubindex{%make-glsl-stage-spec}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%make-gpu-func-spec} NAME IN-ARGS UNIFORMS CONTEXT BODY SHARED EQUIVALENT-INARGS EQUIVALENT-UNIFORMS ACTUAL-UNIFORMS DOC-STRING DECLARATIONS MISSING-DEPENDENCIES DIFF-TAG
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%MAKE-GPU-FUNC-SPEC function}@c
@functionsubindex{%make-gpu-func-spec}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%make-stand-in-lisp-func-for-glsl-stage} SPEC
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%MAKE-STAND-IN-LISP-FUNC-FOR-GLSL-STAGE function}@c
@functionsubindex{%make-stand-in-lisp-func-for-glsl-stage}@c
Makes a regular lisp function with the same names and arguments
  (where possible) as the glsl-stage who's spec is provided.@*

  If called the function will throw an error saying that the function
  can't currently be used from the cpu.
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/glsl-stages<dot>lisp file, , @t{core/pipelines/glsl-stages.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%make-texture} TEX-OBJ DIMENSIONS MIPMAP LAYER-COUNT CUBES BUFFER-STORAGE RECTANGLE IMMUTABLE INITIAL-CONTENTS IMAGE-FORMAT PIXEL-FORMAT GENERATE-MIPMAPS SAMPLES FIXED-SAMPLE-LOCATIONS
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>%MAKE-TEXTURE function}@c
@functionsubindex{%make-texture}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%make-texture-with-lisp-data} TEX-OBJ DIMENSIONS MIPMAP LAYER-COUNT CUBES BUFFER-STORAGE RECTANGLE IMMUTABLE INITIAL-CONTENTS GENERATE-MIPMAPS ELEMENT-TYPE IMAGE-FORMAT PIXEL-FORMAT SAMPLES FIXED-SAMPLE-LOCATIONS
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>%MAKE-TEXTURE-WITH-LISP-DATA function}@c
@functionsubindex{%make-texture-with-lisp-data}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%memcpy} DESTINATION-POINTER SOURCE-POINTER BYTE-LENGTH
@anchor{go to the CEPL<dot>TYPES<colon><colon>%MEMCPY function}@c
@functionsubindex{%memcpy}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%pack-alignment} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%PACK-ALIGNMENT function}@c
@functionsubindex{%pack-alignment}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/pixel-store/pixel-store<dot>lisp file, , @t{core/pixel-store/pixel-store.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%per-attachment-blending-available-p} ()
@anchor{go to the CEPL<dot>FBOS<colon><colon>%PER-ATTACHMENT-BLENDING-AVAILABLE-P function}@c
@functionsubindex{%per-attachment-blending-available-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%post-init} FUNC
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%POST-INIT function}@c
@functionsubindex{%post-init}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%print-mem} POINTER &optional SIZE-IN-BYTES
@anchor{go to the CEPL-UTILS<colon><colon>%PRINT-MEM function}@c
@functionsubindex{%print-mem}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%process-with-gpu-array-range-macro-args} TARGET ACCESS-SET
@anchor{go to the CEPL<dot>GPU-ARRAYS<colon><colon>%PROCESS-WITH-GPU-ARRAY-RANGE-MACRO-ARGS function}@c
@functionsubindex{%process-with-gpu-array-range-macro-args}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS package, , @t{cepl.gpu-arrays}}
@item Source
@ref{go to the cepl/core/gpu-arrays/with-and-push<dot>lisp file, , @t{core/gpu-arrays/with-and-push.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%process-with-gpu-array-range-runtime} GPU-ARRAY START LENGTH
@anchor{go to the CEPL<dot>GPU-ARRAYS<colon><colon>%PROCESS-WITH-GPU-ARRAY-RANGE-RUNTIME function}@c
@functionsubindex{%process-with-gpu-array-range-runtime}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS package, , @t{cepl.gpu-arrays}}
@item Source
@ref{go to the cepl/core/gpu-arrays/with-and-push<dot>lisp file, , @t{core/gpu-arrays/with-and-push.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%pull-spec-common} ASSET-NAME
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%PULL-SPEC-COMMON function}@c
@functionsubindex{%pull-spec-common}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%register-ssbo-id} CTX SSBO-BINDING-POINT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%REGISTER-SSBO-ID function}@c
@functionsubindex{%register-ssbo-id}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%register-ubo-id} CTX UBO-BINDING-POINT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%REGISTER-UBO-ID function}@c
@functionsubindex{%register-ubo-id}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%sampler-context-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-CONTEXT-ID function}@c
@functionsubindex{%sampler-context-id}@c
@deffnx {Function} {(setf %sampler-context-id)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-CONTEXT-ID) function}@c
@functionsubindex{(setf %sampler-context-id)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%scissor-viewport} ()
@anchor{go to the CEPL<dot>SCISSOR<colon><colon>%SCISSOR-VIEWPORT function}@c
@functionsubindex{%scissor-viewport}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SCISSOR package, , @t{cepl.scissor}}
@item Source
@ref{go to the cepl/core/scissor/scissor<dot>lisp file, , @t{core/scissor/scissor.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-border-color} SAMPLER VALUE
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>%SET-BORDER-COLOR function}@c
@functionsubindex{%set-border-color}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-color-mask} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%SET-COLOR-MASK function}@c
@functionsubindex{%set-color-mask}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/color/color<dot>lisp file, , @t{core/color/color.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-color-masks} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%SET-COLOR-MASKS function}@c
@functionsubindex{%set-color-masks}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/color/color<dot>lisp file, , @t{core/color/color.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-compare} SAMPLER VALUE
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>%SET-COMPARE function}@c
@functionsubindex{%set-compare}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-cull-face} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%SET-CULL-FACE function}@c
@functionsubindex{%set-cull-face}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/face/face<dot>lisp file, , @t{core/face/face.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-current-blend-params} ()
@anchor{go to the CEPL<dot>BLENDING<colon><colon>%SET-CURRENT-BLEND-PARAMS function}@c
@functionsubindex{%set-current-blend-params}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-current-blend-params-from-fbo} ()
@anchor{go to the CEPL<dot>BLENDING<colon><colon>%SET-CURRENT-BLEND-PARAMS-FROM-FBO function}@c
@functionsubindex{%set-current-blend-params-from-fbo}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-current-viewport} CEPL-CONTEXT VIEWPORT
@anchor{go to the CEPL<dot>VIEWPORTS<colon><colon>%SET-CURRENT-VIEWPORT function}@c
@functionsubindex{%set-current-viewport}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>VIEWPORTS package, , @t{cepl.viewports}}
@item Source
@ref{go to the cepl/core/viewports/viewport<dot>lisp file, , @t{core/viewports/viewport.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-default-fbo-and-viewport} SURFACE CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%SET-DEFAULT-FBO-AND-VIEWPORT function}@c
@functionsubindex{%set-default-fbo-and-viewport}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-default-fbo-viewport} NEW-DIMENSIONS
@anchor{go to the CEPL<dot>FBOS<colon><colon>%SET-DEFAULT-FBO-VIEWPORT function}@c
@functionsubindex{%set-default-fbo-viewport}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-depth-clamp} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%SET-DEPTH-CLAMP function}@c
@functionsubindex{%set-depth-clamp}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/depth/depth<dot>lisp file, , @t{core/depth/depth.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-depth-mask} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%SET-DEPTH-MASK function}@c
@functionsubindex{%set-depth-mask}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/depth/depth<dot>lisp file, , @t{core/depth/depth.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-depth-range-vec2} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%SET-DEPTH-RANGE-VEC2 function}@c
@functionsubindex{%set-depth-range-vec2}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/depth/depth<dot>lisp file, , @t{core/depth/depth.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-depth-test-function} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%SET-DEPTH-TEST-FUNCTION function}@c
@functionsubindex{%set-depth-test-function}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/depth/depth<dot>lisp file, , @t{core/depth/depth.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-draw-fbo-no-check} CEPL-CONTEXT FBO
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%SET-DRAW-FBO-NO-CHECK function}@c
@functionsubindex{%set-draw-fbo-no-check}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-fbo-bound} CEPL-CONTEXT FBO
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%SET-FBO-BOUND function}@c
@functionsubindex{%set-fbo-bound}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-fbo-no-check} CEPL-CONTEXT FBO
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%SET-FBO-NO-CHECK function}@c
@functionsubindex{%set-fbo-no-check}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-front-face} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%SET-FRONT-FACE function}@c
@functionsubindex{%set-front-face}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/face/face<dot>lisp file, , @t{core/face/face.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-lod-bias} SAMPLER VALUE
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>%SET-LOD-BIAS function}@c
@functionsubindex{%set-lod-bias}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-magnify-filter} SAMPLER VALUE
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>%SET-MAGNIFY-FILTER function}@c
@functionsubindex{%set-magnify-filter}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-max-lod} SAMPLER VALUE
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>%SET-MAX-LOD function}@c
@functionsubindex{%set-max-lod}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-min-lod} SAMPLER VALUE
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>%SET-MIN-LOD function}@c
@functionsubindex{%set-min-lod}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-minify-filter} SAMPLER VALUE
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>%SET-MINIFY-FILTER function}@c
@functionsubindex{%set-minify-filter}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-pack-alignment} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%SET-PACK-ALIGNMENT function}@c
@functionsubindex{%set-pack-alignment}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/pixel-store/pixel-store<dot>lisp file, , @t{core/pixel-store/pixel-store.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-read-fbo-no-check} CEPL-CONTEXT FBO
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%SET-READ-FBO-NO-CHECK function}@c
@functionsubindex{%set-read-fbo-no-check}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-resolution} VIEWPORT X Y
@anchor{go to the CEPL<dot>VIEWPORTS<colon><colon>%SET-RESOLUTION function}@c
@functionsubindex{%set-resolution}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>VIEWPORTS package, , @t{cepl.viewports}}
@item Source
@ref{go to the cepl/core/viewports/viewport<dot>lisp file, , @t{core/viewports/viewport.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-scissor-viewport} ()
@anchor{go to the CEPL<dot>SCISSOR<colon><colon>%SET-SCISSOR-VIEWPORT function}@c
@functionsubindex{%set-scissor-viewport}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SCISSOR package, , @t{cepl.scissor}}
@item Source
@ref{go to the cepl/core/scissor/scissor<dot>lisp file, , @t{core/scissor/scissor.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-unpack-alignment} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%SET-UNPACK-ALIGNMENT function}@c
@functionsubindex{%set-unpack-alignment}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/pixel-store/pixel-store<dot>lisp file, , @t{core/pixel-store/pixel-store.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-wrap} SAMPLER VALUE
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>%SET-WRAP function}@c
@functionsubindex{%set-wrap}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%stencil-mask} FACE CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%STENCIL-MASK function}@c
@functionsubindex{%stencil-mask}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/stencil/mask<dot>lisp file, , @t{core/stencil/mask.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%test-&-process-spec} SPEC &key CACHE-SPEC
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%TEST-&-PROCESS-SPEC function}@c
@functionsubindex{%test-&-process-spec}@c
Use varjo to compile the code.@*
   [0] If the compilation throws a could-not-find-function error, then record
   that missing function's name as a missing dependency.@*

   [1] If it succeeds then look at the list of used external-functions, and
   check which of the names of the macros match the names of a gpu function.
   The ones that match are the dependencies.@*

   [2] We also record the uniforms in the compiled result. The uniforms in the
   definition are the public interface, but the compiler may have removed or
   modified the uniforms. To this end we store the final uniforms and the forms
   that transform between the public uniform arguments and the internal ones.

   [3] We call 'add-layout-to-struct-uniforms' here to ensure that the ubo/ssbo
   arguments have the correct layout information. This is not important for
   the test compilation, but instead for the uniform information that is
   gathered from this test compile (actual-uniforms).
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%texture-dimensions} INITIAL-CONTENTS DIMENSIONS
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>%TEXTURE-DIMENSIONS function}@c
@functionsubindex{%texture-dimensions}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%unbind-fbo} ()
@anchor{go to the CEPL<dot>FBOS<colon><colon>%UNBIND-FBO function}@c
@functionsubindex{%unbind-fbo}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%unbind-tfs-arrays} CTX TFS
@anchor{go to the CEPL<dot>TRANSFORM-FEEDBACK<colon><colon>%UNBIND-TFS-ARRAYS function}@c
@functionsubindex{%unbind-tfs-arrays}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TRANSFORM-FEEDBACK package, , @t{cepl.transform-feedback}}
@item Source
@ref{go to the cepl/core/transform-feedback/transform-feedback<dot>lisp file, , @t{core/transform-feedback/transform-feedback.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%unpack-alignment} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%UNPACK-ALIGNMENT function}@c
@functionsubindex{%unpack-alignment}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/pixel-store/pixel-store<dot>lisp file, , @t{core/pixel-store/pixel-store.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%update-default-framebuffer-dimensions} X Y
@anchor{go to the CEPL<dot>VIEWPORTS<colon><colon>%UPDATE-DEFAULT-FRAMEBUFFER-DIMENSIONS function}@c
@functionsubindex{%update-default-framebuffer-dimensions}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>VIEWPORTS package, , @t{cepl.viewports}}
@item Source
@ref{go to the cepl/core/viewports/viewport<dot>lisp file, , @t{core/viewports/viewport.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%update-fbo-state} FBO
@anchor{go to the CEPL<dot>FBOS<colon><colon>%UPDATE-FBO-STATE function}@c
@functionsubindex{%update-fbo-state}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%update-glsl-stage-data} SPEC
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%UPDATE-GLSL-STAGE-DATA function}@c
@functionsubindex{%update-glsl-stage-data}@c
[0] Add or update the spec
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%update-gpu-function-data} SPEC DEPENDS-ON COMPILED
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%UPDATE-GPU-FUNCTION-DATA function}@c
@functionsubindex{%update-gpu-function-data}@c
[0] Add or update the spec@*

   [1] (re)subscribe to all the dependencies@*

   [2] cache the compile result so we can retrieve it with #'pull1-g
       or the code with #'pull-g
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%upload-tex} TEX TEX-TYPE LEVEL-NUM DIMENSIONS LAYER-NUM FACE-NUM PIX-FORMAT PIX-TYPE POINTER/OFFSET ROW-ALIGNMENT
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>%UPLOAD-TEX function}@c
@functionsubindex{%upload-tex}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%valid-index-type-p} X
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%VALID-INDEX-TYPE-P function}@c
@functionsubindex{%valid-index-type-p}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%varjo-compile-as-pipeline} NAME PRIMITIVE PARSED-GPIPE-ARGS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%VARJO-COMPILE-AS-PIPELINE function}@c
@functionsubindex{%varjo-compile-as-pipeline}@c
Compile the gpu functions for a pipeline@*
   The argument to this function is a list of pairs.
   Each pair contains:@*
   - the shader stage (e.g. vertex fragment etc)@*
   - the name of the gpu function to use for this stage
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%with-context} VAR-NAME CEPL-CONTEXT FORGO-LET BODY CTX-VAR
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%WITH-CONTEXT function}@c
@functionsubindex{%with-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {across-c} FUNCTION C-ARRAY
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>ACROSS-C function}@c
@functionsubindex{across-c}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/map<dot>lisp file, , @t{core/c-arrays/map.lisp}} (file)
@end table
@end deffn
@deffn {Function} {active-p} ()
@anchor{go to the CEPL<dot>LIFECYCLE<colon><colon>ACTIVE-P function}@c
@functionsubindex{active-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>LIFECYCLE package, , @t{cepl.lifecycle}}
@item Source
@ref{go to the cepl/core/lifecycle<dot>lisp file, , @t{core/lifecycle.lisp}} (file)
@end table
@end deffn
@deffn {Function} {add-compile-results-to-pipeline} NAME COMPILED-RESULTS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ADD-COMPILE-RESULTS-TO-PIPELINE function}@c
@functionsubindex{add-compile-results-to-pipeline}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Function} {add-layout-to-struct-uniforms} NAME TARGET-KIND UNIFORMS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ADD-LAYOUT-TO-STRUCT-UNIFORMS function}@c
@functionsubindex{add-layout-to-struct-uniforms}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {aggregate-uniforms} NAME TARGET-KIND FUNC-SPECS &optional ACTUAL-UNIFORMS-P
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>AGGREGATE-UNIFORMS function}@c
@functionsubindex{aggregate-uniforms}@c
The reason we need to aggregate uniforms is as follows:@*
   - pipelines are made of composed gpu functions@*
   - each gpu function may introduce uniforms@*
   - to this end we need to make sure the different functions' uniforms are
     compatible and then return a final list of aggregated uniforms.@*

   The way we do this is:@*
   [0] Remove all duplicates, this handles all cases where the same uniform is
       in different gpu-functions@*
   [1] Now if there is any more than one instance of each uniform name then
       there is a clash@*

   Sidenote:@*
   [X] We call 'add-layout-to-struct-uniforms' here to ensure that the ubo/ssbo
       arguments have the correct layout information. This is not important for
       the test compilation, but instead for the uniform information that is
       gathered from this test compile (actual-uniforms).
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {allocate-immutable-texture} TEXTURE
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>ALLOCATE-IMMUTABLE-TEXTURE function}@c
@functionsubindex{allocate-immutable-texture}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {allocate-mutable-texture} TEXTURE
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>ALLOCATE-MUTABLE-TEXTURE function}@c
@functionsubindex{allocate-mutable-texture}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {allocate-texture} TEXTURE
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>ALLOCATE-TEXTURE function}@c
@functionsubindex{allocate-texture}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {any-samples-passed-conservative-query-active-p} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>ANY-SAMPLES-PASSED-CONSERVATIVE-QUERY-ACTIVE-P function}@c
@functionsubindex{any-samples-passed-conservative-query-active-p}@c
@deffnx {Function} {(setf any-samples-passed-conservative-query-active-p)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF ANY-SAMPLES-PASSED-CONSERVATIVE-QUERY-ACTIVE-P) function}@c
@functionsubindex{(setf any-samples-passed-conservative-query-active-p)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {any-samples-passed-conservative-query-cache-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>ANY-SAMPLES-PASSED-CONSERVATIVE-QUERY-CACHE-ID function}@c
@functionsubindex{any-samples-passed-conservative-query-cache-id}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {any-samples-passed-conservative-query-enum} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>ANY-SAMPLES-PASSED-CONSERVATIVE-QUERY-ENUM function}@c
@functionsubindex{any-samples-passed-conservative-query-enum}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {any-samples-passed-conservative-query-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>ANY-SAMPLES-PASSED-CONSERVATIVE-QUERY-ID function}@c
@functionsubindex{any-samples-passed-conservative-query-id}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {any-samples-passed-conservative-query-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>ANY-SAMPLES-PASSED-CONSERVATIVE-QUERY-P function}@c
@functionsubindex{any-samples-passed-conservative-query-p}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {any-samples-passed-query-active-p} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>ANY-SAMPLES-PASSED-QUERY-ACTIVE-P function}@c
@functionsubindex{any-samples-passed-query-active-p}@c
@deffnx {Function} {(setf any-samples-passed-query-active-p)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF ANY-SAMPLES-PASSED-QUERY-ACTIVE-P) function}@c
@functionsubindex{(setf any-samples-passed-query-active-p)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {any-samples-passed-query-cache-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>ANY-SAMPLES-PASSED-QUERY-CACHE-ID function}@c
@functionsubindex{any-samples-passed-query-cache-id}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {any-samples-passed-query-enum} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>ANY-SAMPLES-PASSED-QUERY-ENUM function}@c
@functionsubindex{any-samples-passed-query-enum}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {any-samples-passed-query-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>ANY-SAMPLES-PASSED-QUERY-ID function}@c
@functionsubindex{any-samples-passed-query-id}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {any-samples-passed-query-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>ANY-SAMPLES-PASSED-QUERY-P function}@c
@functionsubindex{any-samples-passed-query-p}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {aref-c*-1d} C-ARRAY X
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>AREF-C*-1D function}@c
@functionsubindex{aref-c*-1d}@c
@deffnx {Function} {(setf aref-c*-1d)} VALUE C-ARRAY X
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>(SETF AREF-C*-1D) function}@c
@functionsubindex{(setf aref-c*-1d)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/aref-c<dot>lisp file, , @t{core/c-arrays/aref-c.lisp}} (file)
@end table
@end deffn
@deffn {Function} {aref-c*-2d} C-ARRAY X Y
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>AREF-C*-2D function}@c
@functionsubindex{aref-c*-2d}@c
@deffnx {Function} {(setf aref-c*-2d)} VALUE C-ARRAY X Y
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>(SETF AREF-C*-2D) function}@c
@functionsubindex{(setf aref-c*-2d)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/aref-c<dot>lisp file, , @t{core/c-arrays/aref-c.lisp}} (file)
@end table
@end deffn
@deffn {Function} {aref-c*-3d} C-ARRAY X Y Z
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>AREF-C*-3D function}@c
@functionsubindex{aref-c*-3d}@c
@deffnx {Function} {(setf aref-c*-3d)} VALUE C-ARRAY X Y Z
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>(SETF AREF-C*-3D) function}@c
@functionsubindex{(setf aref-c*-3d)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/aref-c<dot>lisp file, , @t{core/c-arrays/aref-c.lisp}} (file)
@end table
@end deffn
@deffn {Function} {aref-c*-4d} C-ARRAY X Y Z W
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>AREF-C*-4D function}@c
@functionsubindex{aref-c*-4d}@c
@deffnx {Function} {(setf aref-c*-4d)} VALUE C-ARRAY X Y Z W
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>(SETF AREF-C*-4D) function}@c
@functionsubindex{(setf aref-c*-4d)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/aref-c<dot>lisp file, , @t{core/c-arrays/aref-c.lisp}} (file)
@end table
@end deffn
@deffn {Function} {arrays-indirect-command-p} OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ARRAYS-INDIRECT-COMMAND-P function}@c
@functionsubindex{arrays-indirect-command-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/multi-draw<dot>lisp file, , @t{core/pipelines/multi-draw.lisp}} (file)
@end table
@end deffn
@deffn {Function} {arrays-indirect-command-pointer} INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ARRAYS-INDIRECT-COMMAND-POINTER function}@c
@functionsubindex{arrays-indirect-command-pointer}@c
@deffnx {Function} {(setf arrays-indirect-command-pointer)} VALUE INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF ARRAYS-INDIRECT-COMMAND-POINTER) function}@c
@functionsubindex{(setf arrays-indirect-command-pointer)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/multi-draw<dot>lisp file, , @t{core/pipelines/multi-draw.lisp}} (file)
@end table
@end deffn
@deffn {Function} {assendingp} LIST
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ASSENDINGP function}@c
@functionsubindex{assendingp}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/pipeline-validation<dot>lisp file, , @t{core/pipelines/pipeline-validation.lisp}} (file)
@end table
@end deffn
@deffn {Function} {assert-arg-format} GFUNC-NAME X
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ASSERT-ARG-FORMAT function}@c
@functionsubindex{assert-arg-format}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {assert-glsl-arg-format} NAME ARG
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ASSERT-GLSL-ARG-FORMAT function}@c
@functionsubindex{assert-glsl-arg-format}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/glsl-stages<dot>lisp file, , @t{core/pipelines/glsl-stages.lisp}} (file)
@end table
@end deffn
@deffn {Function} {assert-glsl-stage-types} IN-ARGS UNIFORMS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ASSERT-GLSL-STAGE-TYPES function}@c
@functionsubindex{assert-glsl-stage-types}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/glsl-stages<dot>lisp file, , @t{core/pipelines/glsl-stages.lisp}} (file)
@end table
@end deffn
@deffn {Function} {assert-layout-consistent} G-STRUCT-INFO TARGET-LAYOUT
@anchor{go to the CEPL<dot>TYPES<colon><colon>ASSERT-LAYOUT-CONSISTENT function}@c
@functionsubindex{assert-layout-consistent}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {assert-no-other-context-is-bound-to-thread} THIS-THREAD
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>ASSERT-NO-OTHER-CONTEXT-IS-BOUND-TO-THREAD function}@c
@functionsubindex{assert-no-other-context-is-bound-to-thread}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {assert-valid-args-for-buffer-backed-texture} IMAGE-FORMAT CUBES RECTANGLE MULTISAMPLE MIPMAP LAYER-COUNT TEXTURE-TYPE
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>ASSERT-VALID-ARGS-FOR-BUFFER-BACKED-TEXTURE function}@c
@functionsubindex{assert-valid-args-for-buffer-backed-texture}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {assert-valid-gpipe-form} PIPELINE-NAME GPIPE-ARGS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ASSERT-VALID-GPIPE-FORM function}@c
@functionsubindex{assert-valid-gpipe-form}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/pipeline-validation<dot>lisp file, , @t{core/pipelines/pipeline-validation.lisp}} (file)
@end table
@end deffn
@deffn {Function} {assert-valid-gpipe-shader-implicit-form} PIPELINE-NAME GPIPE-ARGS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ASSERT-VALID-GPIPE-SHADER-IMPLICIT-FORM function}@c
@functionsubindex{assert-valid-gpipe-shader-implicit-form}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/pipeline-validation<dot>lisp file, , @t{core/pipelines/pipeline-validation.lisp}} (file)
@end table
@end deffn
@deffn {Function} {assert-valid-stage-specs} NAMES
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ASSERT-VALID-STAGE-SPECS function}@c
@functionsubindex{assert-valid-stage-specs}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/pipeline-validation<dot>lisp file, , @t{core/pipelines/pipeline-validation.lisp}} (file)
@end table
@end deffn
@deffn {Function} {att-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>ATT-P function}@c
@functionsubindex{att-p}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {attachment-compatible} ATTACHMENT-NAME IMAGE-FORMAT &optional FOR-BIND
@anchor{go to the CEPL<dot>FBOS<colon><colon>ATTACHMENT-COMPATIBLE function}@c
@functionsubindex{attachment-compatible}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {attachment-pattern*} VALS
@anchor{go to the CEPL<dot>FBOS<colon><colon>ATTACHMENT-PATTERN* function}@c
@functionsubindex{attachment-pattern*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {attachment-viewport-allowing-t} FBO ATTACHMENT-NAME
@anchor{go to the CEPL<dot>FBOS<colon><colon>ATTACHMENT-VIEWPORT-ALLOWING-T function}@c
@functionsubindex{attachment-viewport-allowing-t}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {bake-and-g->} CONTEXT-WITH-PRIMITIVE PRIMITIVE STAGE-PAIRS UNIFORMS-TO-BAKE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>BAKE-AND-G-> function}@c
@functionsubindex{bake-and-g->}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/bake<dot>lisp file, , @t{core/pipelines/bake.lisp}} (file)
@end table
@end deffn
@deffn {Function} {base-gstruct-wrapper-p} OBJECT
@anchor{go to the CEPL<dot>TYPES<colon><colon>BASE-GSTRUCT-WRAPPER-P function}@c
@functionsubindex{base-gstruct-wrapper-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {base-gstruct-wrapper-pointer} INSTANCE
@anchor{go to the CEPL<dot>TYPES<colon><colon>BASE-GSTRUCT-WRAPPER-POINTER function}@c
@functionsubindex{base-gstruct-wrapper-pointer}@c
@deffnx {Function} {(setf base-gstruct-wrapper-pointer)} VALUE INSTANCE
@anchor{go to the CEPL<dot>TYPES<colon><colon>(SETF BASE-GSTRUCT-WRAPPER-POINTER) function}@c
@functionsubindex{(setf base-gstruct-wrapper-pointer)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {begin-scoped-gpu-query} QUERY
@anchor{go to the CEPL<dot>QUERIES<colon><colon>BEGIN-SCOPED-GPU-QUERY function}@c
@functionsubindex{begin-scoped-gpu-query}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>QUERIES package, , @t{cepl.queries}}
@item Source
@ref{go to the cepl/core/queries/query<dot>lisp file, , @t{core/queries/query.lisp}} (file)
@end table
@end deffn
@deffn {Function} {bind-scratch-texture} ()
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>BIND-SCRATCH-TEXTURE function}@c
@functionsubindex{bind-scratch-texture}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/def<dot>lisp file, , @t{core/textures/def.lisp}} (file)
@end table
@end deffn
@deffn {Function} {blank-buffer-object} BUFFER
@anchor{go to the CEPL<dot>GPU-BUFFERS<colon><colon>BLANK-BUFFER-OBJECT function}@c
@functionsubindex{blank-buffer-object}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-BUFFERS package, , @t{cepl.gpu-buffers}}
@item Source
@ref{go to the cepl/core/gpu-buffers/gpu-buffers<dot>lisp file, , @t{core/gpu-buffers/gpu-buffers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {blank-buffer-stream} BUFFER-STREAM
@anchor{go to the CEPL<dot>STREAMS<colon><colon>BLANK-BUFFER-STREAM function}@c
@functionsubindex{blank-buffer-stream}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>STREAMS package, , @t{cepl.streams}}
@item Source
@ref{go to the cepl/core/streams/buffer-streams<dot>lisp file, , @t{core/streams/buffer-streams.lisp}} (file)
@end table
@end deffn
@deffn {Function} {blank-c-array-object} C-ARRAY
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>BLANK-C-ARRAY-OBJECT function}@c
@functionsubindex{blank-c-array-object}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/def<dot>lisp file, , @t{core/c-arrays/def.lisp}} (file)
@end table
@end deffn
@deffn {Function} {blank-gpu-array-b-object} GPU-ARRAY
@anchor{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED<colon><colon>BLANK-GPU-ARRAY-B-OBJECT function}@c
@functionsubindex{blank-gpu-array-b-object}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED package, , @t{cepl.gpu-arrays.buffer-backed}}
@item Source
@ref{go to the cepl/core/gpu-arrays/buffer-backed<dot>lisp file, , @t{core/gpu-arrays/buffer-backed.lisp}} (file)
@end table
@end deffn
@deffn {Function} {blank-texture-object} TEXTURE
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>BLANK-TEXTURE-OBJECT function}@c
@functionsubindex{blank-texture-object}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/def<dot>lisp file, , @t{core/textures/def.lisp}} (file)
@end table
@end deffn
@deffn {Function} {blend-func-namep} KEYWORD
@anchor{go to the CEPL<dot>BLENDING<colon><colon>BLEND-FUNC-NAMEP function}@c
@functionsubindex{blend-func-namep}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@end table
@end deffn
@deffn {Function} {boop-p} OBJECT
@anchor{go to the DEFXSTAR-HIDDEN<colon><colon>BOOP-P function}@c
@functionsubindex{boop-p}@c
@table @strong
@item Package
@ref{go to the DEFXSTAR-HIDDEN package, , @t{defxstar-hidden}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {boop-x} INSTANCE
@anchor{go to the DEFXSTAR-HIDDEN<colon><colon>BOOP-X function}@c
@functionsubindex{boop-x}@c
@deffnx {Function} {(setf boop-x)} VALUE INSTANCE
@anchor{go to the DEFXSTAR-HIDDEN<colon><colon>(SETF BOOP-X) function}@c
@functionsubindex{(setf boop-x)}@c
@table @strong
@item Package
@ref{go to the DEFXSTAR-HIDDEN package, , @t{defxstar-hidden}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {boop-y} INSTANCE
@anchor{go to the DEFXSTAR-HIDDEN<colon><colon>BOOP-Y function}@c
@functionsubindex{boop-y}@c
@deffnx {Function} {(setf boop-y)} VALUE INSTANCE
@anchor{go to the DEFXSTAR-HIDDEN<colon><colon>(SETF BOOP-Y) function}@c
@functionsubindex{(setf boop-y)}@c
@table @strong
@item Package
@ref{go to the DEFXSTAR-HIDDEN package, , @t{defxstar-hidden}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {border-color} SAMPLER
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>BORDER-COLOR function}@c
@functionsubindex{border-color}@c
@deffnx {Function} {(setf border-color)} VALUE SAMPLER
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>(SETF BORDER-COLOR) function}@c
@functionsubindex{(setf border-color)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {(setf border-color)} VALUE TEXTURE
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>(SETF BORDER-COLOR) function}@c
@functionsubindex{(setf border-color)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/texture-samplers<dot>lisp file, , @t{core/textures/texture-samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-bound-static} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>BUFFER-BOUND-STATIC function}@c
@functionsubindex{buffer-bound-static}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-kind->cache-index} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>BUFFER-KIND->CACHE-INDEX function}@c
@functionsubindex{buffer-kind->cache-index}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-kind->enum} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>BUFFER-KIND->ENUM function}@c
@functionsubindex{buffer-kind->enum}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-reserve-block-raw} BUFFER BYTE-SIZE TARGET USAGE
@anchor{go to the CEPL<dot>GPU-BUFFERS<colon><colon>BUFFER-RESERVE-BLOCK-RAW function}@c
@functionsubindex{buffer-reserve-block-raw}@c

This function creates an empty block of data in the opengl buffer.@*
It will remove ALL data currently in the buffer.@*

It also will not update the format of the buffer so you must be sure to handle
this yourself. It is much safer to use this as an assistant function to one
which takes care of these issues
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-BUFFERS package, , @t{cepl.gpu-buffers}}
@item Source
@ref{go to the cepl/core/gpu-buffers/gpu-buffers<dot>lisp file, , @t{core/gpu-buffers/gpu-buffers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-reserve-blocks-from-sizes} BUFFER BYTE-SIZES TARGET USAGE
@anchor{go to the CEPL<dot>GPU-BUFFERS<colon><colon>BUFFER-RESERVE-BLOCKS-FROM-SIZES function}@c
@functionsubindex{buffer-reserve-blocks-from-sizes}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-BUFFERS package, , @t{cepl.gpu-buffers}}
@item Source
@ref{go to the cepl/core/gpu-buffers/gpu-buffers<dot>lisp file, , @t{core/gpu-buffers/gpu-buffers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-set-arrays-from-sizes} BUFFER BYTE-SIZES USAGE
@anchor{go to the CEPL<dot>GPU-BUFFERS<colon><colon>BUFFER-SET-ARRAYS-FROM-SIZES function}@c
@functionsubindex{buffer-set-arrays-from-sizes}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-BUFFERS package, , @t{cepl.gpu-buffers}}
@item Source
@ref{go to the cepl/core/gpu-buffers/gpu-buffers<dot>lisp file, , @t{core/gpu-buffers/gpu-buffers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-stream-compatible-typep} SLOT
@anchor{go to the CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-COMPATIBLE-TYPEP function}@c
@functionsubindex{buffer-stream-compatible-typep}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-texture-allocated-p} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-TEXTURE-ALLOCATED-P function}@c
@functionsubindex{buffer-texture-allocated-p}@c
@deffnx {Function} {(setf buffer-texture-allocated-p)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-TEXTURE-ALLOCATED-P) function}@c
@functionsubindex{(setf buffer-texture-allocated-p)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-texture-base-dimensions} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-TEXTURE-BASE-DIMENSIONS function}@c
@functionsubindex{buffer-texture-base-dimensions}@c
@deffnx {Function} {(setf buffer-texture-base-dimensions)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-TEXTURE-BASE-DIMENSIONS) function}@c
@functionsubindex{(setf buffer-texture-base-dimensions)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-texture-cache-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-TEXTURE-CACHE-ID function}@c
@functionsubindex{buffer-texture-cache-id}@c
@deffnx {Function} {(setf buffer-texture-cache-id)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-TEXTURE-CACHE-ID) function}@c
@functionsubindex{(setf buffer-texture-cache-id)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-texture-cubes-p} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-TEXTURE-CUBES-P function}@c
@functionsubindex{buffer-texture-cubes-p}@c
@deffnx {Function} {(setf buffer-texture-cubes-p)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-TEXTURE-CUBES-P) function}@c
@functionsubindex{(setf buffer-texture-cubes-p)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-texture-fixed-sample-locations-p} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-TEXTURE-FIXED-SAMPLE-LOCATIONS-P function}@c
@functionsubindex{buffer-texture-fixed-sample-locations-p}@c
@deffnx {Function} {(setf buffer-texture-fixed-sample-locations-p)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-TEXTURE-FIXED-SAMPLE-LOCATIONS-P) function}@c
@functionsubindex{(setf buffer-texture-fixed-sample-locations-p)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-texture-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-TEXTURE-ID function}@c
@functionsubindex{buffer-texture-id}@c
@deffnx {Function} {(setf buffer-texture-id)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-TEXTURE-ID) function}@c
@functionsubindex{(setf buffer-texture-id)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-texture-image-format} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-TEXTURE-IMAGE-FORMAT function}@c
@functionsubindex{buffer-texture-image-format}@c
@deffnx {Function} {(setf buffer-texture-image-format)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-TEXTURE-IMAGE-FORMAT) function}@c
@functionsubindex{(setf buffer-texture-image-format)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-texture-last-sampler-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-TEXTURE-LAST-SAMPLER-ID function}@c
@functionsubindex{buffer-texture-last-sampler-id}@c
@deffnx {Function} {(setf buffer-texture-last-sampler-id)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-TEXTURE-LAST-SAMPLER-ID) function}@c
@functionsubindex{(setf buffer-texture-last-sampler-id)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-texture-layer-count} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-TEXTURE-LAYER-COUNT function}@c
@functionsubindex{buffer-texture-layer-count}@c
@deffnx {Function} {(setf buffer-texture-layer-count)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-TEXTURE-LAYER-COUNT) function}@c
@functionsubindex{(setf buffer-texture-layer-count)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-texture-mipmap-levels} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-TEXTURE-MIPMAP-LEVELS function}@c
@functionsubindex{buffer-texture-mipmap-levels}@c
@deffnx {Function} {(setf buffer-texture-mipmap-levels)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-TEXTURE-MIPMAP-LEVELS) function}@c
@functionsubindex{(setf buffer-texture-mipmap-levels)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-texture-mutable-p} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-TEXTURE-MUTABLE-P function}@c
@functionsubindex{buffer-texture-mutable-p}@c
@deffnx {Function} {(setf buffer-texture-mutable-p)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-TEXTURE-MUTABLE-P) function}@c
@functionsubindex{(setf buffer-texture-mutable-p)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-texture-samples} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-TEXTURE-SAMPLES function}@c
@functionsubindex{buffer-texture-samples}@c
@deffnx {Function} {(setf buffer-texture-samples)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-TEXTURE-SAMPLES) function}@c
@functionsubindex{(setf buffer-texture-samples)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-texture-type} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-TEXTURE-TYPE function}@c
@functionsubindex{buffer-texture-type}@c
@deffnx {Function} {(setf buffer-texture-type)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-TEXTURE-TYPE) function}@c
@functionsubindex{(setf buffer-texture-type)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {c-arr-to-lisp-struct-elems} C-ARRAY
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>C-ARR-TO-LISP-STRUCT-ELEMS function}@c
@functionsubindex{c-arr-to-lisp-struct-elems}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/rest<dot>lisp file, , @t{core/c-arrays/rest.lisp}} (file)
@end table
@end deffn
@deffn {Function} {c-arr-to-lisp-val-elems} C-ARRAY
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>C-ARR-TO-LISP-VAL-ELEMS function}@c
@functionsubindex{c-arr-to-lisp-val-elems}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/rest<dot>lisp file, , @t{core/c-arrays/rest.lisp}} (file)
@end table
@end deffn
@deffn {Function} {c-array-byte-size} C-ARRAY
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>C-ARRAY-BYTE-SIZE function}@c
@functionsubindex{c-array-byte-size}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/populate<dot>lisp file, , @t{core/c-arrays/populate.lisp}} (file)
@end table
@end deffn
@deffn {Function} {c-array-rank} C-ARRAY
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>C-ARRAY-RANK function}@c
@functionsubindex{c-array-rank}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/def<dot>lisp file, , @t{core/c-arrays/def.lisp}} (file)
@end table
@end deffn
@deffn {Function} {calc-aligned-offset} BASE-OFFSET BASE-ALIGNMENT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>CALC-ALIGNED-OFFSET function}@c
@functionsubindex{calc-aligned-offset}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/layout<dot>lisp file, , @t{core/types/layout.lisp}} (file)
@end table
@end deffn
@deffn {Function} {calc-array-of-col-mat-layout} LAYOUT-SPECIFIER NAME PARENT-TYPE-BASE-OFFSET PARENT-TYPE-ALIGNED-OFFSET LAST-SLOT-BASE-OFFSET LAST-SLOT-ALIGNED-OFFSET LAST-SLOT-MACHINE-SIZE TYPE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>CALC-ARRAY-OF-COL-MAT-LAYOUT function}@c
@functionsubindex{calc-array-of-col-mat-layout}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/layout<dot>lisp file, , @t{core/types/layout.lisp}} (file)
@end table
@end deffn
@deffn {Function} {calc-array-of-scalar-or-vectors-layout} LAYOUT-SPECIFIER NAME PARENT-TYPE-BASE-OFFSET PARENT-TYPE-ALIGNED-OFFSET LAST-SLOT-BASE-OFFSET LAST-SLOT-ALIGNED-OFFSET LAST-SLOT-MACHINE-SIZE TYPE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>CALC-ARRAY-OF-SCALAR-OR-VECTORS-LAYOUT function}@c
@functionsubindex{calc-array-of-scalar-or-vectors-layout}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/layout<dot>lisp file, , @t{core/types/layout.lisp}} (file)
@end table
@end deffn
@deffn {Function} {calc-array-of-structs-layout} LAYOUT-SPECIFIER NAME PARENT-TYPE-BASE-OFFSET PARENT-TYPE-ALIGNED-OFFSET LAST-SLOT-BASE-OFFSET LAST-SLOT-ALIGNED-OFFSET LAST-SLOT-MACHINE-SIZE TYPE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>CALC-ARRAY-OF-STRUCTS-LAYOUT function}@c
@functionsubindex{calc-array-of-structs-layout}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/layout<dot>lisp file, , @t{core/types/layout.lisp}} (file)
@end table
@end deffn
@deffn {Function} {calc-base-offset} PARENT-TYPE-ALIGNED-OFFSET LAST-SLOT-BASE-OFFSET LAST-SLOT-ALIGNED-OFFSET LAST-SLOT-MACHINE-SIZE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>CALC-BASE-OFFSET function}@c
@functionsubindex{calc-base-offset}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/layout<dot>lisp file, , @t{core/types/layout.lisp}} (file)
@end table
@end deffn
@deffn {Function} {calc-col-mat-layout} LAYOUT-SPECIFIER NAME PARENT-TYPE-BASE-OFFSET PARENT-TYPE-ALIGNED-OFFSET LAST-SLOT-BASE-OFFSET LAST-SLOT-ALIGNED-OFFSET LAST-SLOT-MACHINE-SIZE TYPE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>CALC-COL-MAT-LAYOUT function}@c
@functionsubindex{calc-col-mat-layout}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/layout<dot>lisp file, , @t{core/types/layout.lisp}} (file)
@end table
@end deffn
@deffn {Function} {calc-feedback-style-and-names} VARYING-PAIRS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>CALC-FEEDBACK-STYLE-AND-NAMES function}@c
@functionsubindex{calc-feedback-style-and-names}@c
returns the mode, the var names & the number of streams
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {calc-image-format} ELEMENT-TYPE INITIAL-CONTENTS
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>CALC-IMAGE-FORMAT function}@c
@functionsubindex{calc-image-format}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {calc-layout} LAYOUT-SPECIFIER NAME PARENT-TYPE-BASE-OFFSET PARENT-TYPE-ALIGNED-OFFSET LAST-SLOT-BASE-OFFSET LAST-SLOT-ALIGNED-OFFSET LAST-SLOT-MACHINE-SIZE TYPE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>CALC-LAYOUT function}@c
@functionsubindex{calc-layout}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/layout<dot>lisp file, , @t{core/types/layout.lisp}} (file)
@end table
@end deffn
@deffn {Function} {calc-max-num-mipmap-levels} DIMENSIONS
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>CALC-MAX-NUM-MIPMAP-LEVELS function}@c
@functionsubindex{calc-max-num-mipmap-levels}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {calc-minify-filter} BETWEEN-ARRAYS-ON-THIS-LEVEL BETWEEN-ARRAYS-ON-DIFFERENT-LEVELS
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>CALC-MINIFY-FILTER function}@c
@functionsubindex{calc-minify-filter}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {calc-query-get-func-for-gpu-array} ARR
@anchor{go to the CEPL<dot>QUERIES<colon><colon>CALC-QUERY-GET-FUNC-FOR-GPU-ARRAY function}@c
@functionsubindex{calc-query-get-func-for-gpu-array}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>QUERIES package, , @t{cepl.queries}}
@item Source
@ref{go to the cepl/core/queries/query<dot>lisp file, , @t{core/queries/query.lisp}} (file)
@end table
@end deffn
@deffn {Function} {calc-sampler-type} TEXTURE-TYPE IMAGE-FORMAT &optional SHADOW-SAMPLER
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>CALC-SAMPLER-TYPE function}@c
@functionsubindex{calc-sampler-type}@c
Makes the keyword that names the sampler-type for the given texture-type and format
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {calc-scalar-layout} LAYOUT-SPECIFIER NAME PARENT-TYPE-ALIGNED-OFFSET LAST-SLOT-BASE-OFFSET LAST-SLOT-ALIGNED-OFFSET LAST-SLOT-MACHINE-SIZE TYPE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>CALC-SCALAR-LAYOUT function}@c
@functionsubindex{calc-scalar-layout}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/layout<dot>lisp file, , @t{core/types/layout.lisp}} (file)
@end table
@end deffn
@deffn {Function} {calc-struct-layout} LAYOUT-SPECIFIER NAME PARENT-TYPE-ALIGNED-OFFSET LAST-SLOT-BASE-OFFSET LAST-SLOT-ALIGNED-OFFSET LAST-SLOT-MACHINE-SIZE TYPE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>CALC-STRUCT-LAYOUT function}@c
@functionsubindex{calc-struct-layout}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/layout<dot>lisp file, , @t{core/types/layout.lisp}} (file)
@end table
@end deffn
@deffn {Function} {calc-struct-member-layout} LAYOUT-SPECIFIER MEMBER-NAME-TYPE-PAIRS PARENT-TYPE-ALIGNED-OFFSET LAST-SLOT-BASE-OFFSET LAST-SLOT-ALIGNED-OFFSET LAST-SLOT-MACHINE-SIZE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>CALC-STRUCT-MEMBER-LAYOUT function}@c
@functionsubindex{calc-struct-member-layout}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/layout<dot>lisp file, , @t{core/types/layout.lisp}} (file)
@end table
@end deffn
@deffn {Function} {calc-vector-base-alignment} TYPE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>CALC-VECTOR-BASE-ALIGNMENT function}@c
@functionsubindex{calc-vector-base-alignment}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/layout<dot>lisp file, , @t{core/types/layout.lisp}} (file)
@end table
@end deffn
@deffn {Function} {calc-vector-layout} LAYOUT-SPECIFIER NAME PARENT-TYPE-ALIGNED-OFFSET LAST-SLOT-BASE-OFFSET LAST-SLOT-ALIGNED-OFFSET LAST-SLOT-MACHINE-SIZE TYPE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>CALC-VECTOR-LAYOUT function}@c
@functionsubindex{calc-vector-layout}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/layout<dot>lisp file, , @t{core/types/layout.lisp}} (file)
@end table
@end deffn
@deffn {Function} {call-listeners} ()
@anchor{go to the CEPL<dot>LIFECYCLE<colon><colon>CALL-LISTENERS function}@c
@functionsubindex{call-listeners}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>LIFECYCLE package, , @t{cepl.lifecycle}}
@item Source
@ref{go to the cepl/core/lifecycle<dot>lisp file, , @t{core/lifecycle.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl-client-wait-sync} SYNC FLAGS TIMEOUT
@anchor{go to the CEPL<dot>SYNC<colon><colon>CEPL-CLIENT-WAIT-SYNC function}@c
@functionsubindex{cepl-client-wait-sync}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SYNC package, , @t{cepl.sync}}
@item Source
@ref{go to the cepl/core/sync/sync<dot>lisp file, , @t{core/sync/sync.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl-context-p} OBJECT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>CEPL-CONTEXT-P function}@c
@functionsubindex{cepl-context-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.pipelines.arrays-indirect-command.from-foreign} ()
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>PIPELINES<dot>ARRAYS-INDIRECT-COMMAND<dot>FROM-FOREIGN function}@c
@functionsubindex{cepl.pipelines.arrays-indirect-command.from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/pipelines/multi-draw<dot>lisp file, , @t{core/pipelines/multi-draw.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.pipelines.arrays-indirect-command.make} POINTER
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>PIPELINES<dot>ARRAYS-INDIRECT-COMMAND<dot>MAKE function}@c
@functionsubindex{cepl.pipelines.arrays-indirect-command.make}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/pipelines/multi-draw<dot>lisp file, , @t{core/pipelines/multi-draw.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.pipelines.arrays-indirect-command.to-foreign} ()
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>PIPELINES<dot>ARRAYS-INDIRECT-COMMAND<dot>TO-FOREIGN function}@c
@functionsubindex{cepl.pipelines.arrays-indirect-command.to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/pipelines/multi-draw<dot>lisp file, , @t{core/pipelines/multi-draw.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.pipelines.elements-indirect-command.from-foreign} ()
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>PIPELINES<dot>ELEMENTS-INDIRECT-COMMAND<dot>FROM-FOREIGN function}@c
@functionsubindex{cepl.pipelines.elements-indirect-command.from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/pipelines/multi-draw<dot>lisp file, , @t{core/pipelines/multi-draw.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.pipelines.elements-indirect-command.make} POINTER
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>PIPELINES<dot>ELEMENTS-INDIRECT-COMMAND<dot>MAKE function}@c
@functionsubindex{cepl.pipelines.elements-indirect-command.make}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/pipelines/multi-draw<dot>lisp file, , @t{core/pipelines/multi-draw.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.pipelines.elements-indirect-command.to-foreign} ()
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>PIPELINES<dot>ELEMENTS-INDIRECT-COMMAND<dot>TO-FOREIGN function}@c
@functionsubindex{cepl.pipelines.elements-indirect-command.to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/pipelines/multi-draw<dot>lisp file, , @t{core/pipelines/multi-draw.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pc.from-foreign} ()
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PC<dot>FROM-FOREIGN function}@c
@functionsubindex{cepl.types.predefined.g-pc.from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pc.make} POINTER
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PC<dot>MAKE function}@c
@functionsubindex{cepl.types.predefined.g-pc.make}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pc.to-foreign} ()
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PC<dot>TO-FOREIGN function}@c
@functionsubindex{cepl.types.predefined.g-pc.to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pn.from-foreign} ()
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PN<dot>FROM-FOREIGN function}@c
@functionsubindex{cepl.types.predefined.g-pn.from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pn.make} POINTER
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PN<dot>MAKE function}@c
@functionsubindex{cepl.types.predefined.g-pn.make}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pn.to-foreign} ()
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PN<dot>TO-FOREIGN function}@c
@functionsubindex{cepl.types.predefined.g-pn.to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pnb.from-foreign} ()
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PNB<dot>FROM-FOREIGN function}@c
@functionsubindex{cepl.types.predefined.g-pnb.from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pnb.make} POINTER
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PNB<dot>MAKE function}@c
@functionsubindex{cepl.types.predefined.g-pnb.make}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pnb.to-foreign} ()
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PNB<dot>TO-FOREIGN function}@c
@functionsubindex{cepl.types.predefined.g-pnb.to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pnc.from-foreign} ()
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PNC<dot>FROM-FOREIGN function}@c
@functionsubindex{cepl.types.predefined.g-pnc.from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pnc.make} POINTER
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PNC<dot>MAKE function}@c
@functionsubindex{cepl.types.predefined.g-pnc.make}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pnc.to-foreign} ()
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PNC<dot>TO-FOREIGN function}@c
@functionsubindex{cepl.types.predefined.g-pnc.to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pncb.from-foreign} ()
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PNCB<dot>FROM-FOREIGN function}@c
@functionsubindex{cepl.types.predefined.g-pncb.from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pncb.make} POINTER
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PNCB<dot>MAKE function}@c
@functionsubindex{cepl.types.predefined.g-pncb.make}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pncb.to-foreign} ()
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PNCB<dot>TO-FOREIGN function}@c
@functionsubindex{cepl.types.predefined.g-pncb.to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pnt.from-foreign} ()
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PNT<dot>FROM-FOREIGN function}@c
@functionsubindex{cepl.types.predefined.g-pnt.from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pnt.make} POINTER
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PNT<dot>MAKE function}@c
@functionsubindex{cepl.types.predefined.g-pnt.make}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pnt.to-foreign} ()
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PNT<dot>TO-FOREIGN function}@c
@functionsubindex{cepl.types.predefined.g-pnt.to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pntb.from-foreign} ()
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PNTB<dot>FROM-FOREIGN function}@c
@functionsubindex{cepl.types.predefined.g-pntb.from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pntb.make} POINTER
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PNTB<dot>MAKE function}@c
@functionsubindex{cepl.types.predefined.g-pntb.make}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pntb.to-foreign} ()
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PNTB<dot>TO-FOREIGN function}@c
@functionsubindex{cepl.types.predefined.g-pntb.to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pntc.from-foreign} ()
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PNTC<dot>FROM-FOREIGN function}@c
@functionsubindex{cepl.types.predefined.g-pntc.from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pntc.make} POINTER
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PNTC<dot>MAKE function}@c
@functionsubindex{cepl.types.predefined.g-pntc.make}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pntc.to-foreign} ()
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PNTC<dot>TO-FOREIGN function}@c
@functionsubindex{cepl.types.predefined.g-pntc.to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pntcb.from-foreign} ()
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PNTCB<dot>FROM-FOREIGN function}@c
@functionsubindex{cepl.types.predefined.g-pntcb.from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pntcb.make} POINTER
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PNTCB<dot>MAKE function}@c
@functionsubindex{cepl.types.predefined.g-pntcb.make}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pntcb.to-foreign} ()
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PNTCB<dot>TO-FOREIGN function}@c
@functionsubindex{cepl.types.predefined.g-pntcb.to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pt.from-foreign} ()
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PT<dot>FROM-FOREIGN function}@c
@functionsubindex{cepl.types.predefined.g-pt.from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pt.make} POINTER
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PT<dot>MAKE function}@c
@functionsubindex{cepl.types.predefined.g-pt.make}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pt.to-foreign} ()
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PT<dot>TO-FOREIGN function}@c
@functionsubindex{cepl.types.predefined.g-pt.to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {change-state} TARGET-STATE
@anchor{go to the CEPL<dot>LIFECYCLE<colon><colon>CHANGE-STATE function}@c
@functionsubindex{change-state}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>LIFECYCLE package, , @t{cepl.lifecycle}}
@item Source
@ref{go to the cepl/core/lifecycle<dot>lisp file, , @t{core/lifecycle.lisp}} (file)
@end table
@end deffn
@deffn {Function} {check-c-array-dimensions} DIMENSIONS TOTAL-SIZE ROW-ALIGNMENT
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>CHECK-C-ARRAY-DIMENSIONS function}@c
@functionsubindex{check-c-array-dimensions}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/make<dot>lisp file, , @t{core/c-arrays/make.lisp}} (file)
@end table
@end deffn
@deffn {Function} {check-immutable-feature} ()
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>CHECK-IMMUTABLE-FEATURE function}@c
@functionsubindex{check-immutable-feature}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {check-sampler-feature} ()
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>CHECK-SAMPLER-FEATURE function}@c
@functionsubindex{check-sampler-feature}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {check-single-element-not-list} INITIAL-CONTENTS DIMENSIONS ELEMENT-TYPE
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>CHECK-SINGLE-ELEMENT-NOT-LIST function}@c
@functionsubindex{check-single-element-not-list}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/make<dot>lisp file, , @t{core/c-arrays/make.lisp}} (file)
@end table
@end deffn
@deffn {Function} {check-version-for-per-attachment-params} ()
@anchor{go to the CEPL<dot>BLENDING<colon><colon>CHECK-VERSION-FOR-PER-ATTACHMENT-PARAMS function}@c
@functionsubindex{check-version-for-per-attachment-params}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@end table
@end deffn
@deffn {Function} {clone-stage-spec} SPEC &key NEW-CONTEXT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>CLONE-STAGE-SPEC function}@c
@functionsubindex{clone-stage-spec}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Function} {compile-context-p} OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>COMPILE-CONTEXT-P function}@c
@functionsubindex{compile-context-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/compile-context<dot>lisp file, , @t{core/pipelines/compile-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {compile-context-primitive} INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>COMPILE-CONTEXT-PRIMITIVE function}@c
@functionsubindex{compile-context-primitive}@c
@deffnx {Function} {(setf compile-context-primitive)} VALUE INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF COMPILE-CONTEXT-PRIMITIVE) function}@c
@functionsubindex{(setf compile-context-primitive)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/compile-context<dot>lisp file, , @t{core/pipelines/compile-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {compile-context-stage} INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>COMPILE-CONTEXT-STAGE function}@c
@functionsubindex{compile-context-stage}@c
@deffnx {Function} {(setf compile-context-stage)} VALUE INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF COMPILE-CONTEXT-STAGE) function}@c
@functionsubindex{(setf compile-context-stage)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/compile-context<dot>lisp file, , @t{core/pipelines/compile-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {compile-context-static-p} INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>COMPILE-CONTEXT-STATIC-P function}@c
@functionsubindex{compile-context-static-p}@c
@deffnx {Function} {(setf compile-context-static-p)} VALUE INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF COMPILE-CONTEXT-STATIC-P) function}@c
@functionsubindex{(setf compile-context-static-p)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/compile-context<dot>lisp file, , @t{core/pipelines/compile-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {compile-context-versions} INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>COMPILE-CONTEXT-VERSIONS function}@c
@functionsubindex{compile-context-versions}@c
@deffnx {Function} {(setf compile-context-versions)} VALUE INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF COMPILE-CONTEXT-VERSIONS) function}@c
@functionsubindex{(setf compile-context-versions)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/compile-context<dot>lisp file, , @t{core/pipelines/compile-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {compile-pixel-format} PIXEL-FORMAT
@anchor{go to the CEPL<dot>PIXEL-FORMATS<colon><colon>COMPILE-PIXEL-FORMAT function}@c
@functionsubindex{compile-pixel-format}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIXEL-FORMATS package, , @t{cepl.pixel-formats}}
@item Source
@ref{go to the cepl/core/types/pixel-format<dot>lisp file, , @t{core/types/pixel-format.lisp}} (file)
@end table
@end deffn
@deffn {Function} {complete-single-stage-pipeline} STAGE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>COMPLETE-SINGLE-STAGE-PIPELINE function}@c
@functionsubindex{complete-single-stage-pipeline}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {complete-unbound-context} UNBOUND-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>COMPLETE-UNBOUND-CONTEXT function}@c
@functionsubindex{complete-unbound-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {compute-expander} PROFILE-NAME SPACE-SYMB
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>COMPUTE-EXPANDER function}@c
@functionsubindex{compute-expander}@c
This runs the compute function over the provided space using the
   currently bound program. Please note: It Does Not bind the program so
   this function should only be used from another function which@*
   is handling the binding.
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {compute-glsl-version-from-stage-pairs} STAGE-PAIRS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>COMPUTE-GLSL-VERSION-FROM-STAGE-PAIRS function}@c
@functionsubindex{compute-glsl-version-from-stage-pairs}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {compute-space-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COMPUTE-SPACE-P function}@c
@functionsubindex{compute-space-p}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cons-aware-1d-p} X
@anchor{go to the CEPL<dot>VAOS<colon><colon>CONS-AWARE-1D-P function}@c
@functionsubindex{cons-aware-1d-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>VAOS package, , @t{cepl.vaos}}
@item Source
@ref{go to the cepl/core/vaos/vaos<dot>lisp file, , @t{core/vaos/vaos.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-any-samples-passed-conservative-query} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-ANY-SAMPLES-PASSED-CONSERVATIVE-QUERY function}@c
@functionsubindex{copy-any-samples-passed-conservative-query}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-any-samples-passed-query} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-ANY-SAMPLES-PASSED-QUERY function}@c
@functionsubindex{copy-any-samples-passed-query}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-att} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-ATT function}@c
@functionsubindex{copy-att}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-boop6} INSTANCE
@anchor{go to the CEPL-UTILS<colon><colon>COPY-BOOP6 function}@c
@functionsubindex{copy-boop6}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-buffer-stream} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-BUFFER-STREAM function}@c
@functionsubindex{copy-buffer-stream}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-buffer-texture} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-BUFFER-TEXTURE function}@c
@functionsubindex{copy-buffer-texture}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-c-array} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-C-ARRAY function}@c
@functionsubindex{copy-c-array}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-c-array-to-ssbo} SRC DST
@anchor{go to the CEPL<dot>SSBOS<colon><colon>COPY-C-ARRAY-TO-SSBO function}@c
@functionsubindex{copy-c-array-to-ssbo}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SSBOS package, , @t{cepl.ssbos}}
@item Source
@ref{go to the cepl/core/ssbos/ssbos<dot>lisp file, , @t{core/ssbos/ssbos.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-c-array-to-ubo} SRC DST
@anchor{go to the CEPL<dot>UBOS<colon><colon>COPY-C-ARRAY-TO-UBO function}@c
@functionsubindex{copy-c-array-to-ubo}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>UBOS package, , @t{cepl.ubos}}
@item Source
@ref{go to the cepl/core/ubos/ubo<dot>lisp file, , @t{core/ubos/ubo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-cepl-context} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>COPY-CEPL-CONTEXT function}@c
@functionsubindex{copy-cepl-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-compile-context} COMPILE-CONTEXT &key PRIMITIVE VERSIONS STAGE STATIC-P
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>COPY-COMPILE-CONTEXT function}@c
@functionsubindex{copy-compile-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/compile-context<dot>lisp file, , @t{core/pipelines/compile-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-compute-space} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-COMPUTE-SPACE function}@c
@functionsubindex{copy-compute-space}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-delayed} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>COPY-DELAYED function}@c
@functionsubindex{copy-delayed}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/delayed-resource-init<dot>lisp file, , @t{core/context/delayed-resource-init.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-empty-fbo-params} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-EMPTY-FBO-PARAMS function}@c
@functionsubindex{copy-empty-fbo-params}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-fbo} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-FBO function}@c
@functionsubindex{copy-fbo}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-glambda-state} INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>COPY-GLAMBDA-STATE function}@c
@functionsubindex{copy-glambda-state}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-lambda<dot>lisp file, , @t{core/pipelines/gpu-lambda.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-gpu-array} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-GPU-ARRAY function}@c
@functionsubindex{copy-gpu-array}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-gpu-array-bb} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-GPU-ARRAY-BB function}@c
@functionsubindex{copy-gpu-array-bb}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-gpu-array-t} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-GPU-ARRAY-T function}@c
@functionsubindex{copy-gpu-array-t}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-gpu-buffer} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-GPU-BUFFER function}@c
@functionsubindex{copy-gpu-buffer}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-gpu-fence} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-GPU-FENCE function}@c
@functionsubindex{copy-gpu-fence}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-gpu-query} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-GPU-QUERY function}@c
@functionsubindex{copy-gpu-query}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-lisp-array-to-ssbo} SRC DST
@anchor{go to the CEPL<dot>SSBOS<colon><colon>COPY-LISP-ARRAY-TO-SSBO function}@c
@functionsubindex{copy-lisp-array-to-ssbo}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SSBOS package, , @t{cepl.ssbos}}
@item Source
@ref{go to the cepl/core/ssbos/ssbos<dot>lisp file, , @t{core/ssbos/ssbos.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-lisp-array-to-ubo} SRC DST
@anchor{go to the CEPL<dot>UBOS<colon><colon>COPY-LISP-ARRAY-TO-UBO function}@c
@functionsubindex{copy-lisp-array-to-ubo}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>UBOS package, , @t{cepl.ubos}}
@item Source
@ref{go to the cepl/core/ubos/ubo<dot>lisp file, , @t{core/ubos/ubo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-lisp-list-to-ssbo} SRC DST
@anchor{go to the CEPL<dot>SSBOS<colon><colon>COPY-LISP-LIST-TO-SSBO function}@c
@functionsubindex{copy-lisp-list-to-ssbo}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SSBOS package, , @t{cepl.ssbos}}
@item Source
@ref{go to the cepl/core/ssbos/ssbos<dot>lisp file, , @t{core/ssbos/ssbos.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-lisp-list-to-ubo} SRC DST
@anchor{go to the CEPL<dot>UBOS<colon><colon>COPY-LISP-LIST-TO-UBO function}@c
@functionsubindex{copy-lisp-list-to-ubo}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>UBOS package, , @t{cepl.ubos}}
@item Source
@ref{go to the cepl/core/ubos/ubo<dot>lisp file, , @t{core/ubos/ubo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-pipeline-state} INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>COPY-PIPELINE-STATE function}@c
@functionsubindex{copy-pipeline-state}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-pixel-format} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-PIXEL-FORMAT function}@c
@functionsubindex{copy-pixel-format}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-primitives-generated-query} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-PRIMITIVES-GENERATED-QUERY function}@c
@functionsubindex{copy-primitives-generated-query}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-render-buffer} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-RENDER-BUFFER function}@c
@functionsubindex{copy-render-buffer}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-sampler} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-SAMPLER function}@c
@functionsubindex{copy-sampler}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-sampler-id-box} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-SAMPLER-ID-BOX function}@c
@functionsubindex{copy-sampler-id-box}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-samples-passed-query} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-SAMPLES-PASSED-QUERY function}@c
@functionsubindex{copy-samples-passed-query}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-scoped-gpu-query} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-SCOPED-GPU-QUERY function}@c
@functionsubindex{copy-scoped-gpu-query}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-ssbo} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-SSBO function}@c
@functionsubindex{copy-ssbo}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-ssbo-to-new-c-array} SRC
@anchor{go to the CEPL<dot>SSBOS<colon><colon>COPY-SSBO-TO-NEW-C-ARRAY function}@c
@functionsubindex{copy-ssbo-to-new-c-array}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SSBOS package, , @t{cepl.ssbos}}
@item Source
@ref{go to the cepl/core/ssbos/ssbos<dot>lisp file, , @t{core/ssbos/ssbos.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-ssbo-to-new-lisp-data} SRC
@anchor{go to the CEPL<dot>SSBOS<colon><colon>COPY-SSBO-TO-NEW-LISP-DATA function}@c
@functionsubindex{copy-ssbo-to-new-lisp-data}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SSBOS package, , @t{cepl.ssbos}}
@item Source
@ref{go to the cepl/core/ssbos/ssbos<dot>lisp file, , @t{core/ssbos/ssbos.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-stencil-params} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-STENCIL-PARAMS function}@c
@functionsubindex{copy-stencil-params}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-texture} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-TEXTURE function}@c
@functionsubindex{copy-texture}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-time-elapsed-query} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-TIME-ELAPSED-QUERY function}@c
@functionsubindex{copy-time-elapsed-query}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-timestamp-query} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-TIMESTAMP-QUERY function}@c
@functionsubindex{copy-timestamp-query}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-transform-feedback-primitives-written-query} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-TRANSFORM-FEEDBACK-PRIMITIVES-WRITTEN-QUERY function}@c
@functionsubindex{copy-transform-feedback-primitives-written-query}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-transform-feedback-stream} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-TRANSFORM-FEEDBACK-STREAM function}@c
@functionsubindex{copy-transform-feedback-stream}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-ubo} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-UBO function}@c
@functionsubindex{copy-ubo}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-ubo-to-new-c-array} SRC
@anchor{go to the CEPL<dot>UBOS<colon><colon>COPY-UBO-TO-NEW-C-ARRAY function}@c
@functionsubindex{copy-ubo-to-new-c-array}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>UBOS package, , @t{cepl.ubos}}
@item Source
@ref{go to the cepl/core/ubos/ubo<dot>lisp file, , @t{core/ubos/ubo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-ubo-to-new-lisp-data} SRC
@anchor{go to the CEPL<dot>UBOS<colon><colon>COPY-UBO-TO-NEW-LISP-DATA function}@c
@functionsubindex{copy-ubo-to-new-lisp-data}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>UBOS package, , @t{cepl.ubos}}
@item Source
@ref{go to the cepl/core/ubos/ubo<dot>lisp file, , @t{core/ubos/ubo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-uidx} INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>COPY-UIDX function}@c
@functionsubindex{copy-uidx}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-unbound-cepl-context} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>COPY-UNBOUND-CEPL-CONTEXT function}@c
@functionsubindex{copy-unbound-cepl-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cube->fbo-arrays} FBO-OBJ FUZZY-ARGS
@anchor{go to the CEPL<dot>FBOS<colon><colon>CUBE->FBO-ARRAYS function}@c
@functionsubindex{cube->fbo-arrays}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {current-blend-params} &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>BLENDING<colon><colon>CURRENT-BLEND-PARAMS function}@c
@functionsubindex{current-blend-params}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@end table
@end deffn
@deffn {Function} {def-dispatch-func} CTX COMPILE-CONTEXT NAME INIT-FUNC-NAME UNIFORM-ASSIGNERS AGGREGATE-PUBLIC-UNIFORMS STATE-VAR STATE-TAG COMPUTE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>DEF-DISPATCH-FUNC function}@c
@functionsubindex{def-dispatch-func}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {default-fbo-attachment-enum} ATTACHMENT-NUM
@anchor{go to the CEPL<dot>FBOS<colon><colon>DEFAULT-FBO-ATTACHMENT-ENUM function}@c
@functionsubindex{default-fbo-attachment-enum}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {defun-g-common} NAME ARGS BODY EQUIV
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>DEFUN-G-COMMON function}@c
@functionsubindex{defun-g-common}@c
Define a function that runs on the gpu.
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {defx*} DEFNAME NAME SLOTS
@anchor{go to the CEPL-UTILS<colon><colon>DEFX* function}@c
@functionsubindex{defx*}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {delay-initialization} CEPL-CONTEXT INIT-THUNK WAITING-ON-THESE-RESOURCES
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>DELAY-INITIALIZATION function}@c
@functionsubindex{delay-initialization}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/delayed-resource-init<dot>lisp file, , @t{core/context/delayed-resource-init.lisp}} (file)
@end table
@end deffn
@deffn {Function} {delayed-p} OBJECT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>DELAYED-P function}@c
@functionsubindex{delayed-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/delayed-resource-init<dot>lisp file, , @t{core/context/delayed-resource-init.lisp}} (file)
@end table
@end deffn
@deffn {Function} {delayed-thunk} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>DELAYED-THUNK function}@c
@functionsubindex{delayed-thunk}@c
@deffnx {Function} {(setf delayed-thunk)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF DELAYED-THUNK) function}@c
@functionsubindex{(setf delayed-thunk)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/delayed-resource-init<dot>lisp file, , @t{core/context/delayed-resource-init.lisp}} (file)
@end table
@end deffn
@deffn {Function} {delayed-waiting-on} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>DELAYED-WAITING-ON function}@c
@functionsubindex{delayed-waiting-on}@c
@deffnx {Function} {(setf delayed-waiting-on)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF DELAYED-WAITING-ON) function}@c
@functionsubindex{(setf delayed-waiting-on)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/delayed-resource-init<dot>lisp file, , @t{core/context/delayed-resource-init.lisp}} (file)
@end table
@end deffn
@deffn {Function} {describe-image-format} FORMAT
@anchor{go to the CEPL<dot>PIXEL-FORMATS<colon><colon>DESCRIBE-IMAGE-FORMAT function}@c
@functionsubindex{describe-image-format}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIXEL-FORMATS package, , @t{cepl.pixel-formats}}
@item Source
@ref{go to the cepl/core/types/pixel-format<dot>lisp file, , @t{core/types/pixel-format.lisp}} (file)
@end table
@end deffn
@deffn {Function} {describe-pixel-format} OBJECT
@anchor{go to the CEPL<dot>PIXEL-FORMATS<colon><colon>DESCRIBE-PIXEL-FORMAT function}@c
@functionsubindex{describe-pixel-format}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIXEL-FORMATS package, , @t{cepl.pixel-formats}}
@item Source
@ref{go to the cepl/core/types/pixel-format<dot>lisp file, , @t{core/types/pixel-format.lisp}} (file)
@end table
@end deffn
@deffn {Function} {dimensions-at-mipmap-level} TEXTURE LEVEL
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>DIMENSIONS-AT-MIPMAP-LEVEL function}@c
@functionsubindex{dimensions-at-mipmap-level}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {discard-context-id} ID
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>DISCARD-CONTEXT-ID function}@c
@functionsubindex{discard-context-id}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {dispatch-dyn-gpu-call} PLINE CALL-ARGS RET-TYPES
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>DISPATCH-DYN-GPU-CALL function}@c
@functionsubindex{dispatch-dyn-gpu-call}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/funcall-g<dot>lisp file, , @t{core/pipelines/funcall-g.lisp}} (file)
@end table
@end deffn
@deffn {Function} {dispatch-make-assigner} INDEXES LOCAL-ARG-NAME ARG-NAME TYPE GLSL-NAME QUALIFIERS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>DISPATCH-MAKE-ASSIGNER function}@c
@functionsubindex{dispatch-make-assigner}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Function} {draw-buffer-pattern-p} DRAW-BUFFERS
@anchor{go to the CEPL<dot>FBOS<colon><colon>DRAW-BUFFER-PATTERN-P function}@c
@functionsubindex{draw-buffer-pattern-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {draw-expander} PROFILE-NAME CTX-SYMB STREAM-SYMB DRAW-MODE-SYMB PRIMITIVE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>DRAW-EXPANDER function}@c
@functionsubindex{draw-expander}@c
This draws the single stream provided using the currently
   bound program. Please note: It Does Not bind the program so
   this function should only be used from another function which
   is handling the binding.
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {draw-mode-symbol-group-id} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>DRAW-MODE-SYMBOL-GROUP-ID function}@c
@functionsubindex{draw-mode-symbol-group-id}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {dyn-code-to-pipeline-and-stages} CODE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>DYN-CODE-TO-PIPELINE-AND-STAGES function}@c
@functionsubindex{dyn-code-to-pipeline-and-stages}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/funcall-g<dot>lisp file, , @t{core/pipelines/funcall-g.lisp}} (file)
@end table
@end deffn
@deffn {Function} {elements-indirect-command-p} OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ELEMENTS-INDIRECT-COMMAND-P function}@c
@functionsubindex{elements-indirect-command-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/multi-draw<dot>lisp file, , @t{core/pipelines/multi-draw.lisp}} (file)
@end table
@end deffn
@deffn {Function} {elements-indirect-command-pointer} INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ELEMENTS-INDIRECT-COMMAND-POINTER function}@c
@functionsubindex{elements-indirect-command-pointer}@c
@deffnx {Function} {(setf elements-indirect-command-pointer)} VALUE INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF ELEMENTS-INDIRECT-COMMAND-POINTER) function}@c
@functionsubindex{(setf elements-indirect-command-pointer)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/multi-draw<dot>lisp file, , @t{core/pipelines/multi-draw.lisp}} (file)
@end table
@end deffn
@deffn {Function} {empty-fbo-args-p} FUZZY-ARGS
@anchor{go to the CEPL<dot>FBOS<colon><colon>EMPTY-FBO-ARGS-P function}@c
@functionsubindex{empty-fbo-args-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {empty-fbo-params-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>EMPTY-FBO-PARAMS-P function}@c
@functionsubindex{empty-fbo-params-p}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {enable-transform-feedback} PROG-ID MODE NAMES
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ENABLE-TRANSFORM-FEEDBACK function}@c
@functionsubindex{enable-transform-feedback}@c
Returns the number of gpu-arrays that should be bound in the
   transform-feedback-stream
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {end-scoped-gpu-query} QUERY
@anchor{go to the CEPL<dot>QUERIES<colon><colon>END-SCOPED-GPU-QUERY function}@c
@functionsubindex{end-scoped-gpu-query}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>QUERIES package, , @t{cepl.queries}}
@item Source
@ref{go to the cepl/core/queries/query<dot>lisp file, , @t{core/queries/query.lisp}} (file)
@end table
@end deffn
@deffn {Function} {ensure-cepl-compatible-setup} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>ENSURE-CEPL-COMPATIBLE-SETUP function}@c
@functionsubindex{ensure-cepl-compatible-setup}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {ensure-fbo-array-size} FBO DESIRED-SIZE
@anchor{go to the CEPL<dot>FBOS<colon><colon>ENSURE-FBO-ARRAY-SIZE function}@c
@functionsubindex{ensure-fbo-array-size}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {error-on-invalid-upload-formats} TARGET IMAGE-FORMAT PIXEL-FORMAT PIXEL-TYPE
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>ERROR-ON-INVALID-UPLOAD-FORMATS function}@c
@functionsubindex{error-on-invalid-upload-formats}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {escape-tildes} STR
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ESCAPE-TILDES function}@c
@functionsubindex{escape-tildes}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {establish-texture-type} DIMENSIONS MIPMAP LAYERS CUBES PO2 MULTISAMPLE BUFFER RECTANGLE
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>ESTABLISH-TEXTURE-TYPE function}@c
@functionsubindex{establish-texture-type}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {expand-lambda-defpipeline} NAME CONTEXT GPIPE-ARGS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>EXPAND-LAMBDA-DEFPIPELINE function}@c
@functionsubindex{expand-lambda-defpipeline}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {expand-mappable-slot-to-layout} SLOT TYPE NORMALIZE
@anchor{go to the CEPL<dot>TYPES<colon><colon>EXPAND-MAPPABLE-SLOT-TO-LAYOUT function}@c
@functionsubindex{expand-mappable-slot-to-layout}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {expand-slot-to-layout} SLOT &optional TYPE NORMALIZE
@anchor{go to the CEPL<dot>TYPES<colon><colon>EXPAND-SLOT-TO-LAYOUT function}@c
@functionsubindex{expand-slot-to-layout}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {expand-unmappable-slot-to-layout} SLOT TYPE NORMALIZE
@anchor{go to the CEPL<dot>TYPES<colon><colon>EXPAND-UNMAPPABLE-SLOT-TO-LAYOUT function}@c
@functionsubindex{expand-unmappable-slot-to-layout}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {extract-dimension-from-make-fbo-pattern} PATTERN
@anchor{go to the CEPL<dot>FBOS<colon><colon>EXTRACT-DIMENSION-FROM-MAKE-FBO-PATTERN function}@c
@functionsubindex{extract-dimension-from-make-fbo-pattern}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {extract-matching-dimension-value} ARGS
@anchor{go to the CEPL<dot>FBOS<colon><colon>EXTRACT-MATCHING-DIMENSION-VALUE function}@c
@functionsubindex{extract-matching-dimension-value}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {fallback-iuniform-func} ()
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>FALLBACK-IUNIFORM-FUNC function}@c
@functionsubindex{fallback-iuniform-func}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {fallback-sampler-set} SAMPLER
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>FALLBACK-SAMPLER-SET function}@c
@functionsubindex{fallback-sampler-set}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/texture-samplers<dot>lisp file, , @t{core/textures/texture-samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {fbo-attach-array} CEPL-CONTEXT FBO TEX-ARRAY ATTACHMENT-NAME
@anchor{go to the CEPL<dot>FBOS<colon><colon>FBO-ATTACH-ARRAY function}@c
@functionsubindex{fbo-attach-array}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {fbo-attach-render-buffer} CEPL-CONTEXT FBO RENDER-BUFFER ATTACHMENT-NAME
@anchor{go to the CEPL<dot>FBOS<colon><colon>FBO-ATTACH-RENDER-BUFFER function}@c
@functionsubindex{fbo-attach-render-buffer}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {fbo-color-arrays} FBO
@anchor{go to the CEPL<dot>FBOS<colon><colon>FBO-COLOR-ARRAYS function}@c
@functionsubindex{fbo-color-arrays}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {fbo-detach} CEPL-CONTEXT FBO ATTACHMENT-NAME
@anchor{go to the CEPL<dot>FBOS<colon><colon>FBO-DETACH function}@c
@functionsubindex{fbo-detach}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {fbo-gen-attach} FBO CHECK-DIMENSIONS-MATCHP &rest ARGS
@anchor{go to the CEPL<dot>FBOS<colon><colon>FBO-GEN-ATTACH function}@c
@functionsubindex{fbo-gen-attach}@c
The are 4 kinds of valid argument:@*
   - keyword naming an attachment: This makes a new texture@*
     with size of (current-viewport) and attaches@*
   - (keyword texarray): attaches the tex-array@*
   - (keyword texture): attaches the root tex-array@*
   - (keyword some-type) any types that supports the generic dimensions function
                         creates a new texture at the framesize of the object
                         and attaches it to attachment named by keyword
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {find-compatible-c-array-type} CURRENT-SET DATA
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>FIND-COMPATIBLE-C-ARRAY-TYPE function}@c
@functionsubindex{find-compatible-c-array-type}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/make<dot>lisp file, , @t{core/c-arrays/make.lisp}} (file)
@end table
@end deffn
@deffn {Function} {find-gpu-func-spec-by-name-and-vals} NAME IN-VALS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>FIND-GPU-FUNC-SPEC-BY-NAME-AND-VALS function}@c
@functionsubindex{find-gpu-func-spec-by-name-and-vals}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/funcall-g<dot>lisp file, , @t{core/pipelines/funcall-g.lisp}} (file)
@end table
@end deffn
@deffn {Function} {find-invalid-defpipeline-options} OPTIONS VALID-KEYS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>FIND-INVALID-DEFPIPELINE-OPTIONS function}@c
@functionsubindex{find-invalid-defpipeline-options}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/pipeline-validation<dot>lisp file, , @t{core/pipelines/pipeline-validation.lisp}} (file)
@end table
@end deffn
@deffn {Function} {find-suitable-type} DATUM
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>FIND-SUITABLE-TYPE function}@c
@functionsubindex{find-suitable-type}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/make<dot>lisp file, , @t{core/c-arrays/make.lisp}} (file)
@end table
@end deffn
@deffn {Function} {first-elem} X
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>FIRST-ELEM function}@c
@functionsubindex{first-elem}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/make<dot>lisp file, , @t{core/c-arrays/make.lisp}} (file)
@end table
@end deffn
@deffn {Function} {force-bind-vao} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>FORCE-BIND-VAO function}@c
@functionsubindex{force-bind-vao}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {force-depth-test-function} FUNCTION &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>FORCE-DEPTH-TEST-FUNCTION function}@c
@functionsubindex{force-depth-test-function}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/depth/depth<dot>lisp file, , @t{core/depth/depth.lisp}} (file)
@end table
@end deffn
@deffn {Function} {force-sampler-bound} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>FORCE-SAMPLER-BOUND function}@c
@functionsubindex{force-sampler-bound}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/samplers/context<dot>lisp file, , @t{core/samplers/context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {force-scissor-viewport} ()
@anchor{go to the CEPL<dot>SCISSOR<colon><colon>FORCE-SCISSOR-VIEWPORT function}@c
@functionsubindex{force-scissor-viewport}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SCISSOR package, , @t{cepl.scissor}}
@item Source
@ref{go to the cepl/core/scissor/scissor<dot>lisp file, , @t{core/scissor/scissor.lisp}} (file)
@end table
@end deffn
@deffn {Function} {force-use-program} CTX PROGRAM-ID
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>FORCE-USE-PROGRAM function}@c
@functionsubindex{force-use-program}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/programs<dot>lisp file, , @t{core/pipelines/programs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {forget-fbo} CEPL-CONTEXT FBO
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>FORGET-FBO function}@c
@functionsubindex{forget-fbo}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {forget-gpu-buffer} CEPL-CONTEXT GPU-BUFFER
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>FORGET-GPU-BUFFER function}@c
@functionsubindex{forget-gpu-buffer}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {forget-texture} CEPL-CONTEXT TEXTURE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>FORGET-TEXTURE function}@c
@functionsubindex{forget-texture}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {forgiving-list-dimension-guess} LIST
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>FORGIVING-LIST-DIMENSION-GUESS function}@c
@functionsubindex{forgiving-list-dimension-guess}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/make<dot>lisp file, , @t{core/c-arrays/make.lisp}} (file)
@end table
@end deffn
@deffn {Function} {format-array-slot-for-cstruct} SLOT LAYOUT
@anchor{go to the CEPL<dot>TYPES<colon><colon>FORMAT-ARRAY-SLOT-FOR-CSTRUCT function}@c
@functionsubindex{format-array-slot-for-cstruct}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {format-slot-for-cstruct} SLOT LAYOUT
@anchor{go to the CEPL<dot>TYPES<colon><colon>FORMAT-SLOT-FOR-CSTRUCT function}@c
@functionsubindex{format-slot-for-cstruct}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {format-slot-for-varjo} SLOT
@anchor{go to the CEPL<dot>TYPES<colon><colon>FORMAT-SLOT-FOR-VARJO function}@c
@functionsubindex{format-slot-for-varjo}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {free-context} CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>FREE-CONTEXT function}@c
@functionsubindex{free-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {free-fbo} FBO
@anchor{go to the CEPL<dot>FBOS<colon><colon>FREE-FBO function}@c
@functionsubindex{free-fbo}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {free-gpu-array-bb} GPU-ARRAY
@anchor{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED<colon><colon>FREE-GPU-ARRAY-BB function}@c
@functionsubindex{free-gpu-array-bb}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED package, , @t{cepl.gpu-arrays.buffer-backed}}
@item Source
@ref{go to the cepl/core/gpu-arrays/buffer-backed<dot>lisp file, , @t{core/gpu-arrays/buffer-backed.lisp}} (file)
@end table
@end deffn
@deffn {Function} {free-gpu-array-t} ()
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>FREE-GPU-ARRAY-T function}@c
@functionsubindex{free-gpu-array-t}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/def<dot>lisp file, , @t{core/textures/def.lisp}} (file)
@end table
@end deffn
@deffn {Function} {free-gpu-buffer} BUFFER
@anchor{go to the CEPL<dot>GPU-BUFFERS<colon><colon>FREE-GPU-BUFFER function}@c
@functionsubindex{free-gpu-buffer}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-BUFFERS package, , @t{cepl.gpu-buffers}}
@item Source
@ref{go to the cepl/core/gpu-buffers/gpu-buffers<dot>lisp file, , @t{core/gpu-buffers/gpu-buffers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {free-gpu-buffers} BUFFERS
@anchor{go to the CEPL<dot>GPU-BUFFERS<colon><colon>FREE-GPU-BUFFERS function}@c
@functionsubindex{free-gpu-buffers}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-BUFFERS package, , @t{cepl.gpu-buffers}}
@item Source
@ref{go to the cepl/core/gpu-buffers/gpu-buffers<dot>lisp file, , @t{core/gpu-buffers/gpu-buffers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {free-user-fbo} FBO
@anchor{go to the CEPL<dot>FBOS<colon><colon>FREE-USER-FBO function}@c
@functionsubindex{free-user-fbo}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {from-active} TARGET-STATE
@anchor{go to the CEPL<dot>LIFECYCLE<colon><colon>FROM-ACTIVE function}@c
@functionsubindex{from-active}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>LIFECYCLE package, , @t{cepl.lifecycle}}
@item Source
@ref{go to the cepl/core/lifecycle<dot>lisp file, , @t{core/lifecycle.lisp}} (file)
@end table
@end deffn
@deffn {Function} {from-suspended} TARGET-STATE
@anchor{go to the CEPL<dot>LIFECYCLE<colon><colon>FROM-SUSPENDED function}@c
@functionsubindex{from-suspended}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>LIFECYCLE package, , @t{cepl.lifecycle}}
@item Source
@ref{go to the cepl/core/lifecycle<dot>lisp file, , @t{core/lifecycle.lisp}} (file)
@end table
@end deffn
@deffn {Function} {from-unitialized} TARGET-STATE
@anchor{go to the CEPL<dot>LIFECYCLE<colon><colon>FROM-UNITIALIZED function}@c
@functionsubindex{from-unitialized}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>LIFECYCLE package, , @t{cepl.lifecycle}}
@item Source
@ref{go to the cepl/core/lifecycle<dot>lisp file, , @t{core/lifecycle.lisp}} (file)
@end table
@end deffn
@deffn {Function} {funcs-these-funcs-use} NAMES &optional INCLUDE-NAMES
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>FUNCS-THESE-FUNCS-USE function}@c
@functionsubindex{funcs-these-funcs-use}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Function} {funcs-this-func-uses} KEY
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>FUNCS-THIS-FUNC-USES function}@c
@functionsubindex{funcs-this-func-uses}@c
Recursivly searches for functions by this function.@*
Sorts the list of function names by dependency so the earlier
names are depended on by the functions named later in the list
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Function} {function-arg-p} ARG
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>FUNCTION-ARG-P function}@c
@functionsubindex{function-arg-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {function-formp} X
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>FUNCTION-FORMP function}@c
@functionsubindex{function-formp}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/pipeline-validation<dot>lisp file, , @t{core/pipelines/pipeline-validation.lisp}} (file)
@end table
@end deffn
@deffn {Function} {function-keyed-pipeline} FUNC
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>FUNCTION-KEYED-PIPELINE function}@c
@functionsubindex{function-keyed-pipeline}@c
@deffnx {Function} {(setf function-keyed-pipeline)} SPEC FUNC
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF FUNCTION-KEYED-PIPELINE) function}@c
@functionsubindex{(setf function-keyed-pipeline)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Function} {function-uniforms} FUNC-SPECS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>FUNCTION-UNIFORMS function}@c
@functionsubindex{function-uniforms}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {fuzzy-args->arrays} FBO-OBJ FUZZY-ARGS
@anchor{go to the CEPL<dot>FBOS<colon><colon>FUZZY-ARGS->ARRAYS function}@c
@functionsubindex{fuzzy-args->arrays}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {g-pc-p} OBJECT
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PC-P function}@c
@functionsubindex{g-pc-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {g-pc-pointer} INSTANCE
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PC-POINTER function}@c
@functionsubindex{g-pc-pointer}@c
@deffnx {Function} {(setf g-pc-pointer)} VALUE INSTANCE
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>(SETF G-PC-POINTER) function}@c
@functionsubindex{(setf g-pc-pointer)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {g-pn-p} OBJECT
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PN-P function}@c
@functionsubindex{g-pn-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {g-pn-pointer} INSTANCE
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PN-POINTER function}@c
@functionsubindex{g-pn-pointer}@c
@deffnx {Function} {(setf g-pn-pointer)} VALUE INSTANCE
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>(SETF G-PN-POINTER) function}@c
@functionsubindex{(setf g-pn-pointer)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {g-pnb-p} OBJECT
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNB-P function}@c
@functionsubindex{g-pnb-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {g-pnb-pointer} INSTANCE
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNB-POINTER function}@c
@functionsubindex{g-pnb-pointer}@c
@deffnx {Function} {(setf g-pnb-pointer)} VALUE INSTANCE
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>(SETF G-PNB-POINTER) function}@c
@functionsubindex{(setf g-pnb-pointer)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {g-pnc-p} OBJECT
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNC-P function}@c
@functionsubindex{g-pnc-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {g-pnc-pointer} INSTANCE
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNC-POINTER function}@c
@functionsubindex{g-pnc-pointer}@c
@deffnx {Function} {(setf g-pnc-pointer)} VALUE INSTANCE
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>(SETF G-PNC-POINTER) function}@c
@functionsubindex{(setf g-pnc-pointer)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {g-pncb-p} OBJECT
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNCB-P function}@c
@functionsubindex{g-pncb-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {g-pncb-pointer} INSTANCE
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNCB-POINTER function}@c
@functionsubindex{g-pncb-pointer}@c
@deffnx {Function} {(setf g-pncb-pointer)} VALUE INSTANCE
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>(SETF G-PNCB-POINTER) function}@c
@functionsubindex{(setf g-pncb-pointer)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {g-pnt-p} OBJECT
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNT-P function}@c
@functionsubindex{g-pnt-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {g-pnt-pointer} INSTANCE
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNT-POINTER function}@c
@functionsubindex{g-pnt-pointer}@c
@deffnx {Function} {(setf g-pnt-pointer)} VALUE INSTANCE
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>(SETF G-PNT-POINTER) function}@c
@functionsubindex{(setf g-pnt-pointer)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {g-pntb-p} OBJECT
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNTB-P function}@c
@functionsubindex{g-pntb-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {g-pntb-pointer} INSTANCE
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNTB-POINTER function}@c
@functionsubindex{g-pntb-pointer}@c
@deffnx {Function} {(setf g-pntb-pointer)} VALUE INSTANCE
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>(SETF G-PNTB-POINTER) function}@c
@functionsubindex{(setf g-pntb-pointer)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {g-pntc-p} OBJECT
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNTC-P function}@c
@functionsubindex{g-pntc-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {g-pntc-pointer} INSTANCE
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNTC-POINTER function}@c
@functionsubindex{g-pntc-pointer}@c
@deffnx {Function} {(setf g-pntc-pointer)} VALUE INSTANCE
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>(SETF G-PNTC-POINTER) function}@c
@functionsubindex{(setf g-pntc-pointer)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {g-pntcb-p} OBJECT
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNTCB-P function}@c
@functionsubindex{g-pntcb-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {g-pntcb-pointer} INSTANCE
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNTCB-POINTER function}@c
@functionsubindex{g-pntcb-pointer}@c
@deffnx {Function} {(setf g-pntcb-pointer)} VALUE INSTANCE
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>(SETF G-PNTCB-POINTER) function}@c
@functionsubindex{(setf g-pntcb-pointer)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {g-pt-p} OBJECT
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PT-P function}@c
@functionsubindex{g-pt-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {g-pt-pointer} INSTANCE
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PT-POINTER function}@c
@functionsubindex{g-pt-pointer}@c
@deffnx {Function} {(setf g-pt-pointer)} VALUE INSTANCE
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>(SETF G-PT-POINTER) function}@c
@functionsubindex{(setf g-pt-pointer)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {g-struct-info} NAME &key ERROR-IF-NOT-FOUND
@anchor{go to the CEPL<dot>TYPES<colon><colon>G-STRUCT-INFO function}@c
@functionsubindex{g-struct-info}@c
@deffnx {Function} {(setf g-struct-info)} SLOTS NAME
@anchor{go to the CEPL<dot>TYPES<colon><colon>(SETF G-STRUCT-INFO) function}@c
@functionsubindex{(setf g-struct-info)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gen-buffer} ()
@anchor{go to the CEPL<dot>GPU-BUFFERS<colon><colon>GEN-BUFFER function}@c
@functionsubindex{gen-buffer}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-BUFFERS package, , @t{cepl.gpu-buffers}}
@item Source
@ref{go to the cepl/core/gpu-buffers/gpu-buffers<dot>lisp file, , @t{core/gpu-buffers/gpu-buffers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gen-buffer-tex-initial-contents} INITIAL-CONTENTS DIMENSIONS IMAGE-FORMAT CUBES RECTANGLE MULTISAMPLE MIPMAP LAYER-COUNT PIXEL-FORMAT
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>GEN-BUFFER-TEX-INITIAL-CONTENTS function}@c
@functionsubindex{gen-buffer-tex-initial-contents}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gen-c-array-sizes} DIMENSIONS ELEMENT-BYTE-SIZE ALIGNMENT
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>GEN-C-ARRAY-SIZES function}@c
@functionsubindex{gen-c-array-sizes}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/make<dot>lisp file, , @t{core/c-arrays/make.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gen-complete-lambda-pipeline-code} CTX COMPUTE IMPLICIT-U-LETS IMPLICIT-U-UPLOADS IMPLICIT-UNIFORM-TRANSFORMS POST PRIMITIVE STREAM-SYMB STREAM-TYPE U-CLEANUP U-LETS U-UPLOADS UNIFORM-NAMES
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GEN-COMPLETE-LAMBDA-PIPELINE-CODE function}@c
@functionsubindex{gen-complete-lambda-pipeline-code}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-lambda<dot>lisp file, , @t{core/pipelines/gpu-lambda.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gen-depth-stencil-texture} DEPTH STENCIL
@anchor{go to the CEPL<dot>FBOS<colon><colon>GEN-DEPTH-STENCIL-TEXTURE function}@c
@functionsubindex{gen-depth-stencil-texture}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gen-draw-buffer-call-from-array-form} FORM
@anchor{go to the CEPL<dot>FBOS<colon><colon>GEN-DRAW-BUFFER-CALL-FROM-ARRAY-FORM function}@c
@functionsubindex{gen-draw-buffer-call-from-array-form}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gen-draw-buffer-call-from-pattern} DRAW-BUFFERS
@anchor{go to the CEPL<dot>FBOS<colon><colon>GEN-DRAW-BUFFER-CALL-FROM-PATTERN function}@c
@functionsubindex{gen-draw-buffer-call-from-pattern}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gen-pipeline-init} NAME PRIMITIVE STAGE-PAIRS POST AGGREGATE-PUBLIC-UNIFORMS UNIFORM-ASSIGNERS STATE-TAG
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GEN-PIPELINE-INIT function}@c
@functionsubindex{gen-pipeline-init}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gen-query-id} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GEN-QUERY-ID function}@c
@functionsubindex{gen-query-id}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gen-recompile-func} NAME ORIGINAL-GPIPE-ARGS RAW-CONTEXT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GEN-RECOMPILE-FUNC function}@c
@functionsubindex{gen-recompile-func}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gen-texture} ()
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>GEN-TEXTURE function}@c
@functionsubindex{gen-texture}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gen-update-spec} NAME STAGE-PAIRS RAW-CONTEXT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GEN-UPDATE-SPEC function}@c
@functionsubindex{gen-update-spec}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gen-vertex-stage-code-calling-func} SPEC
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GEN-VERTEX-STAGE-CODE-CALLING-FUNC function}@c
@functionsubindex{gen-vertex-stage-code-calling-func}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/funcall-g<dot>lisp file, , @t{core/pipelines/funcall-g.lisp}} (file)
@end table
@end deffn
@deffn {Function} {generate-uniform-upload-forms} UNIFORM-ASSIGNERS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GENERATE-UNIFORM-UPLOAD-FORMS function}@c
@functionsubindex{generate-uniform-upload-forms}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {get-best-glsl-version} CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>GET-BEST-GLSL-VERSION function}@c
@functionsubindex{get-best-glsl-version}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/version<dot>lisp file, , @t{core/context/version.lisp}} (file)
@end table
@end deffn
@deffn {Function} {get-body-string} BODY
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GET-BODY-STRING function}@c
@functionsubindex{get-body-string}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/glsl-stages<dot>lisp file, , @t{core/pipelines/glsl-stages.lisp}} (file)
@end table
@end deffn
@deffn {Function} {get-component-length} COMPONENTS
@anchor{go to the CEPL<dot>PIXEL-FORMATS<colon><colon>GET-COMPONENT-LENGTH function}@c
@functionsubindex{get-component-length}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIXEL-FORMATS package, , @t{cepl.pixel-formats}}
@item Source
@ref{go to the cepl/core/types/pixel-format<dot>lisp file, , @t{core/types/pixel-format.lisp}} (file)
@end table
@end deffn
@deffn {Function} {get-dyn-return-types-from-stage} STAGE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GET-DYN-RETURN-TYPES-FROM-STAGE function}@c
@functionsubindex{get-dyn-return-types-from-stage}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/funcall-g<dot>lisp file, , @t{core/pipelines/funcall-g.lisp}} (file)
@end table
@end deffn
@deffn {Function} {get-feedback-out-vars} STAGES
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GET-FEEDBACK-OUT-VARS function}@c
@functionsubindex{get-feedback-out-vars}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {get-foreign-uniform-function} TYPE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GET-FOREIGN-UNIFORM-FUNCTION function}@c
@functionsubindex{get-foreign-uniform-function}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniforms<dot>lisp file, , @t{core/pipelines/uniforms.lisp}} (file)
@end table
@end deffn
@deffn {Function} {get-foreign-uniform-function-name} TYPE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GET-FOREIGN-UNIFORM-FUNCTION-NAME function}@c
@functionsubindex{get-foreign-uniform-function-name}@c
Used when uploading from a foreign data source (like a c-array)
   This lets your uploading from an offset the source
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniforms<dot>lisp file, , @t{core/pipelines/uniforms.lisp}} (file)
@end table
@end deffn
@deffn {Function} {get-free-context-id} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>GET-FREE-CONTEXT-ID function}@c
@functionsubindex{get-free-context-id}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {get-free-ssbo-id} ()
@anchor{go to the CEPL<dot>SSBOS<colon><colon>GET-FREE-SSBO-ID function}@c
@functionsubindex{get-free-ssbo-id}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SSBOS package, , @t{cepl.ssbos}}
@item Source
@ref{go to the cepl/core/ssbos/ssbos<dot>lisp file, , @t{core/ssbos/ssbos.lisp}} (file)
@end table
@end deffn
@deffn {Function} {get-free-ubo-id} ()
@anchor{go to the CEPL<dot>UBOS<colon><colon>GET-FREE-UBO-ID function}@c
@functionsubindex{get-free-ubo-id}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>UBOS package, , @t{cepl.ubos}}
@item Source
@ref{go to the cepl/core/ubos/ubo<dot>lisp file, , @t{core/ubos/ubo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {get-func-as-stage-code} FUNC-SPEC
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GET-FUNC-AS-STAGE-CODE function}@c
@functionsubindex{get-func-as-stage-code}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {get-gl-attachment-enum} CEPL-CONTEXT FBO X
@anchor{go to the CEPL<dot>FBOS<colon><colon>GET-GL-ATTACHMENT-ENUM function}@c
@functionsubindex{get-gl-attachment-enum}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {get-gpu-func-spec-tag} ()
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GET-GPU-FUNC-SPEC-TAG function}@c
@functionsubindex{get-gpu-func-spec-tag}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Function} {get-possible-designators-for-name} NAME
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GET-POSSIBLE-DESIGNATORS-FOR-NAME function}@c
@functionsubindex{get-possible-designators-for-name}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {get-sampler-id-box} LOD-BIAS MIN-LOD MAX-LOD MINIFY-FILTER MAGNIFY-FILTER WRAP COMPARE
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>GET-SAMPLER-ID-BOX function}@c
@functionsubindex{get-sampler-id-box}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {get-shader-storage-block-index} PROGRAM NAME
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GET-SHADER-STORAGE-BLOCK-INDEX function}@c
@functionsubindex{get-shader-storage-block-index}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Function} {get-stage-key} STAGE-DESIGNATOR &optional OPTIONS-ON-ERROR
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GET-STAGE-KEY function}@c
@functionsubindex{get-stage-key}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {get-stage-kind-from-context} CONTEXT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GET-STAGE-KIND-FROM-CONTEXT function}@c
@functionsubindex{get-stage-kind-from-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/glsl-stages<dot>lisp file, , @t{core/pipelines/glsl-stages.lisp}} (file)
@end table
@end deffn
@deffn {Function} {get-transform-feedback-primitive} STAGES
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GET-TRANSFORM-FEEDBACK-PRIMITIVE function}@c
@functionsubindex{get-transform-feedback-primitive}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {get-uniform-block-index} PROGRAM NAME
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GET-UNIFORM-BLOCK-INDEX function}@c
@functionsubindex{get-uniform-block-index}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Function} {get-uniform-function} TYPE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GET-UNIFORM-FUNCTION function}@c
@functionsubindex{get-uniform-function}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniforms<dot>lisp file, , @t{core/pipelines/uniforms.lisp}} (file)
@end table
@end deffn
@deffn {Function} {get-uniform-function-name} TYPE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GET-UNIFORM-FUNCTION-NAME function}@c
@functionsubindex{get-uniform-function-name}@c
Used when uploading lisp data
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniforms<dot>lisp file, , @t{core/pipelines/uniforms.lisp}} (file)
@end table
@end deffn
@deffn {Function} {get-varyings} PROG-ID INDEX
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GET-VARYINGS function}@c
@functionsubindex{get-varyings}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gl-calc-byte-size} TYPE DIMENSIONS ROW-ALIGNMENT
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>GL-CALC-BYTE-SIZE function}@c
@functionsubindex{gl-calc-byte-size}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/populate<dot>lisp file, , @t{core/c-arrays/populate.lisp}} (file)
@end table
@end deffn
@deffn {Function} {glambda-state-p} OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GLAMBDA-STATE-P function}@c
@functionsubindex{glambda-state-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-lambda<dot>lisp file, , @t{core/pipelines/gpu-lambda.lisp}} (file)
@end table
@end deffn
@deffn {Function} {glambda-state-pipeline} INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GLAMBDA-STATE-PIPELINE function}@c
@functionsubindex{glambda-state-pipeline}@c
@deffnx {Function} {(setf glambda-state-pipeline)} VALUE INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF GLAMBDA-STATE-PIPELINE) function}@c
@functionsubindex{(setf glambda-state-pipeline)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-lambda<dot>lisp file, , @t{core/pipelines/gpu-lambda.lisp}} (file)
@end table
@end deffn
@deffn {Function} {glambda-state-recompiler} INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GLAMBDA-STATE-RECOMPILER function}@c
@functionsubindex{glambda-state-recompiler}@c
@deffnx {Function} {(setf glambda-state-recompiler)} VALUE INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF GLAMBDA-STATE-RECOMPILER) function}@c
@functionsubindex{(setf glambda-state-recompiler)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-lambda<dot>lisp file, , @t{core/pipelines/gpu-lambda.lisp}} (file)
@end table
@end deffn
@deffn {Function} {glambda-state-spec} INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GLAMBDA-STATE-SPEC function}@c
@functionsubindex{glambda-state-spec}@c
@deffnx {Function} {(setf glambda-state-spec)} VALUE INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF GLAMBDA-STATE-SPEC) function}@c
@functionsubindex{(setf glambda-state-spec)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-lambda<dot>lisp file, , @t{core/pipelines/gpu-lambda.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-array-bb-dimensions} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB-DIMENSIONS function}@c
@functionsubindex{gpu-array-bb-dimensions}@c
@deffnx {Function} {(setf gpu-array-bb-dimensions)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-BB-DIMENSIONS) function}@c
@functionsubindex{(setf gpu-array-bb-dimensions)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-array-sub-data} GPU-ARRAY C-ARRAY &key TYPES-MUST-MATCH
@anchor{go to the CEPL<dot>GPU-BUFFERS<colon><colon>GPU-ARRAY-SUB-DATA function}@c
@functionsubindex{gpu-array-sub-data}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-BUFFERS package, , @t{cepl.gpu-buffers}}
@item Source
@ref{go to the cepl/core/gpu-buffers/gpu-buffers<dot>lisp file, , @t{core/gpu-buffers/gpu-buffers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-array-t-dimensions} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T-DIMENSIONS function}@c
@functionsubindex{gpu-array-t-dimensions}@c
@deffnx {Function} {(setf gpu-array-t-dimensions)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-T-DIMENSIONS) function}@c
@functionsubindex{(setf gpu-array-t-dimensions)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-fence-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-FENCE-P function}@c
@functionsubindex{gpu-fence-p}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-func-specs} NAME &optional ERROR-IF-MISSING
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GPU-FUNC-SPECS function}@c
@functionsubindex{gpu-func-specs}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-query-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-QUERY-P function}@c
@functionsubindex{gpu-query-p}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {guess-a-varjo-array-type} X
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GUESS-A-VARJO-ARRAY-TYPE function}@c
@functionsubindex{guess-a-varjo-array-type}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {guess-a-varjo-bool-type} X
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GUESS-A-VARJO-BOOL-TYPE function}@c
@functionsubindex{guess-a-varjo-bool-type}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {guess-a-varjo-float-type} X
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GUESS-A-VARJO-FLOAT-TYPE function}@c
@functionsubindex{guess-a-varjo-float-type}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {guess-a-varjo-integer-type} X
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GUESS-A-VARJO-INTEGER-TYPE function}@c
@functionsubindex{guess-a-varjo-integer-type}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {guess-a-varjo-number-type} X
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GUESS-A-VARJO-NUMBER-TYPE function}@c
@functionsubindex{guess-a-varjo-number-type}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {guess-a-varjo-type} X
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GUESS-A-VARJO-TYPE function}@c
@functionsubindex{guess-a-varjo-type}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {handle-empty-framebuffer} FBO-OBJ ARGS
@anchor{go to the CEPL<dot>FBOS<colon><colon>HANDLE-EMPTY-FRAMEBUFFER function}@c
@functionsubindex{handle-empty-framebuffer}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {handle-transform-feedback} CTX DRAW-MODE PROG-ID TFS-PRIMITIVE TFS-ARRAY-COUNT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>HANDLE-TRANSFORM-FEEDBACK function}@c
@functionsubindex{handle-transform-feedback}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {has-func-type-in-args} FUNC-SPECS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>HAS-FUNC-TYPE-IN-ARGS function}@c
@functionsubindex{has-func-type-in-args}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {init-buffer-stream-from-id} STREAM-OBJ VAO-GL-OBJECT GPU-ARRAYS INDEX-ARRAY START LENGTH BASE-VERTEX RETAIN-ARRAYS
@anchor{go to the CEPL<dot>STREAMS<colon><colon>INIT-BUFFER-STREAM-FROM-ID function}@c
@functionsubindex{init-buffer-stream-from-id}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>STREAMS package, , @t{cepl.streams}}
@item Source
@ref{go to the cepl/core/streams/buffer-streams<dot>lisp file, , @t{core/streams/buffer-streams.lisp}} (file)
@end table
@end deffn
@deffn {Function} {init-buffer-stream-from-shared} NEW-STREAM SRC-STREAM BASE-VERTEX
@anchor{go to the CEPL<dot>STREAMS<colon><colon>INIT-BUFFER-STREAM-FROM-SHARED function}@c
@functionsubindex{init-buffer-stream-from-shared}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>STREAMS package, , @t{cepl.streams}}
@item Source
@ref{go to the cepl/core/streams/buffer-streams<dot>lisp file, , @t{core/streams/buffer-streams.lisp}} (file)
@end table
@end deffn
@deffn {Function} {init-gl-context} CEPL-CONTEXT SURFACE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>INIT-GL-CONTEXT function}@c
@functionsubindex{init-gl-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {init-gpu-array-from-c-array} ARR C-ARRAY ACCESS-STYLE DIMENSIONS
@anchor{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED<colon><colon>INIT-GPU-ARRAY-FROM-C-ARRAY function}@c
@functionsubindex{init-gpu-array-from-c-array}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED package, , @t{cepl.gpu-arrays.buffer-backed}}
@item Source
@ref{go to the cepl/core/gpu-arrays/buffer-backed<dot>lisp file, , @t{core/gpu-arrays/buffer-backed.lisp}} (file)
@end table
@end deffn
@deffn {Function} {init-gpu-array-no-data} ARRAY DIMENSIONS ELEMENT-TYPE ACCESS-STYLE ROW-ALIGNMENT
@anchor{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED<colon><colon>INIT-GPU-ARRAY-NO-DATA function}@c
@functionsubindex{init-gpu-array-no-data}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED package, , @t{cepl.gpu-arrays.buffer-backed}}
@item Source
@ref{go to the cepl/core/gpu-arrays/buffer-backed<dot>lisp file, , @t{core/gpu-arrays/buffer-backed.lisp}} (file)
@end table
@end deffn
@deffn {Function} {init-gpu-arrays-from-c-arrays} G-ARRAYS C-ARRAYS ACCESS-STYLE
@anchor{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED<colon><colon>INIT-GPU-ARRAYS-FROM-C-ARRAYS function}@c
@functionsubindex{init-gpu-arrays-from-c-arrays}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED package, , @t{cepl.gpu-arrays.buffer-backed}}
@item Source
@ref{go to the cepl/core/gpu-arrays/buffer-backed<dot>lisp file, , @t{core/gpu-arrays/buffer-backed.lisp}} (file)
@end table
@end deffn
@deffn {Function} {init-gpu-buffer-now} NEW-BUFFER GL-OBJECT INITIAL-CONTENTS BUFFER-TARGET USAGE
@anchor{go to the CEPL<dot>GPU-BUFFERS<colon><colon>INIT-GPU-BUFFER-NOW function}@c
@functionsubindex{init-gpu-buffer-now}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-BUFFERS package, , @t{cepl.gpu-buffers}}
@item Source
@ref{go to the cepl/core/gpu-buffers/gpu-buffers<dot>lisp file, , @t{core/gpu-buffers/gpu-buffers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {init-gpu-buffer-now-with-layouts} NEW-BUFFER GL-OBJECT LAYOUTS USAGE KEEP-DATA
@anchor{go to the CEPL<dot>GPU-BUFFERS<colon><colon>INIT-GPU-BUFFER-NOW-WITH-LAYOUTS function}@c
@functionsubindex{init-gpu-buffer-now-with-layouts}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-BUFFERS package, , @t{cepl.gpu-buffers}}
@item Source
@ref{go to the cepl/core/gpu-buffers/gpu-buffers<dot>lisp file, , @t{core/gpu-buffers/gpu-buffers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {init-pending-surfaces} CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>INIT-PENDING-SURFACES function}@c
@functionsubindex{init-pending-surfaces}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/surface<dot>lisp file, , @t{core/context/surface.lisp}} (file)
@end table
@end deffn
@deffn {Function} {initialize-all-delay-items-in-context} CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>INITIALIZE-ALL-DELAY-ITEMS-IN-CONTEXT function}@c
@functionsubindex{initialize-all-delay-items-in-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/delayed-resource-init<dot>lisp file, , @t{core/context/delayed-resource-init.lisp}} (file)
@end table
@end deffn
@deffn {Function} {initialize-all-delayed} THUNKS
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>INITIALIZE-ALL-DELAYED function}@c
@functionsubindex{initialize-all-delayed}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/delayed-resource-init<dot>lisp file, , @t{core/context/delayed-resource-init.lisp}} (file)
@end table
@end deffn
@deffn {Function} {initialize-as-empty-fbo} FBO
@anchor{go to the CEPL<dot>FBOS<colon><colon>INITIALIZE-AS-EMPTY-FBO function}@c
@functionsubindex{initialize-as-empty-fbo}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {initialize-delayed} DELAY-AGAIN ITEM
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>INITIALIZE-DELAYED function}@c
@functionsubindex{initialize-delayed}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/delayed-resource-init<dot>lisp file, , @t{core/context/delayed-resource-init.lisp}} (file)
@end table
@end deffn
@deffn {Function} {initialize-regular-fbo} FBO-OBJ
@anchor{go to the CEPL<dot>FBOS<colon><colon>INITIALIZE-REGULAR-FBO function}@c
@functionsubindex{initialize-regular-fbo}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {interactive-delete-gpu-function} NAME
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>INTERACTIVE-DELETE-GPU-FUNCTION function}@c
@functionsubindex{interactive-delete-gpu-function}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {interactive-pick-gpu-function} NAME
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>INTERACTIVE-PICK-GPU-FUNCTION function}@c
@functionsubindex{interactive-pick-gpu-function}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Function} {lambda-arg-p} X
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>LAMBDA-ARG-P function}@c
@functionsubindex{lambda-arg-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {lambda-g->lisp-code} GLAMBDA
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>LAMBDA-G->LISP-CODE function}@c
@functionsubindex{lambda-g->lisp-code}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-lambda<dot>lisp file, , @t{core/pipelines/gpu-lambda.lisp}} (file)
@end table
@end deffn
@deffn {Function} {lambda-g->state} LAMBDA-G
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>LAMBDA-G->STATE function}@c
@functionsubindex{lambda-g->state}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-lambda<dot>lisp file, , @t{core/pipelines/gpu-lambda.lisp}} (file)
@end table
@end deffn
@deffn {Function} {lambda-g->varjo-lambda-code} GLAMBDA
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>LAMBDA-G->VARJO-LAMBDA-CODE function}@c
@functionsubindex{lambda-g->varjo-lambda-code}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-lambda<dot>lisp file, , @t{core/pipelines/gpu-lambda.lisp}} (file)
@end table
@end deffn
@deffn {Function} {legacy-add-surface} CONTEXT TITLE WIDTH HEIGHT FULLSCREEN RESIZABLE NO-FRAME HIDDEN MAKE-CURRENT GL-VERSION
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>LEGACY-ADD-SURFACE function}@c
@functionsubindex{legacy-add-surface}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/surface<dot>lisp file, , @t{core/context/surface.lisp}} (file)
@end table
@end deffn
@deffn {Function} {link-shaders} SHADERS PROG-ID COMPILED-STAGES TRANSFORM-FEEDBACK-MODE TRANSFORM-FEEDBACK-NAMES
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>LINK-SHADERS function}@c
@functionsubindex{link-shaders}@c
Links all the shaders into the program provided
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {lisp-equivalent-of-keyword-cffi-type} NAME
@anchor{go to the CEPL<dot>TYPES<colon><colon>LISP-EQUIVALENT-OF-KEYWORD-CFFI-TYPE function}@c
@functionsubindex{lisp-equivalent-of-keyword-cffi-type}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {list-of-c-arrays-p} X
@anchor{go to the CEPL<dot>GPU-BUFFERS<colon><colon>LIST-OF-C-ARRAYS-P function}@c
@functionsubindex{list-of-c-arrays-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-BUFFERS package, , @t{cepl.gpu-buffers}}
@item Source
@ref{go to the cepl/core/gpu-buffers/gpu-buffers<dot>lisp file, , @t{core/gpu-buffers/gpu-buffers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {load-shader} FILE-PATH &optional SHADER-TYPE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>LOAD-SHADER function}@c
@functionsubindex{load-shader}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {load-shaders} &rest SHADER-PATHS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>LOAD-SHADERS function}@c
@functionsubindex{load-shaders}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {loop-disabling-attachments} FBO
@anchor{go to the CEPL<dot>BLENDING<colon><colon>LOOP-DISABLING-ATTACHMENTS function}@c
@functionsubindex{loop-disabling-attachments}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@end table
@end deffn
@deffn {Function} {loop-enabling-attachments} FBO
@anchor{go to the CEPL<dot>BLENDING<colon><colon>LOOP-ENABLING-ATTACHMENTS function}@c
@functionsubindex{loop-enabling-attachments}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@end table
@end deffn
@deffn {Function} {lowest-suitable-glsl-version} COMPILE-CONTEXT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>LOWEST-SUITABLE-GLSL-VERSION function}@c
@functionsubindex{lowest-suitable-glsl-version}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {machine-unit-size} TYPE &optional STRIDE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MACHINE-UNIT-SIZE function}@c
@functionsubindex{machine-unit-size}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/layout<dot>lisp file, , @t{core/types/layout.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-arg-assigners} UNIFORM-ARGS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>MAKE-ARG-ASSIGNERS function}@c
@functionsubindex{make-arg-assigners}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-array-assigners} INDEXES ARG-NAME TYPE GLSL-NAME-PATH &optional BYTE-OFFSET
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>MAKE-ARRAY-ASSIGNERS function}@c
@functionsubindex{make-array-assigners}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-array-slot-getter} SLOT TYPE-NAME FOREIGN-STRUCT-NAME LAYOUT
@anchor{go to the CEPL<dot>TYPES<colon><colon>MAKE-ARRAY-SLOT-GETTER function}@c
@functionsubindex{make-array-slot-getter}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-array-slot-setter} SLOT TYPE-NAME LAYOUT
@anchor{go to the CEPL<dot>TYPES<colon><colon>MAKE-ARRAY-SLOT-SETTER function}@c
@functionsubindex{make-array-slot-setter}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-arrays-indirect-command} &key COUNT INSTANCE-COUNT FIRST BASE-INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>MAKE-ARRAYS-INDIRECT-COMMAND function}@c
@functionsubindex{make-arrays-indirect-command}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/multi-draw<dot>lisp file, , @t{core/pipelines/multi-draw.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-assigner} &key LET-FORMS UPLOADERS POINTER-ARG ARG-NAME LOCAL-ARG-NAME CLEANUP ALWAYS-UPLOADP
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>MAKE-ASSIGNER function}@c
@functionsubindex{make-assigner}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-assigner-let} &key NAME INDEX TYPE BODY
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>MAKE-ASSIGNER-LET function}@c
@functionsubindex{make-assigner-let}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-base-gstruct-wrapper} &key (POINTER POINTER)
@anchor{go to the CEPL<dot>TYPES<colon><colon>MAKE-BASE-GSTRUCT-WRAPPER function}@c
@functionsubindex{make-base-gstruct-wrapper}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-boop6} &key (BOOP-X BOOP-X) (BOOP-Y BOOP-Y)
@anchor{go to the DEFXSTAR-HIDDEN<colon><colon>MAKE-BOOP6 function}@c
@functionsubindex{make-boop6}@c
@table @strong
@item Package
@ref{go to the DEFXSTAR-HIDDEN package, , @t{defxstar-hidden}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-buffer-stream-from-id} VAO-GL-OBJECT GPU-ARRAYS &key INDEX-ARRAY START LENGTH RETAIN-ARRAYS PRIMITIVE BASE-VERTEX
@anchor{go to the CEPL<dot>STREAMS<colon><colon>MAKE-BUFFER-STREAM-FROM-ID function}@c
@functionsubindex{make-buffer-stream-from-id}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>STREAMS package, , @t{cepl.streams}}
@item Source
@ref{go to the cepl/core/streams/buffer-streams<dot>lisp file, , @t{core/streams/buffer-streams.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-compile-context} &key (PRIMITIVE PRIMITIVE) (VERSIONS VERSIONS) (STAGE STAGE) (STATIC-P STATIC-P)
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>MAKE-COMPILE-CONTEXT function}@c
@functionsubindex{make-compile-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/compile-context<dot>lisp file, , @t{core/pipelines/compile-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-complete-lambda-pipeline} COMPILE-CONTEXT STAGE-PAIRS FUNC-SPECS POST REGISTER-SPEC
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>MAKE-COMPLETE-LAMBDA-PIPELINE function}@c
@functionsubindex{make-complete-lambda-pipeline}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-lambda<dot>lisp file, , @t{core/pipelines/gpu-lambda.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-context-internals} IS-IMPLICIT-CONTEXT-P &optional GL-VERSION
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>MAKE-CONTEXT-INTERNALS function}@c
@functionsubindex{make-context-internals}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-default-sampler-id-box} ()
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>MAKE-DEFAULT-SAMPLER-ID-BOX function}@c
@functionsubindex{make-default-sampler-id-box}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-delayed} &key (WAITING-ON WAITING-ON) (THUNK THUNK)
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>MAKE-DELAYED function}@c
@functionsubindex{make-delayed}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/delayed-resource-init<dot>lisp file, , @t{core/context/delayed-resource-init.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-elements-indirect-command} &key COUNT INSTANCE-COUNT FIRST-INDEX BASE-VERTEX BASE-INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>MAKE-ELEMENTS-INDIRECT-COMMAND function}@c
@functionsubindex{make-elements-indirect-command}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/multi-draw<dot>lisp file, , @t{core/pipelines/multi-draw.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-eprim-slot-setter} SLOT TYPE-NAME FOREIGN-STRUCT-NAME LAYOUT
@anchor{go to the CEPL<dot>TYPES<colon><colon>MAKE-EPRIM-SLOT-SETTER function}@c
@functionsubindex{make-eprim-slot-setter}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-existing-fbo-empty} FBO LAST-ATTACHMENT
@anchor{go to the CEPL<dot>FBOS<colon><colon>MAKE-EXISTING-FBO-EMPTY function}@c
@functionsubindex{make-existing-fbo-empty}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-fbo-non-empty} FBO
@anchor{go to the CEPL<dot>FBOS<colon><colon>MAKE-FBO-NON-EMPTY function}@c
@functionsubindex{make-fbo-non-empty}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-fbo-now} FBO-OBJ
@anchor{go to the CEPL<dot>FBOS<colon><colon>MAKE-FBO-NOW function}@c
@functionsubindex{make-fbo-now}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-g-pnb} &key POSITION NORMAL TANGENT BI-TANGENT
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>MAKE-G-PNB function}@c
@functionsubindex{make-g-pnb}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-g-pncb} &key POSITION NORMAL TANGENT BI-TANGENT COLOR
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>MAKE-G-PNCB function}@c
@functionsubindex{make-g-pncb}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-g-pntb} &key POSITION NORMAL TANGENT BI-TANGENT TEXTURE
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>MAKE-G-PNTB function}@c
@functionsubindex{make-g-pntb}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-g-pntcb} &key POSITION NORMAL TANGENT BI-TANGENT TEXTURE COLOR
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>MAKE-G-PNTCB function}@c
@functionsubindex{make-g-pntcb}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-glambda-state} &key (PIPELINE PIPELINE) (RECOMPILER RECOMPILER) (SPEC SPEC)
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>MAKE-GLAMBDA-STATE function}@c
@functionsubindex{make-glambda-state}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-lambda<dot>lisp file, , @t{core/pipelines/gpu-lambda.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-gpu-array-share-data} GPU-ARRAY-TO-MODIFY GPU-ARRAY-WITH-DATA BYTE-OFFSET-INTO-SOURCE-DATA ELEMENT-TYPE DIMENSIONS ROW-ALIGNMENT PIXEL-FORMAT
@anchor{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED<colon><colon>MAKE-GPU-ARRAY-SHARE-DATA function}@c
@functionsubindex{make-gpu-array-share-data}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED package, , @t{cepl.gpu-arrays.buffer-backed}}
@item Source
@ref{go to the cepl/core/gpu-arrays/buffer-backed<dot>lisp file, , @t{core/gpu-arrays/buffer-backed.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-gpu-lambda} ARGS BODY
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>MAKE-GPU-LAMBDA function}@c
@functionsubindex{make-gpu-lambda}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-lambda<dot>lisp file, , @t{core/pipelines/gpu-lambda.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-gpu-query} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MAKE-GPU-QUERY function}@c
@functionsubindex{make-gpu-query}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-instance-wrapper-def} NAME FOREIGN-STRUCT-NAME WRAPPER-CONSTRUCTOR-NAME SLOTS TYPED-POPULATE SLOT-LAYOUTS
@anchor{go to the CEPL<dot>TYPES<colon><colon>MAKE-INSTANCE-WRAPPER-DEF function}@c
@functionsubindex{make-instance-wrapper-def}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-lambda-pipeline} GPIPE-ARGS RAW/COMPILED-CONTEXT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>MAKE-LAMBDA-PIPELINE function}@c
@functionsubindex{make-lambda-pipeline}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-lambda<dot>lisp file, , @t{core/pipelines/gpu-lambda.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-lambda-pipeline-inner} GPIPE-ARGS COMPILE-CONTEXT &key REGISTER-LAMBDA-PIPELINE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>MAKE-LAMBDA-PIPELINE-INNER function}@c
@functionsubindex{make-lambda-pipeline-inner}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-lambda<dot>lisp file, , @t{core/pipelines/gpu-lambda.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-lambda-pipeline-spec} PROG-ID COMPILED-STAGES
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>MAKE-LAMBDA-PIPELINE-SPEC function}@c
@functionsubindex{make-lambda-pipeline-spec}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-make-struct} CONSTRUCTOR-NAME WRAPPER-CONSTRUCTOR-NAME AWRAP-TYPE-NAME SLOTS
@anchor{go to the CEPL<dot>TYPES<colon><colon>MAKE-MAKE-STRUCT function}@c
@functionsubindex{make-make-struct}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-partial-lambda-pipeline} FUNC-SPECS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>MAKE-PARTIAL-LAMBDA-PIPELINE function}@c
@functionsubindex{make-partial-lambda-pipeline}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-lambda<dot>lisp file, , @t{core/pipelines/gpu-lambda.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-pipeline-spec} NAME STAGES CONTEXT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>MAKE-PIPELINE-SPEC function}@c
@functionsubindex{make-pipeline-spec}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-pipeline-state} &key (DIFF-TAG DIFF-TAG) (PROG-IDS PROG-IDS) (IMPLICIT-UNIFORM-UPLOAD-FUNC IMPLICIT-UNIFORM-UPLOAD-FUNC) (TFS-PRIMITIVE TFS-PRIMITIVE) (TFS-ARRAY-COUNT TFS-ARRAY-COUNT) (HAS-FRAGMENT-STAGE HAS-FRAGMENT-STAGE) (UNIFORM-INT-IDS UNIFORM-INT-IDS) (UNIFORM-UINT-IDS UNIFORM-UINT-IDS)
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>MAKE-PIPELINE-STATE function}@c
@functionsubindex{make-pipeline-state}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-populate} NAME TYPED-POPULATE SLOTS
@anchor{go to the CEPL<dot>TYPES<colon><colon>MAKE-POPULATE function}@c
@functionsubindex{make-populate}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-pull-push} NAME SLOTS
@anchor{go to the CEPL<dot>TYPES<colon><colon>MAKE-PULL-PUSH function}@c
@functionsubindex{make-pull-push}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-render-buffer-now} RENDER-BUFFER DIMENSIONS IMAGE-FORMAT MULTISAMPLE
@anchor{go to the CEPL<dot>RENDER-BUFFERS<colon><colon>MAKE-RENDER-BUFFER-NOW function}@c
@functionsubindex{make-render-buffer-now}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>RENDER-BUFFERS package, , @t{cepl.render-buffers}}
@item Source
@ref{go to the cepl/core/render-buffers/render-buffer<dot>lisp file, , @t{core/render-buffers/render-buffer.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-sampler-assigner} INDEXES ARG-NAME TYPE GLSL-NAME-PATH
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>MAKE-SAMPLER-ASSIGNER function}@c
@functionsubindex{make-sampler-assigner}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-sampler-now} SAMPLER-OBJ LOD-BIAS MIN-LOD MAX-LOD MINIFY-FILTER MAGNIFY-FILTER WRAP COMPARE
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>MAKE-SAMPLER-NOW function}@c
@functionsubindex{make-sampler-now}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-scoped-gpu-query} &key (ID ID) (ENUM ENUM) (CACHE-ID CACHE-ID) (ACTIVE-P ACTIVE-P)
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MAKE-SCOPED-GPU-QUERY function}@c
@functionsubindex{make-scoped-gpu-query}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-shader} SHADER-TYPE SOURCE-STRING &optional SHADER-ID
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>MAKE-SHADER function}@c
@functionsubindex{make-shader}@c
This makes a new opengl shader object by compiling the text
   in the specified file and, unless specified, establishing the
   shader type from the file extension
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-simple-assigner} INDEXES ARG-NAME TYPE GLSL-NAME-PATH &optional BYTE-OFFSET
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>MAKE-SIMPLE-ASSIGNER function}@c
@functionsubindex{make-simple-assigner}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-slot-getter} SLOT TYPE-NAME FOREIGN-STRUCT-NAME LAYOUT
@anchor{go to the CEPL<dot>TYPES<colon><colon>MAKE-SLOT-GETTER function}@c
@functionsubindex{make-slot-getter}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-slot-setter} SLOT TYPE-NAME FOREIGN-STRUCT-NAME LAYOUT
@anchor{go to the CEPL<dot>TYPES<colon><colon>MAKE-SLOT-SETTER function}@c
@functionsubindex{make-slot-setter}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-ssbo-assigner} INDEXES ARG-NAME VARJO-TYPE GLSL-NAME
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>MAKE-SSBO-ASSIGNER function}@c
@functionsubindex{make-ssbo-assigner}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-ssbo-from-buffer} &rest NOT-YET-IMPLEMENTED
@anchor{go to the CEPL<dot>SSBOS<colon><colon>MAKE-SSBO-FROM-BUFFER function}@c
@functionsubindex{make-ssbo-from-buffer}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SSBOS package, , @t{cepl.ssbos}}
@item Source
@ref{go to the cepl/core/ssbos/ssbos<dot>lisp file, , @t{core/ssbos/ssbos.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-stand-in-lisp-func} SPEC
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>MAKE-STAND-IN-LISP-FUNC function}@c
@functionsubindex{make-stand-in-lisp-func}@c
Makes a regular lisp function with the same names and arguments
  (where possible) as the gpu function who's spec is provided.@*

  If called the function will throw an error saying that the function
  can't currently be used from the cpu.@*

  This means we get function arg hints, doc-string and also we have the
  opportunity to provide a cpu implementation one day we want to.
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-struct-assigners} INDEXES ARG-NAME TYPE GLSL-NAME-PATH &optional BYTE-OFFSET
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>MAKE-STRUCT-ASSIGNERS function}@c
@functionsubindex{make-struct-assigners}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-struct-attrib-assigner} TYPE-NAME SLOTS
@anchor{go to the CEPL<dot>TYPES<colon><colon>MAKE-STRUCT-ATTRIB-ASSIGNER function}@c
@functionsubindex{make-struct-attrib-assigner}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-struct-pixel-format} NAME SLOTS
@anchor{go to the CEPL<dot>TYPES<colon><colon>MAKE-STRUCT-PIXEL-FORMAT function}@c
@functionsubindex{make-struct-pixel-format}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-surface-from-pending} PENDING-SURFACE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>MAKE-SURFACE-FROM-PENDING function}@c
@functionsubindex{make-surface-from-pending}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/surface<dot>lisp file, , @t{core/context/surface.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-t-slot-getter} SLOT TYPE-NAME FOREIGN-STRUCT-NAME
@anchor{go to the CEPL<dot>TYPES<colon><colon>MAKE-T-SLOT-GETTER function}@c
@functionsubindex{make-t-slot-getter}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-t-slot-setter} SLOT TYPE-NAME LAYOUT
@anchor{go to the CEPL<dot>TYPES<colon><colon>MAKE-T-SLOT-SETTER function}@c
@functionsubindex{make-t-slot-setter}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-texture-now} TEX-OBJ INITIAL-CONTENTS DIMENSIONS ELEMENT-TYPE MIPMAP LAYER-COUNT CUBES RECTANGLE IMMUTABLE BUFFER-STORAGE GENERATE-MIPMAPS PIXEL-FORMAT SAMPLES FIXED-SAMPLE-LOCATIONS
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>MAKE-TEXTURE-NOW function}@c
@functionsubindex{make-texture-now}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-ubo-assigner} INDEXES ARG-NAME VARJO-TYPE GLSL-NAME
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>MAKE-UBO-ASSIGNER function}@c
@functionsubindex{make-ubo-assigner}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-ubo-from-buffer} &rest NOT-YET-IMPLEMENTED
@anchor{go to the CEPL<dot>UBOS<colon><colon>MAKE-UBO-FROM-BUFFER function}@c
@functionsubindex{make-ubo-from-buffer}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>UBOS package, , @t{cepl.ubos}}
@item Source
@ref{go to the cepl/core/ubos/ubo<dot>lisp file, , @t{core/ubos/ubo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-uidx} &key (INT INT) (UINT UINT)
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>MAKE-UIDX function}@c
@functionsubindex{make-uidx}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-unbound-cepl-context} &key (CONSUMED CONSUMED) (GL-CONTEXT GL-CONTEXT) (REQUESTED-GL-VERSION REQUESTED-GL-VERSION) (SHARED SHARED) (SURFACE SURFACE) (SURFACES SURFACES)
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>MAKE-UNBOUND-CEPL-CONTEXT function}@c
@functionsubindex{make-unbound-cepl-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-varjo-struct-def} NAME SLOTS
@anchor{go to the CEPL<dot>TYPES<colon><colon>MAKE-VARJO-STRUCT-DEF function}@c
@functionsubindex{make-varjo-struct-def}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-varjo-struct-lookup} NAME
@anchor{go to the CEPL<dot>TYPES<colon><colon>MAKE-VARJO-STRUCT-LOOKUP function}@c
@functionsubindex{make-varjo-struct-lookup}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {mapg-context-p} CTX
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>MAPG-CONTEXT-P function}@c
@functionsubindex{mapg-context-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/mapg-context<dot>lisp file, , @t{core/pipelines/mapg-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {massage-compute-stage-name} NAME
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>MASSAGE-COMPUTE-STAGE-NAME function}@c
@functionsubindex{massage-compute-stage-name}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {merge-into-assigner} POINTER-ARG ASSINGERS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>MERGE-INTO-ASSIGNER function}@c
@functionsubindex{merge-into-assigner}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Function} {multisample-texture-p} TEXTURE
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>MULTISAMPLE-TEXTURE-P function}@c
@functionsubindex{multisample-texture-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {nest-simple-loops} DIMENSIONS INDEX-VARS BODY &optional LOOP-OP
@anchor{go to the CEPL<dot>TYPES<colon><colon>NEST-SIMPLE-LOOPS function}@c
@functionsubindex{nest-simple-loops}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {new-func-key} NAME IN-ARGS-TYPES
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>NEW-FUNC-KEY function}@c
@functionsubindex{new-func-key}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Function} {normalize-slot-description} QUALIFIED-STRUCT-NAME SLOT-DESCRIPTION SLOT-LAYOUT TYPE-NAME READERS WRITERS
@anchor{go to the CEPL<dot>TYPES<colon><colon>NORMALIZE-SLOT-DESCRIPTION function}@c
@functionsubindex{normalize-slot-description}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {note-change} SAMPLER
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>NOTE-CHANGE function}@c
@functionsubindex{note-change}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {pack-pixels-from-texture} TEX-ARRAY PIXEL-FORMAT ROW-ALIGNMENT POINTER/OFFSET
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>PACK-PIXELS-FROM-TEXTURE function}@c
@functionsubindex{pack-pixels-from-texture}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {pairs-key-to-stage} STAGE-PAIRS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>PAIRS-KEY-TO-STAGE function}@c
@functionsubindex{pairs-key-to-stage}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {parse-compile-context} NAME RAW-CONTEXT FOR
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>PARSE-COMPILE-CONTEXT function}@c
@functionsubindex{parse-compile-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/compile-context<dot>lisp file, , @t{core/pipelines/compile-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {parse-defn-args} TYPED-ARGS RESULT-TYPES
@anchor{go to the CEPL<dot>DEFN<colon><colon>PARSE-DEFN-ARGS function}@c
@functionsubindex{parse-defn-args}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>DEFN package, , @t{cepl.defn}}
@item Source
@ref{go to the cepl<dot>build/defn/defn<dot>lisp file, , @t{defn/defn.lisp}} (file)
@end table
@end deffn
@deffn {Function} {parse-gpipe-args} ARGS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>PARSE-GPIPE-ARGS function}@c
@functionsubindex{parse-gpipe-args}@c
Gets the stage pairs and context for the given gpipe form.@*
   If there are only two gpu functions named and no explicit stages then@*
   it is assumed that the first is the vertex stage and the second the fragment
   stage.@*
   Otherwise you are expected to name the stages. You can name one and then let
   this function fill in the rest, but I think that's a bit hairy and will
   probably be removed.@*

   stage pairs are of the form (stage-name . gpu-function-name)
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {parse-gpipe-args-explicit} ARGS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>PARSE-GPIPE-ARGS-EXPLICIT function}@c
@functionsubindex{parse-gpipe-args-explicit}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {parse-gpipe-args-implicit} ARGS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>PARSE-GPIPE-ARGS-IMPLICIT function}@c
@functionsubindex{parse-gpipe-args-implicit}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {parsed-gpipe-args->v-translate-args} NAME PIPELINE-PRIMITIVE STAGE-KIND FUNC-SPEC &optional REPLACEMENTS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>PARSED-GPIPE-ARGS->V-TRANSLATE-ARGS function}@c
@functionsubindex{parsed-gpipe-args->v-translate-args}@c
parsed-gpipe-args->v-translate-args processed the (stage . gfunc-name) pairs
   that %compile-link-and-upload want to call v-rolling-translate on.@*
   To do this we need to look up the gpu function spec and turn them into valid
   arguments for the rolling-translate function.@*
   It also:@*
   [0] if it's a glsl-stage then it is already compiled. Pass the
       compile-result and let varjo handle it@*
   [1] is what handles the transformation of func (including gpu-lambdas)
   [2] 'replacements' specifies uniforms to replace in the stage. 
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {patch-uninitialized-context-with-version} CEPL-CONTEXT REQUESTED-GL-VERSION
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>PATCH-UNINITIALIZED-CONTEXT-WITH-VERSION function}@c
@functionsubindex{patch-uninitialized-context-with-version}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {pipeline-spec} NAME
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>PIPELINE-SPEC function}@c
@functionsubindex{pipeline-spec}@c
@deffnx {Function} {(setf pipeline-spec)} VALUE NAME
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF PIPELINE-SPEC) function}@c
@functionsubindex{(setf pipeline-spec)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Function} {pipeline-state-diff-tag} INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>PIPELINE-STATE-DIFF-TAG function}@c
@functionsubindex{pipeline-state-diff-tag}@c
@deffnx {Function} {(setf pipeline-state-diff-tag)} VALUE INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF PIPELINE-STATE-DIFF-TAG) function}@c
@functionsubindex{(setf pipeline-state-diff-tag)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {pipeline-state-has-fragment-stage} INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>PIPELINE-STATE-HAS-FRAGMENT-STAGE function}@c
@functionsubindex{pipeline-state-has-fragment-stage}@c
@deffnx {Function} {(setf pipeline-state-has-fragment-stage)} VALUE INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF PIPELINE-STATE-HAS-FRAGMENT-STAGE) function}@c
@functionsubindex{(setf pipeline-state-has-fragment-stage)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {pipeline-state-implicit-uniform-upload-func} INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>PIPELINE-STATE-IMPLICIT-UNIFORM-UPLOAD-FUNC function}@c
@functionsubindex{pipeline-state-implicit-uniform-upload-func}@c
@deffnx {Function} {(setf pipeline-state-implicit-uniform-upload-func)} VALUE INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF PIPELINE-STATE-IMPLICIT-UNIFORM-UPLOAD-FUNC) function}@c
@functionsubindex{(setf pipeline-state-implicit-uniform-upload-func)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {pipeline-state-p} OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>PIPELINE-STATE-P function}@c
@functionsubindex{pipeline-state-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {pipeline-state-prog-ids} INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>PIPELINE-STATE-PROG-IDS function}@c
@functionsubindex{pipeline-state-prog-ids}@c
@deffnx {Function} {(setf pipeline-state-prog-ids)} VALUE INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF PIPELINE-STATE-PROG-IDS) function}@c
@functionsubindex{(setf pipeline-state-prog-ids)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {pipeline-state-tfs-array-count} INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>PIPELINE-STATE-TFS-ARRAY-COUNT function}@c
@functionsubindex{pipeline-state-tfs-array-count}@c
@deffnx {Function} {(setf pipeline-state-tfs-array-count)} VALUE INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF PIPELINE-STATE-TFS-ARRAY-COUNT) function}@c
@functionsubindex{(setf pipeline-state-tfs-array-count)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {pipeline-state-tfs-primitive} INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>PIPELINE-STATE-TFS-PRIMITIVE function}@c
@functionsubindex{pipeline-state-tfs-primitive}@c
@deffnx {Function} {(setf pipeline-state-tfs-primitive)} VALUE INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF PIPELINE-STATE-TFS-PRIMITIVE) function}@c
@functionsubindex{(setf pipeline-state-tfs-primitive)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {pipeline-state-uniform-int-ids} INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>PIPELINE-STATE-UNIFORM-INT-IDS function}@c
@functionsubindex{pipeline-state-uniform-int-ids}@c
@deffnx {Function} {(setf pipeline-state-uniform-int-ids)} VALUE INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF PIPELINE-STATE-UNIFORM-INT-IDS) function}@c
@functionsubindex{(setf pipeline-state-uniform-int-ids)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {pipeline-state-uniform-uint-ids} INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>PIPELINE-STATE-UNIFORM-UINT-IDS function}@c
@functionsubindex{pipeline-state-uniform-uint-ids}@c
@deffnx {Function} {(setf pipeline-state-uniform-uint-ids)} VALUE INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF PIPELINE-STATE-UNIFORM-UINT-IDS) function}@c
@functionsubindex{(setf pipeline-state-uniform-uint-ids)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {pixel-format!} COMPONENTS &optional TYPE NORMALIZE REVERSED
@anchor{go to the CEPL<dot>PIXEL-FORMATS<colon><colon>PIXEL-FORMAT! function}@c
@functionsubindex{pixel-format!}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIXEL-FORMATS package, , @t{cepl.pixel-formats}}
@item Source
@ref{go to the cepl/core/types/pixel-format<dot>lisp file, , @t{core/types/pixel-format.lisp}} (file)
@end table
@end deffn
@deffn {Function} {po2p} X
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>PO2P function}@c
@functionsubindex{po2p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {populate-arrays-indirect-command} OBJECT DATA
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>POPULATE-ARRAYS-INDIRECT-COMMAND function}@c
@functionsubindex{populate-arrays-indirect-command}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/multi-draw<dot>lisp file, , @t{core/pipelines/multi-draw.lisp}} (file)
@end table
@end deffn
@deffn {Function} {populate-elements-indirect-command} OBJECT DATA
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>POPULATE-ELEMENTS-INDIRECT-COMMAND function}@c
@functionsubindex{populate-elements-indirect-command}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/multi-draw<dot>lisp file, , @t{core/pipelines/multi-draw.lisp}} (file)
@end table
@end deffn
@deffn {Function} {populate-g-pc} OBJECT DATA
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>POPULATE-G-PC function}@c
@functionsubindex{populate-g-pc}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {populate-g-pn} OBJECT DATA
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>POPULATE-G-PN function}@c
@functionsubindex{populate-g-pn}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {populate-g-pnb} OBJECT DATA
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>POPULATE-G-PNB function}@c
@functionsubindex{populate-g-pnb}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {populate-g-pnc} OBJECT DATA
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>POPULATE-G-PNC function}@c
@functionsubindex{populate-g-pnc}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {populate-g-pncb} OBJECT DATA
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>POPULATE-G-PNCB function}@c
@functionsubindex{populate-g-pncb}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {populate-g-pnt} OBJECT DATA
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>POPULATE-G-PNT function}@c
@functionsubindex{populate-g-pnt}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {populate-g-pntb} OBJECT DATA
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>POPULATE-G-PNTB function}@c
@functionsubindex{populate-g-pntb}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {populate-g-pntc} OBJECT DATA
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>POPULATE-G-PNTC function}@c
@functionsubindex{populate-g-pntc}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {populate-g-pntcb} OBJECT DATA
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>POPULATE-G-PNTCB function}@c
@functionsubindex{populate-g-pntcb}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {populate-g-pt} OBJECT DATA
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>POPULATE-G-PT function}@c
@functionsubindex{populate-g-pt}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {post-gl-init} FBO-OBJ &key ID DRAW-BUFFER-MAP CLEAR-MASK
@anchor{go to the CEPL<dot>FBOS<colon><colon>POST-GL-INIT function}@c
@functionsubindex{post-gl-init}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {potential-struct-layout} NAME LAYOUT-SPECIFIER SLOT-DESCRIPTIONS
@anchor{go to the CEPL<dot>TYPES<colon><colon>POTENTIAL-STRUCT-LAYOUT function}@c
@functionsubindex{potential-struct-layout}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {pre-gl-init} FBO-OBJ &key COLOR-ARRAYS DEPTH-ARRAY STENCIL-ARRAY IS-DEFAULT BLENDING-PARAMS
@anchor{go to the CEPL<dot>FBOS<colon><colon>PRE-GL-INIT function}@c
@functionsubindex{pre-gl-init}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {preprocess-gpu-arrays-for-vao} GPU-ARRAYS
@anchor{go to the CEPL<dot>VAOS<colon><colon>PREPROCESS-GPU-ARRAYS-FOR-VAO function}@c
@functionsubindex{preprocess-gpu-arrays-for-vao}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>VAOS package, , @t{cepl.vaos}}
@item Source
@ref{go to the cepl/core/vaos/vaos<dot>lisp file, , @t{core/vaos/vaos.lisp}} (file)
@end table
@end deffn
@deffn {Function} {primary-context} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>PRIMARY-CONTEXT function}@c
@functionsubindex{primary-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {primary-thread} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>PRIMARY-THREAD function}@c
@functionsubindex{primary-thread}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {primitive-keyword-to-enum-val} KWD
@anchor{go to the %CEPL<dot>TYPES<colon><colon>PRIMITIVE-KEYWORD-TO-ENUM-VAL function}@c
@functionsubindex{primitive-keyword-to-enum-val}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {primitive-vert-length} PRIM
@anchor{go to the %CEPL<dot>TYPES<colon><colon>PRIMITIVE-VERT-LENGTH function}@c
@functionsubindex{primitive-vert-length}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {primitives-generated-query-active-p} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>PRIMITIVES-GENERATED-QUERY-ACTIVE-P function}@c
@functionsubindex{primitives-generated-query-active-p}@c
@deffnx {Function} {(setf primitives-generated-query-active-p)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF PRIMITIVES-GENERATED-QUERY-ACTIVE-P) function}@c
@functionsubindex{(setf primitives-generated-query-active-p)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {primitives-generated-query-cache-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>PRIMITIVES-GENERATED-QUERY-CACHE-ID function}@c
@functionsubindex{primitives-generated-query-cache-id}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {primitives-generated-query-enum} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>PRIMITIVES-GENERATED-QUERY-ENUM function}@c
@functionsubindex{primitives-generated-query-enum}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {primitives-generated-query-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>PRIMITIVES-GENERATED-QUERY-ID function}@c
@functionsubindex{primitives-generated-query-id}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {primitives-generated-query-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>PRIMITIVES-GENERATED-QUERY-P function}@c
@functionsubindex{primitives-generated-query-p}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {process-defn-declares} FUNC-NAME DECLS
@anchor{go to the CEPL<dot>DEFN<colon><colon>PROCESS-DEFN-DECLARES function}@c
@functionsubindex{process-defn-declares}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>DEFN package, , @t{cepl.defn}}
@item Source
@ref{go to the cepl<dot>build/defn/defn<dot>lisp file, , @t{defn/defn.lisp}} (file)
@end table
@end deffn
@deffn {Function} {process-fbo-init-pattern} PATTERN
@anchor{go to the CEPL<dot>FBOS<colon><colon>PROCESS-FBO-INIT-PATTERN function}@c
@functionsubindex{process-fbo-init-pattern}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {process-glsl-arg} ARG
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>PROCESS-GLSL-ARG function}@c
@functionsubindex{process-glsl-arg}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/glsl-stages<dot>lisp file, , @t{core/pipelines/glsl-stages.lisp}} (file)
@end table
@end deffn
@deffn {Function} {process-layout} LAYOUT
@anchor{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED<colon><colon>PROCESS-LAYOUT function}@c
@functionsubindex{process-layout}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED package, , @t{cepl.gpu-arrays.buffer-backed}}
@item Source
@ref{go to the cepl/core/gpu-arrays/buffer-backed<dot>lisp file, , @t{core/gpu-arrays/buffer-backed.lisp}} (file)
@end table
@end deffn
@deffn {Function} {process-layout} LAYOUT
@anchor{go to the CEPL<dot>GPU-BUFFERS<colon><colon>PROCESS-LAYOUT function}@c
@functionsubindex{process-layout}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-BUFFERS package, , @t{cepl.gpu-buffers}}
@item Source
@ref{go to the cepl/core/gpu-buffers/gpu-buffers<dot>lisp file, , @t{core/gpu-buffers/gpu-buffers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {process-layout-specifier} LAYOUT-SPECIFIER
@anchor{go to the %CEPL<dot>TYPES<colon><colon>PROCESS-LAYOUT-SPECIFIER function}@c
@functionsubindex{process-layout-specifier}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/layout<dot>lisp file, , @t{core/types/layout.lisp}} (file)
@end table
@end deffn
@deffn {Function} {process-mp-path} PATHNAME NAME
@anchor{go to the CEPL<colon><colon>PROCESS-MP-PATH function}@c
@functionsubindex{process-mp-path}@c
@table @strong
@item Package
@ref{go to the CEPL package, , @t{cepl}}
@item Source
@ref{go to the cepl/project<dot>lisp file, , @t{project.lisp}} (file)
@end table
@end deffn
@deffn {Function} {process-pixel-format} COMPONENTS TYPE NORMALIZE REVERSED
@anchor{go to the CEPL<dot>PIXEL-FORMATS<colon><colon>PROCESS-PIXEL-FORMAT function}@c
@functionsubindex{process-pixel-format}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIXEL-FORMATS package, , @t{cepl.pixel-formats}}
@item Source
@ref{go to the cepl/core/types/pixel-format<dot>lisp file, , @t{core/types/pixel-format.lisp}} (file)
@end table
@end deffn
@deffn {Function} {process-stream-layout} LAYOUT
@anchor{go to the CEPL<dot>STREAMS<colon><colon>PROCESS-STREAM-LAYOUT function}@c
@functionsubindex{process-stream-layout}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>STREAMS package, , @t{cepl.streams}}
@item Source
@ref{go to the cepl/core/streams/buffer-streams<dot>lisp file, , @t{core/streams/buffer-streams.lisp}} (file)
@end table
@end deffn
@deffn {Function} {program-attrib-count} PROGRAM
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>PROGRAM-ATTRIB-COUNT function}@c
@functionsubindex{program-attrib-count}@c
Returns the number of attributes used by the shader
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/programs<dot>lisp file, , @t{core/pipelines/programs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {program-attributes} PROGRAM
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>PROGRAM-ATTRIBUTES function}@c
@functionsubindex{program-attributes}@c
Returns a list of details of the attributes used by
   the program. Each element in the list is a list in the
   format: (attribute-name attribute-type attribute-size)
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/programs<dot>lisp file, , @t{core/pipelines/programs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {program-uniform-count} PROG-ID
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>PROGRAM-UNIFORM-COUNT function}@c
@functionsubindex{program-uniform-count}@c
Returns the number of uniforms used by the shader
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/programs<dot>lisp file, , @t{core/pipelines/programs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {program-uniforms} PROGRAM-ID
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>PROGRAM-UNIFORMS function}@c
@functionsubindex{program-uniforms}@c
Returns a list of details of the uniforms used by@*
   the program. Each element in the list is a list in the
   format: (uniform-name uniform-type uniform-size)
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/programs<dot>lisp file, , @t{core/pipelines/programs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {ptr-index-1d} C-ARRAY X
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>PTR-INDEX-1D function}@c
@functionsubindex{ptr-index-1d}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/aref-c<dot>lisp file, , @t{core/c-arrays/aref-c.lisp}} (file)
@end table
@end deffn
@deffn {Function} {ptr-index-2d} C-ARRAY X Y
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>PTR-INDEX-2D function}@c
@functionsubindex{ptr-index-2d}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/aref-c<dot>lisp file, , @t{core/c-arrays/aref-c.lisp}} (file)
@end table
@end deffn
@deffn {Function} {ptr-index-3d} C-ARRAY X Y Z
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>PTR-INDEX-3D function}@c
@functionsubindex{ptr-index-3d}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/aref-c<dot>lisp file, , @t{core/c-arrays/aref-c.lisp}} (file)
@end table
@end deffn
@deffn {Function} {ptr-index-4d} C-ARRAY X Y Z W
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>PTR-INDEX-4D function}@c
@functionsubindex{ptr-index-4d}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/aref-c<dot>lisp file, , @t{core/c-arrays/aref-c.lisp}} (file)
@end table
@end deffn
@deffn {Function} {pull-g-soft-multi-func-message} ASSET-NAME
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>PULL-G-SOFT-MULTI-FUNC-MESSAGE function}@c
@functionsubindex{pull-g-soft-multi-func-message}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Function} {read-gpu-function-choice} INTRO-TEXT GFUNC-NAME
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>READ-GPU-FUNCTION-CHOICE function}@c
@functionsubindex{read-gpu-function-choice}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Function} {recompile-name} NAME
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>RECOMPILE-NAME function}@c
@functionsubindex{recompile-name}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Function} {register-event-listener} FUNCTION
@anchor{go to the CEPL<dot>HOST<colon><colon>REGISTER-EVENT-LISTENER function}@c
@functionsubindex{register-event-listener}@c
Register a function to be called on each event from the host
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Function} {register-fbo} CEPL-CONTEXT FBO
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>REGISTER-FBO function}@c
@functionsubindex{register-fbo}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {register-gpu-buffer} CEPL-CONTEXT GPU-BUFFER
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>REGISTER-GPU-BUFFER function}@c
@functionsubindex{register-gpu-buffer}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {register-lambda-pipeline} SPEC CLOSURE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>REGISTER-LAMBDA-PIPELINE function}@c
@functionsubindex{register-lambda-pipeline}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-lambda<dot>lisp file, , @t{core/pipelines/gpu-lambda.lisp}} (file)
@end table
@end deffn
@deffn {Function} {register-named-pipeline} NAME FUNC
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>REGISTER-NAMED-PIPELINE function}@c
@functionsubindex{register-named-pipeline}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {register-texture} CEPL-CONTEXT TEXTURE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>REGISTER-TEXTURE function}@c
@functionsubindex{register-texture}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {reinit-on-context} GPU-ARRAY
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>REINIT-ON-CONTEXT function}@c
@functionsubindex{reinit-on-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {render-buffer-element-type} RENDER-BUFFER
@anchor{go to the CEPL<dot>RENDER-BUFFERS<colon><colon>RENDER-BUFFER-ELEMENT-TYPE function}@c
@functionsubindex{render-buffer-element-type}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>RENDER-BUFFERS package, , @t{cepl.render-buffers}}
@item Source
@ref{go to the cepl/core/render-buffers/render-buffer<dot>lisp file, , @t{core/render-buffers/render-buffer.lisp}} (file)
@end table
@end deffn
@deffn {Function} {replace-host} HOST-OBJ
@anchor{go to the CEPL<dot>HOST<colon><colon>REPLACE-HOST function}@c
@functionsubindex{replace-host}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-api<dot>lisp file, , @t{host/api-api.lisp}} (file)
@end table
@end deffn
@deffn {Function} {request-program-id-for} CONTEXT NAME
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>REQUEST-PROGRAM-ID-FOR function}@c
@functionsubindex{request-program-id-for}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Function} {restore-state} CONTEXT PROGRAM STENCIL VAO FBOS-BOUND DEPTH-TEST-FUNCTION DEPTH-MASK DEPTH-RANGE DEPTH-CLAMP CLEAR-COLOR CULL-FACE FRONT-FACE VIEWPORT COLOR-MASK-INDICES TEX-UNIT-IDS BUFFER-TARGETS SCISSOR-VIEWPORT-INDICES UBO-INDICES SSBO-INDICES UNPACK-ALIGNMENT PACK-ALIGNMENT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>RESTORE-STATE function}@c
@functionsubindex{restore-state}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/known-state-blocks<dot>lisp file, , @t{core/context/known-state-blocks.lisp}} (file)
@end table
@end deffn
@deffn {Function} {rm-index-to-coords} INDEX SUBSCRIPTS
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>RM-INDEX-TO-COORDS function}@c
@functionsubindex{rm-index-to-coords}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/populate<dot>lisp file, , @t{core/c-arrays/populate.lisp}} (file)
@end table
@end deffn
@deffn {Function} {round-to-next-multiple} VAL MULTIPLE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>ROUND-TO-NEXT-MULTIPLE function}@c
@functionsubindex{round-to-next-multiple}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/layout<dot>lisp file, , @t{core/types/layout.lisp}} (file)
@end table
@end deffn
@deffn {Function} {sampler-id-box-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>SAMPLER-ID-BOX-P function}@c
@functionsubindex{sampler-id-box-p}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {sampler-on-context} ()
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>SAMPLER-ON-CONTEXT function}@c
@functionsubindex{sampler-on-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {sampler-typep} TYPE
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>SAMPLER-TYPEP function}@c
@functionsubindex{sampler-typep}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {samples-passed-query-active-p} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>SAMPLES-PASSED-QUERY-ACTIVE-P function}@c
@functionsubindex{samples-passed-query-active-p}@c
@deffnx {Function} {(setf samples-passed-query-active-p)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF SAMPLES-PASSED-QUERY-ACTIVE-P) function}@c
@functionsubindex{(setf samples-passed-query-active-p)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {samples-passed-query-cache-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>SAMPLES-PASSED-QUERY-CACHE-ID function}@c
@functionsubindex{samples-passed-query-cache-id}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {samples-passed-query-enum} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>SAMPLES-PASSED-QUERY-ENUM function}@c
@functionsubindex{samples-passed-query-enum}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {samples-passed-query-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>SAMPLES-PASSED-QUERY-ID function}@c
@functionsubindex{samples-passed-query-id}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {samples-passed-query-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>SAMPLES-PASSED-QUERY-P function}@c
@functionsubindex{samples-passed-query-p}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {scalar-type-p} TYPE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>SCALAR-TYPE-P function}@c
@functionsubindex{scalar-type-p}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/layout<dot>lisp file, , @t{core/types/layout.lisp}} (file)
@end table
@end deffn
@deffn {Function} {scan-array-for-type} DATA
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>SCAN-ARRAY-FOR-TYPE function}@c
@functionsubindex{scan-array-for-type}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/make<dot>lisp file, , @t{core/c-arrays/make.lisp}} (file)
@end table
@end deffn
@deffn {Function} {scan-for-type} DATA
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>SCAN-FOR-TYPE function}@c
@functionsubindex{scan-for-type}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/make<dot>lisp file, , @t{core/c-arrays/make.lisp}} (file)
@end table
@end deffn
@deffn {Function} {scan-list-for-type} DATA
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>SCAN-LIST-FOR-TYPE function}@c
@functionsubindex{scan-list-for-type}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/make<dot>lisp file, , @t{core/c-arrays/make.lisp}} (file)
@end table
@end deffn
@deffn {Function} {scoped-gpu-query-cache-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>SCOPED-GPU-QUERY-CACHE-ID function}@c
@functionsubindex{scoped-gpu-query-cache-id}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {scoped-gpu-query-enum} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>SCOPED-GPU-QUERY-ENUM function}@c
@functionsubindex{scoped-gpu-query-enum}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {scoped-gpu-query-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>SCOPED-GPU-QUERY-ID function}@c
@functionsubindex{scoped-gpu-query-id}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {scoped-gpu-query-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>SCOPED-GPU-QUERY-P function}@c
@functionsubindex{scoped-gpu-query-p}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {serialize-stage-pairs} STAGE-PAIRS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>SERIALIZE-STAGE-PAIRS function}@c
@functionsubindex{serialize-stage-pairs}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {set-buffer-bound-static} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>SET-BUFFER-BOUND-STATIC function}@c
@functionsubindex{set-buffer-bound-static}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {set-context-defaults} CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>SET-CONTEXT-DEFAULTS function}@c
@functionsubindex{set-context-defaults}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/make<dot>lisp file, , @t{core/context/make.lisp}} (file)
@end table
@end deffn
@deffn {Function} {set-current-blend-params} PARAMS &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>BLENDING<colon><colon>SET-CURRENT-BLEND-PARAMS function}@c
@functionsubindex{set-current-blend-params}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@end table
@end deffn
@deffn {Function} {set-current-blend-params-from-fbo} FBO &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>BLENDING<colon><colon>SET-CURRENT-BLEND-PARAMS-FROM-FBO function}@c
@functionsubindex{set-current-blend-params-from-fbo}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@end table
@end deffn
@deffn {Function} {set-patch-stream-primitive} STREAM PRIMITIVE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>SET-PATCH-STREAM-PRIMITIVE function}@c
@functionsubindex{set-patch-stream-primitive}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {set-sampler-bound} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>SET-SAMPLER-BOUND function}@c
@functionsubindex{set-sampler-bound}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/samplers/context<dot>lisp file, , @t{core/samplers/context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {shader-type-from-path} PATH
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>SHADER-TYPE-FROM-PATH function}@c
@functionsubindex{shader-type-from-path}@c
This uses the extension to return the type of the shader.
   Currently it only recognises .vert or .frag files
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {slow-query-mipmap-count} TEXTURE
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>SLOW-QUERY-MIPMAP-COUNT function}@c
@functionsubindex{slow-query-mipmap-count}@c
This is a hack, never use it in production code.@*

GL has no function for querying the number of mipmap levels@*
so what we do is get the maxiumum possible count and iterate through checking
the width to see at what point the width reaches 0 or GL throws an error.
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {spec-changed-p} SPEC OLD-SPEC
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>SPEC-CHANGED-P function}@c
@functionsubindex{spec-changed-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Function} {split-args-for-dyn-call} ARGS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>SPLIT-ARGS-FOR-DYN-CALL function}@c
@functionsubindex{split-args-for-dyn-call}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/funcall-g<dot>lisp file, , @t{core/pipelines/funcall-g.lisp}} (file)
@end table
@end deffn
@deffn {Function} {ssbo-bind-buffer-id-range} CTX ID SSBO-BINDING-POINT OFFSET SIZE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>SSBO-BIND-BUFFER-ID-RANGE function}@c
@functionsubindex{ssbo-bind-buffer-id-range}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {stage-formp} X
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>STAGE-FORMP function}@c
@functionsubindex{stage-formp}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/pipeline-validation<dot>lisp file, , @t{core/pipelines/pipeline-validation.lisp}} (file)
@end table
@end deffn
@deffn {Function} {stages-require-partial-pipeline} FUNC-SPECS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>STAGES-REQUIRE-PARTIAL-PIPELINE function}@c
@functionsubindex{stages-require-partial-pipeline}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {stateless-quad-geometry-stage} &rest ARGS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>STATELESS-QUAD-GEOMETRY-STAGE function}@c
@functionsubindex{stateless-quad-geometry-stage}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/quad-stages<dot>lisp file, , @t{core/pipelines/quad-stages.lisp}} (file)
@end table
@end deffn
@deffn {Function} {stateless-quad-vertex-stage} &rest ARGS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>STATELESS-QUAD-VERTEX-STAGE function}@c
@functionsubindex{stateless-quad-vertex-stage}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/quad-stages<dot>lisp file, , @t{core/pipelines/quad-stages.lisp}} (file)
@end table
@end deffn
@deffn {Function} {stencil-operation-enum-to-func} ENUM
@anchor{go to the CEPL<dot>STENCIL<colon><colon>STENCIL-OPERATION-ENUM-TO-FUNC function}@c
@functionsubindex{stencil-operation-enum-to-func}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>STENCIL package, , @t{cepl.stencil}}
@item Source
@ref{go to the cepl/core/stencil/stencil<dot>lisp file, , @t{core/stencil/stencil.lisp}} (file)
@end table
@end deffn
@deffn {Function} {stencil-operation-to-enum} OPERATION
@anchor{go to the CEPL<dot>STENCIL<colon><colon>STENCIL-OPERATION-TO-ENUM function}@c
@functionsubindex{stencil-operation-to-enum}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>STENCIL package, , @t{cepl.stencil}}
@item Source
@ref{go to the cepl/core/stencil/stencil<dot>lisp file, , @t{core/stencil/stencil.lisp}} (file)
@end table
@end deffn
@deffn {Function} {stencil-params-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>STENCIL-PARAMS-P function}@c
@functionsubindex{stencil-params-p}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {stencil-test-enum-to-func} ENUM
@anchor{go to the CEPL<dot>STENCIL<colon><colon>STENCIL-TEST-ENUM-TO-FUNC function}@c
@functionsubindex{stencil-test-enum-to-func}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>STENCIL package, , @t{cepl.stencil}}
@item Source
@ref{go to the cepl/core/stencil/stencil<dot>lisp file, , @t{core/stencil/stencil.lisp}} (file)
@end table
@end deffn
@deffn {Function} {stencil-test-to-enum} TEST
@anchor{go to the CEPL<dot>STENCIL<colon><colon>STENCIL-TEST-TO-ENUM function}@c
@functionsubindex{stencil-test-to-enum}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>STENCIL package, , @t{cepl.stencil}}
@item Source
@ref{go to the cepl/core/stencil/stencil<dot>lisp file, , @t{core/stencil/stencil.lisp}} (file)
@end table
@end deffn
@deffn {Function} {suitable-array-for-index-p} ARRAY
@anchor{go to the CEPL<dot>VAOS<colon><colon>SUITABLE-ARRAY-FOR-INDEX-P function}@c
@functionsubindex{suitable-array-for-index-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>VAOS package, , @t{cepl.vaos}}
@item Source
@ref{go to the cepl/core/vaos/vaos<dot>lisp file, , @t{core/vaos/vaos.lisp}} (file)
@end table
@end deffn
@deffn {Function} {surface-dimensions} SURFACE
@anchor{go to the CEPL<dot>INTERNALS<colon><colon>SURFACE-DIMENSIONS function}@c
@functionsubindex{surface-dimensions}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>INTERNALS package, , @t{cepl.internals}}
@item Source
@ref{go to the cepl/core/internals<dot>lisp file, , @t{core/internals.lisp}} (file)
@end table
@end deffn
@deffn {Function} {surface-resolution} SURFACE
@anchor{go to the CEPL<dot>INTERNALS<colon><colon>SURFACE-RESOLUTION function}@c
@functionsubindex{surface-resolution}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>INTERNALS package, , @t{cepl.internals}}
@item Source
@ref{go to the cepl/core/internals<dot>lisp file, , @t{core/internals.lisp}} (file)
@end table
@end deffn
@deffn {Function} {suspended-p} ()
@anchor{go to the CEPL<dot>LIFECYCLE<colon><colon>SUSPENDED-P function}@c
@functionsubindex{suspended-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>LIFECYCLE package, , @t{cepl.lifecycle}}
@item Source
@ref{go to the cepl/core/lifecycle<dot>lisp file, , @t{core/lifecycle.lisp}} (file)
@end table
@end deffn
@deffn {Function} {swap-versions} STAGE-PAIRS GLSL-VERSION
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>SWAP-VERSIONS function}@c
@functionsubindex{swap-versions}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {(setf tex-compare)} VALUE TEXTURE
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>(SETF TEX-COMPARE) function}@c
@functionsubindex{(setf tex-compare)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/texture-samplers<dot>lisp file, , @t{core/textures/texture-samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {tex-kind->cache-index} KIND
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>TEX-KIND->CACHE-INDEX function}@c
@functionsubindex{tex-kind->cache-index}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {(setf tex-lod-bias)} VALUE TEXTURE
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>(SETF TEX-LOD-BIAS) function}@c
@functionsubindex{(setf tex-lod-bias)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/texture-samplers<dot>lisp file, , @t{core/textures/texture-samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {(setf tex-magnify-filter)} VALUE TEXTURE
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>(SETF TEX-MAGNIFY-FILTER) function}@c
@functionsubindex{(setf tex-magnify-filter)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/texture-samplers<dot>lisp file, , @t{core/textures/texture-samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {(setf tex-max-lod)} VALUE TEXTURE
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>(SETF TEX-MAX-LOD) function}@c
@functionsubindex{(setf tex-max-lod)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/texture-samplers<dot>lisp file, , @t{core/textures/texture-samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {(setf tex-min-lod)} VALUE TEXTURE
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>(SETF TEX-MIN-LOD) function}@c
@functionsubindex{(setf tex-min-lod)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/texture-samplers<dot>lisp file, , @t{core/textures/texture-samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {(setf tex-minify-filter)} VALUE TEXTURE
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>(SETF TEX-MINIFY-FILTER) function}@c
@functionsubindex{(setf tex-minify-filter)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/texture-samplers<dot>lisp file, , @t{core/textures/texture-samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {tex-storage-1d} TARGET LEVELS IMAGE-FORMAT WIDTH
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>TEX-STORAGE-1D function}@c
@functionsubindex{tex-storage-1d}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {tex-storage-2d} TARGET LEVELS IMAGE-FORMAT WIDTH HEIGHT
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>TEX-STORAGE-2D function}@c
@functionsubindex{tex-storage-2d}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {tex-storage-2d-multisample} TARGET IMAGE-FORMAT WIDTH HEIGHT SAMPLES FIXED-SAMPLE-LOCATIONS
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>TEX-STORAGE-2D-MULTISAMPLE function}@c
@functionsubindex{tex-storage-2d-multisample}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {tex-storage-3d} TARGET LEVELS IMAGE-FORMAT WIDTH HEIGHT DEPTH
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>TEX-STORAGE-3D function}@c
@functionsubindex{tex-storage-3d}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {tex-storage-3d-multisample} TARGET IMAGE-FORMAT WIDTH HEIGHT DEPTH SAMPLES FIXED-SAMPLE-LOCATIONS
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>TEX-STORAGE-3D-MULTISAMPLE function}@c
@functionsubindex{tex-storage-3d-multisample}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {(setf tex-wrap)} VALUE TEXTURE
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>(SETF TEX-WRAP) function}@c
@functionsubindex{(setf tex-wrap)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/texture-samplers<dot>lisp file, , @t{core/textures/texture-samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {time-elapsed-query-active-p} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TIME-ELAPSED-QUERY-ACTIVE-P function}@c
@functionsubindex{time-elapsed-query-active-p}@c
@deffnx {Function} {(setf time-elapsed-query-active-p)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF TIME-ELAPSED-QUERY-ACTIVE-P) function}@c
@functionsubindex{(setf time-elapsed-query-active-p)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {time-elapsed-query-cache-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TIME-ELAPSED-QUERY-CACHE-ID function}@c
@functionsubindex{time-elapsed-query-cache-id}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {time-elapsed-query-enum} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TIME-ELAPSED-QUERY-ENUM function}@c
@functionsubindex{time-elapsed-query-enum}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {time-elapsed-query-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TIME-ELAPSED-QUERY-ID function}@c
@functionsubindex{time-elapsed-query-id}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {time-elapsed-query-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TIME-ELAPSED-QUERY-P function}@c
@functionsubindex{time-elapsed-query-p}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {timestamp-query-cache-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TIMESTAMP-QUERY-CACHE-ID function}@c
@functionsubindex{timestamp-query-cache-id}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {timestamp-query-enum} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TIMESTAMP-QUERY-ENUM function}@c
@functionsubindex{timestamp-query-enum}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {timestamp-query-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TIMESTAMP-QUERY-ID function}@c
@functionsubindex{timestamp-query-id}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {timestamp-query-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TIMESTAMP-QUERY-P function}@c
@functionsubindex{timestamp-query-p}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {to-active} TARGET-STATE
@anchor{go to the CEPL<dot>LIFECYCLE<colon><colon>TO-ACTIVE function}@c
@functionsubindex{to-active}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>LIFECYCLE package, , @t{cepl.lifecycle}}
@item Source
@ref{go to the cepl/core/lifecycle<dot>lisp file, , @t{core/lifecycle.lisp}} (file)
@end table
@end deffn
@deffn {Function} {to-cepl-type-spec} SPEC
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>TO-CEPL-TYPE-SPEC function}@c
@functionsubindex{to-cepl-type-spec}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/funcall-g<dot>lisp file, , @t{core/pipelines/funcall-g.lisp}} (file)
@end table
@end deffn
@deffn {Function} {to-shutting-down} ()
@anchor{go to the CEPL<dot>LIFECYCLE<colon><colon>TO-SHUTTING-DOWN function}@c
@functionsubindex{to-shutting-down}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>LIFECYCLE package, , @t{cepl.lifecycle}}
@item Source
@ref{go to the cepl/core/lifecycle<dot>lisp file, , @t{core/lifecycle.lisp}} (file)
@end table
@end deffn
@deffn {Function} {to-suspended} TARGET-STATE
@anchor{go to the CEPL<dot>LIFECYCLE<colon><colon>TO-SUSPENDED function}@c
@functionsubindex{to-suspended}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>LIFECYCLE package, , @t{cepl.lifecycle}}
@item Source
@ref{go to the cepl/core/lifecycle<dot>lisp file, , @t{core/lifecycle.lisp}} (file)
@end table
@end deffn
@deffn {Function} {transform-feedback-bind-buffer-id-range} CTX ID TFB-BINDING-POINT OFFSET SIZE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>TRANSFORM-FEEDBACK-BIND-BUFFER-ID-RANGE function}@c
@functionsubindex{transform-feedback-bind-buffer-id-range}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {transform-feedback-primitives-written-query-active-p} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TRANSFORM-FEEDBACK-PRIMITIVES-WRITTEN-QUERY-ACTIVE-P function}@c
@functionsubindex{transform-feedback-primitives-written-query-active-p}@c
@deffnx {Function} {(setf transform-feedback-primitives-written-query-active-p)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF TRANSFORM-FEEDBACK-PRIMITIVES-WRITTEN-QUERY-ACTIVE-P) function}@c
@functionsubindex{(setf transform-feedback-primitives-written-query-active-p)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {transform-feedback-primitives-written-query-cache-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TRANSFORM-FEEDBACK-PRIMITIVES-WRITTEN-QUERY-CACHE-ID function}@c
@functionsubindex{transform-feedback-primitives-written-query-cache-id}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {transform-feedback-primitives-written-query-enum} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TRANSFORM-FEEDBACK-PRIMITIVES-WRITTEN-QUERY-ENUM function}@c
@functionsubindex{transform-feedback-primitives-written-query-enum}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {transform-feedback-primitives-written-query-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TRANSFORM-FEEDBACK-PRIMITIVES-WRITTEN-QUERY-ID function}@c
@functionsubindex{transform-feedback-primitives-written-query-id}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {transform-feedback-primitives-written-query-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TRANSFORM-FEEDBACK-PRIMITIVES-WRITTEN-QUERY-P function}@c
@functionsubindex{transform-feedback-primitives-written-query-p}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {transform-feedback-stream-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TRANSFORM-FEEDBACK-STREAM-P function}@c
@functionsubindex{transform-feedback-stream-p}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {try-guessing-a-varjo-type-for-symbol} S
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>TRY-GUESSING-A-VARJO-TYPE-FOR-SYMBOL function}@c
@functionsubindex{try-guessing-a-varjo-type-for-symbol}@c
This function is provided to varjo to allow inference of the
   types of implicit uniforms.
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {try-injecting-a-constant} CONSTANT-NAME
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>TRY-INJECTING-A-CONSTANT function}@c
@functionsubindex{try-injecting-a-constant}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {type-contains-structs} TYPE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>TYPE-CONTAINS-STRUCTS function}@c
@functionsubindex{type-contains-structs}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/glsl-stages<dot>lisp file, , @t{core/pipelines/glsl-stages.lisp}} (file)
@end table
@end deffn
@deffn {Function} {typed-defp} X
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>TYPED-DEFP function}@c
@functionsubindex{typed-defp}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/pipeline-validation<dot>lisp file, , @t{core/pipelines/pipeline-validation.lisp}} (file)
@end table
@end deffn
@deffn {Function} {ubo-bind-buffer-id-range} CTX ID UBO-BINDING-POINT OFFSET SIZE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>UBO-BIND-BUFFER-ID-RANGE function}@c
@functionsubindex{ubo-bind-buffer-id-range}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uidx-int} INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>UIDX-INT function}@c
@functionsubindex{uidx-int}@c
@deffnx {Function} {(setf uidx-int)} VALUE INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF UIDX-INT) function}@c
@functionsubindex{(setf uidx-int)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uidx-p} OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>UIDX-P function}@c
@functionsubindex{uidx-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uidx-uint} INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>UIDX-UINT function}@c
@functionsubindex{uidx-uint}@c
@deffnx {Function} {(setf uidx-uint)} VALUE INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF UIDX-UINT) function}@c
@functionsubindex{(setf uidx-uint)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Function} {unbind-texture-from-scratch} ()
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>UNBIND-TEXTURE-FROM-SCRATCH function}@c
@functionsubindex{unbind-texture-from-scratch}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/def<dot>lisp file, , @t{core/textures/def.lisp}} (file)
@end table
@end deffn
@deffn {Function} {unbound-cepl-context-consumed} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>UNBOUND-CEPL-CONTEXT-CONSUMED function}@c
@functionsubindex{unbound-cepl-context-consumed}@c
@deffnx {Function} {(setf unbound-cepl-context-consumed)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF UNBOUND-CEPL-CONTEXT-CONSUMED) function}@c
@functionsubindex{(setf unbound-cepl-context-consumed)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {unbound-cepl-context-gl-context} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>UNBOUND-CEPL-CONTEXT-GL-CONTEXT function}@c
@functionsubindex{unbound-cepl-context-gl-context}@c
@deffnx {Function} {(setf unbound-cepl-context-gl-context)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF UNBOUND-CEPL-CONTEXT-GL-CONTEXT) function}@c
@functionsubindex{(setf unbound-cepl-context-gl-context)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {unbound-cepl-context-p} OBJECT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>UNBOUND-CEPL-CONTEXT-P function}@c
@functionsubindex{unbound-cepl-context-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {unbound-cepl-context-requested-gl-version} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>UNBOUND-CEPL-CONTEXT-REQUESTED-GL-VERSION function}@c
@functionsubindex{unbound-cepl-context-requested-gl-version}@c
@deffnx {Function} {(setf unbound-cepl-context-requested-gl-version)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF UNBOUND-CEPL-CONTEXT-REQUESTED-GL-VERSION) function}@c
@functionsubindex{(setf unbound-cepl-context-requested-gl-version)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {unbound-cepl-context-shared} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>UNBOUND-CEPL-CONTEXT-SHARED function}@c
@functionsubindex{unbound-cepl-context-shared}@c
@deffnx {Function} {(setf unbound-cepl-context-shared)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF UNBOUND-CEPL-CONTEXT-SHARED) function}@c
@functionsubindex{(setf unbound-cepl-context-shared)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {unbound-cepl-context-surface} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>UNBOUND-CEPL-CONTEXT-SURFACE function}@c
@functionsubindex{unbound-cepl-context-surface}@c
@deffnx {Function} {(setf unbound-cepl-context-surface)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF UNBOUND-CEPL-CONTEXT-SURFACE) function}@c
@functionsubindex{(setf unbound-cepl-context-surface)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {unbound-cepl-context-surfaces} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>UNBOUND-CEPL-CONTEXT-SURFACES function}@c
@functionsubindex{unbound-cepl-context-surfaces}@c
@deffnx {Function} {(setf unbound-cepl-context-surfaces)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF UNBOUND-CEPL-CONTEXT-SURFACES) function}@c
@functionsubindex{(setf unbound-cepl-context-surfaces)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uniform-1b} ()
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>UNIFORM-1B function}@c
@functionsubindex{uniform-1b}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniforms<dot>lisp file, , @t{core/pipelines/uniforms.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uniform-1f} ()
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>UNIFORM-1F function}@c
@functionsubindex{uniform-1f}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniforms<dot>lisp file, , @t{core/pipelines/uniforms.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uniform-1i} ()
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>UNIFORM-1I function}@c
@functionsubindex{uniform-1i}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniforms<dot>lisp file, , @t{core/pipelines/uniforms.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uniform-2f} ()
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>UNIFORM-2F function}@c
@functionsubindex{uniform-2f}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniforms<dot>lisp file, , @t{core/pipelines/uniforms.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uniform-2i} ()
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>UNIFORM-2I function}@c
@functionsubindex{uniform-2i}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniforms<dot>lisp file, , @t{core/pipelines/uniforms.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uniform-3f} ()
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>UNIFORM-3F function}@c
@functionsubindex{uniform-3f}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniforms<dot>lisp file, , @t{core/pipelines/uniforms.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uniform-3i} ()
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>UNIFORM-3I function}@c
@functionsubindex{uniform-3i}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniforms<dot>lisp file, , @t{core/pipelines/uniforms.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uniform-4f} ()
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>UNIFORM-4F function}@c
@functionsubindex{uniform-4f}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniforms<dot>lisp file, , @t{core/pipelines/uniforms.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uniform-4i} ()
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>UNIFORM-4I function}@c
@functionsubindex{uniform-4i}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniforms<dot>lisp file, , @t{core/pipelines/uniforms.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uniform-matrix-2ft} ()
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>UNIFORM-MATRIX-2FT function}@c
@functionsubindex{uniform-matrix-2ft}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniforms<dot>lisp file, , @t{core/pipelines/uniforms.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uniform-matrix-2fvt} LOCATION COUNT PTR
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>UNIFORM-MATRIX-2FVT function}@c
@functionsubindex{uniform-matrix-2fvt}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniforms<dot>lisp file, , @t{core/pipelines/uniforms.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uniform-matrix-3ft} ()
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>UNIFORM-MATRIX-3FT function}@c
@functionsubindex{uniform-matrix-3ft}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniforms<dot>lisp file, , @t{core/pipelines/uniforms.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uniform-matrix-3fvt} LOCATION COUNT PTR
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>UNIFORM-MATRIX-3FVT function}@c
@functionsubindex{uniform-matrix-3fvt}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniforms<dot>lisp file, , @t{core/pipelines/uniforms.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uniform-matrix-4ft} ()
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>UNIFORM-MATRIX-4FT function}@c
@functionsubindex{uniform-matrix-4ft}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniforms<dot>lisp file, , @t{core/pipelines/uniforms.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uniform-matrix-4fvt} LOCATION COUNT PTR
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>UNIFORM-MATRIX-4FVT function}@c
@functionsubindex{uniform-matrix-4fvt}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniforms<dot>lisp file, , @t{core/pipelines/uniforms.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uniform-sampler} ()
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>UNIFORM-SAMPLER function}@c
@functionsubindex{uniform-sampler}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniforms<dot>lisp file, , @t{core/pipelines/uniforms.lisp}} (file)
@end table
@end deffn
@deffn {Function} {update-clear-mask} FBO
@anchor{go to the CEPL<dot>FBOS<colon><colon>UPDATE-CLEAR-MASK function}@c
@functionsubindex{update-clear-mask}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {update-data} DATA TYPE
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>UPDATE-DATA function}@c
@functionsubindex{update-data}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/make<dot>lisp file, , @t{core/c-arrays/make.lisp}} (file)
@end table
@end deffn
@deffn {Function} {update-draw-buffer-map} FBO
@anchor{go to the CEPL<dot>FBOS<colon><colon>UPDATE-DRAW-BUFFER-MAP function}@c
@functionsubindex{update-draw-buffer-map}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {update-pipeline-spec} SPEC
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>UPDATE-PIPELINE-SPEC function}@c
@functionsubindex{update-pipeline-spec}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Function} {update-specs-with-missing-dependencies} ()
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>UPDATE-SPECS-WITH-MISSING-DEPENDENCIES function}@c
@functionsubindex{update-specs-with-missing-dependencies}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Function} {upload-c-array-to-gpu-array-t} GPU-ARRAY C-ARRAY &optional PIXEL-FORMAT
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>UPLOAD-C-ARRAY-TO-GPU-ARRAY-T function}@c
@functionsubindex{upload-c-array-to-gpu-array-t}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {upload-gpu-array-bb-to-gpu-array-t} GPU-ARRAY-T GPU-ARRAY-BB &optional PIXEL-FORMAT
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>UPLOAD-GPU-ARRAY-BB-TO-GPU-ARRAY-T function}@c
@functionsubindex{upload-gpu-array-bb-to-gpu-array-t}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {use-program} CTX PROGRAM-ID
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>USE-PROGRAM function}@c
@functionsubindex{use-program}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/programs<dot>lisp file, , @t{core/pipelines/programs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {valid-index-p} TEXTURE MIPMAP-LEVEL LAYER CUBE-FACE
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>VALID-INDEX-P function}@c
@functionsubindex{valid-index-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {valid-pixel-format-p} COMPONENTS TYPE NORMALIZE REVERSED
@anchor{go to the CEPL<dot>PIXEL-FORMATS<colon><colon>VALID-PIXEL-FORMAT-P function}@c
@functionsubindex{valid-pixel-format-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIXEL-FORMATS package, , @t{cepl.pixel-formats}}
@item Source
@ref{go to the cepl/core/types/pixel-format<dot>lisp file, , @t{core/types/pixel-format.lisp}} (file)
@end table
@end deffn
@deffn {Function} {validate-defstruct-g-form} NAME SLOTS
@anchor{go to the CEPL<dot>TYPES<colon><colon>VALIDATE-DEFSTRUCT-G-FORM function}@c
@functionsubindex{validate-defstruct-g-form}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {validate-dimensions} DATA DIMENSIONS STRUCT-ELEM-TYPE-P
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>VALIDATE-DIMENSIONS function}@c
@functionsubindex{validate-dimensions}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/populate<dot>lisp file, , @t{core/c-arrays/populate.lisp}} (file)
@end table
@end deffn
@deffn {Function} {validate-pixel-format} INITIAL-CONTENTS PIXEL-FORMAT
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>VALIDATE-PIXEL-FORMAT function}@c
@functionsubindex{validate-pixel-format}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {validate-stage-names} NAMES
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>VALIDATE-STAGE-NAMES function}@c
@functionsubindex{validate-stage-names}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {validate-varjo-type-spec} SPEC
@anchor{go to the CEPL<dot>TYPES<colon><colon>VALIDATE-VARJO-TYPE-SPEC function}@c
@functionsubindex{validate-varjo-type-spec}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {varjo->gl-stage-names} STAGE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>VARJO->GL-STAGE-NAMES function}@c
@functionsubindex{varjo->gl-stage-names}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Function} {viewport-for-array} ARR
@anchor{go to the CEPL<dot>FBOS<colon><colon>VIEWPORT-FOR-ARRAY function}@c
@functionsubindex{viewport-for-array}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {vs-spliced-values} ENV THIS &rest SARGS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>VS-SPLICED-VALUES function}@c
@functionsubindex{vs-spliced-values}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/funcall-g<dot>lisp file, , @t{core/pipelines/funcall-g.lisp}} (file)
@end table
@end deffn
@deffn {Function} {with-setf-internals} ENV PLACES VALUES
@anchor{go to the CEPL-UTILS<colon><colon>WITH-SETF-INTERNALS function}@c
@functionsubindex{with-setf-internals}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {wrap-allowing-recompilation} PIPELINE LAMBDA-PIPELINE-SPEC GPIPE-ARGS COMPILE-CONTEXT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>WRAP-ALLOWING-RECOMPILATION function}@c
@functionsubindex{wrap-allowing-recompilation}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-lambda<dot>lisp file, , @t{core/pipelines/gpu-lambda.lisp}} (file)
@end table
@end deffn
@deffn {Function} {wrap-eq} WRAP-A WRAP-B
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>WRAP-EQ function}@c
@functionsubindex{wrap-eq}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {xsymbolp} X
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>XSYMBOLP function}@c
@functionsubindex{xsymbolp}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/pipeline-validation<dot>lisp file, , @t{core/pipelines/pipeline-validation.lisp}} (file)
@end table
@end deffn
" :AFTER-MENU-CONTENTS NIL) #20# #21# #22#) :BEFORE-MENU-CONTENTS NIL :AFTER-MENU-CONTENTS NIL) #S(NET.DIDIERVERNA.DECLT::CONTEXT :SYSTEMS (#<ASDF/SYSTEM:SYSTEM "cepl"> #<ASDF/SYSTEM:SYSTEM "cepl.build">) :PACKAGES (#<PACKAGE "CEPL"> #<PACKAGE "CEPL.PIPELINES"> #<PACKAGE "CEPL.COMPUTE"> #<PACKAGE "CEPL.QUERIES"> #<PACKAGE "CEPL.SYNC"> #<PACKAGE "CEPL.TRANSFORM-FEEDBACK"> #<PACKAGE "CEPL.SCISSOR"> #<PACKAGE "CEPL.STENCIL"> #<PACKAGE "CEPL.BLENDING"> #<PACKAGE "CEPL.FBOS"> #<PACKAGE "CEPL.RENDER-BUFFERS"> #<PACKAGE "CEPL.SAMPLERS"> ...) :EXTERNAL-DEFINITIONS #<HASH-TABLE :TEST EQUAL :COUNT 923 {100C2282E3}> :INTERNAL-DEFINITIONS #<HASH-TABLE :TEST EQUAL :COUNT 1067 {100CA00BE3}> :HYPERLINKSP NIL) "internal" "classes" (#S(NET.DIDIERVERNA.DECLT::CLASS-DEFINITION :SYMBOL CEPL.PIPELINES::CEPL.PIPELINES.ARRAYS-INDIRECT-COMMAND.FOREIGN-TCLASS :FOREIGNP NIL :PARENTS (#S(NET.DIDIERVERNA.DECLT::CLASS-DEFINITION :SYMBOL CFFI::TRANSLATABLE-FOREIGN-TYPE :FOREIGNP T :PARENTS NIL :CHILDREN NIL :METHODS NIL :SLOTS NIL) #S(NET.DIDIERVERNA.DECLT::CLASS-DEFINITION :SYMBOL CFFI::FOREIGN-STRUCT-TYPE :FOREIGNP T :PARENTS NIL :CHILDREN NIL :METHODS NIL :SLOTS NIL)) :CHILDREN NIL :METHODS NIL :SLOTS NIL) #S(NET.DIDIERVERNA.DECLT::CLASS-DEFINITION :SYMBOL CEPL.HIDDEN::CEPL.PIPELINES.ELEMENTS-INDIRECT-COMMAND.CFFI-CT-TYPE :FOREIGNP NIL :PARENTS (#S(NET.DIDIERVERNA.DECLT::CLASS-DEFINITION :SYMBOL CFFI::ENHANCED-FOREIGN-TYPE :FOREIGNP T :PARENTS NIL :CHILDREN NIL :METHODS NIL :SLOTS NIL)) :CHILDREN NIL :METHODS (#S(NET.DIDIERVERNA.DECLT::METHOD-DEFINITION :SYMBOL CFFI:EXPAND-FROM-FOREIGN :FOREIGNP T :METHOD NIL) #S(NET.DIDIERVERNA.DECLT::METHOD-DEFINITION :SYMBOL CFFI:TRANSLATE-FROM-FOREIGN :FOREIGNP T :METHOD NIL)) :SLOTS NIL) #S(NET.DIDIERVERNA.DECLT::CLASS-DEFINITION :SYMBOL CEPL.PIPELINES::CEPL.PIPELINES.ELEMENTS-INDIRECT-COMMAND.FOREIGN-TCLASS :FOREIGNP NIL :PARENTS (#S(NET.DIDIERVERNA.DECLT::CLASS-DEFINITION :SYMBOL CFFI::TRANSLATABLE-FOREIGN-TYPE :FOREIGNP T :PARENTS NIL :CHILDREN NIL :METHODS NIL :SLOTS NIL) #S(NET.DIDIERVERNA.DECLT::CLASS-DEFINITION :SYMBOL CFFI::FOREIGN-STRUCT-TYPE :FOREIGNP T :PARENTS NIL :CHILDREN NIL :METHODS NIL :SLOTS NIL)) :CHILDREN NIL :METHODS NIL :SLOTS NIL) #S(NET.DIDIERVERNA.DECLT::CLASS-DEFINITION :SYMBOL CEPL.HIDDEN::CEPL.TYPES.PREDEFINED.G-PC.CFFI-CT-TYPE :FOREIGNP NIL :PARENTS (#S(NET.DIDIERVERNA.DECLT::CLASS-DEFINITION :SYMBOL CFFI::ENHANCED-FOREIGN-TYPE :FOREIGNP T :PARENTS NIL :CHILDREN NIL :METHODS NIL :SLOTS NIL)) :CHILDREN NIL :METHODS (#S(NET.DIDIERVERNA.DECLT::METHOD-DEFINITION :SYMBOL CFFI:EXPAND-FROM-FOREIGN :FOREIGNP T :METHOD NIL) #S(NET.DIDIERVERNA.DECLT::METHOD-DEFINITION :SYMBOL CFFI:TRANSLATE-FROM-FOREIGN :FOREIGNP T :METHOD NIL)) :SLOTS NIL) #S(NET.DIDIERVERNA.DECLT::CLASS-DEFINITION :SYMBOL CEPL.TYPES.PREDEFINED::CEPL.TYPES.PREDEFINED.G-PC.FOREIGN-TCLASS :FOREIGNP NIL :PARENTS (#S(NET.DIDIERVERNA.DECLT::CLASS-DEFINITION :SYMBOL CFFI::TRANSLATABLE-FOREIGN-TYPE :FOREIGNP T :PARENTS NIL :CHILDREN NIL :METHODS NIL :SLOTS NIL) #S(NET.DIDIERVERNA.DECLT::CLASS-DEFINITION :SYMBOL CFFI::FOREIGN-STRUCT-TYPE :FOREIGNP T :PARENTS NIL :CHILDREN NIL :METHODS NIL :SLOTS NIL)) :CHILDREN NIL :METHODS NIL :SLOTS NIL) #S(NET.DIDIERVERNA.DECLT::CLASS-DEFINITION :SYMBOL CEPL.HIDDEN::CEPL.TYPES.PREDEFINED.G-PN.CFFI-CT-TYPE :FOREIGNP NIL :PARENTS (#S(NET.DIDIERVERNA.DECLT::CLASS-DEFINITION :SYMBOL CFFI::ENHANCED-FOREIGN-TYPE :FOREIGNP T :PARENTS NIL :CHILDREN NIL :METHODS NIL :SLOTS NIL)) :CHILDREN NIL :METHODS (#S(NET.DIDIERVERNA.DECLT::METHOD-DEFINITION :SYMBOL CFFI:EXPAND-FROM-FOREIGN :FOREIGNP T :METHOD NIL) #S(NET.DIDIERVERNA.DECLT::METHOD-DEFINITION :SYMBOL CFFI:TRANSLATE-FROM-FOREIGN :FOREIGNP T :METHOD NIL)) :SLOTS NIL) #S(NET.DIDIERVERNA.DECLT::CLASS-DEFINITION :SYMBOL CEPL.TYPES.PREDEFINED::CEPL.TYPES.PREDEFINED.G-PN.FOREIGN-TCLASS :FOREIGNP NIL :PARENTS (#S(NET.DIDIERVERNA.DECLT::CLASS-DEFINITION :SYMBOL CFFI::TRANSLATABLE-FOREIGN-TYPE :FOREIGNP T :PARENTS NIL :CHILDREN NIL :METHODS NIL :SLOTS NIL) #S(NET.DIDIERVERNA.DECLT::CLASS-DEFINITION :SYMBOL CFFI::FOREIGN-STRUCT-TYPE :FOREIGNP T :PARENTS NIL :CHILDREN NIL :METHODS NIL :SLOTS NIL)) :CHILDREN NIL :METHODS NIL :SLOTS NIL) #S(NET.DIDIERVERNA.DECLT::CLASS-DEFINITION :SYMBOL CEPL.HIDDEN::CEPL.TYPES.PREDEFINED.G-PNB.CFFI-CT-TYPE :FOREIGNP NIL :PARENTS (#S(NET.DIDIERVERNA.DECLT::CLASS-DEFINITION :SYMBOL CFFI::ENHANCED-FOREIGN-TYPE :FOREIGNP T :PARENTS NIL :CHILDREN NIL :METHODS NIL :SLOTS NIL)) :CHILDREN NIL :METHODS (#S(NET.DIDIERVERNA.DECLT::METHOD-DEFINITION :SYMBOL CFFI:EXPAND-FROM-FOREIGN :FOREIGNP T :METHOD NIL) #S(NET.DIDIERVERNA.DECLT::METHOD-DEFINITION :SYMBOL CFFI:TRANSLATE-FROM-FOREIGN :FOREIGNP T :METHOD NIL)) :SLOTS NIL) #S(NET.DIDIERVERNA.DECLT::CLASS-DEFINITION :SYMBOL CEPL.TYPES.PREDEFINED::CEPL.TYPES.PREDEFINED.G-PNB.FOREIGN-TCLASS :FOREIGNP NIL :PARENTS (#S(NET.DIDIERVERNA.DECLT::CLASS-DEFINITION :SYMBOL CFFI::TRANSLATABLE-FOREIGN-TYPE :FOREIGNP T :PARENTS NIL :CHILDREN NIL :METHODS NIL :SLOTS NIL) #S(NET.DIDIERVERNA.DECLT::CLASS-DEFINITION :SYMBOL CFFI::FOREIGN-STRUCT-TYPE :FOREIGNP T :PARENTS NIL :CHILDREN NIL :METHODS NIL :SLOTS NIL)) :CHILDREN NIL :METHODS NIL :SLOTS NIL) #S(NET.DIDIERVERNA.DECLT::CLASS-DEFINITION :SYMBOL CEPL.HIDDEN::CEPL.TYPES.PREDEFINED.G-PNC.CFFI-CT-TYPE :FOREIGNP NIL :PARENTS (#S(NET.DIDIERVERNA.DECLT::CLASS-DEFINITION :SYMBOL CFFI::ENHANCED-FOREIGN-TYPE :FOREIGNP T :PARENTS NIL :CHILDREN NIL :METHODS NIL :SLOTS NIL)) :CHILDREN NIL :METHODS (#S(NET.DIDIERVERNA.DECLT::METHOD-DEFINITION :SYMBOL CFFI:EXPAND-FROM-FOREIGN :FOREIGNP T :METHOD NIL) #S(NET.DIDIERVERNA.DECLT::METHOD-DEFINITION :SYMBOL CFFI:TRANSLATE-FROM-FOREIGN :FOREIGNP T :METHOD NIL)) :SLOTS NIL) #S(NET.DIDIERVERNA.DECLT::CLASS-DEFINITION :SYMBOL CEPL.TYPES.PREDEFINED::CEPL.TYPES.PREDEFINED.G-PNC.FOREIGN-TCLASS :FOREIGNP NIL :PARENTS (#S(NET.DIDIERVERNA.DECLT::CLASS-DEFINITION :SYMBOL CFFI::TRANSLATABLE-FOREIGN-TYPE :FOREIGNP T :PARENTS NIL :CHILDREN NIL :METHODS NIL :SLOTS NIL) #S(NET.DIDIERVERNA.DECLT::CLASS-DEFINITION :SYMBOL CFFI::FOREIGN-STRUCT-TYPE :FOREIGNP T :PARENTS NIL :CHILDREN NIL :METHODS NIL :SLOTS NIL)) :CHILDREN NIL :METHODS NIL :SLOTS NIL) #S(NET.DIDIERVERNA.DECLT::CLASS-DEFINITION :SYMBOL CEPL.HIDDEN::CEPL.TYPES.PREDEFINED.G-PNCB.CFFI-CT-TYPE :FOREIGNP NIL :PARENTS (#S(NET.DIDIERVERNA.DECLT::CLASS-DEFINITION :SYMBOL CFFI::ENHANCED-FOREIGN-TYPE :FOREIGNP T :PARENTS NIL :CHILDREN NIL :METHODS NIL :SLOTS NIL)) :CHILDREN NIL :METHODS (#S(NET.DIDIERVERNA.DECLT::METHOD-DEFINITION :SYMBOL CFFI:EXPAND-FROM-FOREIGN :FOREIGNP T :METHOD NIL) #S(NET.DIDIERVERNA.DECLT::METHOD-DEFINITION :SYMBOL CFFI:TRANSLATE-FROM-FOREIGN :FOREIGNP T :METHOD NIL)) :SLOTS NIL) ...))
20: (NET.DIDIERVERNA.DECLT::ADD-CATEGORIES-NODE #1=#S(NET.DIDIERVERNA.DECLT::NODE :NAME "Internal definitions" :SYNOPSIS NIL :SECTION-TYPE :NUMBERED :SECTION-NAME NIL :NEXT NIL :PREVIOUS #2=#S(NET.DIDIERVERNA.DECLT::NODE :NAME "Exported definitions" :SYNOPSIS NIL :SECTION-TYPE :NUMBERED :SECTION-NAME NIL :NEXT #1# :PREVIOUS NIL :UP #3=#S(NET.DIDIERVERNA.DECLT::NODE :NAME "Definitions" :SYNOPSIS "The symbols documentation" :SECTION-TYPE :NUMBERED :SECTION-NAME NIL :NEXT NIL :PREVIOUS #4=#S(NET.DIDIERVERNA.DECLT::NODE :NAME "Packages" :SYNOPSIS "The packages documentation" :SECTION-TYPE :NUMBERED :SECTION-NAME NIL :NEXT #3# :PREVIOUS #S(NET.DIDIERVERNA.DECLT::NODE :NAME "Files" :SYNOPSIS "The files documentation" :SECTION-TYPE :NUMBERED :SECTION-NAME NIL :NEXT #4# :PREVIOUS # :UP #5=# :CHILDREN # :BEFORE-MENU-CONTENTS "Files are sorted by type and then listed depth-first from the systems
components trees." :AFTER-MENU-CONTENTS NIL) :UP #5# :CHILDREN (# # # # # # # # # # # # ...) :BEFORE-MENU-CONTENTS "Packages are listed by definition order." :AFTER-MENU-CONTENTS NIL) :UP #5# :CHILDREN (#2# #1#) :BEFORE-MENU-CONTENTS "Definitions are sorted by export status, category, package, and then by
lexicographic order." :AFTER-MENU-CONTENTS NIL) :CHILDREN (#6=#S(NET.DIDIERVERNA.DECLT::NODE :NAME "Exported constants" :SYNOPSIS NIL :SECTION-TYPE :NUMBERED :SECTION-NAME "Constants" :NEXT #7=#S(NET.DIDIERVERNA.DECLT::NODE :NAME "Exported special variables" :SYNOPSIS NIL :SECTION-TYPE :NUMBERED :SECTION-NAME "Special variables" :NEXT #8=# :PREVIOUS #6# :UP #2# :CHILDREN NIL :BEFORE-MENU-CONTENTS "@defvr {Special Variable} *bptc-compressed-formats*
@anchor{go to the CEPL<dot>IMAGE-FORMATS<colon><colon>*BPTC-COMPRESSED-FORMATS* special variable}@c
@specialsubindex{*bptc-compressed-formats*}@c

A list of all of OpenGL's bptc compressed formats
@table @strong
@item Package
@ref{go to the CEPL<dot>IMAGE-FORMATS package, , @t{cepl.image-formats}}
@item Source
@ref{go to the cepl/core/types/image-format<dot>lisp file, , @t{core/types/image-format.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *color-renderable-formats*
@anchor{go to the CEPL<dot>IMAGE-FORMATS<colon><colon>*COLOR-RENDERABLE-FORMATS* special variable}@c
@specialsubindex{*color-renderable-formats*}@c

A list of all of OpenGL's color renderable formats
@table @strong
@item Package
@ref{go to the CEPL<dot>IMAGE-FORMATS package, , @t{cepl.image-formats}}
@item Source
@ref{go to the cepl/core/types/image-format<dot>lisp file, , @t{core/types/image-format.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *depth-formats*
@anchor{go to the CEPL<dot>IMAGE-FORMATS<colon><colon>*DEPTH-FORMATS* special variable}@c
@specialsubindex{*depth-formats*}@c

A list of all of OpenGL's depth formats
@table @strong
@item Package
@ref{go to the CEPL<dot>IMAGE-FORMATS package, , @t{cepl.image-formats}}
@item Source
@ref{go to the cepl/core/types/image-format<dot>lisp file, , @t{core/types/image-format.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *depth-stencil-formats*
@anchor{go to the CEPL<dot>IMAGE-FORMATS<colon><colon>*DEPTH-STENCIL-FORMATS* special variable}@c
@specialsubindex{*depth-stencil-formats*}@c

A list of all of OpenGL's depth stencil formats
@table @strong
@item Package
@ref{go to the CEPL<dot>IMAGE-FORMATS package, , @t{cepl.image-formats}}
@item Source
@ref{go to the cepl/core/types/image-format<dot>lisp file, , @t{core/types/image-format.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *floating-point-formats*
@anchor{go to the CEPL<dot>IMAGE-FORMATS<colon><colon>*FLOATING-POINT-FORMATS* special variable}@c
@specialsubindex{*floating-point-formats*}@c

A list of all of OpenGL's floating point formats
@table @strong
@item Package
@ref{go to the CEPL<dot>IMAGE-FORMATS package, , @t{cepl.image-formats}}
@item Source
@ref{go to the cepl/core/types/image-format<dot>lisp file, , @t{core/types/image-format.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *image-formats*
@anchor{go to the CEPL<dot>IMAGE-FORMATS<colon><colon>*IMAGE-FORMATS* special variable}@c
@specialsubindex{*image-formats*}@c

A list of all of OpenGL's image formats
@table @strong
@item Package
@ref{go to the CEPL<dot>IMAGE-FORMATS package, , @t{cepl.image-formats}}
@item Source
@ref{go to the cepl/core/types/image-format<dot>lisp file, , @t{core/types/image-format.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *immutable-available*
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>*IMMUTABLE-AVAILABLE* special variable}@c
@specialsubindex{*immutable-available*}@c

After CEPL has been initialized this variable will hold t if immutable `texture`
storage is available and nil if not.@*

Immutable texture storage does not mean that the texture's `gpu-array` data is
immutable. It means that the underlying format of the texture data cannot be
changed. It is rare that you would want mutable storage and when you do, it is
very hard to not create 'incomplete-textures'.
https://www.opengl.org/wiki/Immutable_Storage_Texture#Texture_completeness@*

CEPL tries to make only complete textures so this is not a concern. If you do
need this level of control, please raise a github issue as I would love to
understand your usecase.
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *red/green-compressed-formats*
@anchor{go to the CEPL<dot>IMAGE-FORMATS<colon><colon>*RED/GREEN-COMPRESSED-FORMATS* special variable}@c
@specialsubindex{*red/green-compressed-formats*}@c

A list of all of OpenGL's red/green compressed formats
@table @strong
@item Package
@ref{go to the CEPL<dot>IMAGE-FORMATS package, , @t{cepl.image-formats}}
@item Source
@ref{go to the cepl/core/types/image-format<dot>lisp file, , @t{core/types/image-format.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *regular-color-formats*
@anchor{go to the CEPL<dot>IMAGE-FORMATS<colon><colon>*REGULAR-COLOR-FORMATS* special variable}@c
@specialsubindex{*regular-color-formats*}@c

A list of all of OpenGL's regular color formats
@table @strong
@item Package
@ref{go to the CEPL<dot>IMAGE-FORMATS package, , @t{cepl.image-formats}}
@item Source
@ref{go to the cepl/core/types/image-format<dot>lisp file, , @t{core/types/image-format.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *s3tc/dxt-compessed-formats*
@anchor{go to the CEPL<dot>IMAGE-FORMATS<colon><colon>*S3TC/DXT-COMPESSED-FORMATS* special variable}@c
@specialsubindex{*s3tc/dxt-compessed-formats*}@c

A list of all of OpenGL's s3tc/dxt compessed formats
@table @strong
@item Package
@ref{go to the CEPL<dot>IMAGE-FORMATS package, , @t{cepl.image-formats}}
@item Source
@ref{go to the cepl/core/types/image-format<dot>lisp file, , @t{core/types/image-format.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *signed-integral-formats*
@anchor{go to the CEPL<dot>IMAGE-FORMATS<colon><colon>*SIGNED-INTEGRAL-FORMATS* special variable}@c
@specialsubindex{*signed-integral-formats*}@c

A list of all of OpenGL's signed integral formats
@table @strong
@item Package
@ref{go to the CEPL<dot>IMAGE-FORMATS package, , @t{cepl.image-formats}}
@item Source
@ref{go to the cepl/core/types/image-format<dot>lisp file, , @t{core/types/image-format.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *signed-normalized-integer-formats*
@anchor{go to the CEPL<dot>IMAGE-FORMATS<colon><colon>*SIGNED-NORMALIZED-INTEGER-FORMATS* special variable}@c
@specialsubindex{*signed-normalized-integer-formats*}@c

A list of all of OpenGL's signed normalized integer formats
@table @strong
@item Package
@ref{go to the CEPL<dot>IMAGE-FORMATS package, , @t{cepl.image-formats}}
@item Source
@ref{go to the cepl/core/types/image-format<dot>lisp file, , @t{core/types/image-format.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *special-color-formats*
@anchor{go to the CEPL<dot>IMAGE-FORMATS<colon><colon>*SPECIAL-COLOR-FORMATS* special variable}@c
@specialsubindex{*special-color-formats*}@c

A list of all of OpenGL's special color formats
@table @strong
@item Package
@ref{go to the CEPL<dot>IMAGE-FORMATS package, , @t{cepl.image-formats}}
@item Source
@ref{go to the cepl/core/types/image-format<dot>lisp file, , @t{core/types/image-format.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *srgb-color-formats*
@anchor{go to the CEPL<dot>IMAGE-FORMATS<colon><colon>*SRGB-COLOR-FORMATS* special variable}@c
@specialsubindex{*srgb-color-formats*}@c

A list of all of OpenGL's srgb color formats
@table @strong
@item Package
@ref{go to the CEPL<dot>IMAGE-FORMATS package, , @t{cepl.image-formats}}
@item Source
@ref{go to the cepl/core/types/image-format<dot>lisp file, , @t{core/types/image-format.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *stencil-formats*
@anchor{go to the CEPL<dot>IMAGE-FORMATS<colon><colon>*STENCIL-FORMATS* special variable}@c
@specialsubindex{*stencil-formats*}@c

A list of all of OpenGL's stencil formats
@table @strong
@item Package
@ref{go to the CEPL<dot>IMAGE-FORMATS package, , @t{cepl.image-formats}}
@item Source
@ref{go to the cepl/core/types/image-format<dot>lisp file, , @t{core/types/image-format.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *unsigned-integral-formats*
@anchor{go to the CEPL<dot>IMAGE-FORMATS<colon><colon>*UNSIGNED-INTEGRAL-FORMATS* special variable}@c
@specialsubindex{*unsigned-integral-formats*}@c

A list of all of OpenGL's unsigned integral formats
@table @strong
@item Package
@ref{go to the CEPL<dot>IMAGE-FORMATS package, , @t{cepl.image-formats}}
@item Source
@ref{go to the cepl/core/types/image-format<dot>lisp file, , @t{core/types/image-format.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *unsigned-normalized-integer-formats*
@anchor{go to the CEPL<dot>IMAGE-FORMATS<colon><colon>*UNSIGNED-NORMALIZED-INTEGER-FORMATS* special variable}@c
@specialsubindex{*unsigned-normalized-integer-formats*}@c

A list of all of OpenGL's unsigned normalized integer formats
@table @strong
@item Package
@ref{go to the CEPL<dot>IMAGE-FORMATS package, , @t{cepl.image-formats}}
@item Source
@ref{go to the cepl/core/types/image-format<dot>lisp file, , @t{core/types/image-format.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *valid-image-formats-for-buffer-backed-texture*
@anchor{go to the CEPL<dot>IMAGE-FORMATS<colon><colon>*VALID-IMAGE-FORMATS-FOR-BUFFER-BACKED-TEXTURE* special variable}@c
@specialsubindex{*valid-image-formats-for-buffer-backed-texture*}@c

A list of all of OpenGL's valid image formats for buffer backed texture
@table @strong
@item Package
@ref{go to the CEPL<dot>IMAGE-FORMATS package, , @t{cepl.image-formats}}
@item Source
@ref{go to the cepl/core/types/image-format<dot>lisp file, , @t{core/types/image-format.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} +null-buffer-backed-gpu-array+
@anchor{go to the %CEPL<dot>TYPES<colon><colon>+NULL-BUFFER-BACKED-GPU-ARRAY+ special variable}@c
@specialsubindex{+null-buffer-backed-gpu-array+}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/nulls-and-uninitialized<dot>lisp file, , @t{core/types/nulls-and-uninitialized.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} +null-fbo+
@anchor{go to the %CEPL<dot>TYPES<colon><colon>+NULL-FBO+ special variable}@c
@specialsubindex{+null-fbo+}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/nulls-and-uninitialized<dot>lisp file, , @t{core/types/nulls-and-uninitialized.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} +null-gpu-buffer+
@anchor{go to the %CEPL<dot>TYPES<colon><colon>+NULL-GPU-BUFFER+ special variable}@c
@specialsubindex{+null-gpu-buffer+}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/nulls-and-uninitialized<dot>lisp file, , @t{core/types/nulls-and-uninitialized.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} +null-texture+
@anchor{go to the %CEPL<dot>TYPES<colon><colon>+NULL-TEXTURE+ special variable}@c
@specialsubindex{+null-texture+}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/nulls-and-uninitialized<dot>lisp file, , @t{core/types/nulls-and-uninitialized.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} +null-texture-backed-gpu-array+
@anchor{go to the %CEPL<dot>TYPES<colon><colon>+NULL-TEXTURE-BACKED-GPU-ARRAY+ special variable}@c
@specialsubindex{+null-texture-backed-gpu-array+}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/nulls-and-uninitialized<dot>lisp file, , @t{core/types/nulls-and-uninitialized.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} +null-vao+
@anchor{go to the %CEPL<dot>TYPES<colon><colon>+NULL-VAO+ special variable}@c
@specialsubindex{+null-vao+}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/nulls-and-uninitialized<dot>lisp file, , @t{core/types/nulls-and-uninitialized.lisp}} (file)
@end table
@end defvr
" :AFTER-MENU-CONTENTS NIL) :PREVIOUS NIL :UP #2# :CHILDREN NIL :BEFORE-MENU-CONTENTS "@defvr {Constant} +gl-id-bit-size+
@anchor{go to the %CEPL<dot>TYPES<colon><colon>+GL-ID-BIT-SIZE+ constant}@c
@constantsubindex{+gl-id-bit-size+}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end defvr
@defvr {Constant} +max-context-count+
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>+MAX-CONTEXT-COUNT+ constant}@c
@constantsubindex{+max-context-count+}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end defvr
@defvr {Constant} +null-gl-id+
@anchor{go to the %CEPL<dot>TYPES<colon><colon>+NULL-GL-ID+ constant}@c
@constantsubindex{+null-gl-id+}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end defvr
@defvr {Constant} +unknown-gl-id+
@anchor{go to the %CEPL<dot>TYPES<colon><colon>+UNKNOWN-GL-ID+ constant}@c
@constantsubindex{+unknown-gl-id+}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end defvr
" :AFTER-MENU-CONTENTS NIL) #7# #8# #9=#S(NET.DIDIERVERNA.DECLT::NODE :NAME "Exported compiler macros" :SYNOPSIS NIL :SECTION-TYPE :NUMBERED :SECTION-NAME "Compiler macros" :NEXT #10=#S(NET.DIDIERVERNA.DECLT::NODE :NAME "Exported functions" :SYNOPSIS NIL :SECTION-TYPE :NUMBERED :SECTION-NAME "Functions" :NEXT #11=# :PREVIOUS #9# :UP #2# :CHILDREN NIL :BEFORE-MENU-CONTENTS "@deffn {Function} {%%make-buffer-texture} &key (ID ID) (CACHE-ID CACHE-ID) (BASE-DIMENSIONS BASE-DIMENSIONS) (TYPE TYPE) (IMAGE-FORMAT IMAGE-FORMAT) (MIPMAP-LEVELS MIPMAP-LEVELS) (LAYER-COUNT LAYER-COUNT) (CUBES-P CUBES-P) (ALLOCATED-P ALLOCATED-P) (MUTABLE-P MUTABLE-P) (SAMPLES SAMPLES) (FIXED-SAMPLE-LOCATIONS-P FIXED-SAMPLE-LOCATIONS-P) (LAST-SAMPLER-ID LAST-SAMPLER-ID) (BACKING-ARRAY BACKING-ARRAY) (OWNS-ARRAY OWNS-ARRAY)
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%%MAKE-BUFFER-TEXTURE function}@c
@functionsubindex{%%make-buffer-texture}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%%make-fbo} &key (ID ID) (EMPTY-PARAMS EMPTY-PARAMS) (COLOR-ARRAYS COLOR-ARRAYS) (DEPTH-ARRAY DEPTH-ARRAY) (STENCIL-ARRAY STENCIL-ARRAY) (DRAW-BUFFER-MAP DRAW-BUFFER-MAP) (CLEAR-MASK CLEAR-MASK) (IS-DEFAULT IS-DEFAULT) (ATTACHMENT-COUNT ATTACHMENT-COUNT) (BLENDING-PARAMS BLENDING-PARAMS)
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%%MAKE-FBO function}@c
@functionsubindex{%%make-fbo}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%%make-texture} &key (ID ID) (CACHE-ID CACHE-ID) (BASE-DIMENSIONS BASE-DIMENSIONS) (TYPE TYPE) (IMAGE-FORMAT IMAGE-FORMAT) (MIPMAP-LEVELS MIPMAP-LEVELS) (LAYER-COUNT LAYER-COUNT) (CUBES-P CUBES-P) (ALLOCATED-P ALLOCATED-P) (MUTABLE-P MUTABLE-P) (SAMPLES SAMPLES) (FIXED-SAMPLE-LOCATIONS-P FIXED-SAMPLE-LOCATIONS-P) (LAST-SAMPLER-ID LAST-SAMPLER-ID)
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%%MAKE-TEXTURE function}@c
@functionsubindex{%%make-texture}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%empty-fbo-params-dimensions} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%EMPTY-FBO-PARAMS-DIMENSIONS function}@c
@functionsubindex{%empty-fbo-params-dimensions}@c
@deffnx {Function} {(setf %empty-fbo-params-dimensions)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %EMPTY-FBO-PARAMS-DIMENSIONS) function}@c
@functionsubindex{(setf %empty-fbo-params-dimensions)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%empty-fbo-params-fbo} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%EMPTY-FBO-PARAMS-FBO function}@c
@functionsubindex{%empty-fbo-params-fbo}@c
@deffnx {Function} {(setf %empty-fbo-params-fbo)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %EMPTY-FBO-PARAMS-FBO) function}@c
@functionsubindex{(setf %empty-fbo-params-fbo)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%empty-fbo-params-fixed-sample-locations-p} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%EMPTY-FBO-PARAMS-FIXED-SAMPLE-LOCATIONS-P function}@c
@functionsubindex{%empty-fbo-params-fixed-sample-locations-p}@c
@deffnx {Function} {(setf %empty-fbo-params-fixed-sample-locations-p)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %EMPTY-FBO-PARAMS-FIXED-SAMPLE-LOCATIONS-P) function}@c
@functionsubindex{(setf %empty-fbo-params-fixed-sample-locations-p)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%empty-fbo-params-layer-count} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%EMPTY-FBO-PARAMS-LAYER-COUNT function}@c
@functionsubindex{%empty-fbo-params-layer-count}@c
@deffnx {Function} {(setf %empty-fbo-params-layer-count)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %EMPTY-FBO-PARAMS-LAYER-COUNT) function}@c
@functionsubindex{(setf %empty-fbo-params-layer-count)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%empty-fbo-params-samples} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%EMPTY-FBO-PARAMS-SAMPLES function}@c
@functionsubindex{%empty-fbo-params-samples}@c
@deffnx {Function} {(setf %empty-fbo-params-samples)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %EMPTY-FBO-PARAMS-SAMPLES) function}@c
@functionsubindex{(setf %empty-fbo-params-samples)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%empty-fbo-params-viewport} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%EMPTY-FBO-PARAMS-VIEWPORT function}@c
@functionsubindex{%empty-fbo-params-viewport}@c
@deffnx {Function} {(setf %empty-fbo-params-viewport)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %EMPTY-FBO-PARAMS-VIEWPORT) function}@c
@functionsubindex{(setf %empty-fbo-params-viewport)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%fbo-attachment-count} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%FBO-ATTACHMENT-COUNT function}@c
@functionsubindex{%fbo-attachment-count}@c
@deffnx {Function} {(setf %fbo-attachment-count)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %FBO-ATTACHMENT-COUNT) function}@c
@functionsubindex{(setf %fbo-attachment-count)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%fbo-blending-params} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%FBO-BLENDING-PARAMS function}@c
@functionsubindex{%fbo-blending-params}@c
@deffnx {Function} {(setf %fbo-blending-params)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %FBO-BLENDING-PARAMS) function}@c
@functionsubindex{(setf %fbo-blending-params)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%fbo-clear-mask} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%FBO-CLEAR-MASK function}@c
@functionsubindex{%fbo-clear-mask}@c
@deffnx {Function} {(setf %fbo-clear-mask)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %FBO-CLEAR-MASK) function}@c
@functionsubindex{(setf %fbo-clear-mask)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%fbo-color-arrays} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%FBO-COLOR-ARRAYS function}@c
@functionsubindex{%fbo-color-arrays}@c
@deffnx {Function} {(setf %fbo-color-arrays)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %FBO-COLOR-ARRAYS) function}@c
@functionsubindex{(setf %fbo-color-arrays)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%fbo-depth-array} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%FBO-DEPTH-ARRAY function}@c
@functionsubindex{%fbo-depth-array}@c
@deffnx {Function} {(setf %fbo-depth-array)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %FBO-DEPTH-ARRAY) function}@c
@functionsubindex{(setf %fbo-depth-array)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%fbo-draw-buffer-map} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%FBO-DRAW-BUFFER-MAP function}@c
@functionsubindex{%fbo-draw-buffer-map}@c
@deffnx {Function} {(setf %fbo-draw-buffer-map)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %FBO-DRAW-BUFFER-MAP) function}@c
@functionsubindex{(setf %fbo-draw-buffer-map)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%fbo-empty-params} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%FBO-EMPTY-PARAMS function}@c
@functionsubindex{%fbo-empty-params}@c
@deffnx {Function} {(setf %fbo-empty-params)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %FBO-EMPTY-PARAMS) function}@c
@functionsubindex{(setf %fbo-empty-params)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%fbo-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%FBO-ID function}@c
@functionsubindex{%fbo-id}@c
@deffnx {Function} {(setf %fbo-id)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %FBO-ID) function}@c
@functionsubindex{(setf %fbo-id)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%fbo-is-default} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%FBO-IS-DEFAULT function}@c
@functionsubindex{%fbo-is-default}@c
@deffnx {Function} {(setf %fbo-is-default)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %FBO-IS-DEFAULT) function}@c
@functionsubindex{(setf %fbo-is-default)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%fbo-stencil-array} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%FBO-STENCIL-ARRAY function}@c
@functionsubindex{%fbo-stencil-array}@c
@deffnx {Function} {(setf %fbo-stencil-array)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %FBO-STENCIL-ARRAY) function}@c
@functionsubindex{(setf %fbo-stencil-array)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%gpu-fence-obj} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%GPU-FENCE-OBJ function}@c
@functionsubindex{%gpu-fence-obj}@c
@deffnx {Function} {(setf %gpu-fence-obj)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %GPU-FENCE-OBJ) function}@c
@functionsubindex{(setf %gpu-fence-obj)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%make-c-array} &key (POINTER POINTER) (DIMENSIONS DIMENSIONS) (TOTAL-SIZE TOTAL-SIZE) (ELEMENT-TYPE ELEMENT-TYPE) (SIZES SIZES) (ROW-ALIGNMENT ROW-ALIGNMENT) (STRUCT-ELEMENT-TYPEP STRUCT-ELEMENT-TYPEP) (ELEMENT-PIXEL-FORMAT ELEMENT-PIXEL-FORMAT) (ELEMENT-FROM-FOREIGN ELEMENT-FROM-FOREIGN) (ELEMENT-TO-FOREIGN ELEMENT-TO-FOREIGN) (FREE FREE)
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%MAKE-C-ARRAY function}@c
@functionsubindex{%make-c-array}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%make-gpu-array} &key (DIMENSIONS DIMENSIONS)
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%MAKE-GPU-ARRAY function}@c
@functionsubindex{%make-gpu-array}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%make-gpu-array-bb} &key (DIMENSIONS DIMENSIONS) (BUFFER BUFFER) (ACCESS-STYLE ACCESS-STYLE) (ELEMENT-TYPE ELEMENT-TYPE) (BYTE-SIZE BYTE-SIZE) (ELEMENT-BYTE-SIZE ELEMENT-BYTE-SIZE) (OFFSET-IN-BYTES-INTO-BUFFER OFFSET-IN-BYTES-INTO-BUFFER) (ELEMENT-PIXEL-FORMAT ELEMENT-PIXEL-FORMAT) (ROW-ALIGNMENT ROW-ALIGNMENT)
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%MAKE-GPU-ARRAY-BB function}@c
@functionsubindex{%make-gpu-array-bb}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%make-gpu-array-t} &key (DIMENSIONS DIMENSIONS) (TEXTURE TEXTURE) (TEXTURE-TYPE TEXTURE-TYPE) (LEVEL-NUM LEVEL-NUM) (LAYER-NUM LAYER-NUM) (FACE-NUM FACE-NUM) (IMAGE-FORMAT IMAGE-FORMAT)
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%MAKE-GPU-ARRAY-T function}@c
@functionsubindex{%make-gpu-array-t}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%make-gpu-buffer} &key (ID ID) (CACHE-ID CACHE-ID) (ARRAYS ARRAYS)
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%MAKE-GPU-BUFFER function}@c
@functionsubindex{%make-gpu-buffer}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%make-gpu-fence} OBJ
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%MAKE-GPU-FENCE function}@c
@functionsubindex{%make-gpu-fence}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%make-render-buffer} &key (ID ID) (IMAGE-FORMAT IMAGE-FORMAT) (RESOLUTION RESOLUTION) (MULTISAMPLE-P MULTISAMPLE-P)
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%MAKE-RENDER-BUFFER function}@c
@functionsubindex{%make-render-buffer}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%make-sampler} &key (CONTEXT-ID CONTEXT-ID) (ID-BOX ID-BOX) (TYPE TYPE) (TEXTURE TEXTURE) (LOD-BIAS LOD-BIAS) (MIN-LOD MIN-LOD) (MAX-LOD MAX-LOD) (BORDER-COLOR BORDER-COLOR) (EXPECTS-MIPMAP EXPECTS-MIPMAP) (MINIFY-FILTER MINIFY-FILTER) (MAGNIFY-FILTER MAGNIFY-FILTER) (WRAP WRAP) (EXPECTS-DEPTH EXPECTS-DEPTH) (COMPARE COMPARE)
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%MAKE-SAMPLER function}@c
@functionsubindex{%make-sampler}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%make-ssbo} &key (ID ID) (DATA DATA) (INDEX INDEX) (OWNS-GPU-ARRAY OWNS-GPU-ARRAY)
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%MAKE-SSBO function}@c
@functionsubindex{%make-ssbo}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%make-stencil-params} &key (TEST TEST) (VALUE VALUE) (MASK MASK) (ON-STENCIL-TEST-FAIL ON-STENCIL-TEST-FAIL) (ON-STENCIL-PASS-DEPTH-TEST-FAIL ON-STENCIL-PASS-DEPTH-TEST-FAIL) (ON-STENCIL-PASS-DEPTH-TEST-PASS ON-STENCIL-PASS-DEPTH-TEST-PASS)
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%MAKE-STENCIL-PARAMS function}@c
@functionsubindex{%make-stencil-params}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%make-tfs} &key (ARRAYS ARRAYS) (PENDING-ARRAYS PENDING-ARRAYS) (BOUND BOUND) (CURRENT-PROG-ID CURRENT-PROG-ID)
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%MAKE-TFS function}@c
@functionsubindex{%make-tfs}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%make-ubo} &key (ID ID) (DATA DATA) (INDEX INDEX) (OWNS-GPU-ARRAY OWNS-GPU-ARRAY)
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%MAKE-UBO function}@c
@functionsubindex{%make-ubo}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%make-viewport} &key (RESOLUTION-X RESOLUTION-X) (RESOLUTION-Y RESOLUTION-Y) (ORIGIN-X ORIGIN-X) (ORIGIN-Y ORIGIN-Y)
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%MAKE-VIEWPORT function}@c
@functionsubindex{%make-viewport}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%render-buffer-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%RENDER-BUFFER-ID function}@c
@functionsubindex{%render-buffer-id}@c
@deffnx {Function} {(setf %render-buffer-id)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %RENDER-BUFFER-ID) function}@c
@functionsubindex{(setf %render-buffer-id)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%render-buffer-image-format} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%RENDER-BUFFER-IMAGE-FORMAT function}@c
@functionsubindex{%render-buffer-image-format}@c
@deffnx {Function} {(setf %render-buffer-image-format)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %RENDER-BUFFER-IMAGE-FORMAT) function}@c
@functionsubindex{(setf %render-buffer-image-format)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%render-buffer-multisample-p} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%RENDER-BUFFER-MULTISAMPLE-P function}@c
@functionsubindex{%render-buffer-multisample-p}@c
@deffnx {Function} {(setf %render-buffer-multisample-p)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %RENDER-BUFFER-MULTISAMPLE-P) function}@c
@functionsubindex{(setf %render-buffer-multisample-p)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%render-buffer-resolution} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%RENDER-BUFFER-RESOLUTION function}@c
@functionsubindex{%render-buffer-resolution}@c
@deffnx {Function} {(setf %render-buffer-resolution)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %RENDER-BUFFER-RESOLUTION) function}@c
@functionsubindex{(setf %render-buffer-resolution)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%sampler-border-color} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-BORDER-COLOR function}@c
@functionsubindex{%sampler-border-color}@c
@deffnx {Function} {(setf %sampler-border-color)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-BORDER-COLOR) function}@c
@functionsubindex{(setf %sampler-border-color)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%sampler-compare} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-COMPARE function}@c
@functionsubindex{%sampler-compare}@c
@deffnx {Function} {(setf %sampler-compare)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-COMPARE) function}@c
@functionsubindex{(setf %sampler-compare)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%sampler-expects-depth} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-EXPECTS-DEPTH function}@c
@functionsubindex{%sampler-expects-depth}@c
@deffnx {Function} {(setf %sampler-expects-depth)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-EXPECTS-DEPTH) function}@c
@functionsubindex{(setf %sampler-expects-depth)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%sampler-expects-mipmap} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-EXPECTS-MIPMAP function}@c
@functionsubindex{%sampler-expects-mipmap}@c
@deffnx {Function} {(setf %sampler-expects-mipmap)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-EXPECTS-MIPMAP) function}@c
@functionsubindex{(setf %sampler-expects-mipmap)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%sampler-id} SAMPLER
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-ID function}@c
@functionsubindex{%sampler-id}@c
@deffnx {Function} {(setf %sampler-id)} VALUE SAMPLER
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-ID) function}@c
@functionsubindex{(setf %sampler-id)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%sampler-id-box} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-ID-BOX function}@c
@functionsubindex{%sampler-id-box}@c
@deffnx {Function} {(setf %sampler-id-box)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-ID-BOX) function}@c
@functionsubindex{(setf %sampler-id-box)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%sampler-lod-bias} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-LOD-BIAS function}@c
@functionsubindex{%sampler-lod-bias}@c
@deffnx {Function} {(setf %sampler-lod-bias)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-LOD-BIAS) function}@c
@functionsubindex{(setf %sampler-lod-bias)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%sampler-magnify-filter} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-MAGNIFY-FILTER function}@c
@functionsubindex{%sampler-magnify-filter}@c
@deffnx {Function} {(setf %sampler-magnify-filter)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-MAGNIFY-FILTER) function}@c
@functionsubindex{(setf %sampler-magnify-filter)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%sampler-max-lod} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-MAX-LOD function}@c
@functionsubindex{%sampler-max-lod}@c
@deffnx {Function} {(setf %sampler-max-lod)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-MAX-LOD) function}@c
@functionsubindex{(setf %sampler-max-lod)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%sampler-min-lod} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-MIN-LOD function}@c
@functionsubindex{%sampler-min-lod}@c
@deffnx {Function} {(setf %sampler-min-lod)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-MIN-LOD) function}@c
@functionsubindex{(setf %sampler-min-lod)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%sampler-minify-filter} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-MINIFY-FILTER function}@c
@functionsubindex{%sampler-minify-filter}@c
@deffnx {Function} {(setf %sampler-minify-filter)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-MINIFY-FILTER) function}@c
@functionsubindex{(setf %sampler-minify-filter)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%sampler-texture} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-TEXTURE function}@c
@functionsubindex{%sampler-texture}@c
@deffnx {Function} {(setf %sampler-texture)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-TEXTURE) function}@c
@functionsubindex{(setf %sampler-texture)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%sampler-type} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-TYPE function}@c
@functionsubindex{%sampler-type}@c
@deffnx {Function} {(setf %sampler-type)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-TYPE) function}@c
@functionsubindex{(setf %sampler-type)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%sampler-wrap} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-WRAP function}@c
@functionsubindex{%sampler-wrap}@c
@deffnx {Function} {(setf %sampler-wrap)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-WRAP) function}@c
@functionsubindex{(setf %sampler-wrap)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%stencil-params-mask} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%STENCIL-PARAMS-MASK function}@c
@functionsubindex{%stencil-params-mask}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%stencil-params-on-stencil-pass-depth-test-fail} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%STENCIL-PARAMS-ON-STENCIL-PASS-DEPTH-TEST-FAIL function}@c
@functionsubindex{%stencil-params-on-stencil-pass-depth-test-fail}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%stencil-params-on-stencil-pass-depth-test-pass} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%STENCIL-PARAMS-ON-STENCIL-PASS-DEPTH-TEST-PASS function}@c
@functionsubindex{%stencil-params-on-stencil-pass-depth-test-pass}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%stencil-params-on-stencil-test-fail} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%STENCIL-PARAMS-ON-STENCIL-TEST-FAIL function}@c
@functionsubindex{%stencil-params-on-stencil-test-fail}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%stencil-params-test} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%STENCIL-PARAMS-TEST function}@c
@functionsubindex{%stencil-params-test}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%stencil-params-value} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%STENCIL-PARAMS-VALUE function}@c
@functionsubindex{%stencil-params-value}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%tfs-arrays} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%TFS-ARRAYS function}@c
@functionsubindex{%tfs-arrays}@c
@deffnx {Function} {(setf %tfs-arrays)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %TFS-ARRAYS) function}@c
@functionsubindex{(setf %tfs-arrays)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%tfs-bound} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%TFS-BOUND function}@c
@functionsubindex{%tfs-bound}@c
@deffnx {Function} {(setf %tfs-bound)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %TFS-BOUND) function}@c
@functionsubindex{(setf %tfs-bound)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%tfs-current-prog-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%TFS-CURRENT-PROG-ID function}@c
@functionsubindex{%tfs-current-prog-id}@c
@deffnx {Function} {(setf %tfs-current-prog-id)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %TFS-CURRENT-PROG-ID) function}@c
@functionsubindex{(setf %tfs-current-prog-id)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%tfs-pending-arrays} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%TFS-PENDING-ARRAYS function}@c
@functionsubindex{%tfs-pending-arrays}@c
@deffnx {Function} {(setf %tfs-pending-arrays)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %TFS-PENDING-ARRAYS) function}@c
@functionsubindex{(setf %tfs-pending-arrays)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%viewport-origin-x} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%VIEWPORT-ORIGIN-X function}@c
@functionsubindex{%viewport-origin-x}@c
@deffnx {Function} {(setf %viewport-origin-x)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %VIEWPORT-ORIGIN-X) function}@c
@functionsubindex{(setf %viewport-origin-x)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%viewport-origin-y} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%VIEWPORT-ORIGIN-Y function}@c
@functionsubindex{%viewport-origin-y}@c
@deffnx {Function} {(setf %viewport-origin-y)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %VIEWPORT-ORIGIN-Y) function}@c
@functionsubindex{(setf %viewport-origin-y)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%viewport-resolution-x} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%VIEWPORT-RESOLUTION-X function}@c
@functionsubindex{%viewport-resolution-x}@c
@deffnx {Function} {(setf %viewport-resolution-x)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %VIEWPORT-RESOLUTION-X) function}@c
@functionsubindex{(setf %viewport-resolution-x)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%viewport-resolution-y} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%VIEWPORT-RESOLUTION-Y function}@c
@functionsubindex{%viewport-resolution-y}@c
@deffnx {Function} {(setf %viewport-resolution-y)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %VIEWPORT-RESOLUTION-Y) function}@c
@functionsubindex{(setf %viewport-resolution-y)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {1d-p} OBJECT
@anchor{go to the CEPL<dot>INTERNALS<colon><colon>1D-P function}@c
@functionsubindex{1d-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>INTERNALS package, , @t{cepl.internals}}
@item Source
@ref{go to the cepl/core/internals<dot>lisp file, , @t{core/internals.lisp}} (file)
@end table
@end deffn
@deffn {Function} {across-c-ptr} FUNCTION C-ARRAY
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>ACROSS-C-PTR function}@c
@functionsubindex{across-c-ptr}@c

This function takes two arguments:@*

- A function that takes a pointer and a (unsigned-byte 32)@*
- A `c-array`@*

`across-c-ptr` will then call the given function once for every element in the
c-array passing in the pointer to an element of the array and the index to that
element.
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/map<dot>lisp file, , @t{core/c-arrays/map.lisp}} (file)
@end table
@end deffn
@deffn {Function} {active-texture-num} NUM
@anchor{go to the %CEPL<dot>TYPES<colon><colon>ACTIVE-TEXTURE-NUM function}@c
@functionsubindex{active-texture-num}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {add-surface} CONTEXT &key TITLE WIDTH HEIGHT FULLSCREEN RESIZABLE NO-FRAME HIDDEN MAKE-CURRENT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>ADD-SURFACE function}@c
@functionsubindex{add-surface}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/surface<dot>lisp file, , @t{core/context/surface.lisp}} (file)
@end table
@end deffn
@deffn {Function} {adjust-gpu-array} BUFFER-BACKED-GPU-ARRAY NEW-DIMENSIONS &key INITIAL-CONTENTS ACCESS-STYLE ROW-ALIGNMENT
@anchor{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED<colon><colon>ADJUST-GPU-ARRAY function}@c
@functionsubindex{adjust-gpu-array}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED package, , @t{cepl.gpu-arrays.buffer-backed}}
@item Source
@ref{go to the cepl/core/gpu-arrays/buffer-backed<dot>lisp file, , @t{core/gpu-arrays/buffer-backed.lisp}} (file)
@end table
@end deffn
@deffn {Function} {always} INCOMING-VAL STORED-VAL
@anchor{go to the CEPL<dot>DOCUMENTATION-FUNCTIONS<colon><colon>ALWAYS function}@c
@functionsubindex{always}@c
Always passes
@table @strong
@item Package
@ref{go to the CEPL<dot>DOCUMENTATION-FUNCTIONS package, , @t{cepl.documentation-functions}}
@item Source
@ref{go to the cepl/core/context/documentation-functions<dot>lisp file, , @t{core/context/documentation-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {arange} X &optional Y Z U V
@anchor{go to the CEPL-UTILS<colon><colon>ARANGE function}@c
@functionsubindex{arange}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {arangei} X &optional Y Z U V
@anchor{go to the CEPL-UTILS<colon><colon>ARANGEI function}@c
@functionsubindex{arangei}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {aref-c} C-ARRAY &rest SUBSCRIPTS
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>AREF-C function}@c
@functionsubindex{aref-c}@c

Accesses the `c-array` element specified by the subscripts
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/aref-c<dot>lisp file, , @t{core/c-arrays/aref-c.lisp}} (file)
@item Writer
@ref{go to the CEPL<dot>C-ARRAYS<colon><colon>(SETF AREF-C) function, , @t{(setf aref-c)}} (function)
@end table
@end deffn
@deffn {Function} {(setf aref-c)} VALUE C-ARRAY &rest SUBSCRIPTS
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>(SETF AREF-C) function}@c
@functionsubindex{(setf aref-c)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/aref-c<dot>lisp file, , @t{core/c-arrays/aref-c.lisp}} (file)
@item Reader
@ref{go to the CEPL<dot>C-ARRAYS<colon><colon>AREF-C function, , @t{aref-c}} (function)
@end table
@end deffn
@deffn {Function} {aref-c*} C-ARRAY SUBSCRIPTS
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>AREF-C* function}@c
@functionsubindex{aref-c*}@c

Accesses the `c-array` element specified by the subscripts.@*

The difference between this and `aref-c` is that this this function takes the
subscripts as a list.
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/aref-c<dot>lisp file, , @t{core/c-arrays/aref-c.lisp}} (file)
@item Writer
@ref{go to the CEPL<dot>C-ARRAYS<colon><colon>(SETF AREF-C*) function, , @t{(setf aref-c*)}} (function)
@end table
@end deffn
@deffn {Function} {(setf aref-c*)} VALUE C-ARRAY SUBSCRIPTS
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>(SETF AREF-C*) function}@c
@functionsubindex{(setf aref-c*)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/aref-c<dot>lisp file, , @t{core/c-arrays/aref-c.lisp}} (file)
@item Reader
@ref{go to the CEPL<dot>C-ARRAYS<colon><colon>AREF-C* function, , @t{aref-c*}} (function)
@end table
@end deffn
@deffn {Function} {arrays-indirect-command-base-instance} WRAPPED-OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ARRAYS-INDIRECT-COMMAND-BASE-INSTANCE function}@c
@functionsubindex{arrays-indirect-command-base-instance}@c
@deffnx {Function} {(setf arrays-indirect-command-base-instance)} VALUE WRAPPED-OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF ARRAYS-INDIRECT-COMMAND-BASE-INSTANCE) function}@c
@functionsubindex{(setf arrays-indirect-command-base-instance)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/multi-draw<dot>lisp file, , @t{core/pipelines/multi-draw.lisp}} (file)
@end table
@end deffn
@deffn {Function} {arrays-indirect-command-count} WRAPPED-OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ARRAYS-INDIRECT-COMMAND-COUNT function}@c
@functionsubindex{arrays-indirect-command-count}@c
@deffnx {Function} {(setf arrays-indirect-command-count)} VALUE WRAPPED-OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF ARRAYS-INDIRECT-COMMAND-COUNT) function}@c
@functionsubindex{(setf arrays-indirect-command-count)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/multi-draw<dot>lisp file, , @t{core/pipelines/multi-draw.lisp}} (file)
@end table
@end deffn
@deffn {Function} {arrays-indirect-command-first} WRAPPED-OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ARRAYS-INDIRECT-COMMAND-FIRST function}@c
@functionsubindex{arrays-indirect-command-first}@c
@deffnx {Function} {(setf arrays-indirect-command-first)} VALUE WRAPPED-OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF ARRAYS-INDIRECT-COMMAND-FIRST) function}@c
@functionsubindex{(setf arrays-indirect-command-first)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/multi-draw<dot>lisp file, , @t{core/pipelines/multi-draw.lisp}} (file)
@end table
@end deffn
@deffn {Function} {arrays-indirect-command-instance-count} WRAPPED-OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ARRAYS-INDIRECT-COMMAND-INSTANCE-COUNT function}@c
@functionsubindex{arrays-indirect-command-instance-count}@c
@deffnx {Function} {(setf arrays-indirect-command-instance-count)} VALUE WRAPPED-OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF ARRAYS-INDIRECT-COMMAND-INSTANCE-COUNT) function}@c
@functionsubindex{(setf arrays-indirect-command-instance-count)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/multi-draw<dot>lisp file, , @t{core/pipelines/multi-draw.lisp}} (file)
@end table
@end deffn
@deffn {Function} {assocr} ITEM ALIST &key KEY TEST TEST-NOT
@anchor{go to the CEPL-UTILS<colon><colon>ASSOCR function}@c
@functionsubindex{assocr}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {att-array} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>ATT-ARRAY function}@c
@functionsubindex{att-array}@c
@deffnx {Function} {(setf att-array)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF ATT-ARRAY) function}@c
@functionsubindex{(setf att-array)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {att-blend} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>ATT-BLEND function}@c
@functionsubindex{att-blend}@c
@deffnx {Function} {(setf att-blend)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF ATT-BLEND) function}@c
@functionsubindex{(setf att-blend)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {att-bparams} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>ATT-BPARAMS function}@c
@functionsubindex{att-bparams}@c
@deffnx {Function} {(setf att-bparams)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF ATT-BPARAMS) function}@c
@functionsubindex{(setf att-bparams)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {att-owned-p} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>ATT-OWNED-P function}@c
@functionsubindex{att-owned-p}@c
@deffnx {Function} {(setf att-owned-p)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF ATT-OWNED-P) function}@c
@functionsubindex{(setf att-owned-p)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {att-viewport} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>ATT-VIEWPORT function}@c
@functionsubindex{att-viewport}@c
@deffnx {Function} {(setf att-viewport)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF ATT-VIEWPORT) function}@c
@functionsubindex{(setf att-viewport)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {attachment} FBO ATTACHMENT-NAME
@anchor{go to the CEPL<dot>FBOS<colon><colon>ATTACHMENT function}@c
@functionsubindex{attachment}@c

This function retrieves the `attachment` named by attachment-name from the
given `fbo`. The result is a `gpu-array`@*

The attachment-name can be one of the following:@*

 a positive integer - In which case this function returns the@*
                      nth color-attachments where (= n attachment-name)@*

 :d - the depth-attachment is returned@*

 :s - the stencil-attachment is returned [0]@*

 :ds - the depth-stencil-attachment is returned [0]@*


You can also setf this function, the value must be a texture-backed gpu-array
with a valid element-type for that attachment.@*

For color attachments this means the element type must be a member of@*
the `*color-renderable-formats*` list@*

For color attachments this means the element type must be a member of@*
the `*depth-formats*` list@*

For stencil attachments this means the element type must be a member of
the `*stencil-formats*` list@*

For depth-stencil attachments this means the element type must be a member of
the `*depth-stencil-formats*` list@*

[0] *WARNING:* :s & :ds are not supported in the current version of CEPL
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@item Writer
@ref{go to the CEPL<dot>FBOS<colon><colon>(SETF ATTACHMENT) function, , @t{(setf attachment)}} (function)
@end table
@end deffn
@deffn {Function} {(setf attachment)} VALUE FBO ATTACHMENT-NAME
@anchor{go to the CEPL<dot>FBOS<colon><colon>(SETF ATTACHMENT) function}@c
@functionsubindex{(setf attachment)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@item Reader
@ref{go to the CEPL<dot>FBOS<colon><colon>ATTACHMENT function, , @t{attachment}} (function)
@end table
@end deffn
@deffn {Function} {attachment-blending} FBO ATTACHMENT-NAME
@anchor{go to the CEPL<dot>FBOS<colon><colon>ATTACHMENT-BLENDING function}@c
@functionsubindex{attachment-blending}@c

This function returns the blending parameters that will be used when rendering
into the specified `attachment` on the given `fbo`@*

Blending parameters tell OpenGL how values written into a `gpu-array` should be
combined with any values that are already present.@*

The canonical use for this is implementing transparency.@*

The details of blending parameters and where they can be used is best covered in
the docstring for the `blending-params` struct.
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@item Writer
@ref{go to the CEPL<dot>FBOS<colon><colon>(SETF ATTACHMENT-BLENDING) function, , @t{(setf attachment-blending)}} (function)
@end table
@end deffn
@deffn {Function} {(setf attachment-blending)} VALUE FBO ATTACHMENT-NAME
@anchor{go to the CEPL<dot>FBOS<colon><colon>(SETF ATTACHMENT-BLENDING) function}@c
@functionsubindex{(setf attachment-blending)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@item Reader
@ref{go to the CEPL<dot>FBOS<colon><colon>ATTACHMENT-BLENDING function, , @t{attachment-blending}} (function)
@end table
@end deffn
@deffn {Function} {attachment-pattern} ()
@anchor{go to the CEPL<dot>FBOS<colon><colon>ATTACHMENT-PATTERN function}@c
@functionsubindex{attachment-pattern}@c

This function returns a typed simple-array with is suitable to pass as
the :draw-buffers argument in `with-fbo-bound`.@*

The arguments must evaluate to numbers of type (unsigned-byte 32).

When called inline in a `with-fbo-bound` form there is an opportunity
for CEPL to optimize the code. For example in this case@*

    (defun foo (fbo)@*
      (with-fbo-bound (fbo :draw-buffers (attachment-pattern 0 2))
        ..@*
        etc))
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {attachment-tex} FBO ATTACHMENT-NAME
@anchor{go to the CEPL<dot>FBOS<colon><colon>ATTACHMENT-TEX function}@c
@functionsubindex{attachment-tex}@c
This function take an `fbo` and the name of an `attachment`. It then returns
the `texture` that backs the `gpu-array` in the specified attachment.@*

It is equivalent to writing:@*

    (gpu-array-texture (attachment fbo attachmnent-name))
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {attachment-viewport} FBO ATTACHMENT-NAME
@anchor{go to the CEPL<dot>FBOS<colon><colon>ATTACHMENT-VIEWPORT function}@c
@functionsubindex{attachment-viewport}@c

This function takes an `fbo` and attachment-name and returns a new `viewport` whos
dimensionsmatch those of the `gpu-array` connected to the `attachment`.
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {backed-by} GPU-ARRAY
@anchor{go to the CEPL<dot>GPU-ARRAYS<colon><colon>BACKED-BY function}@c
@functionsubindex{backed-by}@c

This function takes a `gpu-array` and returns either :texture or :buffer depending
on whether it is a texture-backed gpu-array or a buffer-backed gpu-array.
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS package, , @t{cepl.gpu-arrays}}
@item Source
@ref{go to the cepl/core/gpu-arrays/with-and-push<dot>lisp file, , @t{core/gpu-arrays/with-and-push.lisp}} (file)
@end table
@end deffn
@deffn {Function} {bake-uniforms} PIPELINE &rest UNIFORMS &key &allow-other-keys
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>BAKE-UNIFORMS function}@c
@functionsubindex{bake-uniforms}@c

__WARNING__ EXPRERIMENTAL FEATURE@*

This allows you to create a new lambda-pipeline from existing pipeline whilst also
fixing the values for certain uniforms.@*

These values will be baked into the gpu-code so that they will not need to be uploaded
each time the pipeline is mapped over.@*

For example:@*

    (defpipeline-g draw-cube ()@*
      :vertex (draw-cube-vert g-pnt)@*
      :fragment (draw-cube-frag :vec2))@*

    (defun fix-cube-size (size)@*
      (bake-uniforms #'draw-cube :edge-length (float size)))
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/bake<dot>lisp file, , @t{core/pipelines/bake.lisp}} (file)
@end table
@end deffn
@deffn {Function} {blending-params} FBO &optional ATTACHMENT-NAME
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BLENDING-PARAMS function}@c
@functionsubindex{blending-params}@c

This function, when passed an `fbo` or attachment will return the `blending-params`
for that object.@*

For details on what blending-params are, see the docstring for the
blending-params struct
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF BLENDING-PARAMS) function, , @t{(setf blending-params)}} (function)
@end table
@end deffn
@deffn {Function} {(setf blending-params)} VALUE FBO &optional ATTACHMENT-NAME
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BLENDING-PARAMS) function}@c
@functionsubindex{(setf blending-params)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>BLENDING-PARAMS function, , @t{blending-params}} (function)
@end table
@end deffn
@deffn {Function} {blending-params-destination-alpha} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BLENDING-PARAMS-DESTINATION-ALPHA function}@c
@functionsubindex{blending-params-destination-alpha}@c
@deffnx {Function} {(setf blending-params-destination-alpha)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BLENDING-PARAMS-DESTINATION-ALPHA) function}@c
@functionsubindex{(setf blending-params-destination-alpha)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {blending-params-destination-rgb} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BLENDING-PARAMS-DESTINATION-RGB function}@c
@functionsubindex{blending-params-destination-rgb}@c
@deffnx {Function} {(setf blending-params-destination-rgb)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BLENDING-PARAMS-DESTINATION-RGB) function}@c
@functionsubindex{(setf blending-params-destination-rgb)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {blending-params-mode-alpha} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BLENDING-PARAMS-MODE-ALPHA function}@c
@functionsubindex{blending-params-mode-alpha}@c
@deffnx {Function} {(setf blending-params-mode-alpha)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BLENDING-PARAMS-MODE-ALPHA) function}@c
@functionsubindex{(setf blending-params-mode-alpha)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {blending-params-mode-rgb} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BLENDING-PARAMS-MODE-RGB function}@c
@functionsubindex{blending-params-mode-rgb}@c
@deffnx {Function} {(setf blending-params-mode-rgb)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BLENDING-PARAMS-MODE-RGB) function}@c
@functionsubindex{(setf blending-params-mode-rgb)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {blending-params-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BLENDING-PARAMS-P function}@c
@functionsubindex{blending-params-p}@c

This function returns t when the given value is a `blending-params` object,
otherwise it returns nil
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {blending-params-source-alpha} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BLENDING-PARAMS-SOURCE-ALPHA function}@c
@functionsubindex{blending-params-source-alpha}@c
@deffnx {Function} {(setf blending-params-source-alpha)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BLENDING-PARAMS-SOURCE-ALPHA) function}@c
@functionsubindex{(setf blending-params-source-alpha)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {blending-params-source-rgb} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BLENDING-PARAMS-SOURCE-RGB function}@c
@functionsubindex{blending-params-source-rgb}@c
@deffnx {Function} {(setf blending-params-source-rgb)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BLENDING-PARAMS-SOURCE-RGB) function}@c
@functionsubindex{(setf blending-params-source-rgb)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-data} BUFFER C-ARRAY &key TARGET USAGE OFFSET BYTE-SIZE
@anchor{go to the CEPL<dot>GPU-BUFFERS<colon><colon>BUFFER-DATA function}@c
@functionsubindex{buffer-data}@c

This function populates the `gpu-buffer` with the contents of the `c-array`.

You also pass in the buffer type and the draw type this buffer is to be used
for.@*

The function returns a buffer object with its format slot populated with the
details of the data stored within the buffer
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-BUFFERS package, , @t{cepl.gpu-buffers}}
@item Source
@ref{go to the cepl/core/gpu-buffers/gpu-buffers<dot>lisp file, , @t{core/gpu-buffers/gpu-buffers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-data-raw} DATA-POINTER BYTE-SIZE BUFFER &optional TARGET USAGE BYTE-OFFSET
@anchor{go to the CEPL<dot>GPU-BUFFERS<colon><colon>BUFFER-DATA-RAW function}@c
@functionsubindex{buffer-data-raw}@c

This function populates an opengl buffer with the 'data-byte-size' bytes of data
from the given point, optionally at the offset provided.@*

You also pass in the buffer type and the draw type this buffer is to be@*
used for.@*

The function returns a buffer object with its format slot populated with the
details of the data stored within the buffer
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-BUFFERS package, , @t{cepl.gpu-buffers}}
@item Source
@ref{go to the cepl/core/gpu-buffers/gpu-buffers<dot>lisp file, , @t{core/gpu-buffers/gpu-buffers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-reserve-block} BUFFER TYPE DIMENSIONS TARGET USAGE &key ROW-ALIGNMENT
@anchor{go to the CEPL<dot>GPU-BUFFERS<colon><colon>BUFFER-RESERVE-BLOCK function}@c
@functionsubindex{buffer-reserve-block}@c

This function creates an empty block of data in the opengl buffer equal in size
to:@*

    (* length size-in-bytes-of-type).@*

It will remove ALL data currently in the buffer
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-BUFFERS package, , @t{cepl.gpu-buffers}}
@item Source
@ref{go to the cepl/core/gpu-buffers/gpu-buffers<dot>lisp file, , @t{core/gpu-buffers/gpu-buffers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-stream-%index-type-enum} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-%INDEX-TYPE-ENUM function}@c
@functionsubindex{buffer-stream-%index-type-enum}@c
@deffnx {Function} {(setf buffer-stream-%index-type-enum)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-%INDEX-TYPE-ENUM) function}@c
@functionsubindex{(setf buffer-stream-%index-type-enum)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-stream-%index-type-size} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-%INDEX-TYPE-SIZE function}@c
@functionsubindex{buffer-stream-%index-type-size}@c
@deffnx {Function} {(setf buffer-stream-%index-type-size)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-%INDEX-TYPE-SIZE) function}@c
@functionsubindex{(setf buffer-stream-%index-type-size)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-stream-%primitive} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-%PRIMITIVE function}@c
@functionsubindex{buffer-stream-%primitive}@c
@deffnx {Function} {(setf buffer-stream-%primitive)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-%PRIMITIVE) function}@c
@functionsubindex{(setf buffer-stream-%primitive)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-stream-%start} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-%START function}@c
@functionsubindex{buffer-stream-%start}@c
@deffnx {Function} {(setf buffer-stream-%start)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-%START) function}@c
@functionsubindex{(setf buffer-stream-%start)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-stream-%start-byte} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-%START-BYTE function}@c
@functionsubindex{buffer-stream-%start-byte}@c
@deffnx {Function} {(setf buffer-stream-%start-byte)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-%START-BYTE) function}@c
@functionsubindex{(setf buffer-stream-%start-byte)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-stream-base-vertex} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-BASE-VERTEX function}@c
@functionsubindex{buffer-stream-base-vertex}@c
@deffnx {Function} {(setf buffer-stream-base-vertex)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-BASE-VERTEX) function}@c
@functionsubindex{(setf buffer-stream-base-vertex)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-stream-draw-mode-val} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-DRAW-MODE-VAL function}@c
@functionsubindex{buffer-stream-draw-mode-val}@c
@deffnx {Function} {(setf buffer-stream-draw-mode-val)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-DRAW-MODE-VAL) function}@c
@functionsubindex{(setf buffer-stream-draw-mode-val)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-stream-gpu-arrays} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-GPU-ARRAYS function}@c
@functionsubindex{buffer-stream-gpu-arrays}@c

When you construct a buffer-stream it will (by default) hold onto the
gpu-arrays that were composed.@*

This function when given a buffer-stream will return those stored gpu-arrays
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-GPU-ARRAYS) function, , @t{(setf buffer-stream-gpu-arrays)}} (function)
@end table
@end deffn
@deffn {Function} {(setf buffer-stream-gpu-arrays)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-GPU-ARRAYS) function}@c
@functionsubindex{(setf buffer-stream-gpu-arrays)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-GPU-ARRAYS function, , @t{buffer-stream-gpu-arrays}} (function)
@end table
@end deffn
@deffn {Function} {buffer-stream-index-type} STREAM
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-INDEX-TYPE function}@c
@functionsubindex{buffer-stream-index-type}@c

When passed a buffer-stream with an index this function will return the
element-type of the index-data.
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-INDEX-TYPE) function, , @t{(setf buffer-stream-index-type)}} (function)
@end table
@end deffn
@deffn {Function} {(setf buffer-stream-index-type)} VALUE STREAM
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-INDEX-TYPE) function}@c
@functionsubindex{(setf buffer-stream-index-type)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-INDEX-TYPE function, , @t{buffer-stream-index-type}} (function)
@end table
@end deffn
@deffn {Function} {buffer-stream-length} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-LENGTH function}@c
@functionsubindex{buffer-stream-length}@c

Returns the number of elements in the buffer-stream
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-LENGTH) function, , @t{(setf buffer-stream-length)}} (function)
@end table
@end deffn
@deffn {Function} {(setf buffer-stream-length)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-LENGTH) function}@c
@functionsubindex{(setf buffer-stream-length)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-LENGTH function, , @t{buffer-stream-length}} (function)
@end table
@end deffn
@deffn {Function} {buffer-stream-managed} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-MANAGED function}@c
@functionsubindex{buffer-stream-managed}@c
@deffnx {Function} {(setf buffer-stream-managed)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-MANAGED) function}@c
@functionsubindex{(setf buffer-stream-managed)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-stream-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-P function}@c
@functionsubindex{buffer-stream-p}@c

Returns t if the value passed is a buffer-stream
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-stream-patch-length} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-PATCH-LENGTH function}@c
@functionsubindex{buffer-stream-patch-length}@c
@deffnx {Function} {(setf buffer-stream-patch-length)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-PATCH-LENGTH) function}@c
@functionsubindex{(setf buffer-stream-patch-length)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-stream-primitive} STREAM
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-PRIMITIVE function}@c
@functionsubindex{buffer-stream-primitive}@c

This function returns the primitive that the data pulled from buffer stream
represents.@*

The primitive says what the gpu will draw this data as. It can be any one of:

 :points@*
 :lines@*
 :line-loop@*
 :line-strip@*
 :lines-adjacency@*
 :line-strip-adjacency@*
 :triangles@*
 :triangle-fan@*
 :triangle-strip@*
 :triangles-adjacency@*
 :triangle-strip-adjacency@*
 (:patch <patch-size>)@*

By default the primitive-type is :triangles
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-PRIMITIVE) function, , @t{(setf buffer-stream-primitive)}} (function)
@end table
@end deffn
@deffn {Function} {(setf buffer-stream-primitive)} PRIMITIVE STREAM
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-PRIMITIVE) function}@c
@functionsubindex{(setf buffer-stream-primitive)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-PRIMITIVE function, , @t{buffer-stream-primitive}} (function)
@end table
@end deffn
@deffn {Function} {buffer-stream-primitive-group-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-PRIMITIVE-GROUP-ID function}@c
@functionsubindex{buffer-stream-primitive-group-id}@c
@deffnx {Function} {(setf buffer-stream-primitive-group-id)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-PRIMITIVE-GROUP-ID) function}@c
@functionsubindex{(setf buffer-stream-primitive-group-id)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-stream-start} STREAM
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-START function}@c
@functionsubindex{buffer-stream-start}@c
@deffnx {Function} {(setf buffer-stream-start)} VALUE STREAM
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-START) function}@c
@functionsubindex{(setf buffer-stream-start)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-stream-start-byte} STREAM
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-START-BYTE function}@c
@functionsubindex{buffer-stream-start-byte}@c
@deffnx {Function} {(setf buffer-stream-start-byte)} VALUE STREAM
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-START-BYTE) function}@c
@functionsubindex{(setf buffer-stream-start-byte)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-stream-vao} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-VAO function}@c
@functionsubindex{buffer-stream-vao}@c

Returns the OpenGL Vertex Array Object (VAO) owned by this stream.

Do not modify this unless you are sure what you are doing.@*
In most cases you do not need to interact with the VAO directly
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-VAO) function, , @t{(setf buffer-stream-vao)}} (function)
@end table
@end deffn
@deffn {Function} {(setf buffer-stream-vao)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-VAO) function}@c
@functionsubindex{(setf buffer-stream-vao)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-VAO function, , @t{buffer-stream-vao}} (function)
@end table
@end deffn
@deffn {Function} {buffer-texture-backing-array} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-TEXTURE-BACKING-ARRAY function}@c
@functionsubindex{buffer-texture-backing-array}@c
@deffnx {Function} {(setf buffer-texture-backing-array)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-TEXTURE-BACKING-ARRAY) function}@c
@functionsubindex{(setf buffer-texture-backing-array)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-texture-owns-array} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-TEXTURE-OWNS-ARRAY function}@c
@functionsubindex{buffer-texture-owns-array}@c
@deffnx {Function} {(setf buffer-texture-owns-array)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-TEXTURE-OWNS-ARRAY) function}@c
@functionsubindex{(setf buffer-texture-owns-array)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-texture-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-TEXTURE-P function}@c
@functionsubindex{buffer-texture-p}@c

Return t if the given value is a `texture` who data is stored in a `gpu-buffer` as
opposed to the usual texture memory. Returns nil otherwise
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {c-array-dimensions} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY-DIMENSIONS function}@c
@functionsubindex{c-array-dimensions}@c

`C-ARRAY-DIMENSIONS` takes a `c-array` as an argument and returns the
dimensions of the c-array@*

You can also use the generic function `DIMENSIONS` to get the same
result.
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF C-ARRAY-DIMENSIONS) function, , @t{(setf c-array-dimensions)}} (function)
@end table
@end deffn
@deffn {Function} {(setf c-array-dimensions)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF C-ARRAY-DIMENSIONS) function}@c
@functionsubindex{(setf c-array-dimensions)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY-DIMENSIONS function, , @t{c-array-dimensions}} (function)
@end table
@end deffn
@deffn {Function} {c-array-element-byte-size} C-ARRAY
@anchor{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY-ELEMENT-BYTE-SIZE function}@c
@functionsubindex{c-array-element-byte-size}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {c-array-element-from-foreign} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY-ELEMENT-FROM-FOREIGN function}@c
@functionsubindex{c-array-element-from-foreign}@c
@deffnx {Function} {(setf c-array-element-from-foreign)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF C-ARRAY-ELEMENT-FROM-FOREIGN) function}@c
@functionsubindex{(setf c-array-element-from-foreign)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {c-array-element-pixel-format} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY-ELEMENT-PIXEL-FORMAT function}@c
@functionsubindex{c-array-element-pixel-format}@c
@deffnx {Function} {(setf c-array-element-pixel-format)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF C-ARRAY-ELEMENT-PIXEL-FORMAT) function}@c
@functionsubindex{(setf c-array-element-pixel-format)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {c-array-element-to-foreign} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY-ELEMENT-TO-FOREIGN function}@c
@functionsubindex{c-array-element-to-foreign}@c
@deffnx {Function} {(setf c-array-element-to-foreign)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF C-ARRAY-ELEMENT-TO-FOREIGN) function}@c
@functionsubindex{(setf c-array-element-to-foreign)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {c-array-element-type} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY-ELEMENT-TYPE function}@c
@functionsubindex{c-array-element-type}@c

`C-ARRAY-POINTER` takes a `c-array` as an argument and returns the
type of the elements of the array.@*

You can also use the generic function `ELEMENT-TYPE` to get the same
result.
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF C-ARRAY-ELEMENT-TYPE) function, , @t{(setf c-array-element-type)}} (function)
@end table
@end deffn
@deffn {Function} {(setf c-array-element-type)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF C-ARRAY-ELEMENT-TYPE) function}@c
@functionsubindex{(setf c-array-element-type)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY-ELEMENT-TYPE function, , @t{c-array-element-type}} (function)
@end table
@end deffn
@deffn {Function} {c-array-free} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY-FREE function}@c
@functionsubindex{c-array-free}@c
@deffnx {Function} {(setf c-array-free)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF C-ARRAY-FREE) function}@c
@functionsubindex{(setf c-array-free)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {c-array-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY-P function}@c
@functionsubindex{c-array-p}@c

Return t if the argument is a `c-array`. Returns nil otherwise.
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {c-array-pointer} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY-POINTER function}@c
@functionsubindex{c-array-pointer}@c

`C-ARRAY-POINTER` takes a `c-array` as an argument and returns the
pointer to the foreign data.@*

You can also use the generic function `POINTER` to get the same result.
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF C-ARRAY-POINTER) function, , @t{(setf c-array-pointer)}} (function)
@end table
@end deffn
@deffn {Function} {(setf c-array-pointer)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF C-ARRAY-POINTER) function}@c
@functionsubindex{(setf c-array-pointer)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY-POINTER function, , @t{c-array-pointer}} (function)
@end table
@end deffn
@deffn {Function} {c-array-row-alignment} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY-ROW-ALIGNMENT function}@c
@functionsubindex{c-array-row-alignment}@c
@deffnx {Function} {(setf c-array-row-alignment)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF C-ARRAY-ROW-ALIGNMENT) function}@c
@functionsubindex{(setf c-array-row-alignment)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {c-array-sizes} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY-SIZES function}@c
@functionsubindex{c-array-sizes}@c
@deffnx {Function} {(setf c-array-sizes)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF C-ARRAY-SIZES) function}@c
@functionsubindex{(setf c-array-sizes)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {c-array-struct-element-typep} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY-STRUCT-ELEMENT-TYPEP function}@c
@functionsubindex{c-array-struct-element-typep}@c
@deffnx {Function} {(setf c-array-struct-element-typep)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF C-ARRAY-STRUCT-ELEMENT-TYPEP) function}@c
@functionsubindex{(setf c-array-struct-element-typep)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {c-array-total-size} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY-TOTAL-SIZE function}@c
@functionsubindex{c-array-total-size}@c
@deffnx {Function} {(setf c-array-total-size)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF C-ARRAY-TOTAL-SIZE) function}@c
@functionsubindex{(setf c-array-total-size)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {calc-block-layout} LAYOUT-SPECIFIER VARJO-STRUCT-TYPE-NAME
@anchor{go to the %CEPL<dot>TYPES<colon><colon>CALC-BLOCK-LAYOUT function}@c
@functionsubindex{calc-block-layout}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/layout<dot>lisp file, , @t{core/types/layout.lisp}} (file)
@end table
@end deffn
@deffn {Function} {calc-struct-layout-from-name-type-pairs} LAYOUT-SPECIFIER NAME NAME-TYPE-PAIRS
@anchor{go to the %CEPL<dot>TYPES<colon><colon>CALC-STRUCT-LAYOUT-FROM-NAME-TYPE-PAIRS function}@c
@functionsubindex{calc-struct-layout-from-name-type-pairs}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/layout<dot>lisp file, , @t{core/types/layout.lisp}} (file)
@end table
@end deffn
@deffn {Function} {can-bind-query-p} CEPL-CONTEXT QUERY
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>CAN-BIND-QUERY-P function}@c
@functionsubindex{can-bind-query-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl-context} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>CEPL-CONTEXT function}@c
@functionsubindex{cepl-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl-describe} NAME &optional STREAM
@anchor{go to the CEPL<colon><colon>CEPL-DESCRIBE function}@c
@functionsubindex{cepl-describe}@c
@table @strong
@item Package
@ref{go to the CEPL package, , @t{cepl}}
@item Source
@ref{go to the cepl/core/repl<dot>lisp file, , @t{core/repl.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cffi-type->gl-type} TYPE
@anchor{go to the CEPL<dot>INTERNALS<colon><colon>CFFI-TYPE->GL-TYPE function}@c
@functionsubindex{cffi-type->gl-type}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>INTERNALS package, , @t{cepl.internals}}
@item Source
@ref{go to the cepl/core/internals<dot>lisp file, , @t{core/internals.lisp}} (file)
@end table
@end deffn
@deffn {Function} {check-array-sizes-for-copy} SRC-DIMS DST-DIMS
@anchor{go to the %CEPL<dot>TYPES<colon><colon>CHECK-ARRAY-SIZES-FOR-COPY function}@c
@functionsubindex{check-array-sizes-for-copy}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/checks<dot>lisp file, , @t{core/types/checks.lisp}} (file)
@end table
@end deffn
@deffn {Function} {check-array-types-for-copy} SRC-ELEM-TYPE DST-ELEM-TYPE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>CHECK-ARRAY-TYPES-FOR-COPY function}@c
@functionsubindex{check-array-types-for-copy}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/checks<dot>lisp file, , @t{core/types/checks.lisp}} (file)
@end table
@end deffn
@deffn {Function} {check-framebuffer-status} FBO
@anchor{go to the CEPL<dot>FBOS<colon><colon>CHECK-FRAMEBUFFER-STATUS function}@c
@functionsubindex{check-framebuffer-status}@c

This function asks OpenGL to check the given `FBO` and ensure that it is@*
'complete'.@*

This function will either return the particular 'framebuffer complete' flag or@*
will throw a condition with an explanation of the problem.@*

For a full rundown on what it means for a fbo to be complete see:@*
[glwiki- framebuffer completeness](https://www.opengl.org/wiki/Framebuffer_Object#Framebuffer_Completeness)

All fbos made in CEPL using `make-fbo` are checked for completeness before@*
being returned to the user.
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {clear} &optional TARGET
@anchor{go to the CEPL<dot>FBOS<colon><colon>CLEAR function}@c
@functionsubindex{clear}@c

What this function will clear depends on what is passed:@*

- a `fbo` - See 'clearing fbos' below@*
- an `attachment` - See 'clearing a single attachment' below@*
- nothing - The 'current fbo' will be cleared@*

**-- Clearing Fbos --**@*

In this case clearing means that all the elements of the attachments will be set
to a certain value. The value that the attachment's `gpu-array`s will be set to
varies based on the attachment.@*

- color attachments: Will be set to the value set in #'gl:clear-color@*
- depth attachments: Will be set to the value set in #'gl:clear-depth@*
- stencil attachments: Will be set to the value set in #'gl:clear-stencil@*

You can also use `clear-fbo` for this task@*


**-- Clearing a single attachment --**@*

Not currently implemented
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {clear-attachment} ATTACHMENT
@anchor{go to the CEPL<dot>FBOS<colon><colon>CLEAR-ATTACHMENT function}@c
@functionsubindex{clear-attachment}@c

Not currently implemented@*

This function will clear a single `attachment` of a `fbo`.
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {clear-color} &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>CLEAR-COLOR function}@c
@functionsubindex{clear-color}@c
@deffnx {Function} {(setf clear-color)} VEC4-COLOR &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF CLEAR-COLOR) function}@c
@functionsubindex{(setf clear-color)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/color/color<dot>lisp file, , @t{core/color/color.lisp}} (file)
@end table
@end deffn
@deffn {Function} {clear-fbo} FBO
@anchor{go to the CEPL<dot>FBOS<colon><colon>CLEAR-FBO function}@c
@functionsubindex{clear-fbo}@c

This function will set the elements of the `attachment`s of the `fbo` to a
certain value. The value that the attachment's `gpu-array`s will be set to
varies based on the attachment.@*

- color attachments: Will be set to the value set in #'gl:clear-color
- depth attachments: Will be set to the value set in #'gl:clear-depth
- stencil attachments: Will be set to the value set in #'gl:clear-stencil

You can also perform this action by calling `clear` with an fbo
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {clone-c-array} C-ARRAY
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>CLONE-C-ARRAY function}@c
@functionsubindex{clone-c-array}@c

Takes a `c-array` and makes a new c-array with the same contents as the the
original. The contents in foreign memory are copied.
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/make<dot>lisp file, , @t{core/c-arrays/make.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cls} ()
@anchor{go to the CEPL<colon><colon>CLS function}@c
@functionsubindex{cls}@c

CLS is here as it reminds me of qbasic and that makes me happy.@*

It calls #'clear and #'swap twice so dont use this in your actually rendering
code. It can be handy though if you want to clear the screen from the repl.
@table @strong
@item Package
@ref{go to the CEPL package, , @t{cepl}}
@item Source
@ref{go to the cepl/core/repl<dot>lisp file, , @t{core/repl.lisp}} (file)
@end table
@end deffn
@deffn {Function} {color-attachment-enum} ATTACHMENT-NUM
@anchor{go to the CEPL<dot>INTERNALS<colon><colon>COLOR-ATTACHMENT-ENUM function}@c
@functionsubindex{color-attachment-enum}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>INTERNALS package, , @t{cepl.internals}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {color-mask} INDEX &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>COLOR-MASK function}@c
@functionsubindex{color-mask}@c
@deffnx {Function} {(setf color-mask)} VALUE INDEX &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF COLOR-MASK) function}@c
@functionsubindex{(setf color-mask)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/color/color<dot>lisp file, , @t{core/color/color.lisp}} (file)
@end table
@end deffn
@deffn {Function} {color-masks} &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>COLOR-MASKS function}@c
@functionsubindex{color-masks}@c
@deffnx {Function} {(setf color-masks)} VALUE &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF COLOR-MASKS) function}@c
@functionsubindex{(setf color-masks)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/color/color<dot>lisp file, , @t{core/color/color.lisp}} (file)
@end table
@end deffn
@deffn {Function} {color-renderable-formatp} FORMAT
@anchor{go to the CEPL<dot>IMAGE-FORMATS<colon><colon>COLOR-RENDERABLE-FORMATP function}@c
@functionsubindex{color-renderable-formatp}@c

This function returns t if the value provided is a keyword that can be found in
*color-renderable-formats*
@table @strong
@item Package
@ref{go to the CEPL<dot>IMAGE-FORMATS package, , @t{cepl.image-formats}}
@item Source
@ref{go to the cepl/core/types/image-format<dot>lisp file, , @t{core/types/image-format.lisp}} (file)
@end table
@end deffn
@deffn {Function} {compare} SAMPLER
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COMPARE function}@c
@functionsubindex{compare}@c

This function sets the comparison mode of the `texture` or `sampler` given@*

-WARNING-@*

This feature is currently unsupported until shadow samplers are more fully
tested in CEPL. Use at your own risk@*


**-- Comparison --**@*

Depth `texture`s (textures that have a depth component image format) can be
sampled in one of two ways. They can be sampled as a normal texture, which
simply retrieves the depth value (with filtering applied). This will return a
vec4 containing a single floating-point value.@*

They can also be fetched in comparison mode. This means that sampling from
the texture requires a value to compare to those pulled from the texture;
this value is called the reference value. The result of the comparison
depends on the comparison function set in the texture. If the function
succeeds, the resulting value is 1s0; if it fails, it is 0s0.@*

When linear filtering is used, the actual returned value is
implementation-defined. However, the value will be on the range 0  1 and
will be proportional to the number of neighboring texels that pass the
comparison based on the single given value.@*

If the texture is a normalized integer depth format, then the reference value
is clamped to 0  1, to match the values from the texture. Otherwise, the value
is not clamped.@*

Using this mode requires two special settings. First, the sampler used in GLSL
must be a shadow sampler. Second, the texture used in that sampler must have
activated depth comparison mode. Attempting to use a texture without comparison
with a shadow sampler, or vice-versa, will result in an error upon rendering.

To set the texture to comparison mode, set the :texture-compare-mode
texture parameter to :compare-ref-to-texture. The comparison function to
use when comparing the reference to the texture is set with the
:texture-compare-func texture parameter. Acceptable values are:@*

    :never (always fails)@*
    :always (always succeeds)@*
    :less@*
    :lequal@*
    :equal,@*
    :not-equal@*
    :gequal@*
    :greater@*

The comparison works as follows:@*

    (funcall operator ref texture)@*

where ref is the reference value given to the texture lookup function by
GLSL, and texture is the value fetched from the texture. So :LESS will be
true if the reference value is strictly less than the value pulled from the
texture.
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF COMPARE) function, , @t{(setf compare)}} (function)
@end table
@end deffn
@deffn {Function} {(setf compare)} VALUE SAMPLER
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF COMPARE) function}@c
@functionsubindex{(setf compare)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>COMPARE function, , @t{compare}} (function)
@end table
@end deffn
@deffn {Function} {compile-g} NAME &optional DEFINITION
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>COMPILE-G function}@c
@functionsubindex{compile-g}@c

This function takes a lambda-g form and compiles it to a gpu-lambda object.

This is used for similar reasons to `compile` in Common Lisp, you have a
lambda definition as lists and you want a compiled lambda.@*

The result of this function is suitable for passing to pipeline-g which lets
you define a map-g'able pipeline at runtime.@*

Whilst this shares the same signature as CL's #'compile in our version the
'name' argument must be nil.
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-lambda<dot>lisp file, , @t{core/pipelines/gpu-lambda.lisp}} (file)
@end table
@end deffn
@deffn {Function} {compute-space-as-uvec3} SPACE
@anchor{go to the CEPL<dot>COMPUTE<colon><colon>COMPUTE-SPACE-AS-UVEC3 function}@c
@functionsubindex{compute-space-as-uvec3}@c
@deffnx {Function} {(setf compute-space-as-uvec3)} VALUE SPACE
@anchor{go to the CEPL<dot>COMPUTE<colon><colon>(SETF COMPUTE-SPACE-AS-UVEC3) function}@c
@functionsubindex{(setf compute-space-as-uvec3)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>COMPUTE package, , @t{cepl.compute}}
@item Source
@ref{go to the cepl/core/compute/compute<dot>lisp file, , @t{core/compute/compute.lisp}} (file)
@end table
@end deffn
@deffn {Function} {compute-space-dimensions} SPACE
@anchor{go to the CEPL<dot>COMPUTE<colon><colon>COMPUTE-SPACE-DIMENSIONS function}@c
@functionsubindex{compute-space-dimensions}@c
@deffnx {Function} {(setf compute-space-dimensions)} VALUE SPACE
@anchor{go to the CEPL<dot>COMPUTE<colon><colon>(SETF COMPUTE-SPACE-DIMENSIONS) function}@c
@functionsubindex{(setf compute-space-dimensions)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>COMPUTE package, , @t{cepl.compute}}
@item Source
@ref{go to the cepl/core/compute/compute<dot>lisp file, , @t{core/compute/compute.lisp}} (file)
@end table
@end deffn
@deffn {Function} {compute-space-size-x} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COMPUTE-SPACE-SIZE-X function}@c
@functionsubindex{compute-space-size-x}@c
@deffnx {Function} {(setf compute-space-size-x)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF COMPUTE-SPACE-SIZE-X) function}@c
@functionsubindex{(setf compute-space-size-x)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {compute-space-size-y} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COMPUTE-SPACE-SIZE-Y function}@c
@functionsubindex{compute-space-size-y}@c
@deffnx {Function} {(setf compute-space-size-y)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF COMPUTE-SPACE-SIZE-Y) function}@c
@functionsubindex{(setf compute-space-size-y)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {compute-space-size-z} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COMPUTE-SPACE-SIZE-Z function}@c
@functionsubindex{compute-space-size-z}@c
@deffnx {Function} {(setf compute-space-size-z)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF COMPUTE-SPACE-SIZE-Z) function}@c
@functionsubindex{(setf compute-space-size-z)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {consecutive-integers-p} INTEGERS
@anchor{go to the CEPL-UTILS<colon><colon>CONSECUTIVE-INTEGERS-P function}@c
@functionsubindex{consecutive-integers-p}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {context-id} CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>CONTEXT-ID function}@c
@functionsubindex{context-id}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-blending-params} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-BLENDING-PARAMS function}@c
@functionsubindex{copy-blending-params}@c

This function, when passed a `blending-params` object, will create a new
blending-params object with the same settings as the one passed.
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-buffer-backed-gpu-array-to-new-c-array} SRC
@anchor{go to the CEPL<dot>GPU-ARRAYS<colon><colon>COPY-BUFFER-BACKED-GPU-ARRAY-TO-NEW-C-ARRAY function}@c
@functionsubindex{copy-buffer-backed-gpu-array-to-new-c-array}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS package, , @t{cepl.gpu-arrays}}
@item Source
@ref{go to the cepl/core/gpu-arrays/with-and-push<dot>lisp file, , @t{core/gpu-arrays/with-and-push.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-buffer-backed-gpu-array-to-new-lisp-data} SRC
@anchor{go to the CEPL<dot>GPU-ARRAYS<colon><colon>COPY-BUFFER-BACKED-GPU-ARRAY-TO-NEW-LISP-DATA function}@c
@functionsubindex{copy-buffer-backed-gpu-array-to-new-lisp-data}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS package, , @t{cepl.gpu-arrays}}
@item Source
@ref{go to the cepl/core/gpu-arrays/with-and-push<dot>lisp file, , @t{core/gpu-arrays/with-and-push.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-buffer-backed-gpu-array-to-texture-backed-gpu-array} SRC DST
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>COPY-BUFFER-BACKED-GPU-ARRAY-TO-TEXTURE-BACKED-GPU-ARRAY function}@c
@functionsubindex{copy-buffer-backed-gpu-array-to-texture-backed-gpu-array}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-c-array-to-buffer-backed-gpu-array} SRC DST
@anchor{go to the CEPL<dot>GPU-ARRAYS<colon><colon>COPY-C-ARRAY-TO-BUFFER-BACKED-GPU-ARRAY function}@c
@functionsubindex{copy-c-array-to-buffer-backed-gpu-array}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS package, , @t{cepl.gpu-arrays}}
@item Source
@ref{go to the cepl/core/gpu-arrays/with-and-push<dot>lisp file, , @t{core/gpu-arrays/with-and-push.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-c-array-to-new-lisp-data} SRC
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>COPY-C-ARRAY-TO-NEW-LISP-DATA function}@c
@functionsubindex{copy-c-array-to-new-lisp-data}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/rest<dot>lisp file, , @t{core/c-arrays/rest.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-c-array-to-texture-backed-gpu-array} SRC DST
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>COPY-C-ARRAY-TO-TEXTURE-BACKED-GPU-ARRAY function}@c
@functionsubindex{copy-c-array-to-texture-backed-gpu-array}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-lisp-data-to-buffer-backed-gpu-array} SRC DST
@anchor{go to the CEPL<dot>GPU-ARRAYS<colon><colon>COPY-LISP-DATA-TO-BUFFER-BACKED-GPU-ARRAY function}@c
@functionsubindex{copy-lisp-data-to-buffer-backed-gpu-array}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS package, , @t{cepl.gpu-arrays}}
@item Source
@ref{go to the cepl/core/gpu-arrays/with-and-push<dot>lisp file, , @t{core/gpu-arrays/with-and-push.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-lisp-data-to-c-array} C-ARRAY DATA &optional CHECK-SIZES
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>COPY-LISP-DATA-TO-C-ARRAY function}@c
@functionsubindex{copy-lisp-data-to-c-array}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/populate<dot>lisp file, , @t{core/c-arrays/populate.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-lisp-data-to-texture-backed-gpu-array} SRC DST
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>COPY-LISP-DATA-TO-TEXTURE-BACKED-GPU-ARRAY function}@c
@functionsubindex{copy-lisp-data-to-texture-backed-gpu-array}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-texture-backed-gpu-array-to-buffer-backed-gpu-array} SRC DST
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>COPY-TEXTURE-BACKED-GPU-ARRAY-TO-BUFFER-BACKED-GPU-ARRAY function}@c
@functionsubindex{copy-texture-backed-gpu-array-to-buffer-backed-gpu-array}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-texture-backed-gpu-array-to-c-array} SRC DST
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>COPY-TEXTURE-BACKED-GPU-ARRAY-TO-C-ARRAY function}@c
@functionsubindex{copy-texture-backed-gpu-array-to-c-array}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-texture-backed-gpu-array-to-new-buffer-backed-gpu-array} SRC
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>COPY-TEXTURE-BACKED-GPU-ARRAY-TO-NEW-BUFFER-BACKED-GPU-ARRAY function}@c
@functionsubindex{copy-texture-backed-gpu-array-to-new-buffer-backed-gpu-array}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-texture-backed-gpu-array-to-new-c-array} SRC
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>COPY-TEXTURE-BACKED-GPU-ARRAY-TO-NEW-C-ARRAY function}@c
@functionsubindex{copy-texture-backed-gpu-array-to-new-c-array}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-texture-backed-gpu-array-to-new-lisp-data} SRC
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>COPY-TEXTURE-BACKED-GPU-ARRAY-TO-NEW-LISP-DATA function}@c
@functionsubindex{copy-texture-backed-gpu-array-to-new-lisp-data}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-viewport} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-VIEWPORT function}@c
@functionsubindex{copy-viewport}@c

This function returns a new `viewport` with identical origin and resolution to the
viewport provided.
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cull-face} &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>CULL-FACE function}@c
@functionsubindex{cull-face}@c
@deffnx {Function} {(setf cull-face)} FACE &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF CULL-FACE) function}@c
@functionsubindex{(setf cull-face)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/face/face<dot>lisp file, , @t{core/face/face.lisp}} (file)
@end table
@end deffn
@deffn {Function} {current-stencil-params} FACE &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>STENCIL<colon><colon>CURRENT-STENCIL-PARAMS function}@c
@functionsubindex{current-stencil-params}@c
@deffnx {Function} {(setf current-stencil-params)} PARAMS FACE &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>STENCIL<colon><colon>(SETF CURRENT-STENCIL-PARAMS) function}@c
@functionsubindex{(setf current-stencil-params)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>STENCIL package, , @t{cepl.stencil}}
@item Source
@ref{go to the cepl/core/stencil/stencil<dot>lisp file, , @t{core/stencil/stencil.lisp}} (file)
@end table
@end deffn
@deffn {Function} {current-surface} &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>CURRENT-SURFACE function}@c
@functionsubindex{current-surface}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {current-viewport} &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>VIEWPORTS<colon><colon>CURRENT-VIEWPORT function}@c
@functionsubindex{current-viewport}@c

This function returns the `viewport` that is current in this scope.@*

If no other code in the callstack has used `with-viewport` or `with-fbo-viewport`
then the result will be the default viewport.
@table @strong
@item Package
@ref{go to the CEPL<dot>VIEWPORTS package, , @t{cepl.viewports}}
@item Source
@ref{go to the cepl/core/viewports/viewport<dot>lisp file, , @t{core/viewports/viewport.lisp}} (file)
@end table
@end deffn
@deffn {Function} {depth-clamp} &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>DEPTH-CLAMP function}@c
@functionsubindex{depth-clamp}@c
@deffnx {Function} {(setf depth-clamp)} VALUE &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF DEPTH-CLAMP) function}@c
@functionsubindex{(setf depth-clamp)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/depth/depth<dot>lisp file, , @t{core/depth/depth.lisp}} (file)
@end table
@end deffn
@deffn {Function} {depth-formatp} FORMAT
@anchor{go to the CEPL<dot>IMAGE-FORMATS<colon><colon>DEPTH-FORMATP function}@c
@functionsubindex{depth-formatp}@c

This function returns t if the value provided is a keyword that can be found in
*depth-formats*
@table @strong
@item Package
@ref{go to the CEPL<dot>IMAGE-FORMATS package, , @t{cepl.image-formats}}
@item Source
@ref{go to the cepl/core/types/image-format<dot>lisp file, , @t{core/types/image-format.lisp}} (file)
@end table
@end deffn
@deffn {Function} {depth-mask} &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>DEPTH-MASK function}@c
@functionsubindex{depth-mask}@c
@deffnx {Function} {(setf depth-mask)} VALUE &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF DEPTH-MASK) function}@c
@functionsubindex{(setf depth-mask)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/depth/depth<dot>lisp file, , @t{core/depth/depth.lisp}} (file)
@end table
@end deffn
@deffn {Function} {depth-range-vec2} &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>DEPTH-RANGE-VEC2 function}@c
@functionsubindex{depth-range-vec2}@c
@deffnx {Function} {(setf depth-range-vec2)} VEC2-RANGE &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF DEPTH-RANGE-VEC2) function}@c
@functionsubindex{(setf depth-range-vec2)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/depth/depth<dot>lisp file, , @t{core/depth/depth.lisp}} (file)
@end table
@end deffn
@deffn {Function} {depth-stencil-formatp} FORMAT
@anchor{go to the CEPL<dot>IMAGE-FORMATS<colon><colon>DEPTH-STENCIL-FORMATP function}@c
@functionsubindex{depth-stencil-formatp}@c

This function returns t if the value provided is a keyword that can be found in
*depth-stencil-formats*
@table @strong
@item Package
@ref{go to the CEPL<dot>IMAGE-FORMATS package, , @t{cepl.image-formats}}
@item Source
@ref{go to the cepl/core/types/image-format<dot>lisp file, , @t{core/types/image-format.lisp}} (file)
@end table
@end deffn
@deffn {Function} {depth-test-function} &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>DEPTH-TEST-FUNCTION function}@c
@functionsubindex{depth-test-function}@c
@deffnx {Function} {(setf depth-test-function)} FUNCTION &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF DEPTH-TEST-FUNCTION) function}@c
@functionsubindex{(setf depth-test-function)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/depth/depth<dot>lisp file, , @t{core/depth/depth.lisp}} (file)
@end table
@end deffn
@deffn {Function} {destination-alpha} FBO &optional ATTACHMENT-NAME
@anchor{go to the CEPL<dot>BLENDING<colon><colon>DESTINATION-ALPHA function}@c
@functionsubindex{destination-alpha}@c

This function, when passed a `blending-params` object, will return the name of the
function that will be applied to the alpha value that is currently in the `fbo`
and is about to be combined with the value coming from the pipeline.@*

The result will be one of the following:@*

    :zero@*
    :one@*
    :src-color@*
    :one-minus-src-color@*
    :dst-color@*
    :one-minus-dst-color@*
    :src-alpha@*
    :one-minus-src-alpha@*
    :dst-alpha@*
    :one-minus-dst-alpha@*
    :constant-color@*
    :one-minus-constant-color@*
    :constant-alpha@*
    :one-minus-constant-alpha@*
    :src-alpha-saturate@*
    :src1-color@*
    :one-minus-src-color@*
    :src1-alpha@*
    :one-minus-src-alpha@*

To see more info on this subject please see the doc-string for the
blending-params struct.
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@item Writer
@ref{go to the CEPL<dot>BLENDING<colon><colon>(SETF DESTINATION-ALPHA) function, , @t{(setf destination-alpha)}} (function)
@end table
@end deffn
@deffn {Function} {(setf destination-alpha)} VALUE FBO &optional ATTACHMENT-NAME
@anchor{go to the CEPL<dot>BLENDING<colon><colon>(SETF DESTINATION-ALPHA) function}@c
@functionsubindex{(setf destination-alpha)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@item Reader
@ref{go to the CEPL<dot>BLENDING<colon><colon>DESTINATION-ALPHA function, , @t{destination-alpha}} (function)
@end table
@end deffn
@deffn {Function} {destination-rgb} FBO &optional ATTACHMENT-NAME
@anchor{go to the CEPL<dot>BLENDING<colon><colon>DESTINATION-RGB function}@c
@functionsubindex{destination-rgb}@c

This function, when passed a `blending-params` object, will return the name of the
function that will be applied to the color value that is currently in the `fbo`
and is about to be combined with the value coming from the pipeline.@*

The result will be one of the following:@*

    :zero@*
    :one@*
    :src-color@*
    :one-minus-src-color@*
    :dst-color@*
    :one-minus-dst-color@*
    :src-alpha@*
    :one-minus-src-alpha@*
    :dst-alpha@*
    :one-minus-dst-alpha@*
    :constant-color@*
    :one-minus-constant-color@*
    :constant-alpha@*
    :one-minus-constant-alpha@*
    :src-alpha-saturate@*
    :src1-color@*
    :one-minus-src-color@*
    :src1-alpha@*
    :one-minus-src-alpha@*

To see more info on this subject please see the doc-string for the
blending-params struct.
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@item Writer
@ref{go to the CEPL<dot>BLENDING<colon><colon>(SETF DESTINATION-RGB) function, , @t{(setf destination-rgb)}} (function)
@end table
@end deffn
@deffn {Function} {(setf destination-rgb)} VALUE FBO &optional ATTACHMENT-NAME
@anchor{go to the CEPL<dot>BLENDING<colon><colon>(SETF DESTINATION-RGB) function}@c
@functionsubindex{(setf destination-rgb)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@item Reader
@ref{go to the CEPL<dot>BLENDING<colon><colon>DESTINATION-RGB function, , @t{destination-rgb}} (function)
@end table
@end deffn
@deffn {Function} {destroy-surface} SURFACE &rest ARGS &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>DESTROY-SURFACE function}@c
@functionsubindex{destroy-surface}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Function} {double-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>DOUBLE-FROM-FOREIGN function}@c
@functionsubindex{double-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {double-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>DOUBLE-TO-FOREIGN function}@c
@functionsubindex{double-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {draw-fbo-bound} CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>DRAW-FBO-BOUND function}@c
@functionsubindex{draw-fbo-bound}@c
@deffnx {Function} {(setf draw-fbo-bound)} FBO CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF DRAW-FBO-BOUND) function}@c
@functionsubindex{(setf draw-fbo-bound)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {draw-mode-group-id} X
@anchor{go to the %CEPL<dot>TYPES<colon><colon>DRAW-MODE-GROUP-ID function}@c
@functionsubindex{draw-mode-group-id}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {elements-indirect-command-base-instance} WRAPPED-OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ELEMENTS-INDIRECT-COMMAND-BASE-INSTANCE function}@c
@functionsubindex{elements-indirect-command-base-instance}@c
@deffnx {Function} {(setf elements-indirect-command-base-instance)} VALUE WRAPPED-OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF ELEMENTS-INDIRECT-COMMAND-BASE-INSTANCE) function}@c
@functionsubindex{(setf elements-indirect-command-base-instance)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/multi-draw<dot>lisp file, , @t{core/pipelines/multi-draw.lisp}} (file)
@end table
@end deffn
@deffn {Function} {elements-indirect-command-base-vertex} WRAPPED-OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ELEMENTS-INDIRECT-COMMAND-BASE-VERTEX function}@c
@functionsubindex{elements-indirect-command-base-vertex}@c
@deffnx {Function} {(setf elements-indirect-command-base-vertex)} VALUE WRAPPED-OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF ELEMENTS-INDIRECT-COMMAND-BASE-VERTEX) function}@c
@functionsubindex{(setf elements-indirect-command-base-vertex)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/multi-draw<dot>lisp file, , @t{core/pipelines/multi-draw.lisp}} (file)
@end table
@end deffn
@deffn {Function} {elements-indirect-command-count} WRAPPED-OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ELEMENTS-INDIRECT-COMMAND-COUNT function}@c
@functionsubindex{elements-indirect-command-count}@c
@deffnx {Function} {(setf elements-indirect-command-count)} VALUE WRAPPED-OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF ELEMENTS-INDIRECT-COMMAND-COUNT) function}@c
@functionsubindex{(setf elements-indirect-command-count)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/multi-draw<dot>lisp file, , @t{core/pipelines/multi-draw.lisp}} (file)
@end table
@end deffn
@deffn {Function} {elements-indirect-command-first-index} WRAPPED-OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ELEMENTS-INDIRECT-COMMAND-FIRST-INDEX function}@c
@functionsubindex{elements-indirect-command-first-index}@c
@deffnx {Function} {(setf elements-indirect-command-first-index)} VALUE WRAPPED-OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF ELEMENTS-INDIRECT-COMMAND-FIRST-INDEX) function}@c
@functionsubindex{(setf elements-indirect-command-first-index)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/multi-draw<dot>lisp file, , @t{core/pipelines/multi-draw.lisp}} (file)
@end table
@end deffn
@deffn {Function} {elements-indirect-command-instance-count} WRAPPED-OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ELEMENTS-INDIRECT-COMMAND-INSTANCE-COUNT function}@c
@functionsubindex{elements-indirect-command-instance-count}@c
@deffnx {Function} {(setf elements-indirect-command-instance-count)} VALUE WRAPPED-OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF ELEMENTS-INDIRECT-COMMAND-INSTANCE-COUNT) function}@c
@functionsubindex{(setf elements-indirect-command-instance-count)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/multi-draw<dot>lisp file, , @t{core/pipelines/multi-draw.lisp}} (file)
@end table
@end deffn
@deffn {Function} {empty-fbo-params} FBO
@anchor{go to the %CEPL<dot>TYPES<colon><colon>EMPTY-FBO-PARAMS function}@c
@functionsubindex{empty-fbo-params}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {empty-fbo-params-dimensions} PARAMS
@anchor{go to the CEPL<dot>FBOS<colon><colon>EMPTY-FBO-PARAMS-DIMENSIONS function}@c
@functionsubindex{empty-fbo-params-dimensions}@c
@deffnx {Function} {(setf empty-fbo-params-dimensions)} VALUE PARAMS
@anchor{go to the CEPL<dot>FBOS<colon><colon>(SETF EMPTY-FBO-PARAMS-DIMENSIONS) function}@c
@functionsubindex{(setf empty-fbo-params-dimensions)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {empty-fbo-params-fixed-sample-locations-p} PARAMS
@anchor{go to the CEPL<dot>FBOS<colon><colon>EMPTY-FBO-PARAMS-FIXED-SAMPLE-LOCATIONS-P function}@c
@functionsubindex{empty-fbo-params-fixed-sample-locations-p}@c
@deffnx {Function} {(setf empty-fbo-params-fixed-sample-locations-p)} VALUE PARAMS
@anchor{go to the CEPL<dot>FBOS<colon><colon>(SETF EMPTY-FBO-PARAMS-FIXED-SAMPLE-LOCATIONS-P) function}@c
@functionsubindex{(setf empty-fbo-params-fixed-sample-locations-p)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {empty-fbo-params-layer-count} PARAMS
@anchor{go to the CEPL<dot>FBOS<colon><colon>EMPTY-FBO-PARAMS-LAYER-COUNT function}@c
@functionsubindex{empty-fbo-params-layer-count}@c
@deffnx {Function} {(setf empty-fbo-params-layer-count)} VALUE PARAMS
@anchor{go to the CEPL<dot>FBOS<colon><colon>(SETF EMPTY-FBO-PARAMS-LAYER-COUNT) function}@c
@functionsubindex{(setf empty-fbo-params-layer-count)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {empty-fbo-params-samples} PARAMS
@anchor{go to the CEPL<dot>FBOS<colon><colon>EMPTY-FBO-PARAMS-SAMPLES function}@c
@functionsubindex{empty-fbo-params-samples}@c
@deffnx {Function} {(setf empty-fbo-params-samples)} VALUE PARAMS
@anchor{go to the CEPL<dot>FBOS<colon><colon>(SETF EMPTY-FBO-PARAMS-SAMPLES) function}@c
@functionsubindex{(setf empty-fbo-params-samples)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {empty-fbo-params-viewport} PARAMS
@anchor{go to the CEPL<dot>FBOS<colon><colon>EMPTY-FBO-PARAMS-VIEWPORT function}@c
@functionsubindex{empty-fbo-params-viewport}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {ensure-vec-index} VEC INDEX NULL-ELEMENT &optional ELEMENT-TYPE
@anchor{go to the CEPL-UTILS<colon><colon>ENSURE-VEC-INDEX function}@c
@functionsubindex{ensure-vec-index}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {fbo-bound} CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>FBO-BOUND function}@c
@functionsubindex{fbo-bound}@c
@deffnx {Function} {(setf fbo-bound)} FBO CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF FBO-BOUND) function}@c
@functionsubindex{(setf fbo-bound)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {fbo-empty-p} FBO
@anchor{go to the %CEPL<dot>TYPES<colon><colon>FBO-EMPTY-P function}@c
@functionsubindex{fbo-empty-p}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {fbo-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>FBO-P function}@c
@functionsubindex{fbo-p}@c

This function will return t if the given value is an `fbo`, otherwise it will
return nil
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {file-to-string} PATH
@anchor{go to the CEPL-UTILS<colon><colon>FILE-TO-STRING function}@c
@functionsubindex{file-to-string}@c
Sucks up an entire file from PATH into a freshly-allocated
   string, returning two values: the string and the number of
   bytes read.
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {filter-hash} FUNCTION HASH-TABLE
@anchor{go to the CEPL-UTILS<colon><colon>FILTER-HASH function}@c
@functionsubindex{filter-hash}@c
map through a hash and actually return something
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {find-in-tree} ITEM TREE &key TEST
@anchor{go to the CEPL-UTILS<colon><colon>FIND-IN-TREE function}@c
@functionsubindex{find-in-tree}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {flatten} X
@anchor{go to the CEPL-UTILS<colon><colon>FLATTEN function}@c
@functionsubindex{flatten}@c
Walks a list tree and flattens it (returns a 1d list
   containing all the elements from the tree)
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {float-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>FLOAT-FROM-FOREIGN function}@c
@functionsubindex{float-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {float-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>FLOAT-TO-FOREIGN function}@c
@functionsubindex{float-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {force-bind-query} CEPL-CONTEXT QUERY
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>FORCE-BIND-QUERY function}@c
@functionsubindex{force-bind-query}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {force-unbind-query} CEPL-CONTEXT QUERY
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>FORCE-UNBIND-QUERY function}@c
@functionsubindex{force-unbind-query}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {free-buffer} BUFFER
@anchor{go to the CEPL<dot>GPU-BUFFERS<colon><colon>FREE-BUFFER function}@c
@functionsubindex{free-buffer}@c

This function, when passed a `gpu-buffer` will free the memory on the gpu and
'blank' the `gpu-buffer`.@*

Blanking in this case means that the slots of the `gpu-buffer` will all be set to
default values.
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-BUFFERS package, , @t{cepl.gpu-buffers}}
@item Source
@ref{go to the cepl/core/gpu-buffers/gpu-buffers<dot>lisp file, , @t{core/gpu-buffers/gpu-buffers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {free-buffer-stream} BUFFER-STREAM
@anchor{go to the CEPL<dot>STREAMS<colon><colon>FREE-BUFFER-STREAM function}@c
@functionsubindex{free-buffer-stream}@c

Calling this with a buffer-stream will free the VAO owned by this buffer-stream
and blank the buffer-stream object.@*

It will not free any of the gpu-data that was composed to make this stream.@*

Calling the generic function `free` with a buffer-stream will call this function
@table @strong
@item Package
@ref{go to the CEPL<dot>STREAMS package, , @t{cepl.streams}}
@item Source
@ref{go to the cepl/core/streams/buffer-streams<dot>lisp file, , @t{core/streams/buffer-streams.lisp}} (file)
@end table
@end deffn
@deffn {Function} {free-buffers} BUFFERS
@anchor{go to the CEPL<dot>GPU-BUFFERS<colon><colon>FREE-BUFFERS function}@c
@functionsubindex{free-buffers}@c

This function, when passed a list of  gpus-buffer will free the gpu memory for
all the gpus-buffers and 'blank' them.@*

Blanking in this case means that the slots of each `gpu-buffer` will all be set to
default values.
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-BUFFERS package, , @t{cepl.gpu-buffers}}
@item Source
@ref{go to the cepl/core/gpu-buffers/gpu-buffers<dot>lisp file, , @t{core/gpu-buffers/gpu-buffers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {free-c-array} C-ARRAY
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>FREE-C-ARRAY function}@c
@functionsubindex{free-c-array}@c

Frees the foreign memory allocated with the `c-array` and 'blanks' the c-array.

Blanking the c-array means its fields will be set to default values,@*
for example dimensions will be 0, the pointer will be null etc.@*

The generic function `free` will call `free-c-array` when passed a c-array.
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/def<dot>lisp file, , @t{core/c-arrays/def.lisp}} (file)
@end table
@end deffn
@deffn {Function} {free-gpu-fence} FENCE
@anchor{go to the CEPL<dot>SYNC<colon><colon>FREE-GPU-FENCE function}@c
@functionsubindex{free-gpu-fence}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SYNC package, , @t{cepl.sync}}
@item Source
@ref{go to the cepl/core/sync/sync<dot>lisp file, , @t{core/sync/sync.lisp}} (file)
@end table
@end deffn
@deffn {Function} {free-pipeline} PIPELINE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>FREE-PIPELINE function}@c
@functionsubindex{free-pipeline}@c

This function takes a pipeline designator[0] and frees it, this releases
frees the gl-program object.@*

[0] either a lambda-pipeline or a symbol naming a pipeline
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {free-sampler} SAMPLER
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>FREE-SAMPLER function}@c
@functionsubindex{free-sampler}@c

Calling this with a `sampler` will free the gl sampler and blank the lisp object representing it.

Calling the generic function `free` with a sampler will call this function
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {free-vao} VAO
@anchor{go to the CEPL<dot>VAOS<colon><colon>FREE-VAO function}@c
@functionsubindex{free-vao}@c

Takes a GL VAO and deletes it
@table @strong
@item Package
@ref{go to the CEPL<dot>VAOS package, , @t{cepl.vaos}}
@item Source
@ref{go to the cepl/core/vaos/vaos<dot>lisp file, , @t{core/vaos/vaos.lisp}} (file)
@end table
@end deffn
@deffn {Function} {free-vaos} VAOS
@anchor{go to the CEPL<dot>VAOS<colon><colon>FREE-VAOS function}@c
@functionsubindex{free-vaos}@c

Takes a list of GL VAOs and deletes them.

This function exists as a minor optimization.
@table @strong
@item Package
@ref{go to the CEPL<dot>VAOS package, , @t{cepl.vaos}}
@item Source
@ref{go to the cepl/core/vaos/vaos<dot>lisp file, , @t{core/vaos/vaos.lisp}} (file)
@end table
@end deffn
@deffn {Function} {front-face} &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>FRONT-FACE function}@c
@functionsubindex{front-face}@c
@deffnx {Function} {(setf front-face)} WINDING-DIRECTION &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF FRONT-FACE) function}@c
@functionsubindex{(setf front-face)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/face/face<dot>lisp file, , @t{core/face/face.lisp}} (file)
@end table
@end deffn
@deffn {Function} {funcall-g} NAME &rest ARGS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>FUNCALL-G function}@c
@functionsubindex{funcall-g}@c

funcall-g is an experimental function. What it aims to allow you to do is to
generate and run a pipeline which runs the requested function once with the
given arguments on the GPU.@*

By doing this it gives you a way to try out your gpu-functions from the REPL
without having to make a pipeline map-g over it whilst use ssbos or
transform-feedback to capture the result.@*

Currently this only works with functions that would work within a vertex
shader  (so things like gl-frag-pos will not work) however we want to expand on
this in the future.@*

This is not intended to be used *anywhere* where performance matters, it was
made solely as a debugging/development aid. Every time it is run it must:@*

- generate a pipeline@*
- compile it@*
- map-g over it@*
- marshal the results back to lisp@*
- free the pipeline@*

This is *extremly* expensive, however as long as it takes less that 20ms or so
it is fast enough for use from the repl.
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/funcall-g<dot>lisp file, , @t{core/pipelines/funcall-g.lisp}} (file)
@end table
@end deffn
@deffn {Function} {generate-mipmaps} TEXTURE
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>GENERATE-MIPMAPS function}@c
@functionsubindex{generate-mipmaps}@c

Calling this with a `texture` asks OpenGL to generate mipmaps for the texture.

You do not normally need to use this function as you can use the :mipmaps
argument on `make-texture`. See `make-texture` for more details.
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gl-enum} KWD
@anchor{go to the CEPL-UTILS<colon><colon>GL-ENUM function}@c
@functionsubindex{gl-enum}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gl-initialized-p} &optional CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>GL-INITIALIZED-P function}@c
@functionsubindex{gl-initialized-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gl-type-size} TYPE
@anchor{go to the CEPL<dot>INTERNALS<colon><colon>GL-TYPE-SIZE function}@c
@functionsubindex{gl-type-size}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>INTERNALS package, , @t{cepl.internals}}
@item Source
@ref{go to the cepl/core/internals<dot>lisp file, , @t{core/internals.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-array-access-style} GPU-ARRAY
@anchor{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED<colon><colon>GPU-ARRAY-ACCESS-STYLE function}@c
@functionsubindex{gpu-array-access-style}@c

When passed a buffer-backed `gpu-array` this function will return the access-style
of the underlying gpu-buffer.@*

The access-style of a gpu-array (or `gpu-buffer`) is a hint to OpenGL on how you
intend to use the array. It is optional whether your gpu manufacturer's
implementation of GL takes any notice of this option. When they do take notice
of it, it will to optimize access to the underlying data.@*

There are also no repercussions for accessing the data in a way contrary to the
declared access-style (other than potential performance costs).
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED package, , @t{cepl.gpu-arrays.buffer-backed}}
@item Source
@ref{go to the cepl/core/gpu-arrays/buffer-backed<dot>lisp file, , @t{core/gpu-arrays/buffer-backed.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-array-bb-access-style} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB-ACCESS-STYLE function}@c
@functionsubindex{gpu-array-bb-access-style}@c
@deffnx {Function} {(setf gpu-array-bb-access-style)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-BB-ACCESS-STYLE) function}@c
@functionsubindex{(setf gpu-array-bb-access-style)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-array-bb-buffer} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB-BUFFER function}@c
@functionsubindex{gpu-array-bb-buffer}@c
@deffnx {Function} {(setf gpu-array-bb-buffer)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-BB-BUFFER) function}@c
@functionsubindex{(setf gpu-array-bb-buffer)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-array-bb-byte-size} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB-BYTE-SIZE function}@c
@functionsubindex{gpu-array-bb-byte-size}@c
@deffnx {Function} {(setf gpu-array-bb-byte-size)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-BB-BYTE-SIZE) function}@c
@functionsubindex{(setf gpu-array-bb-byte-size)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-array-bb-element-byte-size} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB-ELEMENT-BYTE-SIZE function}@c
@functionsubindex{gpu-array-bb-element-byte-size}@c
@deffnx {Function} {(setf gpu-array-bb-element-byte-size)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-BB-ELEMENT-BYTE-SIZE) function}@c
@functionsubindex{(setf gpu-array-bb-element-byte-size)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-array-bb-element-pixel-format} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB-ELEMENT-PIXEL-FORMAT function}@c
@functionsubindex{gpu-array-bb-element-pixel-format}@c
@deffnx {Function} {(setf gpu-array-bb-element-pixel-format)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-BB-ELEMENT-PIXEL-FORMAT) function}@c
@functionsubindex{(setf gpu-array-bb-element-pixel-format)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-array-bb-element-type} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB-ELEMENT-TYPE function}@c
@functionsubindex{gpu-array-bb-element-type}@c
@deffnx {Function} {(setf gpu-array-bb-element-type)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-BB-ELEMENT-TYPE) function}@c
@functionsubindex{(setf gpu-array-bb-element-type)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-array-bb-offset-in-bytes-into-buffer} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB-OFFSET-IN-BYTES-INTO-BUFFER function}@c
@functionsubindex{gpu-array-bb-offset-in-bytes-into-buffer}@c
@deffnx {Function} {(setf gpu-array-bb-offset-in-bytes-into-buffer)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-BB-OFFSET-IN-BYTES-INTO-BUFFER) function}@c
@functionsubindex{(setf gpu-array-bb-offset-in-bytes-into-buffer)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-array-bb-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB-P function}@c
@functionsubindex{gpu-array-bb-p}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-array-bb-row-alignment} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB-ROW-ALIGNMENT function}@c
@functionsubindex{gpu-array-bb-row-alignment}@c
@deffnx {Function} {(setf gpu-array-bb-row-alignment)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-BB-ROW-ALIGNMENT) function}@c
@functionsubindex{(setf gpu-array-bb-row-alignment)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-array-buffer} GPU-ARRAY
@anchor{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED<colon><colon>GPU-ARRAY-BUFFER function}@c
@functionsubindex{gpu-array-buffer}@c

When passed a buffer-backed `gpu-array` this function will return the `gpu-buffer`
backing this array.@*

Note that if you made the array with `make-gpu-arrays` then there will be
multiple gpu-arrays sharing this buffer, so care should be taken when modifying
or freeing data.
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED package, , @t{cepl.gpu-arrays.buffer-backed}}
@item Source
@ref{go to the cepl/core/gpu-arrays/buffer-backed<dot>lisp file, , @t{core/gpu-arrays/buffer-backed.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-array-dimensions} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-DIMENSIONS function}@c
@functionsubindex{gpu-array-dimensions}@c

Return a list whose elements are the dimensions of the array.@*

You can also use the generic function `dimensions` to get this info.
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-DIMENSIONS) function, , @t{(setf gpu-array-dimensions)}} (function)
@end table
@end deffn
@deffn {Function} {(setf gpu-array-dimensions)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-DIMENSIONS) function}@c
@functionsubindex{(setf gpu-array-dimensions)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-DIMENSIONS function, , @t{gpu-array-dimensions}} (function)
@end table
@end deffn
@deffn {Function} {gpu-array-element-type} GPU-ARRAY
@anchor{go to the CEPL<dot>GPU-ARRAYS<colon><colon>GPU-ARRAY-ELEMENT-TYPE function}@c
@functionsubindex{gpu-array-element-type}@c

Will return the type of the elements in the `gpu-array` given.@*

If this is a texture-backed gpu-array then the element-type will be the same as
the 'image-format' of the `texture`.
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS package, , @t{cepl.gpu-arrays}}
@item Source
@ref{go to the cepl/core/gpu-arrays/with-and-push<dot>lisp file, , @t{core/gpu-arrays/with-and-push.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-array-face-num} GPU-ARRAY
@anchor{go to the CEPL<dot>GPU-ARRAYS<dot>TEXTURE-BACKED<colon><colon>GPU-ARRAY-FACE-NUM function}@c
@functionsubindex{gpu-array-face-num}@c

When passed a texture-backed `gpu-array` this function will return the index of
the `texture`'s cubeface that contains this gpu-array. This only truly applies to
gpu-arrays belonging to cubemap `texture`s, for all gpu-arrays this number will
always be 0.
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS<dot>TEXTURE-BACKED package, , @t{cepl.gpu-arrays.texture-backed}}
@item Source
@ref{go to the cepl/core/gpu-arrays/texture-backed<dot>lisp file, , @t{core/gpu-arrays/texture-backed.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-array-layer-num} GPU-ARRAY
@anchor{go to the CEPL<dot>GPU-ARRAYS<dot>TEXTURE-BACKED<colon><colon>GPU-ARRAY-LAYER-NUM function}@c
@functionsubindex{gpu-array-layer-num}@c

When passed a texture-backed `gpu-array` this function will return the index of
the gpu-array within the array-textures. This only truly applies to gpu-arrays
 belonging to array-textures, for all gpu-arrays this number will always be 0.
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS<dot>TEXTURE-BACKED package, , @t{cepl.gpu-arrays.texture-backed}}
@item Source
@ref{go to the cepl/core/gpu-arrays/texture-backed<dot>lisp file, , @t{core/gpu-arrays/texture-backed.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-array-level-num} GPU-ARRAY
@anchor{go to the CEPL<dot>GPU-ARRAYS<dot>TEXTURE-BACKED<colon><colon>GPU-ARRAY-LEVEL-NUM function}@c
@functionsubindex{gpu-array-level-num}@c

When passed a texture-backed `gpu-array` this function will return the
mipmap level the gpu-array resides on within the `texture`.@*

This only truly applies to gpu-arrays with mipmaps, for all gpu-arrays this
number will always be 0.
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS<dot>TEXTURE-BACKED package, , @t{cepl.gpu-arrays.texture-backed}}
@item Source
@ref{go to the cepl/core/gpu-arrays/texture-backed<dot>lisp file, , @t{core/gpu-arrays/texture-backed.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-array-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-P function}@c
@functionsubindex{gpu-array-p}@c

Will return t if the value given is a `gpu-array`.@*

This will return t for both texture-backed and buffer-backed gpu-arrays
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-array-t-face-num} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T-FACE-NUM function}@c
@functionsubindex{gpu-array-t-face-num}@c
@deffnx {Function} {(setf gpu-array-t-face-num)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-T-FACE-NUM) function}@c
@functionsubindex{(setf gpu-array-t-face-num)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-array-t-image-format} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T-IMAGE-FORMAT function}@c
@functionsubindex{gpu-array-t-image-format}@c
@deffnx {Function} {(setf gpu-array-t-image-format)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-T-IMAGE-FORMAT) function}@c
@functionsubindex{(setf gpu-array-t-image-format)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-array-t-layer-num} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T-LAYER-NUM function}@c
@functionsubindex{gpu-array-t-layer-num}@c
@deffnx {Function} {(setf gpu-array-t-layer-num)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-T-LAYER-NUM) function}@c
@functionsubindex{(setf gpu-array-t-layer-num)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-array-t-level-num} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T-LEVEL-NUM function}@c
@functionsubindex{gpu-array-t-level-num}@c
@deffnx {Function} {(setf gpu-array-t-level-num)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-T-LEVEL-NUM) function}@c
@functionsubindex{(setf gpu-array-t-level-num)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-array-t-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T-P function}@c
@functionsubindex{gpu-array-t-p}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-array-t-texture} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T-TEXTURE function}@c
@functionsubindex{gpu-array-t-texture}@c
@deffnx {Function} {(setf gpu-array-t-texture)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-T-TEXTURE) function}@c
@functionsubindex{(setf gpu-array-t-texture)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-array-t-texture-type} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T-TEXTURE-TYPE function}@c
@functionsubindex{gpu-array-t-texture-type}@c
@deffnx {Function} {(setf gpu-array-t-texture-type)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-T-TEXTURE-TYPE) function}@c
@functionsubindex{(setf gpu-array-t-texture-type)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-array-texture} GPU-ARRAY
@anchor{go to the CEPL<dot>GPU-ARRAYS<dot>TEXTURE-BACKED<colon><colon>GPU-ARRAY-TEXTURE function}@c
@functionsubindex{gpu-array-texture}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS<dot>TEXTURE-BACKED package, , @t{cepl.gpu-arrays.texture-backed}}
@item Source
@ref{go to the cepl/core/gpu-arrays/texture-backed<dot>lisp file, , @t{core/gpu-arrays/texture-backed.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-array-texture-type} GPU-ARRAY
@anchor{go to the CEPL<dot>GPU-ARRAYS<dot>TEXTURE-BACKED<colon><colon>GPU-ARRAY-TEXTURE-TYPE function}@c
@functionsubindex{gpu-array-texture-type}@c

When passed a texture-backed `gpu-array` this function will return the
type of the `texture` containing this gpu-array.@*

The result will be one of the following:@*

    :texture-1d@*
    :texture-2d@*
    :texture-3d@*
    :texture-1d-array@*
    :texture-2d-array@*
    :texture-cube-map@*
    :texture-cube-map-array@*
    :texture-rectangle@*
    :texture-buffer@*
    :texture-buffer@*
    :texture-buffer@*
    :texture-2d-multisample@*
    :texture-2d-multisample-array
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS<dot>TEXTURE-BACKED package, , @t{cepl.gpu-arrays.texture-backed}}
@item Source
@ref{go to the cepl/core/gpu-arrays/texture-backed<dot>lisp file, , @t{core/gpu-arrays/texture-backed.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-buffer-arrays} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-BUFFER-ARRAYS function}@c
@functionsubindex{gpu-buffer-arrays}@c

This function returns an array of the raw :uint8 `gpu-array`s that make up the
data in this `gpu-buffer`.
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-BUFFER-ARRAYS) function, , @t{(setf gpu-buffer-arrays)}} (function)
@end table
@end deffn
@deffn {Function} {(setf gpu-buffer-arrays)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-BUFFER-ARRAYS) function}@c
@functionsubindex{(setf gpu-buffer-arrays)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-BUFFER-ARRAYS function, , @t{gpu-buffer-arrays}} (function)
@end table
@end deffn
@deffn {Function} {gpu-buffer-bound} CEPL-CONTEXT TARGET
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>GPU-BUFFER-BOUND function}@c
@functionsubindex{gpu-buffer-bound}@c
@deffnx {Function} {(setf gpu-buffer-bound)} VAL CTX TARGET
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF GPU-BUFFER-BOUND) function}@c
@functionsubindex{(setf gpu-buffer-bound)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-buffer-cache-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-BUFFER-CACHE-ID function}@c
@functionsubindex{gpu-buffer-cache-id}@c
@deffnx {Function} {(setf gpu-buffer-cache-id)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-BUFFER-CACHE-ID) function}@c
@functionsubindex{(setf gpu-buffer-cache-id)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-buffer-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-BUFFER-ID function}@c
@functionsubindex{gpu-buffer-id}@c

This function, when passed a `gpu-buffer` will return the OpenGL buffer object
from the `gpu-buffer`.@*

It is not recommended to modify this directly as the changes from doing so won't
be reflected in the layout of the `gpu-buffer`, which may potentially put the
`gpu-buffer` (and and `gpu-array` or `ubo` using it) into an invalid state.
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-BUFFER-ID) function, , @t{(setf gpu-buffer-id)}} (function)
@end table
@end deffn
@deffn {Function} {(setf gpu-buffer-id)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-BUFFER-ID) function}@c
@functionsubindex{(setf gpu-buffer-id)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-BUFFER-ID function, , @t{gpu-buffer-id}} (function)
@end table
@end deffn
@deffn {Function} {gpu-buffer-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-BUFFER-P function}@c
@functionsubindex{gpu-buffer-p}@c

This function returns t if the given value is a `gpu-buffer`. Otherwise it
returns nil.
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-fence-signalled-p} FENCE
@anchor{go to the CEPL<dot>SYNC<colon><colon>GPU-FENCE-SIGNALLED-P function}@c
@functionsubindex{gpu-fence-signalled-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SYNC package, , @t{cepl.sync}}
@item Source
@ref{go to the cepl/core/sync/sync<dot>lisp file, , @t{core/sync/sync.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-functions} NAME
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GPU-FUNCTIONS function}@c
@functionsubindex{gpu-functions}@c

This function returns all the signatures of the gpu-functions named 'name'.

The reason there may be many is that functions can be 'overloaded' so you
can have multiple gpu-functions with the same name as long as they can be
uniquely identified by the combination of their name and argument types.
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-query-cache-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-QUERY-CACHE-ID function}@c
@functionsubindex{gpu-query-cache-id}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-query-enum} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-QUERY-ENUM function}@c
@functionsubindex{gpu-query-enum}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-query-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-QUERY-ID function}@c
@functionsubindex{gpu-query-id}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-query-result-available-p} QUERY
@anchor{go to the CEPL<dot>QUERIES<colon><colon>GPU-QUERY-RESULT-AVAILABLE-P function}@c
@functionsubindex{gpu-query-result-available-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>QUERIES package, , @t{cepl.queries}}
@item Source
@ref{go to the cepl/core/queries/query<dot>lisp file, , @t{core/queries/query.lisp}} (file)
@end table
@end deffn
@deffn {Function} {group} SOURCE N
@anchor{go to the CEPL-UTILS<colon><colon>GROUP function}@c
@functionsubindex{group}@c
This takes a  flat list and emit a list of lists, each n long
   containing the elements of the original list
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {half-float-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>HALF-FLOAT-FROM-FOREIGN function}@c
@functionsubindex{half-float-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {half-float-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>HALF-FLOAT-TO-FOREIGN function}@c
@functionsubindex{half-float-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {half-vec2-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>HALF-VEC2-FROM-FOREIGN function}@c
@functionsubindex{half-vec2-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {half-vec2-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>HALF-VEC2-TO-FOREIGN function}@c
@functionsubindex{half-vec2-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {half-vec3-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>HALF-VEC3-FROM-FOREIGN function}@c
@functionsubindex{half-vec3-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {half-vec3-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>HALF-VEC3-TO-FOREIGN function}@c
@functionsubindex{half-vec3-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {half-vec4-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>HALF-VEC4-FROM-FOREIGN function}@c
@functionsubindex{half-vec4-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {half-vec4-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>HALF-VEC4-TO-FOREIGN function}@c
@functionsubindex{half-vec4-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {has-feature} X
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>HAS-FEATURE function}@c
@functionsubindex{has-feature}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/gl-context<dot>lisp file, , @t{core/context/gl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {hash-keys} HASH-TABLE
@anchor{go to the CEPL-UTILS<colon><colon>HASH-KEYS function}@c
@functionsubindex{hash-keys}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {hash-values} HASH-TABLE
@anchor{go to the CEPL-UTILS<colon><colon>HASH-VALUES function}@c
@functionsubindex{hash-values}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {hidden-symb} SYMBOL &optional SUB-NAME
@anchor{go to the CEPL-UTILS<colon><colon>HIDDEN-SYMB function}@c
@functionsubindex{hidden-symb}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {holds-gl-object-ref-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>HOLDS-GL-OBJECT-REF-P function}@c
@functionsubindex{holds-gl-object-ref-p}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {host-step} WIN
@anchor{go to the CEPL<dot>HOST<colon><colon>HOST-STEP function}@c
@functionsubindex{host-step}@c
not external
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Function} {host-swap} WIN
@anchor{go to the CEPL<dot>HOST<colon><colon>HOST-SWAP function}@c
@functionsubindex{host-swap}@c
not external
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Function} {image-format->lisp-type} IMAGE-FORMAT
@anchor{go to the CEPL<dot>TYPES<colon><colon>IMAGE-FORMAT->LISP-TYPE function}@c
@functionsubindex{image-format->lisp-type}@c

This function, when given a image-format name, will attempt to find and
return the name of a lisp type that is equivalent.@*

If no such type is found then nil is returned
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/pixel-format<dot>lisp file, , @t{core/types/pixel-format.lisp}} (file)
@end table
@end deffn
@deffn {Function} {image-format->pixel-format} IMAGE-FORMAT &key ERROR-IF-MISSING
@anchor{go to the CEPL<dot>TYPES<colon><colon>IMAGE-FORMAT->PIXEL-FORMAT function}@c
@functionsubindex{image-format->pixel-format}@c

This function, when given an image-format name, will attempt to find and
return equivalent equivalent `pixel-format`.@*

If no such type is found then nil is returned
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/pixel-format<dot>lisp file, , @t{core/types/pixel-format.lisp}} (file)
@end table
@end deffn
@deffn {Function} {image-formatp} FORMAT
@anchor{go to the CEPL<dot>IMAGE-FORMATS<colon><colon>IMAGE-FORMATP function}@c
@functionsubindex{image-formatp}@c

This function returns t if the value provided is a keyword that can be found in
*image-formats*
@table @strong
@item Package
@ref{go to the CEPL<dot>IMAGE-FORMATS package, , @t{cepl.image-formats}}
@item Source
@ref{go to the cepl/core/types/image-format<dot>lisp file, , @t{core/types/image-format.lisp}} (file)
@end table
@end deffn
@deffn {Function} {indexp} X
@anchor{go to the %CEPL<dot>TYPES<colon><colon>INDEXP function}@c
@functionsubindex{indexp}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {initialize} &rest ARGS &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>INITIALIZE function}@c
@functionsubindex{initialize}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Function} {initialize-cepl} &key GL-VERSION HOST-INIT-FLAGS
@anchor{go to the CEPL<colon><colon>INITIALIZE-CEPL function}@c
@functionsubindex{initialize-cepl}@c
@table @strong
@item Package
@ref{go to the CEPL package, , @t{cepl}}
@item Source
@ref{go to the cepl/core/repl<dot>lisp file, , @t{core/repl.lisp}} (file)
@end table
@end deffn
@deffn {Function} {int-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>INT-FROM-FOREIGN function}@c
@functionsubindex{int-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {int-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>INT-TO-FOREIGN function}@c
@functionsubindex{int-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {int32-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>INT32-FROM-FOREIGN function}@c
@functionsubindex{int32-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {int32-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>INT32-TO-FOREIGN function}@c
@functionsubindex{int32-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {int8-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>INT8-FROM-FOREIGN function}@c
@functionsubindex{int8-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {int8-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>INT8-TO-FOREIGN function}@c
@functionsubindex{int8-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {int8-vec2-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>INT8-VEC2-FROM-FOREIGN function}@c
@functionsubindex{int8-vec2-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {int8-vec2-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>INT8-VEC2-TO-FOREIGN function}@c
@functionsubindex{int8-vec2-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {int8-vec3-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>INT8-VEC3-FROM-FOREIGN function}@c
@functionsubindex{int8-vec3-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {int8-vec3-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>INT8-VEC3-TO-FOREIGN function}@c
@functionsubindex{int8-vec3-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {int8-vec4-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>INT8-VEC4-FROM-FOREIGN function}@c
@functionsubindex{int8-vec4-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {int8-vec4-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>INT8-VEC4-TO-FOREIGN function}@c
@functionsubindex{int8-vec4-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {intersperse} SYMB SEQUENCE
@anchor{go to the CEPL-UTILS<colon><colon>INTERSPERSE function}@c
@functionsubindex{intersperse}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {ivec2-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>IVEC2-FROM-FOREIGN function}@c
@functionsubindex{ivec2-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {ivec2-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>IVEC2-TO-FOREIGN function}@c
@functionsubindex{ivec2-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {ivec3-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>IVEC3-FROM-FOREIGN function}@c
@functionsubindex{ivec3-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {ivec3-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>IVEC3-TO-FOREIGN function}@c
@functionsubindex{ivec3-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {ivec4-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>IVEC4-FROM-FOREIGN function}@c
@functionsubindex{ivec4-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {ivec4-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>IVEC4-TO-FOREIGN function}@c
@functionsubindex{ivec4-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {just-ignore} &rest ARGS
@anchor{go to the CEPL-UTILS<colon><colon>JUST-IGNORE function}@c
@functionsubindex{just-ignore}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {keep} INCOMING-VAL STORED-VAL
@anchor{go to the CEPL<dot>DOCUMENTATION-FUNCTIONS<colon><colon>KEEP function}@c
@functionsubindex{keep}@c
Always returns the stored-val
@table @strong
@item Package
@ref{go to the CEPL<dot>DOCUMENTATION-FUNCTIONS package, , @t{cepl.documentation-functions}}
@item Source
@ref{go to the cepl/core/context/documentation-functions<dot>lisp file, , @t{core/context/documentation-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {kwd} &rest ARGS
@anchor{go to the CEPL-UTILS<colon><colon>KWD function}@c
@functionsubindex{kwd}@c
This takes a list of symbols (or strings) and outputs one
   keyword symbol.@*
   If the input is symbol/s then the output is a regular keyword
   If the input is string/s, then the output is@*
   a :|keyword like this|
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {last1} LIST
@anchor{go to the CEPL-UTILS<colon><colon>LAST1 function}@c
@functionsubindex{last1}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {lisp-type->image-format} LISP-TYPE
@anchor{go to the CEPL<dot>TYPES<colon><colon>LISP-TYPE->IMAGE-FORMAT function}@c
@functionsubindex{lisp-type->image-format}@c

This function, when given a lisp type name, will attempt to find and
return the name of a GL image-format that is equivalent.@*

If no such type is found then nil is returned
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/pixel-format<dot>lisp file, , @t{core/types/pixel-format.lisp}} (file)
@end table
@end deffn
@deffn {Function} {lispify-name} NAME
@anchor{go to the CEPL-UTILS<colon><colon>LISPIFY-NAME function}@c
@functionsubindex{lispify-name}@c
take a string and changes it to uppercase and replaces
   all underscores _ with minus symbols -
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {list-not-consp} X
@anchor{go to the CEPL-UTILS<colon><colon>LIST-NOT-CONSP function}@c
@functionsubindex{list-not-consp}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {listen-to-lifecycle-changes} FUNC &rest STATES-TO-SUBSCRIBE-TO
@anchor{go to the CEPL<dot>LIFECYCLE<colon><colon>LISTEN-TO-LIFECYCLE-CHANGES function}@c
@functionsubindex{listen-to-lifecycle-changes}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>LIFECYCLE package, , @t{cepl.lifecycle}}
@item Source
@ref{go to the cepl/core/lifecycle<dot>lisp file, , @t{core/lifecycle.lisp}} (file)
@end table
@end deffn
@deffn {Function} {listify} X
@anchor{go to the CEPL-UTILS<colon><colon>LISTIFY function}@c
@functionsubindex{listify}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {load-in-release-mode} &optional CEPL-HOST
@anchor{go to the CEPL<dot>BUILD<colon><colon>LOAD-IN-RELEASE-MODE function}@c
@functionsubindex{load-in-release-mode}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>BUILD package, , @t{cepl.build}}
@item Source
@ref{go to the cepl<dot>build/build/build<dot>lisp file, , @t{build/build.lisp}} (file)
@end table
@end deffn
@deffn {Function} {lod-bias} SAMPLER
@anchor{go to the %CEPL<dot>TYPES<colon><colon>LOD-BIAS function}@c
@functionsubindex{lod-bias}@c

This function sets the lod-bias of the given `texture` or `sampler`@*


**-- LOD --**@*

There is a pair of sampling parameters that affect the mipmap image selection:
:max-lod and :min-lod (floating-point values).@*

The way these work in mipmap selection is quite complicated; the specification
goes into full detail about it.@*

example:@*

    (setf (min-lod texture-or-sampler) value)@*
    (setf (max-lod texture-or-sampler) value)@*


LOD bias:@*
The mipmap image selection process can be adjusted coarsely by using the
:lod-bias sampling parameter. This bias will be added to the mipmap@*
LOD calculation (as well as added to the bias specified in one of the `texture`
accessing functions in GLSL), which is used to select the image. A positive bias
means that larger mipmaps will be selected even when the texture is viewed from
farther away. This can cause visual aliasing, but in small quantities it can
make textures a bit more sharp.@*

    (setf (lod-bias texture-or-sampler) value)
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF LOD-BIAS) function, , @t{(setf lod-bias)}} (function)
@end table
@end deffn
@deffn {Function} {(setf lod-bias)} VALUE SAMPLER
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF LOD-BIAS) function}@c
@functionsubindex{(setf lod-bias)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>LOD-BIAS function, , @t{lod-bias}} (function)
@end table
@end deffn
@deffn {Function} {magnify-filter} SAMPLER
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MAGNIFY-FILTER function}@c
@functionsubindex{magnify-filter}@c

This function takes a `sampler` or `texture` and sets the approach used when the
area of the fragment in texture space is smaller than a texel.@*


**-- The magnification filter --**@*

The magnification filter is controlled by the :magnify-filter texture parameter.
This value can be :linear or :nearest.@*

If :nearest is used, then the implementation will select the texel nearest the
texture coordinate; this is commonly called 'point sampling').@*

If :linear is used, the implementation will perform a weighted linear blend
between the nearest adjacent samples.@*

    (setf (magnify-filter tex-or-sampler) :linear)@*
    (setf (magnify-filter tex-or-sampler) :nearest)
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF MAGNIFY-FILTER) function, , @t{(setf magnify-filter)}} (function)
@end table
@end deffn
@deffn {Function} {(setf magnify-filter)} VALUE SAMPLER
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF MAGNIFY-FILTER) function}@c
@functionsubindex{(setf magnify-filter)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>MAGNIFY-FILTER function, , @t{magnify-filter}} (function)
@end table
@end deffn
@deffn {Function} {make-any-samples-passed-conservative-query} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MAKE-ANY-SAMPLES-PASSED-CONSERVATIVE-QUERY function}@c
@functionsubindex{make-any-samples-passed-conservative-query}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-any-samples-passed-query} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MAKE-ANY-SAMPLES-PASSED-QUERY function}@c
@functionsubindex{make-any-samples-passed-query}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-att} &key (ARRAY ARRAY) (BLEND BLEND) (BPARAMS BPARAMS) (OWNED-P OWNED-P) (VIEWPORT VIEWPORT)
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MAKE-ATT function}@c
@functionsubindex{make-att}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-blending-params} &key (MODE-RGB MODE-RGB) (MODE-ALPHA MODE-ALPHA) (SOURCE-RGB SOURCE-RGB) (SOURCE-ALPHA SOURCE-ALPHA) (DESTINATION-RGB DESTINATION-RGB) (DESTINATION-ALPHA DESTINATION-ALPHA)
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MAKE-BLENDING-PARAMS function}@c
@functionsubindex{make-blending-params}@c

This function makes a new `blending-params` object.@*

The valid values for `source-rgb`, `source-alpha`, `destination-rgb`
and `destination-alpha` are:@*

    :zero@*
    :one@*
    :src-color@*
    :one-minus-src-color@*
    :dst-color@*
    :one-minus-dst-color@*
    :src-alpha@*
    :one-minus-src-alpha@*
    :dst-alpha@*
    :one-minus-dst-alpha@*
    :constant-color@*
    :one-minus-constant-color@*
    :constant-alpha@*
    :one-minus-constant-alpha@*
    :src-alpha-saturate@*
    :src1-color@*
    :one-minus-src-color@*
    :src1-alpha@*
    :one-minus-src-alpha@*

The valid values for `mode-rgb` and `mode-alpha` are:@*

    :func-add@*
    :func-subtract@*
    :func-reverse-subtract@*
    :min@*
    :max@*

For details on their behaviour on the blending-params object please see the
docstring for blending-params.
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-buffer-stream} GPU-ARRAYS &key INDEX-ARRAY START LENGTH RETAIN-ARRAYS PRIMITIVE BASE-VERTEX
@anchor{go to the CEPL<dot>STREAMS<colon><colon>MAKE-BUFFER-STREAM function}@c
@functionsubindex{make-buffer-stream}@c

This function composes a number of gpu-arrays into a buffer-stream.@*
No data is copied, the buffer-stream simply refers to the gpu-arrays so the
gpu knows where to pull data from.@*

You can optionally pass a gpu-array to act as an index into the other arrays.

Usually when you map over a buffer-stream it will call the pipeline pulling 1
value from each of the composed gpu-arrays on each 'iteration'[0].@*
When you have an index then map-g will pull 1 value from index each 'iteration'
and use that to pick which value to use from the other arrays. This approach
gives bigs boosts in performance and memory usage when rendering.@*

The element-type of the index-array must be of the following:@*
:uint8 :ushort :uint :unsigned-short :unsigned-int@*

As well as an element type you also can specify the primitive-type. This says
what the gpu will draw this data as. It can be any one of:@*

 :points@*
 :lines@*
 :line-loop@*
 :line-strip@*
 :lines-adjacency@*
 :line-strip-adjacency@*
 :triangles@*
 :triangle-fan@*
 :triangle-strip@*
 :triangles-adjacency@*
 :triangle-strip-adjacency@*
 (:patch <patch-size>)@*

By default the primitive-type is :triangles@*

It is also worth noting  that you can also use gpu-sub-arrays in here if you
want to limit the data you are using, for example the following is perfectly
legal code:@*

    (make-buffer-stream@*
      :gpu-arrays `(,(gpu-sub-array monster-pos-data 1000 2000)
                   ,(gpu-sub-array monster-col-data 1000 2000))
      :index-array monster-index-array@*
      :length 1000)@*

[0] The use of the term 'iteration' here is quoted as the gpu is going to be
    doing this work in parallel, however it makes the explanation clearer so
    that is why it is there. If you have a clearer way of explaining the
    behaviour please file it as an issue on github.
@table @strong
@item Package
@ref{go to the CEPL<dot>STREAMS package, , @t{cepl.streams}}
@item Source
@ref{go to the cepl/core/streams/buffer-streams<dot>lisp file, , @t{core/streams/buffer-streams.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-buffer-stream-from-id-and-layouts} VAO-GL-OBJECT DATA-LAYOUTS INDEX-LAYOUT &key START LENGTH PRIMITIVE
@anchor{go to the CEPL<dot>STREAMS<colon><colon>MAKE-BUFFER-STREAM-FROM-ID-AND-LAYOUTS function}@c
@functionsubindex{make-buffer-stream-from-id-and-layouts}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>STREAMS package, , @t{cepl.streams}}
@item Source
@ref{go to the cepl/core/streams/buffer-streams<dot>lisp file, , @t{core/streams/buffer-streams.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-buffer-stream-sharing} STREAM &optional BASE-VERTEX
@anchor{go to the CEPL<dot>STREAMS<colon><colon>MAKE-BUFFER-STREAM-SHARING function}@c
@functionsubindex{make-buffer-stream-sharing}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>STREAMS package, , @t{cepl.streams}}
@item Source
@ref{go to the cepl/core/streams/buffer-streams<dot>lisp file, , @t{core/streams/buffer-streams.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-c-array} INITIAL-CONTENTS &key DIMENSIONS ELEMENT-TYPE ROW-ALIGNMENT
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>MAKE-C-ARRAY function}@c
@functionsubindex{make-c-array}@c

This function will make and return a new `c-array`.@*

It can be used in a few different ways:@*

- with :initial-contents to nil:@*
  In this case you need to provide dimensions and an element-type.@*

- with :initial-contents populated.@*
  The initial-contents can be a (potentially nested) list or array.@*

When :initial-contents is an array then the dimension of the c-array@*
will be the same as the array passed in. CEPL currently only supports up@*
to 4D c-arrays.@*

When the :initial-contents is a flat list then each element is used as one@*
element in the c-array.@*
If the :initial-contents is a nested list then you must either:@*

- specify multiple dimensions and an element-type@*
- specify an element-type to be some struct type, then nested lists are then@*
  used to populate the fields of the foreign structs. For an example of this@*
  please see [this example](https://github.com/cbaggers/cepl.examples/blob/master/examples/triangle.lisp#L30).

If the :element-type is not provided then CEPL will look at every element in@*
the initial-contents and try and find the smallest (in bytes) foreign type@*
which works for every element. This mean if the array is full of single-floats@*
then CEPL will choose :float, not :double.@*
Naturally this behaviour is too slow for use in performance critical@*
applications however it is nice for experimentation and working from the repl.@*

If you need what would be called a displaced array in lisp then please see the@*
`subseq-c` function.
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/make<dot>lisp file, , @t{core/c-arrays/make.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-c-array-from-pointer} DIMENSIONS ELEMENT-TYPE POINTER &key FREE ELEMENT-BYTE-SIZE ROW-ALIGNMENT
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>MAKE-C-ARRAY-FROM-POINTER function}@c
@functionsubindex{make-c-array-from-pointer}@c

Will create a CEPL `c-array` with the element-type and dimensions specified,
and will store the pointer as where the data is expected to be.@*

This function does allocate the memory or validate the type or dimensions so be
very careful when using this function.
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/make<dot>lisp file, , @t{core/c-arrays/make.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-compute-space} &optional SIZE-X SIZE-Y SIZE-Z
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MAKE-COMPUTE-SPACE function}@c
@functionsubindex{make-compute-space}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-context} &key GL-VERSION
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>MAKE-CONTEXT function}@c
@functionsubindex{make-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-context-shared-with-current-context} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>MAKE-CONTEXT-SHARED-WITH-CURRENT-CONTEXT function}@c
@functionsubindex{make-context-shared-with-current-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-empty-fbo-params} &key (FBO FBO) (DIMENSIONS DIMENSIONS) (VIEWPORT VIEWPORT) (LAYER-COUNT LAYER-COUNT) (SAMPLES SAMPLES) (FIXED-SAMPLE-LOCATIONS-P FIXED-SAMPLE-LOCATIONS-P)
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MAKE-EMPTY-FBO-PARAMS function}@c
@functionsubindex{make-empty-fbo-params}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-fbo} &rest FUZZY-ATTACH-ARGS
@anchor{go to the CEPL<dot>FBOS<colon><colon>MAKE-FBO function}@c
@functionsubindex{make-fbo}@c

This, like other make-* functions in CEPL has a large variety of valid
arguments. The goal of this apparent complexity is to make exploration from the
repl easy, whilst still allowing absolutely control when it is needed.@*

Lets look at the behaviour when given different arguments@*


**-- (make-fbo) --**@*

Empty FBOs are possible in CEPL, however they wernt added in GL until v4.3 so
please see the empty FBO section below.@*

**-- (make-fbo 0) --**@*

Make an fbo with one color attachment in attachment slot 0.@*
CEPL with make a `texture` with dimensions equal to that of the current `viewport`
and with the element-type :rgba (which is a sensible default for a color
attachment)@*

**-- (make-fbo 0 1) --**@*

Make an fbo with two color attachments 1 in each of attachment slots 0 & 1.
CEPL with make the textures with dimensions equal to that of the current
viewport and with the element-type :rgba (which is a sensible default for a
color attachment)@*

**-- (make-fbo :d) --**@*

Make an fbo with one depth attachment.@*
CEPL with make a texture with dimensions equal to that of the current viewport
and with the element-type :depth-component24 (which is a sensible default for a
depth attachment)@*

**-- (make-fbo 0 1 :d) --**@*

Make an fbo with two color attachments and one depth attachment.@*

**-- (make-fbo (list 0 some-gpu-array)) --**@*

Makes an fbo with one color attachment whos `gpu-array` is 'some-gpu-array'@*

**--  (make-fbo (list 0 some-texture)) --**@*

Makes an fbo with one color attachment whos gpu-array is (texref some-texture)@*

**-- (make-fbo '(0 :dimensions (100 100) :element-type :rgba8)) --**@*

Makes an fbo with one color attachment whos gpu-array is taken from a new
texture created by taking the arguments after 0 and applying them to
`make-texture`@*

**-- Any combination of the above --**@*

**-- Empty FBOs --**@*

Empty FBOs are interesting in that you have a none of the pipeline outputs will
be written to anywhere, but rendering can otherwise proceed as normal. They were
only added in GL 4.3 so `make-fbo` will error if the current GL version is too low.

When defining an empty fbo there can be at most 1 attachment declaration.@*
When present the name must be NIL. You may also optionally specify the following
parameters as you would in `make-texture`:@*

- :dimensions@*
- :layer-count@*
- :samples@*
- :fixed-sample-locations@*

So the following are legal:@*

- `(make-fbo '(nil :dimensions (1024 1024)))`@*
- `(make-fbo '(nil))`@*
- `(make-fbo)`@*

**-- Cube Texture Initialization --**@*

One last variant is allowed. You are allowed to pass a cube-map texture along
with and optional depth option. This will result in each face of the cube being
bound to the fbo's attachments.@*

    (make-fbo cube-tex)@*

    (make-fbo cube-tex '(:d :dimensions (32 32))@*

    (make-fbo cube-tex :d) ;; depth attachment dimensions will match faces
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-g-pc} &key POSITION COLOR
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>MAKE-G-PC function}@c
@functionsubindex{make-g-pc}@c

This function returns a new instance of the gpu struct of type G-PC
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-g-pn} &key POSITION NORMAL
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>MAKE-G-PN function}@c
@functionsubindex{make-g-pn}@c

This function returns a new instance of the gpu struct of type G-PN
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-g-pnc} &key POSITION NORMAL COLOR
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>MAKE-G-PNC function}@c
@functionsubindex{make-g-pnc}@c

This function returns a new instance of the gpu struct of type G-PNC
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-g-pnt} &key POSITION NORMAL TEXTURE
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>MAKE-G-PNT function}@c
@functionsubindex{make-g-pnt}@c

This function returns a new instance of the gpu struct of type G-PNT
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-g-pntc} &key POSITION NORMAL TEXTURE COLOR
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>MAKE-G-PNTC function}@c
@functionsubindex{make-g-pntc}@c

This function returns a new instance of the gpu struct of type G-PNTC
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-g-pt} &key POSITION TEXTURE
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>MAKE-G-PT function}@c
@functionsubindex{make-g-pt}@c

This function returns a new instance of the gpu struct of type G-PT
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-gl-context} &rest ARGS &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>MAKE-GL-CONTEXT function}@c
@functionsubindex{make-gl-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-gl-context-current-on-surface} GL-CONTEXT SURFACE
@anchor{go to the CEPL<dot>HOST<colon><colon>MAKE-GL-CONTEXT-CURRENT-ON-SURFACE function}@c
@functionsubindex{make-gl-context-current-on-surface}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-gl-context-shared-with-current-context} &rest ARGS &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>MAKE-GL-CONTEXT-SHARED-WITH-CURRENT-CONTEXT function}@c
@functionsubindex{make-gl-context-shared-with-current-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-gpu-array-from-buffer} BUFFER &key ELEMENT-TYPE DIMENSIONS ACCESS-STYLE KEEP-DATA
@anchor{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED<colon><colon>MAKE-GPU-ARRAY-FROM-BUFFER function}@c
@functionsubindex{make-gpu-array-from-buffer}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED package, , @t{cepl.gpu-arrays.buffer-backed}}
@item Source
@ref{go to the cepl/core/gpu-arrays/buffer-backed<dot>lisp file, , @t{core/gpu-arrays/buffer-backed.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-gpu-array-from-buffer-id} GL-BUFFER-ID &key ELEMENT-TYPE DIMENSIONS ACCESS-STYLE
@anchor{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED<colon><colon>MAKE-GPU-ARRAY-FROM-BUFFER-ID function}@c
@functionsubindex{make-gpu-array-from-buffer-id}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED package, , @t{cepl.gpu-arrays.buffer-backed}}
@item Source
@ref{go to the cepl/core/gpu-arrays/buffer-backed<dot>lisp file, , @t{core/gpu-arrays/buffer-backed.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-gpu-arrays} C-ARRAYS &key ACCESS-STYLE
@anchor{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED<colon><colon>MAKE-GPU-ARRAYS function}@c
@functionsubindex{make-gpu-arrays}@c

This function takes a list of x `c-array`s and returns a list of x buffer-backed
`gpu-array`s.@*

The reason to use this rather than:@*

    (mapcar `make-gpu-array` c-arrays-list)@*

is that all of the gpu-arrays created will share the same `gpu-buffer`.@*

Usually you will know if you need this instead of `make-gpu-array` as you will
have some behaviour or performance characteristic in mind.
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED package, , @t{cepl.gpu-arrays.buffer-backed}}
@item Source
@ref{go to the cepl/core/gpu-arrays/buffer-backed<dot>lisp file, , @t{core/gpu-arrays/buffer-backed.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-gpu-arrays-from-buffer} BUFFER LAYOUTS &key ACCESS-STYLE KEEP-DATA
@anchor{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED<colon><colon>MAKE-GPU-ARRAYS-FROM-BUFFER function}@c
@functionsubindex{make-gpu-arrays-from-buffer}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED package, , @t{cepl.gpu-arrays.buffer-backed}}
@item Source
@ref{go to the cepl/core/gpu-arrays/buffer-backed<dot>lisp file, , @t{core/gpu-arrays/buffer-backed.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-gpu-arrays-from-buffer-id} GL-BUFFER-ID LAYOUTS &key ACCESS-STYLE
@anchor{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED<colon><colon>MAKE-GPU-ARRAYS-FROM-BUFFER-ID function}@c
@functionsubindex{make-gpu-arrays-from-buffer-id}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED package, , @t{cepl.gpu-arrays.buffer-backed}}
@item Source
@ref{go to the cepl/core/gpu-arrays/buffer-backed<dot>lisp file, , @t{core/gpu-arrays/buffer-backed.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-gpu-buffer} &key INITIAL-CONTENTS BUFFER-TARGET USAGE
@anchor{go to the CEPL<dot>GPU-BUFFERS<colon><colon>MAKE-GPU-BUFFER function}@c
@functionsubindex{make-gpu-buffer}@c

This function creates and returns a new `gpu-buffer`.@*


If you wish to populate the buffer during construction you can pass a `c-array` as
the :initial-contents.@*


The :usage argument is a hint to OpenGL on how you intend to use the `gpu-buffer`.
It is optional whether your gpu manufacturer's implementation of GL takes any
notice of this option. When they do take notice of it, it will to optimize
access to the underlying data.@*


The :target argument can take any of the following binding targets:@*

    Buffer Binding Target      Purpose
    -------------------------------------------------------------
    :array-buffer              Vertex attributes@*
    :atomic-counter-buffer     Atomic counter storage@*
    :copy-read-buffer          Buffer copy source@*
    :copy-write-buffer         Buffer copy destination
    :dispatch-indirect-buffer  Indirect compute dispatch commands
    :draw-indirect-buffer      Indirect command arguments
    :element-array-buffer      Vertex array indices@*
    :pixel-pack-buffer         Pixel read target@*
    :pixel-unpack-buffer       Texture data source@*
    :query-buffer              Query result buffer@*
    :shader-storage-buffer     Read-write storage for shaders@*
    :texture-buffer            Texture data buffer@*
    :transform-feedback-buffer Transform feedback buffer@*
    :uniform-buffer            Uniform block storage@*

Do note that the default of :array-buffer is perfectly fine for creating the
`gpu-buffer` and uploading the data. It does not limit how the buffer can be used
in future parts of your program.@*

@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-BUFFERS package, , @t{cepl.gpu-buffers}}
@item Source
@ref{go to the cepl/core/gpu-buffers/gpu-buffers<dot>lisp file, , @t{core/gpu-buffers/gpu-buffers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-gpu-buffer-from-id} GL-OBJECT &rest ARGS &key INITIAL-CONTENTS LAYOUTS BUFFER-TARGET USAGE KEEP-DATA
@anchor{go to the CEPL<dot>GPU-BUFFERS<colon><colon>MAKE-GPU-BUFFER-FROM-ID function}@c
@functionsubindex{make-gpu-buffer-from-id}@c

This function takes an existing GL Buffer Object and wraps it in a new
`gpu-buffer`.@*


If you wish to populate the buffer during construction you can pass a `c-array` as
the :initial-contents.@*


The :usage argument is a hint to OpenGL on how you intend to use the `gpu-buffer`.
It is optional whether your gpu manufacturer's implementation of GL takes any
notice of this option. When they do take notice of it, it will to optimize
access to the underlying data.@*


The :target argument can take any of the following binding targets:@*

    Buffer Binding Target      Purpose
    -------------------------------------------------------------
    :array-buffer              Vertex attributes@*
    :atomic-counter-buffer     Atomic counter storage@*
    :copy-read-buffer          Buffer copy source@*
    :copy-write-buffer         Buffer copy destination
    :dispatch-indirect-buffer  Indirect compute dispatch commands
    :draw-indirect-buffer      Indirect command arguments
    :element-array-buffer      Vertex array indices@*
    :pixel-pack-buffer         Pixel read target@*
    :pixel-unpack-buffer       Texture data source@*
    :query-buffer              Query result buffer@*
    :shader-storage-buffer     Read-write storage for shaders@*
    :texture-buffer            Texture data buffer@*
    :transform-feedback-buffer Transform feedback buffer@*
    :uniform-buffer            Uniform block storage@*

Do note that the default of :array-buffer is perfectly fine for creating the
`gpu-buffer` and uploading the data. It does not limit how the buffer can be used
in future parts of your program.
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-BUFFERS package, , @t{cepl.gpu-buffers}}
@item Source
@ref{go to the cepl/core/gpu-buffers/gpu-buffers<dot>lisp file, , @t{core/gpu-buffers/gpu-buffers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-gpu-fence} ()
@anchor{go to the CEPL<dot>SYNC<colon><colon>MAKE-GPU-FENCE function}@c
@functionsubindex{make-gpu-fence}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SYNC package, , @t{cepl.sync}}
@item Source
@ref{go to the cepl/core/sync/sync<dot>lisp file, , @t{core/sync/sync.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-keyword} &rest ARGS
@anchor{go to the CEPL-UTILS<colon><colon>MAKE-KEYWORD function}@c
@functionsubindex{make-keyword}@c
This takes a list of symbols (or strings) and outputs one
   keyword symbol.@*
   If the input is symbol/s then the output is a regular keyword
   If the input is string/s, then the output is@*
   a :|keyword like this|
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-pixel-format} &key (COMPONENTS COMPONENTS) (TYPE TYPE) (NORMALIZE NORMALIZE) (SIZES SIZES) (REVERSED REVERSED) (COMP-LENGTH COMP-LENGTH)
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MAKE-PIXEL-FORMAT function}@c
@functionsubindex{make-pixel-format}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-primitives-generated-query} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MAKE-PRIMITIVES-GENERATED-QUERY function}@c
@functionsubindex{make-primitives-generated-query}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-project} PATHNAME &key NAME HOST REPL DEPENDS-ON
@anchor{go to the CEPL<colon><colon>MAKE-PROJECT function}@c
@functionsubindex{make-project}@c

This function is a simple way to make a lisp project with all the@*
supporting libraries to get up and running with cepl quickly.@*

It uses the excellent quickproject project, so before starting be sure@*
to run the following in your repl:@*

    (ql:quickload :quickproject)@*

By default it assumes you want to use sdl2, skitter and dirt, and that@*
you will be using slime as the communication layer between lisp and your editor.

Valid values for the :repl argument are currently :slime or :slynk.
@table @strong
@item Package
@ref{go to the CEPL package, , @t{cepl}}
@item Source
@ref{go to the cepl/project<dot>lisp file, , @t{project.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-raw-buffer-stream} &key VAO START LENGTH INDEX-TYPE MANAGED GPU-ARRAYS PRIMITIVE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MAKE-RAW-BUFFER-STREAM function}@c
@functionsubindex{make-raw-buffer-stream}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-render-buffer} ELEMENT-TYPE DIMENSIONS &key MULTISAMPLE
@anchor{go to the CEPL<dot>RENDER-BUFFERS<colon><colon>MAKE-RENDER-BUFFER function}@c
@functionsubindex{make-render-buffer}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>RENDER-BUFFERS package, , @t{cepl.render-buffers}}
@item Source
@ref{go to the cepl/core/render-buffers/render-buffer<dot>lisp file, , @t{core/render-buffers/render-buffer.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-sampler-id-box} &key (ID ID) (SHARED-P SHARED-P)
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MAKE-SAMPLER-ID-BOX function}@c
@functionsubindex{make-sampler-id-box}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-samples-passed-query} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MAKE-SAMPLES-PASSED-QUERY function}@c
@functionsubindex{make-samples-passed-query}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-ssbo} DATA &optional ELEMENT-TYPE
@anchor{go to the CEPL<dot>SSBOS<colon><colon>MAKE-SSBO function}@c
@functionsubindex{make-ssbo}@c

This function will make and return a new `ssbo`@*

You need only provide an element type and the lisp data to populate that type.

For example, given the following type:@*

   (defstruct-g test@*
     (scale :float :accessor scale)@*
     (age :int))@*

You create a ssbo using this type as follows:@*

    (make-ssbo '(1.2 10) 'test)@*

You can also pass in a c-array or gpu-array and omit the optional type
specifier.@*

If you wish to make a ssbo from a specific element of a `c-array` or
`gpu-array` please see the #'make-ssbo-from-array function
@table @strong
@item Package
@ref{go to the CEPL<dot>SSBOS package, , @t{cepl.ssbos}}
@item Source
@ref{go to the cepl/core/ssbos/ssbos<dot>lisp file, , @t{core/ssbos/ssbos.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-ssbo-from-array} DATA &optional INDEX ELEMENT-TYPE
@anchor{go to the CEPL<dot>SSBOS<colon><colon>MAKE-SSBO-FROM-ARRAY function}@c
@functionsubindex{make-ssbo-from-array}@c

This function takes a lisp-array, `c-array` or `gpu-array` and an index.@*
It returns a new `ssbo` with the specified element as the data of the ssbo.

If made from a c-array or lisp-array, a fresh gpu memory is allocated to hold
the data@*

If made from a gpu-array the ssbo simply holds a reference to the gpu-array
and the index. No new memory is allocated. This means that if that
gpu-array is destroyed then this ssbo is in an invalid state.@*

This also means it is possible to do invalid things when rendering. For example
say you used the ssbo as an input whilst streaming vertex data from the same
array. Consult GL documentation for details on such exceptional cases.
@table @strong
@item Package
@ref{go to the CEPL<dot>SSBOS package, , @t{cepl.ssbos}}
@item Source
@ref{go to the cepl/core/ssbos/ssbos<dot>lisp file, , @t{core/ssbos/ssbos.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-stencil-params} &key TEST VALUE MASK ON-STENCIL-TEST-FAIL ON-STENCIL-PASS-DEPTH-TEST-FAIL ON-STENCIL-PASS-DEPTH-TEST-PASS
@anchor{go to the CEPL<dot>STENCIL<colon><colon>MAKE-STENCIL-PARAMS function}@c
@functionsubindex{make-stencil-params}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>STENCIL package, , @t{cepl.stencil}}
@item Source
@ref{go to the cepl/core/stencil/stencil<dot>lisp file, , @t{core/stencil/stencil.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-surface} &rest ARGS &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>MAKE-SURFACE function}@c
@functionsubindex{make-surface}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-surface-current} CEPL-CONTEXT SURFACE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>MAKE-SURFACE-CURRENT function}@c
@functionsubindex{make-surface-current}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/surface<dot>lisp file, , @t{core/context/surface.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-texture} INITIAL-CONTENTS &key DIMENSIONS ELEMENT-TYPE MIPMAP LAYER-COUNT CUBES RECTANGLE IMMUTABLE BUFFER-STORAGE GENERATE-MIPMAPS PIXEL-FORMAT SAMPLES FIXED-SAMPLE-LOCATIONS
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>MAKE-TEXTURE function}@c
@functionsubindex{make-texture}@c

This function allows you to make any kind of `texture` based on the arguments@*
provided. Whilst the signature is quite intimidating your rarely need to use@*
more than a few of the arguments to make a given texture.@*

For example:@*

    (make-texture '(1 2 3 4))@*

 will give you a valid texture.@*

We will now go through the arguments and their behaviours:@*

**-- :initial-contents :dimensions & :element-type --**@*

- with :initial-contents to nil:@*
  In this case you need to provide dimensions and an element-type.@*

- with :initial-contents populated.@*
  The initial-contents can be a (potentially nested) list, array or `c-array`.@*

When the :initial-contents are a c-array then the dimensions and element-type@*
are taken from the c-array. As the data is already in foreign memory the@*
upload will be notable faster that from lisp-data->gpu as no type conversions@*
are needed@*

When the :initial-contents are an array then the dimension of the texture@*
will be the same as the array passed in. Remember OpenGL only allows up to@*
3 dimensions for the textures@*

When the :initial-contents is a flat list then each element is used as one@*
element in the textures `gpu-array`@*

If the :initial-contents is a nested list then you must either:@*

- specify multiple dimensions and an element-type@*
- specify an element-type to be some struct type, then nested lists are then@*
  used to populate the fields of the foreign structs. For an example of this@*
  please see this example: https://github.com/cbaggers/cepl.examples/blob/master/examples/triangle.lisp#L30.

If the :element-type is not provided then CEPL will look at every element in@*
the initial-contents and try and find the smallest (in bytes) foreign type@*
which works for every element. This mean if the array is full of single-floats@*
then CEPL will choose :float, not :double.@*
Naturally this behaviour is too slow for use in performance critical@*
applications however it is nice for experimentation and working from the repl.@*

Extra element-type details:@*
Unlike c-array and gpu-arrays (which use foreign types for their elements)@*
textures have a different set of acceptable element-types. These are called@*
'image formats'.@*

If you provide a GL image-format as the :element-type CEPL will use it directly@*

If you provide a (foreign) lisp type then CEPL will try to find the appropriate@*
image-format for that type.@*

**-- :pixel-format --**@*

If this optional argument is not nil, then CEPL will use the pixel format@*
provided when uploading the pixel data.@*

Usually this is not provided as CEPL can calculate a valid pixel-format to@*
use from the element-type.@*

**-- :mipmap & :generate-mipmaps --**@*

If this is set to t then CEPL will make mipmaps for the `texture`. The texture@*
will have (floor (log (apply #'max dimensions) 2)) levels of mipmaps@*

If this is set to a positive integer CEPL will check that the number of levels@*
is allowed for the dimensions given and make that many levels of mipmaps.@*

If generate-mipmaps is t CEPL will ask OpenGL to generate content for all the@*
mipmaps levels.@*

**-- :layer-count --**@*

If this is set to a value greater than 1 then you are trying to create one of@*
the following:@*

:texture-1d-array@*
:texture-2d-array@*
:texture-cube-map-array@*

Which one is created depends on the dimensions provided and whether cubes is t.@*

**-- :cubes --**@*

If this is t then you are trying to make a cube-map texture@*

**-- :rectangle --**@*

If this is t then you are trying to make a rectangle texture.@*

This is different from a regular 2d texture (which can also be rectangular)@*

This texture only has one 2-dimensional `gpu-array`. The texture cannot have@*
mipmapping. Texture coordinates used for these textures are not normalized.@*

**-- :samples --**@*

Specify the number of samples in the texture (see the GL wiki for more details@*
on multisample textures)@*

**-- :immutable --**@*

Set this to nil if you definitely dont want to use immutable texture storage.@*
See the docstring for 'texture for more details@*

**-- :buffer-storage --**@*

If this is set to t you are trying to make a `buffer-texture`.@*

If you set this to t then the `element-type` should NOT be an image-format. Use@*
a foreign lisp type instead. Or leave it nil if you want CEPL to take the type@*
from the initial-contents@*

See the docstring for `texture` for more details.
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-texture-from-id} GL-OBJECT &key BASE-DIMENSIONS TEXTURE-TYPE ELEMENT-TYPE MIPMAP-LEVELS LAYER-COUNT CUBES ALLOCATED MUTABLE-P SAMPLES FIXED-SAMPLE-LOCATIONS
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>MAKE-TEXTURE-FROM-ID function}@c
@functionsubindex{make-texture-from-id}@c

Wrap and existing GL Texture Object in a CEPL `texture` struct.@*

This function does not do ANY sanity checking on the values provided, use only
if you are 100% sure of what you are setting.@*

We will now go through the arguments and their behaviours:@*

**-- :dimensions --**@*

It is required that you provide dimensions when calling this function.@*

The dimensions can be a single integer (for a 1D texture) or a list of
integers (for a multi-dimensional texture).@*

One differnce between make-texture and make-texture-from-id is that in this
function it is valid to pass the symbol ? in place of a dimension when it is
unknown. CEPL will not complain but will store 0 in place of the unknown dimension
which may cause issues if you try and use any function that expects to be able
to get valid size information.@*

**-- :element-type --**@*

It is required that you provide an element-type when calling this function.@*

Unlike c-array and gpu-arrays (which use foreign types for their elements)
textures have a different set of acceptable element-types. These are called
'image formats'.@*

NOTES: Unlike `make-texture`, `make-texture-from-id` does not attempt to
convert lisp types or pixel-formats to GLSL image-formats@*


**-- :mipmap-levels --**@*

This tells CEPL the number of mipmap levels the texture has.@*

1 is the default.@*

**-- :layer-count --**@*

If this is set to a value greater than 1 then the texture is one of@*
the following:@*

:texture-1d-array@*
:texture-2d-array@*
:texture-cube-map-array@*

Which one is created depends on the dimensions provided and whether cubes is t.

**-- :cubes --**@*

If this is t then you are trying to make a cube-map texture@*

**-- :samples --**@*

Specify the number of samples in the texture (see the GL wiki for more details
on multisample textures)@*

**-- :mutable-p --**@*

Speicifies if the texture is using mutable storage.@*

See the docstring for `texture` for more details.
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-time-elapsed-query} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MAKE-TIME-ELAPSED-QUERY function}@c
@functionsubindex{make-time-elapsed-query}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-timestamp-query} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MAKE-TIMESTAMP-QUERY function}@c
@functionsubindex{make-timestamp-query}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-transform-feedback-primitives-written-query} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MAKE-TRANSFORM-FEEDBACK-PRIMITIVES-WRITTEN-QUERY function}@c
@functionsubindex{make-transform-feedback-primitives-written-query}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-transform-feedback-stream} &rest BUFFER-BACKED-GPU-ARRAYS
@anchor{go to the CEPL<dot>TRANSFORM-FEEDBACK<colon><colon>MAKE-TRANSFORM-FEEDBACK-STREAM function}@c
@functionsubindex{make-transform-feedback-stream}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TRANSFORM-FEEDBACK package, , @t{cepl.transform-feedback}}
@item Source
@ref{go to the cepl/core/transform-feedback/transform-feedback<dot>lisp file, , @t{core/transform-feedback/transform-feedback.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-ubo} DATA &optional ELEMENT-TYPE
@anchor{go to the CEPL<dot>UBOS<colon><colon>MAKE-UBO function}@c
@functionsubindex{make-ubo}@c

This function will make and return a new `ubo`@*

You need only provide an element type and the lisp data to populate that type.

For example, given the following type:@*

   (defstruct-g test@*
     (scale :float :accessor scale)@*
     (age :int))@*

You create a ubo using this type as follows:@*

    (make-ubo '(1.2 10) 'test)@*

You can also pass in a c-array or gpu-array and omit the optional type
specifier.@*

If you wish to make a ubo from a specific element of a `c-array` or
`gpu-array` please see the #'make-ubo-from-array function.
@table @strong
@item Package
@ref{go to the CEPL<dot>UBOS package, , @t{cepl.ubos}}
@item Source
@ref{go to the cepl/core/ubos/ubo<dot>lisp file, , @t{core/ubos/ubo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-ubo-from-array} DATA &optional INDEX ELEMENT-TYPE
@anchor{go to the CEPL<dot>UBOS<colon><colon>MAKE-UBO-FROM-ARRAY function}@c
@functionsubindex{make-ubo-from-array}@c

This function takes a lisp-array, `c-array` or `gpu-array` and an index.@*
It returns a new `ubo` with the specified element as the data of the ubo.@*

If made from a c-array or lisp-array, a fresh gpu memory is allocated to hold
the data@*

If made from a gpu-array the ubo simply holds a reference to the gpu-array
and the index. No new memory is allocated. This means that if that
gpu-array is destroyed then this ubo is in an invalid state.@*

This also means it is possible to do invalid things when rendering. For example
say you used the ubo as an input whilst streaming vertex data from the same
array. Consult GL documentation for details on such exceptional cases.
@table @strong
@item Package
@ref{go to the CEPL<dot>UBOS package, , @t{cepl.ubos}}
@item Source
@ref{go to the cepl/core/ubos/ubo<dot>lisp file, , @t{core/ubos/ubo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-uninitialized-buffer-stream} PRIMITIVE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MAKE-UNINITIALIZED-BUFFER-STREAM function}@c
@functionsubindex{make-uninitialized-buffer-stream}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/nulls-and-uninitialized<dot>lisp file, , @t{core/types/nulls-and-uninitialized.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-uninitialized-fbo} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MAKE-UNINITIALIZED-FBO function}@c
@functionsubindex{make-uninitialized-fbo}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/nulls-and-uninitialized<dot>lisp file, , @t{core/types/nulls-and-uninitialized.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-uninitialized-gpu-array-bb} &optional BUFFER
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MAKE-UNINITIALIZED-GPU-ARRAY-BB function}@c
@functionsubindex{make-uninitialized-gpu-array-bb}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/nulls-and-uninitialized<dot>lisp file, , @t{core/types/nulls-and-uninitialized.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-uninitialized-gpu-array-t} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MAKE-UNINITIALIZED-GPU-ARRAY-T function}@c
@functionsubindex{make-uninitialized-gpu-array-t}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/nulls-and-uninitialized<dot>lisp file, , @t{core/types/nulls-and-uninitialized.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-uninitialized-gpu-buffer} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MAKE-UNINITIALIZED-GPU-BUFFER function}@c
@functionsubindex{make-uninitialized-gpu-buffer}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/nulls-and-uninitialized<dot>lisp file, , @t{core/types/nulls-and-uninitialized.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-uninitialized-render-buffer} &optional MULTISAMPLE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MAKE-UNINITIALIZED-RENDER-BUFFER function}@c
@functionsubindex{make-uninitialized-render-buffer}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/nulls-and-uninitialized<dot>lisp file, , @t{core/types/nulls-and-uninitialized.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-uninitialized-sampler} TEXTURE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MAKE-UNINITIALIZED-SAMPLER function}@c
@functionsubindex{make-uninitialized-sampler}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/nulls-and-uninitialized<dot>lisp file, , @t{core/types/nulls-and-uninitialized.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-uninitialized-texture} &optional BUFFER-BACKED-P
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MAKE-UNINITIALIZED-TEXTURE function}@c
@functionsubindex{make-uninitialized-texture}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/nulls-and-uninitialized<dot>lisp file, , @t{core/types/nulls-and-uninitialized.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-vao} GPU-ARRAYS &optional INDEX-ARRAY
@anchor{go to the CEPL<dot>VAOS<colon><colon>MAKE-VAO function}@c
@functionsubindex{make-vao}@c

This function returns a new GL VAO when given

- a list of gpu-arrays@*
- optionally 1 gpu-array to be used as an index
@table @strong
@item Package
@ref{go to the CEPL<dot>VAOS package, , @t{cepl.vaos}}
@item Source
@ref{go to the cepl/core/vaos/vaos<dot>lisp file, , @t{core/vaos/vaos.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-vao-from-id} GL-OBJECT GPU-ARRAYS &optional INDEX-ARRAY
@anchor{go to the CEPL<dot>VAOS<colon><colon>MAKE-VAO-FROM-ID function}@c
@functionsubindex{make-vao-from-id}@c

This function takes an existing OpenGL VAO and set it up to stream vertices from
the given arrays.
@table @strong
@item Package
@ref{go to the CEPL<dot>VAOS package, , @t{cepl.vaos}}
@item Source
@ref{go to the cepl/core/vaos/vaos<dot>lisp file, , @t{core/vaos/vaos.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-viewport} &optional RESOLUTION ORIGIN
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MAKE-VIEWPORT function}@c
@functionsubindex{make-viewport}@c

This function returns a new `viewport` with the specified resolution and
origin
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {map-c} FUNCTION C-ARRAY &optional DESTINATION-ELEMENT-TYPE
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>MAP-C function}@c
@functionsubindex{map-c}@c

When given a function and a `c-array` this function will map the function across
every element of the c-array and write the results of the function into a new
c-array with the same element-type and dimensions as the original c-array.@*

You may also pass in an optional foreign type that will be used as the element
type of the new array.@*

If, rather than making a new c-array, you wish to modify the given c-array you
should use `map-c-into` instead.
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/map<dot>lisp file, , @t{core/c-arrays/map.lisp}} (file)
@end table
@end deffn
@deffn {Function} {map-c-into} DESTINATION-C-ARRAY FUNCTION SOURCE-C-ARRAY
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>MAP-C-INTO function}@c
@functionsubindex{map-c-into}@c

When given a destination `c-array`, a function and a source c-array this function
will map the function across every element of the source c-array and write the
results of the function destrucively into the destination c-array.
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/map<dot>lisp file, , @t{core/c-arrays/map.lisp}} (file)
@end table
@end deffn
@deffn {Function} {mapcat} FUNCTION &rest LISTS
@anchor{go to the CEPL-UTILS<colon><colon>MAPCAT function}@c
@functionsubindex{mapcat}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {mat2-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>MAT2-FROM-FOREIGN function}@c
@functionsubindex{mat2-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {mat2-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>MAT2-TO-FOREIGN function}@c
@functionsubindex{mat2-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {mat2x2-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>MAT2X2-FROM-FOREIGN function}@c
@functionsubindex{mat2x2-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {mat2x2-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>MAT2X2-TO-FOREIGN function}@c
@functionsubindex{mat2x2-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {mat2x3-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>MAT2X3-FROM-FOREIGN function}@c
@functionsubindex{mat2x3-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {mat2x3-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>MAT2X3-TO-FOREIGN function}@c
@functionsubindex{mat2x3-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {mat2x4-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>MAT2X4-FROM-FOREIGN function}@c
@functionsubindex{mat2x4-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {mat2x4-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>MAT2X4-TO-FOREIGN function}@c
@functionsubindex{mat2x4-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {mat3-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>MAT3-FROM-FOREIGN function}@c
@functionsubindex{mat3-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {mat3-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>MAT3-TO-FOREIGN function}@c
@functionsubindex{mat3-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {mat3x2-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>MAT3X2-FROM-FOREIGN function}@c
@functionsubindex{mat3x2-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {mat3x2-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>MAT3X2-TO-FOREIGN function}@c
@functionsubindex{mat3x2-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {mat3x3-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>MAT3X3-FROM-FOREIGN function}@c
@functionsubindex{mat3x3-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {mat3x3-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>MAT3X3-TO-FOREIGN function}@c
@functionsubindex{mat3x3-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {mat3x4-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>MAT3X4-FROM-FOREIGN function}@c
@functionsubindex{mat3x4-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {mat3x4-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>MAT3X4-TO-FOREIGN function}@c
@functionsubindex{mat3x4-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {mat4-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>MAT4-FROM-FOREIGN function}@c
@functionsubindex{mat4-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {mat4-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>MAT4-TO-FOREIGN function}@c
@functionsubindex{mat4-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {mat4x2-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>MAT4X2-FROM-FOREIGN function}@c
@functionsubindex{mat4x2-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {mat4x2-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>MAT4X2-TO-FOREIGN function}@c
@functionsubindex{mat4x2-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {mat4x3-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>MAT4X3-FROM-FOREIGN function}@c
@functionsubindex{mat4x3-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {mat4x3-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>MAT4X3-TO-FOREIGN function}@c
@functionsubindex{mat4x3-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {mat4x4-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>MAT4X4-FROM-FOREIGN function}@c
@functionsubindex{mat4x4-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {mat4x4-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>MAT4X4-TO-FOREIGN function}@c
@functionsubindex{mat4x4-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {max-lod} SAMPLER
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MAX-LOD function}@c
@functionsubindex{max-lod}@c

This function sets the max-lod of the given `texture` or `sampler`@*


**-- LOD --**@*

Together with :min-lod this sampling parameter affects the mipmap image
selection.@*

The way these work in mipmap selection is quite complicated; the specification
goes into full detail about it.@*

example:@*

    (setf (min-lod texture-or-sampler) value)@*
    (setf (max-lod texture-or-sampler) value)
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF MAX-LOD) function, , @t{(setf max-lod)}} (function)
@end table
@end deffn
@deffn {Function} {(setf max-lod)} VALUE SAMPLER
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF MAX-LOD) function}@c
@functionsubindex{(setf max-lod)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>MAX-LOD function, , @t{max-lod}} (function)
@end table
@end deffn
@deffn {Function} {min-lod} SAMPLER
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MIN-LOD function}@c
@functionsubindex{min-lod}@c

This function sets the min-lod of the given `texture` or `sampler`@*


**-- LOD --**@*

Together with :max-lod this sampling parameter affects the mipmap image
selection.@*

The way these work in mipmap selection is quite complicated; the specification
goes into full detail about it.@*

example:@*

    (setf (min-lod texture-or-sampler) value)@*
    (setf (max-lod texture-or-sampler) value)
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF MIN-LOD) function, , @t{(setf min-lod)}} (function)
@end table
@end deffn
@deffn {Function} {(setf min-lod)} VALUE SAMPLER
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF MIN-LOD) function}@c
@functionsubindex{(setf min-lod)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>MIN-LOD function, , @t{min-lod}} (function)
@end table
@end deffn
@deffn {Function} {minify-filter} SAMPLER
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MINIFY-FILTER function}@c
@functionsubindex{minify-filter}@c

This function takes a `sampler` or `texture` and sets the approach used when the
area of the fragment in texture space is larger than a texel.@*

**-- The minification filter --**@*

The minification filter is controlled by the :texture-min-filter texture
parameter. To understand these values better, it is important to discuss what
the particular options are. Here is the full list:@*

    :nearest                 :linear@*
    :nearest-mipmap-nearest  :nearest-mipmap-linear@*
    :linear-mipmap-nearest   :linear-mipmap-linear@*

When doing minification, you can choose to use mipmapping or not. Using
mipmapping means selecting between multiple mipmaps based on the angle and size
of the texture relative to the screen. Whether you use mipmapping or not,
you can still select between linear blending of the particular layer or nearest.
And if you do use mipmapping, you can choose to either select a single mipmap to
sample from, or you can sample the two adjacent mipmaps and linearly blend the
resulting values to get the final result.@*

    The OpenGL minification settings for these are as follows:@*
    Param Setting            Lin within mip-level@*
    :nearest                 No@*
    :linear                  Yes@*
    :nearest-mipmap-nearest  No@*
    :linear-mipmap-nearest   Yes@*
    :nearest-mipmap-linear   No@*
    :linear-mipmap-linear    Yes@*

    Param Setting            Has mipmapping@*
    :nearest                 No@*
    :linear                  No@*
    :nearest-mipmap-nearest  Yes@*
    :linear-mipmap-nearest   Yes@*
    :nearest-mipmap-linear   Yes@*
    :linear-mipmap-linear    Yes@*

    Param Setting            Linear between mip-levels@*
    :nearest                 -@*
    :linear                  -@*
    :nearest-mipmap-nearest  No@*
    :linear-mipmap-nearest   No@*
    :nearest-mipmap-linear   Yes@*
    :linear-mipmap-linear    Yes@*

Remembering these combinations can be annoying so CEPL provides an additional
function called #'set-minify-filter see the docstring for details@*

examples:@*

    (setf (minify-filter tex-or-sampler) :linear)@*
    (setf (minify-filter tex-or-sampler) :nearest-mipmap-nearest)
    (setf-minify-filter tex-or-sampler :nearest :nearest)@*

@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF MINIFY-FILTER) function, , @t{(setf minify-filter)}} (function)
@end table
@end deffn
@deffn {Function} {(setf minify-filter)} VALUE SAMPLER
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF MINIFY-FILTER) function}@c
@functionsubindex{(setf minify-filter)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>MINIFY-FILTER function, , @t{minify-filter}} (function)
@end table
@end deffn
@deffn {Function} {mkstr} &rest ARGS
@anchor{go to the CEPL-UTILS<colon><colon>MKSTR function}@c
@functionsubindex{mkstr}@c
Takes a list of strings or symbols and returns one string
   of them concatenated together. For example:
    CEPL-EXAMPLES> (cepl-utils:mkstr 'jam 'ham')
     'JAMHAM'@*
    CEPL-EXAMPLES> (cepl-utils:mkstr 'jam' 'ham')
     'jamham'
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {mode-alpha} FBO &optional ATTACHMENT-NAME
@anchor{go to the CEPL<dot>BLENDING<colon><colon>MODE-ALPHA function}@c
@functionsubindex{mode-alpha}@c

This function, when passed a `blending-params` object, will return the name of the
equation that will be used to compute the final alpha value from the processed
`source-alpha` and `destination-alpha`.@*

The result will be one of the following:@*

    :func-add@*
    :func-subtract@*
    :func-reverse-subtract@*
    :min@*
    :max@*

To see more info on this subject please see the doc-string for the
blending-params struct.
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@item Writer
@ref{go to the CEPL<dot>BLENDING<colon><colon>(SETF MODE-ALPHA) function, , @t{(setf mode-alpha)}} (function)
@end table
@end deffn
@deffn {Function} {(setf mode-alpha)} VALUE FBO &optional ATTACHMENT-NAME
@anchor{go to the CEPL<dot>BLENDING<colon><colon>(SETF MODE-ALPHA) function}@c
@functionsubindex{(setf mode-alpha)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@item Reader
@ref{go to the CEPL<dot>BLENDING<colon><colon>MODE-ALPHA function, , @t{mode-alpha}} (function)
@end table
@end deffn
@deffn {Function} {mode-rgb} FBO &optional ATTACHMENT-NAME
@anchor{go to the CEPL<dot>BLENDING<colon><colon>MODE-RGB function}@c
@functionsubindex{mode-rgb}@c

This function, when passed a `blending-params` object, will return the name of the
equation that will be used to compute the final color value from the processed
`source-rgb` and `destination-rgb`.@*

The result will be one of the following:@*

    :func-add@*
    :func-subtract@*
    :func-reverse-subtract@*
    :min@*
    :max@*

To see more info on this subject please see the doc-string for the
blending-params struct.
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@item Writer
@ref{go to the CEPL<dot>BLENDING<colon><colon>(SETF MODE-RGB) function, , @t{(setf mode-rgb)}} (function)
@end table
@end deffn
@deffn {Function} {(setf mode-rgb)} VALUE FBO &optional ATTACHMENT-NAME
@anchor{go to the CEPL<dot>BLENDING<colon><colon>(SETF MODE-RGB) function}@c
@functionsubindex{(setf mode-rgb)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@item Reader
@ref{go to the CEPL<dot>BLENDING<colon><colon>MODE-RGB function, , @t{mode-rgb}} (function)
@end table
@end deffn
@deffn {Function} {multi-buffer-data} BUFFER C-ARRAYS TARGET USAGE
@anchor{go to the CEPL<dot>GPU-BUFFERS<colon><colon>MULTI-BUFFER-DATA function}@c
@functionsubindex{multi-buffer-data}@c

This function takes a list of `c-array`s and uploads all of the data to the
`gpu-buffer`.
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-BUFFERS package, , @t{cepl.gpu-buffers}}
@item Source
@ref{go to the cepl/core/gpu-buffers/gpu-buffers<dot>lisp file, , @t{core/gpu-buffers/gpu-buffers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {n-of} THING COUNT
@anchor{go to the CEPL-UTILS<colon><colon>N-OF function}@c
@functionsubindex{n-of}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {never} INCOMING-VAL STORED-VAL
@anchor{go to the CEPL<dot>DOCUMENTATION-FUNCTIONS<colon><colon>NEVER function}@c
@functionsubindex{never}@c
Never passes
@table @strong
@item Package
@ref{go to the CEPL<dot>DOCUMENTATION-FUNCTIONS package, , @t{cepl.documentation-functions}}
@item Source
@ref{go to the cepl/core/context/documentation-functions<dot>lisp file, , @t{core/context/documentation-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {ni-call} PACKAGE-NAME FUNC-NAME &rest ARGS
@anchor{go to the CEPL-UTILS<colon><colon>NI-CALL function}@c
@functionsubindex{ni-call}@c
Non-interning funcall
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {ni-val} PACKAGE-NAME SYMB-NAME
@anchor{go to the CEPL-UTILS<colon><colon>NI-VAL function}@c
@functionsubindex{ni-val}@c
Non-interning get value
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {one} INCOMING-VAL STORED-VAL
@anchor{go to the CEPL<dot>DOCUMENTATION-FUNCTIONS<colon><colon>ONE function}@c
@functionsubindex{one}@c
Always returns 0
@table @strong
@item Package
@ref{go to the CEPL<dot>DOCUMENTATION-FUNCTIONS package, , @t{cepl.documentation-functions}}
@item Source
@ref{go to the cepl/core/context/documentation-functions<dot>lisp file, , @t{core/context/documentation-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {pack-alignment} &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>PACK-ALIGNMENT function}@c
@functionsubindex{pack-alignment}@c
@deffnx {Function} {(setf pack-alignment)} ROW-ALIGNMENT &optional FORCE CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF PACK-ALIGNMENT) function}@c
@functionsubindex{(setf pack-alignment)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/pixel-store/pixel-store<dot>lisp file, , @t{core/pixel-store/pixel-store.lisp}} (file)
@end table
@end deffn
@deffn {Function} {parse-body+} NAME BODY &optional EXTRA-DECLS
@anchor{go to the CEPL<dot>DEFN<colon><colon>PARSE-BODY+ function}@c
@functionsubindex{parse-body+}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>DEFN package, , @t{cepl.defn}}
@item Source
@ref{go to the cepl<dot>build/defn/defn<dot>lisp file, , @t{defn/defn.lisp}} (file)
@end table
@end deffn
@deffn {Function} {per-attachment-blending-available-p} &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>FBOS<colon><colon>PER-ATTACHMENT-BLENDING-AVAILABLE-P function}@c
@functionsubindex{per-attachment-blending-available-p}@c

This function will return t if you are on a version of opengl that supports
setting blending parameters on framebuffer `attachment`s. Otherwise it returns nil

If the result is nil then you will only be able to change blend params on the
first attachment. You can however enable blending on any number of attachments
and they will inherit their params from attachment 0@*

For more details see `cepl.blending`
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@end table
@end deffn
@deffn {Function} {pixel-format->image-format} PIXEL-FORMAT &key ERROR-IF-MISSING
@anchor{go to the CEPL<dot>TYPES<colon><colon>PIXEL-FORMAT->IMAGE-FORMAT function}@c
@functionsubindex{pixel-format->image-format}@c

This function, when given a `pixel-format` object, will attempt to find and
return the name of a GL image-format that is equivalent.@*

If no such type is found then nil is returned
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/pixel-format<dot>lisp file, , @t{core/types/pixel-format.lisp}} (file)
@end table
@end deffn
@deffn {Function} {pixel-format->lisp-type} PIXEL-FORMAT
@anchor{go to the CEPL<dot>TYPES<colon><colon>PIXEL-FORMAT->LISP-TYPE function}@c
@functionsubindex{pixel-format->lisp-type}@c

This function, when given a `pixel-format` object, will attempt to find and
return the name of a lisp type that is equivalent.@*

If no such type is found then nil is returned
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/pixel-format<dot>lisp file, , @t{core/types/pixel-format.lisp}} (file)
@end table
@end deffn
@deffn {Function} {pixel-format-comp-length} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>PIXEL-FORMAT-COMP-LENGTH function}@c
@functionsubindex{pixel-format-comp-length}@c

This function when passed a `pixel-format` will return the number of components
it has. The values will be from 1 upto 4
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF PIXEL-FORMAT-COMP-LENGTH) function, , @t{(setf pixel-format-comp-length)}} (function)
@end table
@end deffn
@deffn {Function} {(setf pixel-format-comp-length)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF PIXEL-FORMAT-COMP-LENGTH) function}@c
@functionsubindex{(setf pixel-format-comp-length)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>PIXEL-FORMAT-COMP-LENGTH function, , @t{pixel-format-comp-length}} (function)
@end table
@end deffn
@deffn {Function} {pixel-format-components} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>PIXEL-FORMAT-COMPONENTS function}@c
@functionsubindex{pixel-format-components}@c

This function returns the components of the given `pixel-format` as a keyword

possible values are:@*
:r@*
:rg@*
:rgb@*
:rgba@*
:stencil-only@*
:depth
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF PIXEL-FORMAT-COMPONENTS) function, , @t{(setf pixel-format-components)}} (function)
@end table
@end deffn
@deffn {Function} {(setf pixel-format-components)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF PIXEL-FORMAT-COMPONENTS) function}@c
@functionsubindex{(setf pixel-format-components)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>PIXEL-FORMAT-COMPONENTS function, , @t{pixel-format-components}} (function)
@end table
@end deffn
@deffn {Function} {pixel-format-normalize} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>PIXEL-FORMAT-NORMALIZE function}@c
@functionsubindex{pixel-format-normalize}@c

This function returns whether values of the components belonging to the
`pixel-format` are normalized.@*

If t then sampling the values on the gpu will gives values in the
range 0s0  1s0
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF PIXEL-FORMAT-NORMALIZE) function, , @t{(setf pixel-format-normalize)}} (function)
@end table
@end deffn
@deffn {Function} {(setf pixel-format-normalize)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF PIXEL-FORMAT-NORMALIZE) function}@c
@functionsubindex{(setf pixel-format-normalize)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>PIXEL-FORMAT-NORMALIZE function, , @t{pixel-format-normalize}} (function)
@end table
@end deffn
@deffn {Function} {pixel-format-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>PIXEL-FORMAT-P function}@c
@functionsubindex{pixel-format-p}@c

This function returns t if the the given value is a `pixel-format`. Otherwise it
returns nil
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {pixel-format-reversed} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>PIXEL-FORMAT-REVERSED function}@c
@functionsubindex{pixel-format-reversed}@c

Some `pixel-format`s are 'reversed' meaning the component order in the data is
reversed.@*

This function will return t if the pixel format provided is a reversed-type
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF PIXEL-FORMAT-REVERSED) function, , @t{(setf pixel-format-reversed)}} (function)
@end table
@end deffn
@deffn {Function} {(setf pixel-format-reversed)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF PIXEL-FORMAT-REVERSED) function}@c
@functionsubindex{(setf pixel-format-reversed)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>PIXEL-FORMAT-REVERSED function, , @t{pixel-format-reversed}} (function)
@end table
@end deffn
@deffn {Function} {pixel-format-sizes} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>PIXEL-FORMAT-SIZES function}@c
@functionsubindex{pixel-format-sizes}@c

Some `pixel-format`s and image-formats are 'special' and have specifically sized
components.@*

This function will return a list of sizes in bits of the components.
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF PIXEL-FORMAT-SIZES) function, , @t{(setf pixel-format-sizes)}} (function)
@end table
@end deffn
@deffn {Function} {(setf pixel-format-sizes)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF PIXEL-FORMAT-SIZES) function}@c
@functionsubindex{(setf pixel-format-sizes)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>PIXEL-FORMAT-SIZES function, , @t{pixel-format-sizes}} (function)
@end table
@end deffn
@deffn {Function} {pixel-format-type} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>PIXEL-FORMAT-TYPE function}@c
@functionsubindex{pixel-format-type}@c

This function returns the lisp type of a single 'element' of the given
`pixel-format`.@*

For example:@*
- the element type of a :vec3 is a :float.@*
- the element type of a :vec2 is a :float.@*
- the element type of a :int8 is a :int8
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF PIXEL-FORMAT-TYPE) function, , @t{(setf pixel-format-type)}} (function)
@end table
@end deffn
@deffn {Function} {(setf pixel-format-type)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF PIXEL-FORMAT-TYPE) function}@c
@functionsubindex{(setf pixel-format-type)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>PIXEL-FORMAT-TYPE function, , @t{pixel-format-type}} (function)
@end table
@end deffn
@deffn {Function} {ptr-index} C-ARRAY X &optional Y Z W
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>PTR-INDEX function}@c
@functionsubindex{ptr-index}@c

This function takes a `c-array` and some subscripts and will return the ptr to the
specified element of the c-array
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/aref-c<dot>lisp file, , @t{core/c-arrays/aref-c.lisp}} (file)
@end table
@end deffn
@deffn {Function} {pull-all-gpu-commands-issued-time} ()
@anchor{go to the CEPL<dot>QUERIES<colon><colon>PULL-ALL-GPU-COMMANDS-ISSUED-TIME function}@c
@functionsubindex{pull-all-gpu-commands-issued-time}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>QUERIES package, , @t{cepl.queries}}
@item Source
@ref{go to the cepl/core/queries/query<dot>lisp file, , @t{core/queries/query.lisp}} (file)
@end table
@end deffn
@deffn {Function} {pull-gpu-query-result} QUERY &optional WAIT
@anchor{go to the CEPL<dot>QUERIES<colon><colon>PULL-GPU-QUERY-RESULT function}@c
@functionsubindex{pull-gpu-query-result}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>QUERIES package, , @t{cepl.queries}}
@item Source
@ref{go to the cepl/core/queries/query<dot>lisp file, , @t{core/queries/query.lisp}} (file)
@end table
@end deffn
@deffn {Function} {push-gpu-query-result-to-gpu-array} QUERY DESTINATION-GPU-ARRAY &optional DESTINATION-ARRAY-INDEX
@anchor{go to the CEPL<dot>QUERIES<colon><colon>PUSH-GPU-QUERY-RESULT-TO-GPU-ARRAY function}@c
@functionsubindex{push-gpu-query-result-to-gpu-array}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>QUERIES package, , @t{cepl.queries}}
@item Source
@ref{go to the cepl/core/queries/query<dot>lisp file, , @t{core/queries/query.lisp}} (file)
@end table
@end deffn
@deffn {Function} {query-all-gpu-commands-completed-time} TIMESTAMP-QUERY
@anchor{go to the CEPL<dot>QUERIES<colon><colon>QUERY-ALL-GPU-COMMANDS-COMPLETED-TIME function}@c
@functionsubindex{query-all-gpu-commands-completed-time}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>QUERIES package, , @t{cepl.queries}}
@item Source
@ref{go to the cepl/core/queries/query<dot>lisp file, , @t{core/queries/query.lisp}} (file)
@end table
@end deffn
@deffn {Function} {quit} ()
@anchor{go to the CEPL<colon><colon>QUIT function}@c
@functionsubindex{quit}@c

Call this to shutdown CEPL.@*

As well as its own internal work, CEPL will ask the host to shut itself down.
@table @strong
@item Package
@ref{go to the CEPL package, , @t{cepl}}
@item Source
@ref{go to the cepl/core/repl<dot>lisp file, , @t{core/repl.lisp}} (file)
@end table
@end deffn
@deffn {Function} {range} X &optional Y Z U V
@anchor{go to the CEPL-UTILS<colon><colon>RANGE function}@c
@functionsubindex{range}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {rangei} X &optional Y Z U V
@anchor{go to the CEPL-UTILS<colon><colon>RANGEI function}@c
@functionsubindex{rangei}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {read-fbo-bound} CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>READ-FBO-BOUND function}@c
@functionsubindex{read-fbo-bound}@c
@deffnx {Function} {(setf read-fbo-bound)} FBO CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF READ-FBO-BOUND) function}@c
@functionsubindex{(setf read-fbo-bound)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {read-integers} &optional STREAM EOF-ERROR-P EOF-VALUE RECURSIVE-P
@anchor{go to the CEPL-UTILS<colon><colon>READ-INTEGERS function}@c
@functionsubindex{read-integers}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {reallocate-buffer} BUFFER
@anchor{go to the CEPL<dot>GPU-BUFFERS<colon><colon>REALLOCATE-BUFFER function}@c
@functionsubindex{reallocate-buffer}@c

This function takes a buffer and recreates the data-store for it. All data currently in the buffer will be lost.
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-BUFFERS package, , @t{cepl.gpu-buffers}}
@item Source
@ref{go to the cepl/core/gpu-buffers/gpu-buffers<dot>lisp file, , @t{core/gpu-buffers/gpu-buffers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {reallocate-gpu-array} GPU-ARRAY
@anchor{go to the CEPL<dot>GPU-ARRAYS<colon><colon>REALLOCATE-GPU-ARRAY function}@c
@functionsubindex{reallocate-gpu-array}@c

This function takes a `gpu-array` and reallocates the buffer that is backing it.
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS package, , @t{cepl.gpu-arrays}}
@item Source
@ref{go to the cepl/core/gpu-arrays/with-and-push<dot>lisp file, , @t{core/gpu-arrays/with-and-push.lisp}} (file)
@end table
@end deffn
@deffn {Function} {register-event-listener} FUNCTION
@anchor{go to the CEPL<colon><colon>REGISTER-EVENT-LISTENER function}@c
@functionsubindex{register-event-listener}@c
Register a function to be called on every event.@*
   The function must take 1 argument, which will be the event.
@table @strong
@item Package
@ref{go to the CEPL package, , @t{cepl}}
@item Source
@ref{go to the cepl/core/repl<dot>lisp file, , @t{core/repl.lisp}} (file)
@end table
@end deffn
@deffn {Function} {register-host} HOST-CLASS-NAME
@anchor{go to the CEPL<dot>HOST<colon><colon>REGISTER-HOST function}@c
@functionsubindex{register-host}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-api<dot>lisp file, , @t{host/api-api.lisp}} (file)
@end table
@end deffn
@deffn {Function} {remove-surface} CONTEXT SURFACE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>REMOVE-SURFACE function}@c
@functionsubindex{remove-surface}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/surface<dot>lisp file, , @t{core/context/surface.lisp}} (file)
@end table
@end deffn
@deffn {Function} {render-buffer-dimensions} RENDER-BUFFER
@anchor{go to the CEPL<dot>RENDER-BUFFERS<colon><colon>RENDER-BUFFER-DIMENSIONS function}@c
@functionsubindex{render-buffer-dimensions}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>RENDER-BUFFERS package, , @t{cepl.render-buffers}}
@item Source
@ref{go to the cepl/core/render-buffers/render-buffer<dot>lisp file, , @t{core/render-buffers/render-buffer.lisp}} (file)
@end table
@end deffn
@deffn {Function} {render-buffer-image-format} RENDER-BUFFER
@anchor{go to the CEPL<dot>RENDER-BUFFERS<colon><colon>RENDER-BUFFER-IMAGE-FORMAT function}@c
@functionsubindex{render-buffer-image-format}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>RENDER-BUFFERS package, , @t{cepl.render-buffers}}
@item Source
@ref{go to the cepl/core/render-buffers/render-buffer<dot>lisp file, , @t{core/render-buffers/render-buffer.lisp}} (file)
@end table
@end deffn
@deffn {Function} {render-buffer-multisample-p} RENDER-BUFFER
@anchor{go to the CEPL<dot>RENDER-BUFFERS<colon><colon>RENDER-BUFFER-MULTISAMPLE-P function}@c
@functionsubindex{render-buffer-multisample-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>RENDER-BUFFERS package, , @t{cepl.render-buffers}}
@item Source
@ref{go to the cepl/core/render-buffers/render-buffer<dot>lisp file, , @t{core/render-buffers/render-buffer.lisp}} (file)
@end table
@end deffn
@deffn {Function} {render-buffer-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>RENDER-BUFFER-P function}@c
@functionsubindex{render-buffer-p}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {render-buffer-resolution} RENDER-BUFFER
@anchor{go to the CEPL<dot>RENDER-BUFFERS<colon><colon>RENDER-BUFFER-RESOLUTION function}@c
@functionsubindex{render-buffer-resolution}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>RENDER-BUFFERS package, , @t{cepl.render-buffers}}
@item Source
@ref{go to the cepl/core/render-buffers/render-buffer<dot>lisp file, , @t{core/render-buffers/render-buffer.lisp}} (file)
@end table
@end deffn
@deffn {Function} {repl} &optional WIDTH HEIGHT GL-VERSION
@anchor{go to the CEPL<colon><colon>REPL function}@c
@functionsubindex{repl}@c

This function is a legacy item at this stage, but is still here as it feels
nice.@*

It calls #'initialize-cepl to make a resizable window and prints out a message
in the repl.
@table @strong
@item Package
@ref{go to the CEPL package, , @t{cepl}}
@item Source
@ref{go to the cepl/core/repl<dot>lisp file, , @t{core/repl.lisp}} (file)
@end table
@end deffn
@deffn {Function} {replace-nth} LIST N FORM
@anchor{go to the CEPL-UTILS<colon><colon>REPLACE-NTH function}@c
@functionsubindex{replace-nth}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {row-major-aref-c} C-ARRAY INDEX
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>ROW-MAJOR-AREF-C function}@c
@functionsubindex{row-major-aref-c}@c
@deffnx {Function} {(setf row-major-aref-c)} VALUE C-ARRAY INDEX
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>(SETF ROW-MAJOR-AREF-C) function}@c
@functionsubindex{(setf row-major-aref-c)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/aref-c<dot>lisp file, , @t{core/c-arrays/aref-c.lisp}} (file)
@end table
@end deffn
@deffn {Function} {sample} TEXTURE &key LOD-BIAS MIN-LOD MAX-LOD MINIFY-FILTER MAGNIFY-FILTER WRAP COMPARE
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>SAMPLE function}@c
@functionsubindex{sample}@c

This function takes a `texture` and optionally some sampling parameters and
returns a `sampler`.@*

The sampler is an object that is passed to a pipeline so that the shaders in
the gpu-functions in the pipeline can read from the gpu-arrays in the texture.

For details on what the parameters are and mean see the docstring for the
'sampler type@*

**-- Note about GL Versions --**@*

Sampler Objects were introduced in GL 3.3. So for now CEPL needs at least v3.3
in future we hope to lower the requirement to 3.1 but this will take some extra
work.@*

**-- NOTE For those with GL experience --**@*

You will have noticed that in CEPL your sampler is tied to one texture which is
unlike in regular GL where a sample object can be used to override the sampling
parameters of any number of textures. At first this would seem very wasteful
however CEPL does not use 1 GL Sampler Object per CEPL sampler. The ID sharing
is done based on the parameters.@*

This means you get the same number of sampler objects as your would normally
but with the added benefit that samplers are semantically dual with buffer-streams
giving greater api consistancy.
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {sampler-id-box-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>SAMPLER-ID-BOX-ID function}@c
@functionsubindex{sampler-id-box-id}@c
@deffnx {Function} {(setf sampler-id-box-id)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF SAMPLER-ID-BOX-ID) function}@c
@functionsubindex{(setf sampler-id-box-id)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {sampler-id-box-shared-p} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>SAMPLER-ID-BOX-SHARED-P function}@c
@functionsubindex{sampler-id-box-shared-p}@c
@deffnx {Function} {(setf sampler-id-box-shared-p)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF SAMPLER-ID-BOX-SHARED-P) function}@c
@functionsubindex{(setf sampler-id-box-shared-p)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {sampler-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>SAMPLER-P function}@c
@functionsubindex{sampler-p}@c

This function returns t if the supplied value is a `sampler` and nil otherwise
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {sampler-shared-p} SAMPLER
@anchor{go to the %CEPL<dot>TYPES<colon><colon>SAMPLER-SHARED-P function}@c
@functionsubindex{sampler-shared-p}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {sampler-texture} SAMPLER
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>SAMPLER-TEXTURE function}@c
@functionsubindex{sampler-texture}@c

This function takes a `sampler` as its only argument and returns the `texture`
being sampled by the sampler.
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {sampler-type} SAMPLER
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>SAMPLER-TYPE function}@c
@functionsubindex{sampler-type}@c

This function takes a `sampler` as its only argument and returns the kind
of sampler it is.@*

The result will be one of the kinds listed in cepl.samplers::+sampler-types+
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {scissor-viewport} &optional INDEX CEPL-CONTEXT
@anchor{go to the CEPL<dot>SCISSOR<colon><colon>SCISSOR-VIEWPORT function}@c
@functionsubindex{scissor-viewport}@c
@deffnx {Function} {(setf scissor-viewport)} VIEWPORT &optional INDEX CEPL-CONTEXT
@anchor{go to the CEPL<dot>SCISSOR<colon><colon>(SETF SCISSOR-VIEWPORT) function}@c
@functionsubindex{(setf scissor-viewport)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SCISSOR package, , @t{cepl.scissor}}
@item Source
@ref{go to the cepl/core/scissor/scissor<dot>lisp file, , @t{core/scissor/scissor.lisp}} (file)
@end table
@end deffn
@deffn {Function} {scoped-gpu-query-active-p} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>SCOPED-GPU-QUERY-ACTIVE-P function}@c
@functionsubindex{scoped-gpu-query-active-p}@c
@deffnx {Function} {(setf scoped-gpu-query-active-p)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF SCOPED-GPU-QUERY-ACTIVE-P) function}@c
@functionsubindex{(setf scoped-gpu-query-active-p)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {set-default-swap-arg} WIN-HANDLE
@anchor{go to the CEPL<dot>HOST<colon><colon>SET-DEFAULT-SWAP-ARG function}@c
@functionsubindex{set-default-swap-arg}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-0<dot>lisp file, , @t{host/api-0.lisp}} (file)
@end table
@end deffn
@deffn {Function} {set-make-gl-context-current-on-surface} FUNC
@anchor{go to the CEPL<dot>HOST<colon><colon>SET-MAKE-GL-CONTEXT-CURRENT-ON-SURFACE function}@c
@functionsubindex{set-make-gl-context-current-on-surface}@c
Call this and pass the function that will be called when the cepl needs to
     make the context current
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Function} {set-minify-filter} SAMPLER FOR-LEVEL &key BETWEEN-LEVELS
@anchor{go to the %CEPL<dot>TYPES<colon><colon>SET-MINIFY-FILTER function}@c
@functionsubindex{set-minify-filter}@c

As the naming of the values for #'minify-filter are quite confusing this
function allows you to set the minify filter for the given `texture` or `sampler`
based on the following:@*

- for-level: what sampling should be used between texels on the current
             mipmap level. The value can be :linear or :nearest@*

- between-level: what sampling should be used between texels on different
                 mipmap levels. The value can be :linear or :nearest@*
                 This argument is optional.
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {set-register-event-callback-func} FUNC
@anchor{go to the CEPL<dot>HOST<colon><colon>SET-REGISTER-EVENT-CALLBACK-FUNC function}@c
@functionsubindex{set-register-event-callback-func}@c
Call this and pass the function that will be called when the cepl needs to
     query the window size
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Function} {set-step-func} FUNC
@anchor{go to the CEPL<dot>HOST<colon><colon>SET-STEP-FUNC function}@c
@functionsubindex{set-step-func}@c
Call this and pass the function that will be called every time
     #'cepl:step-host is called
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Function} {set-surface-fullscreen} SURFACE STATE &rest ARGS &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>SET-SURFACE-FULLSCREEN function}@c
@functionsubindex{set-surface-fullscreen}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Function} {set-surface-size} SURFACE WIDTH HEIGHT &rest ARGS &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>SET-SURFACE-SIZE function}@c
@functionsubindex{set-surface-size}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Function} {set-surface-title} SURFACE TITLE &rest ARGS &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>SET-SURFACE-TITLE function}@c
@functionsubindex{set-surface-title}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Function} {set-swap-func} FUNC
@anchor{go to the CEPL<dot>HOST<colon><colon>SET-SWAP-FUNC function}@c
@functionsubindex{set-swap-func}@c
Call this and pass the function that will be called every time #'cepl:swap
     is called
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Function} {set-window-size-func} FUNC
@anchor{go to the CEPL<dot>HOST<colon><colon>SET-WINDOW-SIZE-FUNC function}@c
@functionsubindex{set-window-size-func}@c
Call this and pass the function that will be called when the cepl needs to
     query the window size
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Function} {short-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>SHORT-FROM-FOREIGN function}@c
@functionsubindex{short-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {short-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>SHORT-TO-FOREIGN function}@c
@functionsubindex{short-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {shutting-down-p} ()
@anchor{go to the CEPL<dot>LIFECYCLE<colon><colon>SHUTTING-DOWN-P function}@c
@functionsubindex{shutting-down-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>LIFECYCLE package, , @t{cepl.lifecycle}}
@item Source
@ref{go to the cepl/core/lifecycle<dot>lisp file, , @t{core/lifecycle.lisp}} (file)
@end table
@end deffn
@deffn {Function} {sn-equal} A B
@anchor{go to the CEPL-UTILS<colon><colon>SN-EQUAL function}@c
@functionsubindex{sn-equal}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {source-alpha} FBO &optional ATTACHMENT-NAME
@anchor{go to the CEPL<dot>BLENDING<colon><colon>SOURCE-ALPHA function}@c
@functionsubindex{source-alpha}@c

This function, when passed a `blending-params` object, will return the name of the
function that will be applied to the alpha value that is coming from the
pipeline and is to be combined with the value already in the `fbo`.@*

The result will be one of the following:@*

    :zero@*
    :one@*
    :src-color@*
    :one-minus-src-color@*
    :dst-color@*
    :one-minus-dst-color@*
    :src-alpha@*
    :one-minus-src-alpha@*
    :dst-alpha@*
    :one-minus-dst-alpha@*
    :constant-color@*
    :one-minus-constant-color@*
    :constant-alpha@*
    :one-minus-constant-alpha@*
    :src-alpha-saturate@*
    :src1-color@*
    :one-minus-src-color@*
    :src1-alpha@*
    :one-minus-src-alpha@*

To see more info on this subject please see the doc-string for the
blending-params struct.
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@item Writer
@ref{go to the CEPL<dot>BLENDING<colon><colon>(SETF SOURCE-ALPHA) function, , @t{(setf source-alpha)}} (function)
@end table
@end deffn
@deffn {Function} {(setf source-alpha)} VALUE FBO &optional ATTACHMENT-NAME
@anchor{go to the CEPL<dot>BLENDING<colon><colon>(SETF SOURCE-ALPHA) function}@c
@functionsubindex{(setf source-alpha)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@item Reader
@ref{go to the CEPL<dot>BLENDING<colon><colon>SOURCE-ALPHA function, , @t{source-alpha}} (function)
@end table
@end deffn
@deffn {Function} {source-rgb} FBO &optional ATTACHMENT-NAME
@anchor{go to the CEPL<dot>BLENDING<colon><colon>SOURCE-RGB function}@c
@functionsubindex{source-rgb}@c

This function, when passed a `blending-params` object, will return the name of the
function that will be applied to the color value that is coming from the
pipeline and is to be combined with the value already in the `fbo`.@*

The result will be one of the following:@*

    :zero@*
    :one@*
    :src-color@*
    :one-minus-src-color@*
    :dst-color@*
    :one-minus-dst-color@*
    :src-alpha@*
    :one-minus-src-alpha@*
    :dst-alpha@*
    :one-minus-dst-alpha@*
    :constant-color@*
    :one-minus-constant-color@*
    :constant-alpha@*
    :one-minus-constant-alpha@*
    :src-alpha-saturate@*
    :src1-color@*
    :one-minus-src-color@*
    :src1-alpha@*
    :one-minus-src-alpha@*

To see more info on this subject please see the doc-string for the
blending-params struct.
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@item Writer
@ref{go to the CEPL<dot>BLENDING<colon><colon>(SETF SOURCE-RGB) function, , @t{(setf source-rgb)}} (function)
@end table
@end deffn
@deffn {Function} {(setf source-rgb)} VALUE FBO &optional ATTACHMENT-NAME
@anchor{go to the CEPL<dot>BLENDING<colon><colon>(SETF SOURCE-RGB) function}@c
@functionsubindex{(setf source-rgb)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@item Reader
@ref{go to the CEPL<dot>BLENDING<colon><colon>SOURCE-RGB function, , @t{source-rgb}} (function)
@end table
@end deffn
@deffn {Function} {split-float-version} FLOAT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>SPLIT-FLOAT-VERSION function}@c
@functionsubindex{split-float-version}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/version<dot>lisp file, , @t{core/context/version.lisp}} (file)
@end table
@end deffn
@deffn {Function} {split-seq-by-seq} DELIM SEQUENCE
@anchor{go to the CEPL-UTILS<colon><colon>SPLIT-SEQ-BY-SEQ function}@c
@functionsubindex{split-seq-by-seq}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {split-string} DELIMITER STRING
@anchor{go to the CEPL-UTILS<colon><colon>SPLIT-STRING function}@c
@functionsubindex{split-string}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {ssbo-data} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>SSBO-DATA function}@c
@functionsubindex{ssbo-data}@c

Returns the `gpu-array` that contains the data presented by this `SSBO`
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF SSBO-DATA) function, , @t{(setf ssbo-data)}} (function)
@end table
@end deffn
@deffn {Function} {(setf ssbo-data)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF SSBO-DATA) function}@c
@functionsubindex{(setf ssbo-data)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>SSBO-DATA function, , @t{ssbo-data}} (function)
@end table
@end deffn
@deffn {Function} {ssbo-data-type} SSBO
@anchor{go to the CEPL<dot>SSBOS<colon><colon>SSBO-DATA-TYPE function}@c
@functionsubindex{ssbo-data-type}@c

This function returns the type of the data that is contained in the `SSBO`
@table @strong
@item Package
@ref{go to the CEPL<dot>SSBOS package, , @t{cepl.ssbos}}
@item Source
@ref{go to the cepl/core/ssbos/ssbos<dot>lisp file, , @t{core/ssbos/ssbos.lisp}} (file)
@end table
@end deffn
@deffn {Function} {ssbo-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>SSBO-ID function}@c
@functionsubindex{ssbo-id}@c

This function return the id of the GL SSBO abstracted by this CEPL `SSBO`.
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF SSBO-ID) function, , @t{(setf ssbo-id)}} (function)
@end table
@end deffn
@deffn {Function} {(setf ssbo-id)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF SSBO-ID) function}@c
@functionsubindex{(setf ssbo-id)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>SSBO-ID function, , @t{ssbo-id}} (function)
@end table
@end deffn
@deffn {Function} {ssbo-index} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>SSBO-INDEX function}@c
@functionsubindex{ssbo-index}@c

This function returns the index into the ssbo-data where the element defined by
this `ssbo` is located
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF SSBO-INDEX) function, , @t{(setf ssbo-index)}} (function)
@end table
@end deffn
@deffn {Function} {(setf ssbo-index)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF SSBO-INDEX) function}@c
@functionsubindex{(setf ssbo-index)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>SSBO-INDEX function, , @t{ssbo-index}} (function)
@end table
@end deffn
@deffn {Function} {ssbo-owns-gpu-array} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>SSBO-OWNS-GPU-ARRAY function}@c
@functionsubindex{ssbo-owns-gpu-array}@c

This function returns t if the `gpu-array` was created by `make-ssbo` or nil if it is
using data from a gpu-array passed to make-ssbo
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF SSBO-OWNS-GPU-ARRAY) function, , @t{(setf ssbo-owns-gpu-array)}} (function)
@end table
@end deffn
@deffn {Function} {(setf ssbo-owns-gpu-array)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF SSBO-OWNS-GPU-ARRAY) function}@c
@functionsubindex{(setf ssbo-owns-gpu-array)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>SSBO-OWNS-GPU-ARRAY function, , @t{ssbo-owns-gpu-array}} (function)
@end table
@end deffn
@deffn {Function} {ssbo-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>SSBO-P function}@c
@functionsubindex{ssbo-p}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {stencil-decf} INCOMING-VAL STORED-VAL
@anchor{go to the CEPL<dot>DOCUMENTATION-FUNCTIONS<colon><colon>STENCIL-DECF function}@c
@functionsubindex{stencil-decf}@c
Decrement the stored value clamping to 0@*

   We only show the implementation for 8bit stencil here due to strong
   recommendations from guides to use 8bit stencils. Not an issue
   as this is only a stand-in function anyway
@table @strong
@item Package
@ref{go to the CEPL<dot>DOCUMENTATION-FUNCTIONS package, , @t{cepl.documentation-functions}}
@item Source
@ref{go to the cepl/core/context/documentation-functions<dot>lisp file, , @t{core/context/documentation-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {stencil-decf-wrap} INCOMING-VAL STORED-VAL
@anchor{go to the CEPL<dot>DOCUMENTATION-FUNCTIONS<colon><colon>STENCIL-DECF-WRAP function}@c
@functionsubindex{stencil-decf-wrap}@c
Decrement the stored value wrapping if underflows@*

   We only show the implementation for 8bit stencil here due to strong
   recommendations from guides to use 8bit stencils. Not an issue
   as this is only a stand-in function anyway
@table @strong
@item Package
@ref{go to the CEPL<dot>DOCUMENTATION-FUNCTIONS package, , @t{cepl.documentation-functions}}
@item Source
@ref{go to the cepl/core/context/documentation-functions<dot>lisp file, , @t{core/context/documentation-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {stencil-formatp} FORMAT
@anchor{go to the CEPL<dot>IMAGE-FORMATS<colon><colon>STENCIL-FORMATP function}@c
@functionsubindex{stencil-formatp}@c

This function returns t if the value provided is a keyword that can be found in
*stencil-formats*
@table @strong
@item Package
@ref{go to the CEPL<dot>IMAGE-FORMATS package, , @t{cepl.image-formats}}
@item Source
@ref{go to the cepl/core/types/image-format<dot>lisp file, , @t{core/types/image-format.lisp}} (file)
@end table
@end deffn
@deffn {Function} {stencil-incf} INCOMING-VAL STORED-VAL
@anchor{go to the CEPL<dot>DOCUMENTATION-FUNCTIONS<colon><colon>STENCIL-INCF function}@c
@functionsubindex{stencil-incf}@c
Increment the stored value clamping to maximum@*

   We only show the implementation for 8bit stencil here due to strong
   recommendations from guides to use 8bit stencils. Not an issue
   as this is only a stand-in function anyway
@table @strong
@item Package
@ref{go to the CEPL<dot>DOCUMENTATION-FUNCTIONS package, , @t{cepl.documentation-functions}}
@item Source
@ref{go to the cepl/core/context/documentation-functions<dot>lisp file, , @t{core/context/documentation-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {stencil-incf-wrap} INCOMING-VAL STORED-VAL
@anchor{go to the CEPL<dot>DOCUMENTATION-FUNCTIONS<colon><colon>STENCIL-INCF-WRAP function}@c
@functionsubindex{stencil-incf-wrap}@c
Increment the stored value wrapping if it overflows@*

   We only show the implementation for 8bit stencil here due to strong
   recommendations from guides to use 8bit stencils. Not an issue
   as this is only a stand-in function anyway
@table @strong
@item Package
@ref{go to the CEPL<dot>DOCUMENTATION-FUNCTIONS package, , @t{cepl.documentation-functions}}
@item Source
@ref{go to the cepl/core/context/documentation-functions<dot>lisp file, , @t{core/context/documentation-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {stencil-invert} INCOMING-VAL STORED-VAL
@anchor{go to the CEPL<dot>DOCUMENTATION-FUNCTIONS<colon><colon>STENCIL-INVERT function}@c
@functionsubindex{stencil-invert}@c
Invert the stored value@*

   We only show the implementation for 8bit stencil here due to strong
   recommendations from guides to use 8bit stencils. Not an issue
   as this function only exists as documentation anyway
@table @strong
@item Package
@ref{go to the CEPL<dot>DOCUMENTATION-FUNCTIONS package, , @t{cepl.documentation-functions}}
@item Source
@ref{go to the cepl/core/context/documentation-functions<dot>lisp file, , @t{core/context/documentation-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {stencil-mask} FACE &optional CEPL-CONTEXT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>STENCIL-MASK function}@c
@functionsubindex{stencil-mask}@c
@deffnx {Function} {(setf stencil-mask)} MASK FACE &optional CEPL-CONTEXT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF STENCIL-MASK) function}@c
@functionsubindex{(setf stencil-mask)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/stencil/mask<dot>lisp file, , @t{core/stencil/mask.lisp}} (file)
@end table
@end deffn
@deffn {Function} {stencil-params-mask} PARAMS
@anchor{go to the CEPL<dot>STENCIL<colon><colon>STENCIL-PARAMS-MASK function}@c
@functionsubindex{stencil-params-mask}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>STENCIL package, , @t{cepl.stencil}}
@item Source
@ref{go to the cepl/core/stencil/stencil<dot>lisp file, , @t{core/stencil/stencil.lisp}} (file)
@end table
@end deffn
@deffn {Function} {stencil-params-on-dpfail} PARAMS
@anchor{go to the CEPL<dot>STENCIL<colon><colon>STENCIL-PARAMS-ON-DPFAIL function}@c
@functionsubindex{stencil-params-on-dpfail}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>STENCIL package, , @t{cepl.stencil}}
@item Source
@ref{go to the cepl/core/stencil/stencil<dot>lisp file, , @t{core/stencil/stencil.lisp}} (file)
@end table
@end deffn
@deffn {Function} {stencil-params-on-dppass} PARAMS
@anchor{go to the CEPL<dot>STENCIL<colon><colon>STENCIL-PARAMS-ON-DPPASS function}@c
@functionsubindex{stencil-params-on-dppass}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>STENCIL package, , @t{cepl.stencil}}
@item Source
@ref{go to the cepl/core/stencil/stencil<dot>lisp file, , @t{core/stencil/stencil.lisp}} (file)
@end table
@end deffn
@deffn {Function} {stencil-params-on-sfail} PARAMS
@anchor{go to the CEPL<dot>STENCIL<colon><colon>STENCIL-PARAMS-ON-SFAIL function}@c
@functionsubindex{stencil-params-on-sfail}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>STENCIL package, , @t{cepl.stencil}}
@item Source
@ref{go to the cepl/core/stencil/stencil<dot>lisp file, , @t{core/stencil/stencil.lisp}} (file)
@end table
@end deffn
@deffn {Function} {stencil-params-on-stencil-pass-depth-test-fail} PARAMS
@anchor{go to the CEPL<dot>STENCIL<colon><colon>STENCIL-PARAMS-ON-STENCIL-PASS-DEPTH-TEST-FAIL function}@c
@functionsubindex{stencil-params-on-stencil-pass-depth-test-fail}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>STENCIL package, , @t{cepl.stencil}}
@item Source
@ref{go to the cepl/core/stencil/stencil<dot>lisp file, , @t{core/stencil/stencil.lisp}} (file)
@end table
@end deffn
@deffn {Function} {stencil-params-on-stencil-pass-depth-test-pass} PARAMS
@anchor{go to the CEPL<dot>STENCIL<colon><colon>STENCIL-PARAMS-ON-STENCIL-PASS-DEPTH-TEST-PASS function}@c
@functionsubindex{stencil-params-on-stencil-pass-depth-test-pass}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>STENCIL package, , @t{cepl.stencil}}
@item Source
@ref{go to the cepl/core/stencil/stencil<dot>lisp file, , @t{core/stencil/stencil.lisp}} (file)
@end table
@end deffn
@deffn {Function} {stencil-params-on-stencil-test-fail} PARAMS
@anchor{go to the CEPL<dot>STENCIL<colon><colon>STENCIL-PARAMS-ON-STENCIL-TEST-FAIL function}@c
@functionsubindex{stencil-params-on-stencil-test-fail}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>STENCIL package, , @t{cepl.stencil}}
@item Source
@ref{go to the cepl/core/stencil/stencil<dot>lisp file, , @t{core/stencil/stencil.lisp}} (file)
@end table
@end deffn
@deffn {Function} {stencil-params-test} PARAMS
@anchor{go to the CEPL<dot>STENCIL<colon><colon>STENCIL-PARAMS-TEST function}@c
@functionsubindex{stencil-params-test}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>STENCIL package, , @t{cepl.stencil}}
@item Source
@ref{go to the cepl/core/stencil/stencil<dot>lisp file, , @t{core/stencil/stencil.lisp}} (file)
@end table
@end deffn
@deffn {Function} {stencil-params-value} PARAMS
@anchor{go to the CEPL<dot>STENCIL<colon><colon>STENCIL-PARAMS-VALUE function}@c
@functionsubindex{stencil-params-value}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>STENCIL package, , @t{cepl.stencil}}
@item Source
@ref{go to the cepl/core/stencil/stencil<dot>lisp file, , @t{core/stencil/stencil.lisp}} (file)
@end table
@end deffn
@deffn {Function} {stencil-replace} INCOMING-VAL STORED-VAL
@anchor{go to the CEPL<dot>DOCUMENTATION-FUNCTIONS<colon><colon>STENCIL-REPLACE function}@c
@functionsubindex{stencil-replace}@c
Invert the stored value@*

   We only show the implementation for 8bit stencil here due to strong
   recommendations from guides to use 8bit stencils. Not an issue
   as this function only exists as documentation anyway
@table @strong
@item Package
@ref{go to the CEPL<dot>DOCUMENTATION-FUNCTIONS package, , @t{cepl.documentation-functions}}
@item Source
@ref{go to the cepl/core/context/documentation-functions<dot>lisp file, , @t{core/context/documentation-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {step-host} &optional CONTEXT
@anchor{go to the CEPL<colon><colon>STEP-HOST function}@c
@functionsubindex{step-host}@c

Call this to ask the host update its own internals.@*

This description is a bit nebulous as cepl doesnt impose what the host should do
when this call is made; however it is usual to call #'step-host every tick of
a main-loop and so often hosts will use this to do per-tick jobs like polling
for input events.
@table @strong
@item Package
@ref{go to the CEPL package, , @t{cepl}}
@item Source
@ref{go to the cepl/core/repl<dot>lisp file, , @t{core/repl.lisp}} (file)
@end table
@end deffn
@deffn {Function} {stop-listening-to-lifecycle-changes} FUNC
@anchor{go to the CEPL<dot>LIFECYCLE<colon><colon>STOP-LISTENING-TO-LIFECYCLE-CHANGES function}@c
@functionsubindex{stop-listening-to-lifecycle-changes}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>LIFECYCLE package, , @t{cepl.lifecycle}}
@item Source
@ref{go to the cepl/core/lifecycle<dot>lisp file, , @t{core/lifecycle.lisp}} (file)
@end table
@end deffn
@deffn {Function} {sub-at-index} SEQ INDEX NEW-VAL
@anchor{go to the CEPL-UTILS<colon><colon>SUB-AT-INDEX function}@c
@functionsubindex{sub-at-index}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {subseq-c} ARRAY START &optional END
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>SUBSEQ-C function}@c
@functionsubindex{subseq-c}@c

This function returns a `c-array` which contains a subset of the array passed into
this function.@*

It does not copy the foreign data, instead this array points to within the data
of the original array. This means these arrays now share data (like a displaced
array in standard CL.@*

Due to this you have to be very careful when freeing the underlying array as
this will affect any other array sharing that data.@*

If you want a copy of a subseq of a c-array then use something like:@*

    (clone-c-array (subseq-c arr 3 10))@*

The reason that this arguably more dangerous behaviour is default is efficiency.
CEPL tries not to allocate new memory when the function is not explicitly about
that.
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/rest<dot>lisp file, , @t{core/c-arrays/rest.lisp}} (file)
@end table
@end deffn
@deffn {Function} {subseq-g} ARRAY START &optional END
@anchor{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED<colon><colon>SUBSEQ-G function}@c
@functionsubindex{subseq-g}@c

This function returns a `gpu-array` which contains a subset of the gpu-array
passed into this function.@*

It does not copy the foreign data, instead this array points to within the data
of the original array. This means these arrays now share data (like a displaced
array in standard CL.@*

Due to this you have to be very careful when freeing the underlying array as
this will affect any other array sharing that data.@*

The reason that this arguably more dangerous behaviour is default is efficiency.
Mofidying gpu memory in performance critical applications should be done at
specific times so as not to get blocked by rendering commands. As such CEPL
tries not to allocate new memory when the function is not explicitly about that.
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED package, , @t{cepl.gpu-arrays.buffer-backed}}
@item Source
@ref{go to the cepl/core/gpu-arrays/buffer-backed<dot>lisp file, , @t{core/gpu-arrays/buffer-backed.lisp}} (file)
@end table
@end deffn
@deffn {Function} {subseq-g-raw} ARRAY START END &key NEW-ELEMENT-TYPE
@anchor{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED<colon><colon>SUBSEQ-G-RAW function}@c
@functionsubindex{subseq-g-raw}@c

This function returns a `gpu-array` which contains a subset of the gpu-array
passed into this function optionally allowing you to change the element-type
of the resulting gpu-array.@*

It does not copy the foreign data, instead this array points to within the data
of the original array. This means these arrays now share data (like a displaced
array in standard CL.@*

Due to this you have to be very careful when freeing the underlying array as
this will affect any other array sharing that data.@*

Also you have to be careful that the new element-type you choose makes sense
given the data already in the arrays. For example taking an gpu-array of :vec4
and making an gpu-array of :float will give you sensible values, however making
a gpu-array of :int will give you garbage.@*

Unless you have a very specific use-case then it is best to use `subseq-g`@*

The reason that this arguably more dangerous behaviour is default is efficiency.
Mofidying gpu memory in performance critical applications should be done at
specific times so as not to get blocked by rendering commands. As such CEPL
tries not to allocate new memory when the function is not explicitly about that.
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED package, , @t{cepl.gpu-arrays.buffer-backed}}
@item Source
@ref{go to the cepl/core/gpu-arrays/buffer-backed<dot>lisp file, , @t{core/gpu-arrays/buffer-backed.lisp}} (file)
@end table
@end deffn
@deffn {Function} {supports-multiple-contexts-p} &rest ARGS &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>SUPPORTS-MULTIPLE-CONTEXTS-P function}@c
@functionsubindex{supports-multiple-contexts-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Function} {supports-multiple-surfaces-p} &rest ARGS &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>SUPPORTS-MULTIPLE-SURFACES-P function}@c
@functionsubindex{supports-multiple-surfaces-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Function} {surface-dimensions} SURFACE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>SURFACE-DIMENSIONS function}@c
@functionsubindex{surface-dimensions}@c
@deffnx {Function} {(setf surface-dimensions)} VALUE SURFACE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF SURFACE-DIMENSIONS) function}@c
@functionsubindex{(setf surface-dimensions)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/surface<dot>lisp file, , @t{core/context/surface.lisp}} (file)
@end table
@end deffn
@deffn {Function} {surface-fullscreen-p} SURFACE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>SURFACE-FULLSCREEN-P function}@c
@functionsubindex{surface-fullscreen-p}@c
@deffnx {Function} {(setf surface-fullscreen-p)} VALUE SURFACE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF SURFACE-FULLSCREEN-P) function}@c
@functionsubindex{(setf surface-fullscreen-p)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/surface<dot>lisp file, , @t{core/context/surface.lisp}} (file)
@end table
@end deffn
@deffn {Function} {surface-fullscreen-p} SURFACE &rest ARGS &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>SURFACE-FULLSCREEN-P function}@c
@functionsubindex{surface-fullscreen-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Function} {surface-resolution} SURFACE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>SURFACE-RESOLUTION function}@c
@functionsubindex{surface-resolution}@c
@deffnx {Function} {(setf surface-resolution)} VALUE SURFACE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF SURFACE-RESOLUTION) function}@c
@functionsubindex{(setf surface-resolution)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/surface<dot>lisp file, , @t{core/context/surface.lisp}} (file)
@end table
@end deffn
@deffn {Function} {surface-title} SURFACE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>SURFACE-TITLE function}@c
@functionsubindex{surface-title}@c
@deffnx {Function} {(setf surface-title)} VALUE SURFACE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF SURFACE-TITLE) function}@c
@functionsubindex{(setf surface-title)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/surface<dot>lisp file, , @t{core/context/surface.lisp}} (file)
@end table
@end deffn
@deffn {Function} {surface-title} SURFACE &rest ARGS &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>SURFACE-TITLE function}@c
@functionsubindex{surface-title}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Function} {surfaces} &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>SURFACES function}@c
@functionsubindex{surfaces}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {swap} &optional CONTEXT
@anchor{go to the CEPL<colon><colon>SWAP function}@c
@functionsubindex{swap}@c

Call this ask the host to swap the buffers of the default framebuffer.

We usually do this when we have finished drawing a given frame.
@table @strong
@item Package
@ref{go to the CEPL package, , @t{cepl}}
@item Source
@ref{go to the cepl/core/repl<dot>lisp file, , @t{core/repl.lisp}} (file)
@end table
@end deffn
@deffn {Function} {symb} &rest ARGS
@anchor{go to the CEPL-UTILS<colon><colon>SYMB function}@c
@functionsubindex{symb}@c
This takes a list of symbols (or strings) and outputs one
   symbol.@*
   If the input is symbol/s then the output is a regular symbol
   If the input is string/s, then the output is@*
   a |symbol like this|
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {symb-name=} A B
@anchor{go to the CEPL-UTILS<colon><colon>SYMB-NAME= function}@c
@functionsubindex{symb-name=}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {symb-package} PACKAGE &rest ARGS
@anchor{go to the CEPL-UTILS<colon><colon>SYMB-PACKAGE function}@c
@functionsubindex{symb-package}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {symbol-name-equal} A B
@anchor{go to the CEPL-UTILS<colon><colon>SYMBOL-NAME-EQUAL function}@c
@functionsubindex{symbol-name-equal}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {texref} TEXTURE &key MIPMAP-LEVEL LAYER CUBE-FACE
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>TEXREF function}@c
@functionsubindex{texref}@c

This function allows you to access a specific `gpu-array` from the `texture`.

:mipmap-level is invalid if the texture doesnt have mipmaps@*

:layer is invalid if the texture-type is not a 1d,2d or cube-map array-texture.

:cube-face is invalid if the texture is not a cube-map texture
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {texture-allocated-p} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TEXTURE-ALLOCATED-P function}@c
@functionsubindex{texture-allocated-p}@c
@deffnx {Function} {(setf texture-allocated-p)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF TEXTURE-ALLOCATED-P) function}@c
@functionsubindex{(setf texture-allocated-p)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {texture-base-dimensions} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TEXTURE-BASE-DIMENSIONS function}@c
@functionsubindex{texture-base-dimensions}@c

Returns the resolution of the `gpu-array` at the 'base-level' of the mipmap chain.
The base level is the largest one.
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF TEXTURE-BASE-DIMENSIONS) function, , @t{(setf texture-base-dimensions)}} (function)
@end table
@end deffn
@deffn {Function} {(setf texture-base-dimensions)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF TEXTURE-BASE-DIMENSIONS) function}@c
@functionsubindex{(setf texture-base-dimensions)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>TEXTURE-BASE-DIMENSIONS function, , @t{texture-base-dimensions}} (function)
@end table
@end deffn
@deffn {Function} {texture-cache-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TEXTURE-CACHE-ID function}@c
@functionsubindex{texture-cache-id}@c
@deffnx {Function} {(setf texture-cache-id)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF TEXTURE-CACHE-ID) function}@c
@functionsubindex{(setf texture-cache-id)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {texture-cubes-p} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TEXTURE-CUBES-P function}@c
@functionsubindex{texture-cubes-p}@c

This function returns t if the `texture` is a cube texture and nil otherwise
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF TEXTURE-CUBES-P) function, , @t{(setf texture-cubes-p)}} (function)
@end table
@end deffn
@deffn {Function} {(setf texture-cubes-p)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF TEXTURE-CUBES-P) function}@c
@functionsubindex{(setf texture-cubes-p)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>TEXTURE-CUBES-P function, , @t{texture-cubes-p}} (function)
@end table
@end deffn
@deffn {Function} {texture-element-type} TEXTURE
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>TEXTURE-ELEMENT-TYPE function}@c
@functionsubindex{texture-element-type}@c

This function returns the element-type of the given `texture`.@*

If the texture is a `buffer-texture` then the element-type will be a foreign lisp
type.@*

Otherwise it will be one of the image-formats@*

**-- Element Types Details --**@*

Unlike `c-array` and `gpu-array`s (which use foreign types for their elements)
textures have a different set of acceptable format. These are called@*
'image formats'.@*

The name may imply that these formats are only usable for image data but this
is not the case. Most of the types we are used to are there, but under unsual
names.@*

This would make this a ripe candidate for CEPL to clean up the naming.. but it
doesnt, why?@*

Well the answer to that is image-formats are damn confusing and if we change
too much of the naming it will be even more confusing when trying to google
information. Instead CEPL provides a number of functions for converting
between (foreign) lisp types and their image-format counterparts.@*

@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/def<dot>lisp file, , @t{core/textures/def.lisp}} (file)
@end table
@end deffn
@deffn {Function} {texture-fixed-sample-locations-p} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TEXTURE-FIXED-SAMPLE-LOCATIONS-P function}@c
@functionsubindex{texture-fixed-sample-locations-p}@c
@deffnx {Function} {(setf texture-fixed-sample-locations-p)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF TEXTURE-FIXED-SAMPLE-LOCATIONS-P) function}@c
@functionsubindex{(setf texture-fixed-sample-locations-p)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {texture-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TEXTURE-ID function}@c
@functionsubindex{texture-id}@c

This function returns the id of the GL Texture Object from the CEPL `texture`.

Don't use this unless you know what you are doing on the GL side.
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF TEXTURE-ID) function, , @t{(setf texture-id)}} (function)
@end table
@end deffn
@deffn {Function} {(setf texture-id)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF TEXTURE-ID) function}@c
@functionsubindex{(setf texture-id)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>TEXTURE-ID function, , @t{texture-id}} (function)
@end table
@end deffn
@deffn {Function} {texture-image-format} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TEXTURE-IMAGE-FORMAT function}@c
@functionsubindex{texture-image-format}@c
@deffnx {Function} {(setf texture-image-format)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF TEXTURE-IMAGE-FORMAT) function}@c
@functionsubindex{(setf texture-image-format)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {texture-last-sampler-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TEXTURE-LAST-SAMPLER-ID function}@c
@functionsubindex{texture-last-sampler-id}@c
@deffnx {Function} {(setf texture-last-sampler-id)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF TEXTURE-LAST-SAMPLER-ID) function}@c
@functionsubindex{(setf texture-last-sampler-id)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {texture-layer-count} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TEXTURE-LAYER-COUNT function}@c
@functionsubindex{texture-layer-count}@c

When called with a `texture` with one of the following texture-types:
:texture-1d-array@*
:texture-2d-array@*
:texture-cube-map-array@*

then this function returns the number of 'layers' in the texture.

For all other texture types this will return 0
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF TEXTURE-LAYER-COUNT) function, , @t{(setf texture-layer-count)}} (function)
@end table
@end deffn
@deffn {Function} {(setf texture-layer-count)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF TEXTURE-LAYER-COUNT) function}@c
@functionsubindex{(setf texture-layer-count)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>TEXTURE-LAYER-COUNT function, , @t{texture-layer-count}} (function)
@end table
@end deffn
@deffn {Function} {texture-mipmap-levels} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TEXTURE-MIPMAP-LEVELS function}@c
@functionsubindex{texture-mipmap-levels}@c

When called with a `texture` with mipmaps enabled this function returns the number
of 'mipmap levels' in the texture.@*

For all other texture types this will return 0
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF TEXTURE-MIPMAP-LEVELS) function, , @t{(setf texture-mipmap-levels)}} (function)
@end table
@end deffn
@deffn {Function} {(setf texture-mipmap-levels)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF TEXTURE-MIPMAP-LEVELS) function}@c
@functionsubindex{(setf texture-mipmap-levels)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>TEXTURE-MIPMAP-LEVELS function, , @t{texture-mipmap-levels}} (function)
@end table
@end deffn
@deffn {Function} {texture-mutable-p} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TEXTURE-MUTABLE-P function}@c
@functionsubindex{texture-mutable-p}@c

When called with a `texture` this function returns t if the texture was made with
mutable texture storage and nil otherwise.@*

Using immutable texture storage does not mean that the data inside the texture's
`gpu-array`s cannot be mutated.@*

Mutable texture storage allows you to redefine the 'nature' of the data stored
in the gpu-arrays after they are created, by that we mean things like the type
of the data, the resolution of the gpu-arrays.@*

As it is hard to change such things without creating an 'incomplete' texture[0]
CEPL opts to treat all textures as immutable textures.@*
When the OpenGL version doesnt support immutable texture storage CEPL makes uses
immutable storage, allocates all the memory at construction, and doesnt provide
abstractions over the opengl features that would modify the storage.@*

[0] - https://www.opengl.org/wiki/Immutable_Storage_Texture#Texture_completeness
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF TEXTURE-MUTABLE-P) function, , @t{(setf texture-mutable-p)}} (function)
@end table
@end deffn
@deffn {Function} {(setf texture-mutable-p)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF TEXTURE-MUTABLE-P) function}@c
@functionsubindex{(setf texture-mutable-p)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>TEXTURE-MUTABLE-P function, , @t{texture-mutable-p}} (function)
@end table
@end deffn
@deffn {Function} {texture-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TEXTURE-P function}@c
@functionsubindex{texture-p}@c

This function returns t if the given value is a `texture`, otherwise nil is
returned.
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {texture-type} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TEXTURE-TYPE function}@c
@functionsubindex{texture-type}@c

This function will return the type of the given `texture`.

The possible values are:@*

    :texture-1d@*
    :texture-2d@*
    :texture-3d@*
    :texture-rectangle@*
    :texture-buffer@*
    :texture-cube-map@*
    :texture-1d-array@*
    :texture-2d-array@*
    :texture-cube-map-array
    :texture-2d-multisample
    :texture-2d-multisample-array
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF TEXTURE-TYPE) function, , @t{(setf texture-type)}} (function)
@end table
@end deffn
@deffn {Function} {(setf texture-type)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF TEXTURE-TYPE) function}@c
@functionsubindex{(setf texture-type)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>TEXTURE-TYPE function, , @t{texture-type}} (function)
@end table
@end deffn
@deffn {Function} {transform-feedback-stream-arrays} TFS
@anchor{go to the CEPL<dot>TRANSFORM-FEEDBACK<colon><colon>TRANSFORM-FEEDBACK-STREAM-ARRAYS function}@c
@functionsubindex{transform-feedback-stream-arrays}@c
@deffnx {Function} {(setf transform-feedback-stream-arrays)} BUFFER-BACKED-GPU-ARRAYS TFS
@anchor{go to the CEPL<dot>TRANSFORM-FEEDBACK<colon><colon>(SETF TRANSFORM-FEEDBACK-STREAM-ARRAYS) function}@c
@functionsubindex{(setf transform-feedback-stream-arrays)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TRANSFORM-FEEDBACK package, , @t{cepl.transform-feedback}}
@item Source
@ref{go to the cepl/core/transform-feedback/transform-feedback<dot>lisp file, , @t{core/transform-feedback/transform-feedback.lisp}} (file)
@end table
@end deffn
@deffn {Function} {ubo-data} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>UBO-DATA function}@c
@functionsubindex{ubo-data}@c

Returns the `gpu-array` that contains the data presented by this `UBO`
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF UBO-DATA) function, , @t{(setf ubo-data)}} (function)
@end table
@end deffn
@deffn {Function} {(setf ubo-data)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF UBO-DATA) function}@c
@functionsubindex{(setf ubo-data)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>UBO-DATA function, , @t{ubo-data}} (function)
@end table
@end deffn
@deffn {Function} {ubo-data-type} UBO
@anchor{go to the CEPL<dot>UBOS<colon><colon>UBO-DATA-TYPE function}@c
@functionsubindex{ubo-data-type}@c

This function returns the type of the data that is contained in the `UBO`
@table @strong
@item Package
@ref{go to the CEPL<dot>UBOS package, , @t{cepl.ubos}}
@item Source
@ref{go to the cepl/core/ubos/ubo<dot>lisp file, , @t{core/ubos/ubo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {ubo-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>UBO-ID function}@c
@functionsubindex{ubo-id}@c

This function return the id of the GL UBO abstracted by this CEPL `UBO`.
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF UBO-ID) function, , @t{(setf ubo-id)}} (function)
@end table
@end deffn
@deffn {Function} {(setf ubo-id)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF UBO-ID) function}@c
@functionsubindex{(setf ubo-id)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>UBO-ID function, , @t{ubo-id}} (function)
@end table
@end deffn
@deffn {Function} {ubo-index} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>UBO-INDEX function}@c
@functionsubindex{ubo-index}@c

This function returns the index into the ubo-data where the element defined by
this `ubo` is located
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF UBO-INDEX) function, , @t{(setf ubo-index)}} (function)
@end table
@end deffn
@deffn {Function} {(setf ubo-index)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF UBO-INDEX) function}@c
@functionsubindex{(setf ubo-index)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>UBO-INDEX function, , @t{ubo-index}} (function)
@end table
@end deffn
@deffn {Function} {ubo-owns-gpu-array} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>UBO-OWNS-GPU-ARRAY function}@c
@functionsubindex{ubo-owns-gpu-array}@c

This function returns t if the `gpu-array` was created by `make-ubo` or nil if it is
using data from a gpu-array passed to make-ubo
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF UBO-OWNS-GPU-ARRAY) function, , @t{(setf ubo-owns-gpu-array)}} (function)
@end table
@end deffn
@deffn {Function} {(setf ubo-owns-gpu-array)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF UBO-OWNS-GPU-ARRAY) function}@c
@functionsubindex{(setf ubo-owns-gpu-array)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>UBO-OWNS-GPU-ARRAY function, , @t{ubo-owns-gpu-array}} (function)
@end table
@end deffn
@deffn {Function} {ubo-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>UBO-P function}@c
@functionsubindex{ubo-p}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uint-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>UINT-FROM-FOREIGN function}@c
@functionsubindex{uint-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uint-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>UINT-TO-FOREIGN function}@c
@functionsubindex{uint-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uint32-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>UINT32-FROM-FOREIGN function}@c
@functionsubindex{uint32-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uint32-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>UINT32-TO-FOREIGN function}@c
@functionsubindex{uint32-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uint8-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>UINT8-FROM-FOREIGN function}@c
@functionsubindex{uint8-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uint8-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>UINT8-TO-FOREIGN function}@c
@functionsubindex{uint8-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uint8-vec2-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>UINT8-VEC2-FROM-FOREIGN function}@c
@functionsubindex{uint8-vec2-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uint8-vec2-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>UINT8-VEC2-TO-FOREIGN function}@c
@functionsubindex{uint8-vec2-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uint8-vec3-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>UINT8-VEC3-FROM-FOREIGN function}@c
@functionsubindex{uint8-vec3-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uint8-vec3-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>UINT8-VEC3-TO-FOREIGN function}@c
@functionsubindex{uint8-vec3-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uint8-vec4-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>UINT8-VEC4-FROM-FOREIGN function}@c
@functionsubindex{uint8-vec4-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uint8-vec4-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>UINT8-VEC4-TO-FOREIGN function}@c
@functionsubindex{uint8-vec4-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uninitialized-p} ()
@anchor{go to the CEPL<dot>LIFECYCLE<colon><colon>UNINITIALIZED-P function}@c
@functionsubindex{uninitialized-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>LIFECYCLE package, , @t{cepl.lifecycle}}
@item Source
@ref{go to the cepl/core/lifecycle<dot>lisp file, , @t{core/lifecycle.lisp}} (file)
@end table
@end deffn
@deffn {Function} {unknown-gl-id-p} ID
@anchor{go to the %CEPL<dot>TYPES<colon><colon>UNKNOWN-GL-ID-P function}@c
@functionsubindex{unknown-gl-id-p}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {unpack-alignment} &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>UNPACK-ALIGNMENT function}@c
@functionsubindex{unpack-alignment}@c
@deffnx {Function} {(setf unpack-alignment)} ROW-ALIGNMENT &optional FORCE CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF UNPACK-ALIGNMENT) function}@c
@functionsubindex{(setf unpack-alignment)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/pixel-store/pixel-store<dot>lisp file, , @t{core/pixel-store/pixel-store.lisp}} (file)
@end table
@end deffn
@deffn {Function} {ushort-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>USHORT-FROM-FOREIGN function}@c
@functionsubindex{ushort-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {ushort-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>USHORT-TO-FOREIGN function}@c
@functionsubindex{ushort-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uvec2-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>UVEC2-FROM-FOREIGN function}@c
@functionsubindex{uvec2-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uvec2-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>UVEC2-TO-FOREIGN function}@c
@functionsubindex{uvec2-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uvec3-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>UVEC3-FROM-FOREIGN function}@c
@functionsubindex{uvec3-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uvec3-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>UVEC3-TO-FOREIGN function}@c
@functionsubindex{uvec3-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uvec4-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>UVEC4-FROM-FOREIGN function}@c
@functionsubindex{uvec4-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uvec4-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>UVEC4-TO-FOREIGN function}@c
@functionsubindex{uvec4-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {valid-image-format-for-buffer-backed-texturep} FORMAT
@anchor{go to the CEPL<dot>IMAGE-FORMATS<colon><colon>VALID-IMAGE-FORMAT-FOR-BUFFER-BACKED-TEXTUREP function}@c
@functionsubindex{valid-image-format-for-buffer-backed-texturep}@c

This function returns t if the value provided is a keyword that can be found in
*valid-image-formats-for-buffer-backed-texture*
@table @strong
@item Package
@ref{go to the CEPL<dot>IMAGE-FORMATS package, , @t{cepl.image-formats}}
@item Source
@ref{go to the cepl/core/types/image-format<dot>lisp file, , @t{core/types/image-format.lisp}} (file)
@end table
@end deffn
@deffn {Function} {vao-bound} CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>VAO-BOUND function}@c
@functionsubindex{vao-bound}@c
@deffnx {Function} {(setf vao-bound)} VAO CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF VAO-BOUND) function}@c
@functionsubindex{(setf vao-bound)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {vec2-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>VEC2-FROM-FOREIGN function}@c
@functionsubindex{vec2-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {vec2-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>VEC2-TO-FOREIGN function}@c
@functionsubindex{vec2-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {vec3-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>VEC3-FROM-FOREIGN function}@c
@functionsubindex{vec3-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {vec3-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>VEC3-TO-FOREIGN function}@c
@functionsubindex{vec3-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {vec4-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>VEC4-FROM-FOREIGN function}@c
@functionsubindex{vec4-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {vec4-to-foreign} ()
@anchor{go to the CEPL<dot>TYPES<dot>FOREIGN<colon><colon>VEC4-TO-FOREIGN function}@c
@functionsubindex{vec4-to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>FOREIGN package, , @t{cepl.types.foreign}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {viewport-dimensions} VIEWPORT
@anchor{go to the CEPL<dot>VIEWPORTS<colon><colon>VIEWPORT-DIMENSIONS function}@c
@functionsubindex{viewport-dimensions}@c

This function returns the resolution of the `viewport` as a list of integers

If you call the generic function `dimensions` with a viewport you will get
this value.@*

If you need this value as a vec2 use `viewport-resolution` or just the
generic function `resolution`
@table @strong
@item Package
@ref{go to the CEPL<dot>VIEWPORTS package, , @t{cepl.viewports}}
@item Source
@ref{go to the cepl/core/viewports/viewport<dot>lisp file, , @t{core/viewports/viewport.lisp}} (file)
@item Writer
@ref{go to the CEPL<dot>VIEWPORTS<colon><colon>(SETF VIEWPORT-DIMENSIONS) function, , @t{(setf viewport-dimensions)}} (function)
@end table
@end deffn
@deffn {Function} {(setf viewport-dimensions)} VALUE VIEWPORT
@anchor{go to the CEPL<dot>VIEWPORTS<colon><colon>(SETF VIEWPORT-DIMENSIONS) function}@c
@functionsubindex{(setf viewport-dimensions)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>VIEWPORTS package, , @t{cepl.viewports}}
@item Source
@ref{go to the cepl/core/viewports/viewport<dot>lisp file, , @t{core/viewports/viewport.lisp}} (file)
@item Reader
@ref{go to the CEPL<dot>VIEWPORTS<colon><colon>VIEWPORT-DIMENSIONS function, , @t{viewport-dimensions}} (function)
@end table
@end deffn
@deffn {Function} {viewport-eql} V0 V1
@anchor{go to the CEPL<dot>VIEWPORTS<colon><colon>VIEWPORT-EQL function}@c
@functionsubindex{viewport-eql}@c

This function returns t if the two viewports have the same resolution and origin.
@table @strong
@item Package
@ref{go to the CEPL<dot>VIEWPORTS package, , @t{cepl.viewports}}
@item Source
@ref{go to the cepl/core/viewports/viewport<dot>lisp file, , @t{core/viewports/viewport.lisp}} (file)
@end table
@end deffn
@deffn {Function} {viewport-origin} VIEWPORT
@anchor{go to the CEPL<dot>VIEWPORTS<colon><colon>VIEWPORT-ORIGIN function}@c
@functionsubindex{viewport-origin}@c

This function returns the origin of the `viewport`.@*

This is the top-left corner of the rectangle within the surface that OpenGL (and
thus CEPL) will draw into
@table @strong
@item Package
@ref{go to the CEPL<dot>VIEWPORTS package, , @t{cepl.viewports}}
@item Source
@ref{go to the cepl/core/viewports/viewport<dot>lisp file, , @t{core/viewports/viewport.lisp}} (file)
@item Writer
@ref{go to the CEPL<dot>VIEWPORTS<colon><colon>(SETF VIEWPORT-ORIGIN) function, , @t{(setf viewport-origin)}} (function)
@end table
@end deffn
@deffn {Function} {(setf viewport-origin)} VALUE VIEWPORT
@anchor{go to the CEPL<dot>VIEWPORTS<colon><colon>(SETF VIEWPORT-ORIGIN) function}@c
@functionsubindex{(setf viewport-origin)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>VIEWPORTS package, , @t{cepl.viewports}}
@item Source
@ref{go to the cepl/core/viewports/viewport<dot>lisp file, , @t{core/viewports/viewport.lisp}} (file)
@item Reader
@ref{go to the CEPL<dot>VIEWPORTS<colon><colon>VIEWPORT-ORIGIN function, , @t{viewport-origin}} (function)
@end table
@end deffn
@deffn {Function} {viewport-origin-x} VIEWPORT
@anchor{go to the CEPL<dot>VIEWPORTS<colon><colon>VIEWPORT-ORIGIN-X function}@c
@functionsubindex{viewport-origin-x}@c

This function returns the x component of the resolution of the `viewport` as
a float.
@table @strong
@item Package
@ref{go to the CEPL<dot>VIEWPORTS package, , @t{cepl.viewports}}
@item Source
@ref{go to the cepl/core/viewports/viewport<dot>lisp file, , @t{core/viewports/viewport.lisp}} (file)
@end table
@end deffn
@deffn {Function} {viewport-origin-y} VIEWPORT
@anchor{go to the CEPL<dot>VIEWPORTS<colon><colon>VIEWPORT-ORIGIN-Y function}@c
@functionsubindex{viewport-origin-y}@c

This function returns the y component of the resolution of the `viewport` as
a float.
@table @strong
@item Package
@ref{go to the CEPL<dot>VIEWPORTS package, , @t{cepl.viewports}}
@item Source
@ref{go to the cepl/core/viewports/viewport<dot>lisp file, , @t{core/viewports/viewport.lisp}} (file)
@end table
@end deffn
@deffn {Function} {viewport-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>VIEWPORT-P function}@c
@functionsubindex{viewport-p}@c

This function will return t if the value given is a `viewport`, otherwise it will
return nil
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {viewport-params-to-vec4} &optional VIEWPORT
@anchor{go to the CEPL<dot>VIEWPORTS<colon><colon>VIEWPORT-PARAMS-TO-VEC4 function}@c
@functionsubindex{viewport-params-to-vec4}@c

Will return a vec4 packed with the origin and resolution. The format is as
follows:@*

    (v! origin-x origin-y resolution-x resolution-y)@*

If now viewport is provided the the `current-viewport` is used.
@table @strong
@item Package
@ref{go to the CEPL<dot>VIEWPORTS package, , @t{cepl.viewports}}
@item Source
@ref{go to the cepl/core/viewports/viewport<dot>lisp file, , @t{core/viewports/viewport.lisp}} (file)
@end table
@end deffn
@deffn {Function} {viewport-resolution} VIEWPORT
@anchor{go to the CEPL<dot>VIEWPORTS<colon><colon>VIEWPORT-RESOLUTION function}@c
@functionsubindex{viewport-resolution}@c

This function returns the resolution of the `viewport` as a vec2@*

If you call the generic function `resolution` with a viewport you will get
this value.@*

If you need this value as a list use `viewport-dimensions` or just the
generic function `dimensions`
@table @strong
@item Package
@ref{go to the CEPL<dot>VIEWPORTS package, , @t{cepl.viewports}}
@item Source
@ref{go to the cepl/core/viewports/viewport<dot>lisp file, , @t{core/viewports/viewport.lisp}} (file)
@item Writer
@ref{go to the CEPL<dot>VIEWPORTS<colon><colon>(SETF VIEWPORT-RESOLUTION) function, , @t{(setf viewport-resolution)}} (function)
@end table
@end deffn
@deffn {Function} {(setf viewport-resolution)} VALUE VIEWPORT
@anchor{go to the CEPL<dot>VIEWPORTS<colon><colon>(SETF VIEWPORT-RESOLUTION) function}@c
@functionsubindex{(setf viewport-resolution)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>VIEWPORTS package, , @t{cepl.viewports}}
@item Source
@ref{go to the cepl/core/viewports/viewport<dot>lisp file, , @t{core/viewports/viewport.lisp}} (file)
@item Reader
@ref{go to the CEPL<dot>VIEWPORTS<colon><colon>VIEWPORT-RESOLUTION function, , @t{viewport-resolution}} (function)
@end table
@end deffn
@deffn {Function} {viewport-resolution-x} VIEWPORT
@anchor{go to the CEPL<dot>VIEWPORTS<colon><colon>VIEWPORT-RESOLUTION-X function}@c
@functionsubindex{viewport-resolution-x}@c

This function returns the x component of the resolution of the `viewport` as
a float.
@table @strong
@item Package
@ref{go to the CEPL<dot>VIEWPORTS package, , @t{cepl.viewports}}
@item Source
@ref{go to the cepl/core/viewports/viewport<dot>lisp file, , @t{core/viewports/viewport.lisp}} (file)
@end table
@end deffn
@deffn {Function} {viewport-resolution-y} VIEWPORT
@anchor{go to the CEPL<dot>VIEWPORTS<colon><colon>VIEWPORT-RESOLUTION-Y function}@c
@functionsubindex{viewport-resolution-y}@c

This function returns the y component of the resolution of the `viewport` as
a float.
@table @strong
@item Package
@ref{go to the CEPL<dot>VIEWPORTS package, , @t{cepl.viewports}}
@item Source
@ref{go to the cepl/core/viewports/viewport<dot>lisp file, , @t{core/viewports/viewport.lisp}} (file)
@end table
@end deffn
@deffn {Function} {wait-on-gpu-fence} FENCE &optional TIMEOUT FLUSH
@anchor{go to the CEPL<dot>SYNC<colon><colon>WAIT-ON-GPU-FENCE function}@c
@functionsubindex{wait-on-gpu-fence}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SYNC package, , @t{cepl.sync}}
@item Source
@ref{go to the cepl/core/sync/sync<dot>lisp file, , @t{core/sync/sync.lisp}} (file)
@end table
@end deffn
@deffn {Function} {walk-replace} TO-REPLACE REPLACE-WITH FORM &key TEST
@anchor{go to the CEPL-UTILS<colon><colon>WALK-REPLACE function}@c
@functionsubindex{walk-replace}@c
This walks a list tree ('form') replacing all occurences of
   'to-replace' with 'replace-with'. This is pretty inefficent
   but will be fine for macros.
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {window-dimensions} WINDOW
@anchor{go to the CEPL<dot>INTERNALS<colon><colon>WINDOW-DIMENSIONS function}@c
@functionsubindex{window-dimensions}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>INTERNALS package, , @t{cepl.internals}}
@item Source
@ref{go to the cepl/core/internals<dot>lisp file, , @t{core/internals.lisp}} (file)
@end table
@end deffn
@deffn {Function} {window-resolution} WINDOW
@anchor{go to the CEPL<dot>INTERNALS<colon><colon>WINDOW-RESOLUTION function}@c
@functionsubindex{window-resolution}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>INTERNALS package, , @t{cepl.internals}}
@item Source
@ref{go to the cepl/core/internals<dot>lisp file, , @t{core/internals.lisp}} (file)
@end table
@end deffn
@deffn {Function} {window-size} WIN
@anchor{go to the CEPL<dot>HOST<colon><colon>WINDOW-SIZE function}@c
@functionsubindex{window-size}@c
When given the host-specific window handle will return the size of the window
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Function} {wrap} SAMPLER
@anchor{go to the %CEPL<dot>TYPES<colon><colon>WRAP function}@c
@functionsubindex{wrap}@c

This function sets the wrap parameter of the `texture` or `sampler` given.@*

When setf'ing this parameter you can provide either one approach to be used
for all 3 potential dimensions of the texture, or you can provide a vector
of the 3 approaches you want to used.@*


**-- Wrapping --**@*

When using normalized texture coordinates we are used to thinking about our
coordinate being between 0s0 and 1s0 and that value dictating where we are
sampling from.@*

However normalized texture coordinates are not limited to values between@*
0s0 and 1s0. They can be any floating-point number.@*

When a texture coordinate is not within the 0  1 range, some means must be
employed to decide what the color value will be.@*

The different approaches are as follows:@*

    :repeat: the texture coordinate wraps around the texture. so a texture
             coordinate of -0.2 becomes the equivalent of 0.8.@*

    :mirrored-repeat: the texture coordinate wraps around like a mirror.
                      -0.2 becomes 0.2, -1.2 becomes 0.8, etc.@*

    :clamp-to-edge: the texture coordinate is clamped to the 0  1 range.@*

    :clamp-to-border: the texture coordinate is clamped to the 0  1@*
                      range, but the edge texels are blended with a@*
                      constant border color.@*

    :mirror-clamp-to-edge: (only available with OpenGL 4.4 or
                           :arb-texture-mirror-clamp-to-edge) the texture@*
                           is clamped to the -1  1 range, but mirrors the
                           negative direction with the positive. Basically,
                           it acts as :clamp-to-edge, except that it@*
                           takes the absolute value of the texture
                           coordinates before clamping.@*

This also applies to Rectangle Textures, except that the range at which they
apply edge sampling is based on the texel width/height of the texture, not
the normalized 0  1 range.@*

This does not apply to Buffer Textures, as they must use the texelFetch sampling
functions and thus cannot sample outside of the texel range of the texture.@*

example:@*

    (setf (wrap texture-or-sampler)@*
          #(:clamp-to-edge :repeat-to-edge :clamp-to-edge))@*

    (setf (wrap texture-or-sampler) :clamp-to-edge)@*


@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@item Writer
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF WRAP) function, , @t{(setf wrap)}} (function)
@end table
@end deffn
@deffn {Function} {(setf wrap)} VALUE SAMPLER
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF WRAP) function}@c
@functionsubindex{(setf wrap)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@item Reader
@ref{go to the %CEPL<dot>TYPES<colon><colon>WRAP function, , @t{wrap}} (function)
@end table
@end deffn
@deffn {Function} {zero} INCOMING-VAL STORED-VAL
@anchor{go to the CEPL<dot>DOCUMENTATION-FUNCTIONS<colon><colon>ZERO function}@c
@functionsubindex{zero}@c
Always returns 0
@table @strong
@item Package
@ref{go to the CEPL<dot>DOCUMENTATION-FUNCTIONS package, , @t{cepl.documentation-functions}}
@item Source
@ref{go to the cepl/core/context/documentation-functions<dot>lisp file, , @t{core/context/documentation-functions.lisp}} (file)
@end table
@end deffn
" :AFTER-MENU-CONTENTS NIL) :PREVIOUS #8# :UP #2# :CHILDREN NIL :BEFORE-MENU-CONTENTS "@deffn {Compiler Macro} {aref-c} C-ARRAY &rest SUBSCRIPTS
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>AREF-C compiler macro}@c
@compilermacrosubindex{aref-c}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/aref-c<dot>lisp file, , @t{core/c-arrays/aref-c.lisp}} (file)
@end table
@end deffn
@deffn {Compiler Macro} {assocr} ITEM ALIST &key KEY TEST TEST-NOT
@anchor{go to the CEPL-UTILS<colon><colon>ASSOCR compiler macro}@c
@compilermacrosubindex{assocr}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Compiler Macro} {cepl-context} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>CEPL-CONTEXT compiler macro}@c
@compilermacrosubindex{cepl-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Compiler Macro} {clear} &optional TARGET
@anchor{go to the CEPL<dot>FBOS<colon><colon>CLEAR compiler macro}@c
@compilermacrosubindex{clear}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Compiler Macro} {color-mask} INDEX &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>COLOR-MASK compiler macro}@c
@compilermacrosubindex{color-mask}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/color/color<dot>lisp file, , @t{core/color/color.lisp}} (file)
@end table
@end deffn
@deffn {Compiler Macro} {color-masks} &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>COLOR-MASKS compiler macro}@c
@compilermacrosubindex{color-masks}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/color/color<dot>lisp file, , @t{core/color/color.lisp}} (file)
@end table
@end deffn
@deffn {Compiler Macro} {cull-face} &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>CULL-FACE compiler macro}@c
@compilermacrosubindex{cull-face}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/face/face<dot>lisp file, , @t{core/face/face.lisp}} (file)
@end table
@end deffn
@deffn {Compiler Macro} {current-stencil-params} FACE &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>STENCIL<colon><colon>CURRENT-STENCIL-PARAMS compiler macro}@c
@compilermacrosubindex{current-stencil-params}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>STENCIL package, , @t{cepl.stencil}}
@item Source
@ref{go to the cepl/core/stencil/stencil<dot>lisp file, , @t{core/stencil/stencil.lisp}} (file)
@end table
@end deffn
@deffn {Compiler Macro} {depth-clamp} &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>DEPTH-CLAMP compiler macro}@c
@compilermacrosubindex{depth-clamp}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/depth/depth<dot>lisp file, , @t{core/depth/depth.lisp}} (file)
@end table
@end deffn
@deffn {Compiler Macro} {depth-mask} &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>DEPTH-MASK compiler macro}@c
@compilermacrosubindex{depth-mask}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/depth/depth<dot>lisp file, , @t{core/depth/depth.lisp}} (file)
@end table
@end deffn
@deffn {Compiler Macro} {depth-range-vec2} &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>DEPTH-RANGE-VEC2 compiler macro}@c
@compilermacrosubindex{depth-range-vec2}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/depth/depth<dot>lisp file, , @t{core/depth/depth.lisp}} (file)
@end table
@end deffn
@deffn {Compiler Macro} {depth-test-function} &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>DEPTH-TEST-FUNCTION compiler macro}@c
@compilermacrosubindex{depth-test-function}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/depth/depth<dot>lisp file, , @t{core/depth/depth.lisp}} (file)
@end table
@end deffn
@deffn {Compiler Macro} {ensure-vec-index} VEC INDEX NULL-ELEMENT &optional ELEMENT-TYPE
@anchor{go to the CEPL-UTILS<colon><colon>ENSURE-VEC-INDEX compiler macro}@c
@compilermacrosubindex{ensure-vec-index}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Compiler Macro} {front-face} &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>FRONT-FACE compiler macro}@c
@compilermacrosubindex{front-face}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/face/face<dot>lisp file, , @t{core/face/face.lisp}} (file)
@end table
@end deffn
@deffn {Compiler Macro} {gpu-buffer-bound} CTX TARGET
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>GPU-BUFFER-BOUND compiler macro}@c
@compilermacrosubindex{gpu-buffer-bound}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Compiler Macro} {pack-alignment} &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>PACK-ALIGNMENT compiler macro}@c
@compilermacrosubindex{pack-alignment}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/pixel-store/pixel-store<dot>lisp file, , @t{core/pixel-store/pixel-store.lisp}} (file)
@end table
@end deffn
@deffn {Compiler Macro} {per-attachment-blending-available-p} &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>FBOS<colon><colon>PER-ATTACHMENT-BLENDING-AVAILABLE-P compiler macro}@c
@compilermacrosubindex{per-attachment-blending-available-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@end table
@end deffn
@deffn {Compiler Macro} {ptr-index} C-ARRAY &optional X Y Z W
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>PTR-INDEX compiler macro}@c
@compilermacrosubindex{ptr-index}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/aref-c<dot>lisp file, , @t{core/c-arrays/aref-c.lisp}} (file)
@end table
@end deffn
@deffn {Compiler Macro} {scissor-viewport} &optional INDEX CEPL-CONTEXT
@anchor{go to the CEPL<dot>SCISSOR<colon><colon>SCISSOR-VIEWPORT compiler macro}@c
@compilermacrosubindex{scissor-viewport}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SCISSOR package, , @t{cepl.scissor}}
@item Source
@ref{go to the cepl/core/scissor/scissor<dot>lisp file, , @t{core/scissor/scissor.lisp}} (file)
@end table
@end deffn
@deffn {Compiler Macro} {stencil-mask} FACE &optional CEPL-CONTEXT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>STENCIL-MASK compiler macro}@c
@compilermacrosubindex{stencil-mask}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/stencil/mask<dot>lisp file, , @t{core/stencil/mask.lisp}} (file)
@end table
@end deffn
@deffn {Compiler Macro} {unpack-alignment} &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>UNPACK-ALIGNMENT compiler macro}@c
@compilermacrosubindex{unpack-alignment}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/pixel-store/pixel-store<dot>lisp file, , @t{core/pixel-store/pixel-store.lisp}} (file)
@end table
@end deffn
" :AFTER-MENU-CONTENTS NIL) #10# #11# #12=#S(NET.DIDIERVERNA.DECLT::NODE :NAME "Exported conditions" :SYNOPSIS NIL :SECTION-TYPE :NUMBERED :SECTION-NAME "Conditions" :NEXT #13=#S(NET.DIDIERVERNA.DECLT::NODE :NAME "Exported structures" :SYNOPSIS NIL :SECTION-TYPE :NUMBERED :SECTION-NAME "Structures" :NEXT #14=# :PREVIOUS #12# :UP #2# :CHILDREN NIL :BEFORE-MENU-CONTENTS "@deftp {Structure} {any-samples-passed-conservative-query} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>ANY-SAMPLES-PASSED-CONSERVATIVE-QUERY structure}@c
@structuresubindex{any-samples-passed-conservative-query}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@ref{go to the %CEPL<dot>TYPES<colon><colon>SCOPED-GPU-QUERY structure, , @t{scoped-gpu-query}} (structure)
@item Direct slots
@defvr {Slot} enum
@slotsubindex{enum}@c
@table @strong
@item Type
@t{(and (signed-byte 32) (signed-byte 32))}
@item Initform
@t{36202}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>ANY-SAMPLES-PASSED-CONSERVATIVE-QUERY-ENUM function, , @t{any-samples-passed-conservative-query-enum}} (function)
@item Writers
@t{(setf any-samples-passed-conservative-query-enum)} (function)
@end table
@end defvr
@defvr {Slot} cache-id
@slotsubindex{cache-id}@c
@table @strong
@item Type
@t{(and (integer 0 7) (integer 0 7))}
@item Initform
@t{3}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>ANY-SAMPLES-PASSED-CONSERVATIVE-QUERY-CACHE-ID function, , @t{any-samples-passed-conservative-query-cache-id}} (function)
@item Writers
@t{(setf any-samples-passed-conservative-query-cache-id)} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {any-samples-passed-query} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>ANY-SAMPLES-PASSED-QUERY structure}@c
@structuresubindex{any-samples-passed-query}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@ref{go to the %CEPL<dot>TYPES<colon><colon>SCOPED-GPU-QUERY structure, , @t{scoped-gpu-query}} (structure)
@item Direct slots
@defvr {Slot} enum
@slotsubindex{enum}@c
@table @strong
@item Type
@t{(and (signed-byte 32) (signed-byte 32))}
@item Initform
@t{35887}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>ANY-SAMPLES-PASSED-QUERY-ENUM function, , @t{any-samples-passed-query-enum}} (function)
@item Writers
@t{(setf any-samples-passed-query-enum)} (function)
@end table
@end defvr
@defvr {Slot} cache-id
@slotsubindex{cache-id}@c
@table @strong
@item Type
@t{(and (integer 0 7) (integer 0 7))}
@item Initform
@t{2}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>ANY-SAMPLES-PASSED-QUERY-CACHE-ID function, , @t{any-samples-passed-query-cache-id}} (function)
@item Writers
@t{(setf any-samples-passed-query-cache-id)} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {arrays-indirect-command} ()
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ARRAYS-INDIRECT-COMMAND structure}@c
@structuresubindex{arrays-indirect-command}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/multi-draw<dot>lisp file, , @t{core/pipelines/multi-draw.lisp}} (file)
@item Direct superclasses
@ref{go to the CEPL<dot>TYPES<colon><colon>BASE-GSTRUCT-WRAPPER structure, , @t{base-gstruct-wrapper}} (structure)
@item Direct methods
@itemize @bullet
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PUSH-G COMMON-LISP<colon><colon>LIST CEPL<dot>PIPELINES<colon><colon>ARRAYS-INDIRECT-COMMAND method, , @t{push-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PULL1-G CEPL<dot>PIPELINES<colon><colon>ARRAYS-INDIRECT-COMMAND method, , @t{pull1-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PULL-G CEPL<dot>PIPELINES<colon><colon>ARRAYS-INDIRECT-COMMAND method, , @t{pull-g}} (method)
@item
@ref{go to the CEPL<dot>INTERNALS<colon><colon>POPULATE CEPL<dot>PIPELINES<colon><colon>ARRAYS-INDIRECT-COMMAND COMMON-LISP<colon><colon>T method, , @t{populate}} (method)
@item
@t{print-object} (method)
@end itemize
@end table
@end deftp
@deftp {Structure} {att} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>ATT structure}@c
@structuresubindex{att}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@t{structure-object} (structure)
@item Direct slots
@defvr {Slot} array
@slotsubindex{array}@c
@table @strong
@item Type
@t{(or null %cepl.types:gpu-array-t %cepl.types:render-buffer)}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>ATT-ARRAY function, , @t{att-array}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF ATT-ARRAY) function, , @t{(setf att-array)}} (function)
@end table
@end defvr
@defvr {Slot} blend
@slotsubindex{blend}@c
@table @strong
@item Type
@t{boolean}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>ATT-BLEND function, , @t{att-blend}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF ATT-BLEND) function, , @t{(setf att-blend)}} (function)
@end table
@end defvr
@defvr {Slot} bparams
@slotsubindex{bparams}@c
@table @strong
@item Type
@t{(or null %cepl.types:blending-params)}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>ATT-BPARAMS function, , @t{att-bparams}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF ATT-BPARAMS) function, , @t{(setf att-bparams)}} (function)
@end table
@end defvr
@defvr {Slot} owned-p
@slotsubindex{owned-p}@c
@table @strong
@item Type
@t{boolean}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>ATT-OWNED-P function, , @t{att-owned-p}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF ATT-OWNED-P) function, , @t{(setf att-owned-p)}} (function)
@end table
@end defvr
@defvr {Slot} viewport
@slotsubindex{viewport}@c
@table @strong
@item Type
@t{(or null %cepl.types:viewport)}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>ATT-VIEWPORT function, , @t{att-viewport}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF ATT-VIEWPORT) function, , @t{(setf att-viewport)}} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {blending-params} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BLENDING-PARAMS structure}@c
@structuresubindex{blending-params}@c

Blending Parameters dictate how a color is written into an `FBO`'s attachment if
there is already a color there.@*

Blending Parameters (or `blending-params`) can be applied in CEPL in 3 places:@*

- On an FBO:@*
  This sets the rules for all attachments in the FBO@*

- On an FBO Attachment:@*
  This overrides the rules set on the FBO but only for the one attachment.@*
  This is only supported on some versions of OpenGL.@*

- On a blending-params object:@*
  This object can then be applied using with-blending@*
  (see with-blending's docstring for more info)@*


The interaction between the options in the blending-params is fairly complex@*
so whilst we seek to give an introduction here, some cases will be best covered@*
in other documentation.@*


**-- The Parameters --**@*

There are 3 pairs of parameters that work together to tell GL how to compute@*
the final color.@*

In all cases below 'source' means the color coming from the pipeline that needs@*
to be written into the FBO, and 'destination' means the color already in the FBO@*

Conceptually what is happening is that `source-rgb`, `source-alpha`, `destination-rgb`
and `destination-alpha` all name functions that will be called on their respective
values. This will result in new source-rgb, source-alpha, destinations-rgb and
destination-alpha values.@*

Those new values are then given to the `mode-rgb` and `mode-alpha` functions which
compute the final color.@*

So in pseudo-code it would look this this:@*

    (defun compute-final-color (blend-params src-rgb src-alpha@*
                                dest-rgb dest-alpha)@*
      (let ((new-src-rgb@*
             (funcall (blend-params-source-rgb blend-params)
                      src-rgb@*
                      dest-rgb))@*
            (new-dest-rgb@*
             (funcall (blend-params-destination-rgb blend-params)
                      src-rgb@*
                      dest-rgb))@*
            (new-src-alpha@*
             (funcall (blend-params-source-alpha blend-params)
                      src-alpha@*
                      dest-alpha))@*
            (new-dest-alpha@*
             (funcall (blend-params-destination-alpha blend-params)
                      src-alpha@*
                      dest-alpha)))@*
        ;; compute final colors@*
        (values (funcall (blend-params-mode-rgb blend-params)
                         new-src-rgb@*
                         new-dest-rgb)@*
                (funcall (blend-params-mode-alpha blend-params)
                         new-src-alpha@*
                         new-dest-alpha))))@*


**-- :source-rgb, :source-alpha, :destination-rgb & :destination-alpha --**@*

This is the list of operations and what they do to the *-rgb or *alpha values
given.@*

    Parameter                 | RGB Factor                      | Alpha Factor
    --------------------------------------------------------------------------
    :zero                     | (v! 0 0 0)                      | 0@*
    :one                      | (v! 1 1 1)                      | 1@*
    :src-color                | (v! rs0 gs0 bs0)                | as0
    :one-minus-src-color      | (- (v! 1 1 1) (v! rs0 gs0 bs0)) | 1 - as0
    :dst-color                | (v! rd gd bd)                   | ad
    :one-minus-dst-color      | (- (v! 1 1 1) (v! rd gd bd))    | 1 - ad
    :src-alpha                | (v! as0 as0 as0)                | as0
    :one-minus-src-alpha      | (- (v! 1 1 1) (v! as0 as0 as0)) | 1 - as0
    :dst-alpha                | (v! ad ad ad)                   | ad
    :one-minus-dst-alpha      | (- (v! 1 1 1) (v! ad ad ad))    | ad
    :constant-color           | (v! rc gc bc)                   | ac
    :one-minus-constant-color | (- (v! 1 1 1) (v! rc gc bc))    | 1 - ac
    :constant-alpha           | (v! ac ac ac)                   | ac
    :one-minus-constant-alpha | (- (v! 1 1 1) (v! ac ac ac))    | 1 - ac
    :src-alpha-saturate       | (v! i i i)                      | 1@*
    :src1-color               | (v! rs1 gs1 bs1)                | as1
    :one-minus-src1-color     | (- (v! 1 1 1) (v! rs1 gs1 bs1)) | 1 - as1
    :src1-alpha               | (v! as1 as1 as1)                | as1
    :one-minus-src1-alpha     | (- (v! 1 1 1) (v! as1 as1 as1)) | 1 - as1@*


**-- :mode-rgb & :mode-alpha --**@*

As mentioned above, to compute the final color two equations are used:@*
one for the RGB portion of the color, and one for the alpha of the color.@*
This is useful if you want treat rgb and alpha differently when producing the@*
end result.@*

The equations available are:@*

:func-add - The source and destination colors are added to each other.@*
            O = sS + dD. The s and d are blending parameters that are@*
            multiplied into each of S and D before the addition.@*

:func-subtract - Subtracts the destination from the source. O = sS - dD.@*
                 The source and dest are again multiplied by blending
                 parameters.@*

:func-reverse-subtract - Subtracts the source from the destination.@*
                         O = sD - dS. The source and dest are multiplied by
                         blending parameters.@*

:min - The output color is the component-wise minimum value of the source@*
       and dest colors. So performing :min in the RGB equation means that@*
       Or = min(Sr, Dr), Og = min(Sg, Dg), and so forth.@*
       The parameters s and d are ignored for this equation.@*

:max - The output color is the component-wise maximum value of the source and@*
       dest colors. The parameters s and d are ignored for this equation.@*


**-- Precision --**@*

Despite the apparent precision of the above equations, blending arithmetic is@*
not exactly specified, because blending operates with imprecise integer color
values.@*
However, a blend factor that should be equal to 1 is guaranteed not to modify@*
its multiplicand, and a blend factor equal to 0 reduces its multiplicand to 0.@*

For example, when:@*

- srcRGB is GL_SRC_ALPHA@*
- dstRGB is GL_ONE_MINUS_SRC_ALPHA,@*
- As0 is equal to 1@*

the equations reduce to simple replacement:@*

> todo
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@t{structure-object} (structure)
@item Direct slots
@defvr {Slot} mode-rgb
@slotsubindex{mode-rgb}@c
@table @strong
@item Type
@t{keyword}
@item Initform
@t{:func-add}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>BLENDING-PARAMS-MODE-RGB function, , @t{blending-params-mode-rgb}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF BLENDING-PARAMS-MODE-RGB) function, , @t{(setf blending-params-mode-rgb)}} (function)
@end table
@end defvr
@defvr {Slot} mode-alpha
@slotsubindex{mode-alpha}@c
@table @strong
@item Type
@t{keyword}
@item Initform
@t{:func-add}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>BLENDING-PARAMS-MODE-ALPHA function, , @t{blending-params-mode-alpha}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF BLENDING-PARAMS-MODE-ALPHA) function, , @t{(setf blending-params-mode-alpha)}} (function)
@end table
@end defvr
@defvr {Slot} source-rgb
@slotsubindex{source-rgb}@c
@table @strong
@item Type
@t{keyword}
@item Initform
@t{:src-alpha}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>BLENDING-PARAMS-SOURCE-RGB function, , @t{blending-params-source-rgb}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF BLENDING-PARAMS-SOURCE-RGB) function, , @t{(setf blending-params-source-rgb)}} (function)
@end table
@end defvr
@defvr {Slot} source-alpha
@slotsubindex{source-alpha}@c
@table @strong
@item Type
@t{keyword}
@item Initform
@t{:src-alpha}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>BLENDING-PARAMS-SOURCE-ALPHA function, , @t{blending-params-source-alpha}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF BLENDING-PARAMS-SOURCE-ALPHA) function, , @t{(setf blending-params-source-alpha)}} (function)
@end table
@end defvr
@defvr {Slot} destination-rgb
@slotsubindex{destination-rgb}@c
@table @strong
@item Type
@t{keyword}
@item Initform
@t{:one-minus-src-alpha}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>BLENDING-PARAMS-DESTINATION-RGB function, , @t{blending-params-destination-rgb}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF BLENDING-PARAMS-DESTINATION-RGB) function, , @t{(setf blending-params-destination-rgb)}} (function)
@end table
@end defvr
@defvr {Slot} destination-alpha
@slotsubindex{destination-alpha}@c
@table @strong
@item Type
@t{keyword}
@item Initform
@t{:one-minus-src-alpha}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>BLENDING-PARAMS-DESTINATION-ALPHA function, , @t{blending-params-destination-alpha}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF BLENDING-PARAMS-DESTINATION-ALPHA) function, , @t{(setf blending-params-destination-alpha)}} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {buffer-stream} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM structure}@c
@structuresubindex{buffer-stream}@c

A buffer-stream is a structure that represents stream of gpu-data composed from
gpu-array and/or gpu-buffers.@*

To render in CEPL we map a buffer-stream over a gpu-pipeline. The buffer-stream
contains data (usually geometry) that is passed to the vertex-shader.@*

A buffer-stream composes various sources of gpu-data together. So if, for example,
the vertex shader took 3 arguments of types :vec2 :vec3 :float. Then you could
make a stream that composes 3 gpu-arrays with element-types :vec2 :vec3 :float
and map this over the pipeline.@*

Naturally, as we are talking about buffer-stream, only buffer-backed gpu-arrays
can be composed with buffer-streams.@*

Info for people used to OpenGL:@*
A buffer-stream is basically a VAO with some extra metadata such as the 'range'
of data to draw the 'style' of drawing & the 'primitive' the data represents .
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@t{structure-object} (structure)
@item Direct methods
@itemize @bullet
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>FREE %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM method, , @t{free}} (method)
@item
@t{print-object} (method)
@item
@ref{go to the %CEPL<dot>TYPES<colon><colon>CAN-BE-SHARED-BETWEEN-CONTEXTS-P %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM method, , @t{can-be-shared-between-contexts-p}} (method)
@end itemize
@item Direct slots
@defvr {Slot} vao
@slotsubindex{vao}@c
@table @strong
@item Type
@t{%cepl.types:gl-id}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-VAO function, , @t{buffer-stream-vao}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-VAO) function, , @t{(setf buffer-stream-vao)}} (function)
@end table
@end defvr
@defvr {Slot} %start
@slotsubindex{%start}@c
@table @strong
@item Type
@t{(unsigned-byte 64)}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-%START function, , @t{buffer-stream-%start}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-%START) function, , @t{(setf buffer-stream-%start)}} (function)
@end table
@end defvr
@defvr {Slot} %start-byte
@slotsubindex{%start-byte}@c
@table @strong
@item Type
@t{(unsigned-byte 64)}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-%START-BYTE function, , @t{buffer-stream-%start-byte}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-%START-BYTE) function, , @t{(setf buffer-stream-%start-byte)}} (function)
@end table
@end defvr
@defvr {Slot} base-vertex
@slotsubindex{base-vertex}@c
@table @strong
@item Type
@t{(unsigned-byte 32)}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-BASE-VERTEX function, , @t{buffer-stream-base-vertex}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-BASE-VERTEX) function, , @t{(setf buffer-stream-base-vertex)}} (function)
@end table
@end defvr
@defvr {Slot} length
@slotsubindex{length}@c
@table @strong
@item Type
@t{unsigned-byte}
@item Initform
@t{1}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-LENGTH function, , @t{buffer-stream-length}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-LENGTH) function, , @t{(setf buffer-stream-length)}} (function)
@end table
@end defvr
@defvr {Slot} %index-type-enum
@slotsubindex{%index-type-enum}@c
@table @strong
@item Type
@t{%cepl.types:gl-enum-value}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-%INDEX-TYPE-ENUM function, , @t{buffer-stream-%index-type-enum}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-%INDEX-TYPE-ENUM) function, , @t{(setf buffer-stream-%index-type-enum)}} (function)
@end table
@end defvr
@defvr {Slot} %index-type-size
@slotsubindex{%index-type-size}@c
@table @strong
@item Type
@t{(unsigned-byte 8)}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-%INDEX-TYPE-SIZE function, , @t{buffer-stream-%index-type-size}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-%INDEX-TYPE-SIZE) function, , @t{(setf buffer-stream-%index-type-size)}} (function)
@end table
@end defvr
@defvr {Slot} gpu-arrays
@slotsubindex{gpu-arrays}@c
@table @strong
@item Type
@t{list}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-GPU-ARRAYS function, , @t{buffer-stream-gpu-arrays}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-GPU-ARRAYS) function, , @t{(setf buffer-stream-gpu-arrays)}} (function)
@end table
@end defvr
@defvr {Slot} %primitive
@slotsubindex{%primitive}@c
@table @strong
@item Type
@t{symbol}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-%PRIMITIVE function, , @t{buffer-stream-%primitive}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-%PRIMITIVE) function, , @t{(setf buffer-stream-%primitive)}} (function)
@end table
@end defvr
@defvr {Slot} primitive-group-id
@slotsubindex{primitive-group-id}@c
@table @strong
@item Type
@t{(unsigned-byte 8)}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-PRIMITIVE-GROUP-ID function, , @t{buffer-stream-primitive-group-id}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-PRIMITIVE-GROUP-ID) function, , @t{(setf buffer-stream-primitive-group-id)}} (function)
@end table
@end defvr
@defvr {Slot} draw-mode-val
@slotsubindex{draw-mode-val}@c
@table @strong
@item Type
@t{(unsigned-byte 32)}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-DRAW-MODE-VAL function, , @t{buffer-stream-draw-mode-val}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-DRAW-MODE-VAL) function, , @t{(setf buffer-stream-draw-mode-val)}} (function)
@end table
@end defvr
@defvr {Slot} patch-length
@slotsubindex{patch-length}@c
@table @strong
@item Type
@t{(unsigned-byte 8)}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-PATCH-LENGTH function, , @t{buffer-stream-patch-length}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-PATCH-LENGTH) function, , @t{(setf buffer-stream-patch-length)}} (function)
@end table
@end defvr
@defvr {Slot} managed
@slotsubindex{managed}@c
@table @strong
@item Type
@t{boolean}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-MANAGED function, , @t{buffer-stream-managed}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-STREAM-MANAGED) function, , @t{(setf buffer-stream-managed)}} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {buffer-texture} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-TEXTURE structure}@c
@structuresubindex{buffer-texture}@c

`Buffer-texture`s are a special kind of `texture` where the data resides, not in
texture memory, but in buffer memory.@*

This means that when you call texref on this texture you will recieve a
buffer-backed texture instead of the usual texture-backed ones.@*

buffer-textures are created by calling `make-texture` with the :buffer key
argument set to t.@*

Buffer textures have limitations over regular textures:@*

- cannot be mipmapped@*
- can only only have one `gpu-array`@*
- that gpu-array must be one dimensional@*
- can only be accessed in shaders with #'texel-fetch@*
- can have a more limited number of valid element-types[0] to choose from
  see *valid-image-formats-for-buffer-backed-texture* for details@*

[0] OpenGL calls the element-types of textures 'image-formats' or sometimes
    'internal-formats'. Even though the name implies they are only useful
    for image data we keep the name as the subject of image-formats is
    complicated enough without us adding more things to think about
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@t{texture} (structure)
@item Direct methods
@itemize @bullet
@item
@ref{go to the CEPL<dot>TEXTURES<colon><colon>FREE-TEXTURE %CEPL<dot>TYPES<colon><colon>BUFFER-TEXTURE method, , @t{free-texture}} (method)
@item
@t{print-object} (method)
@end itemize
@item Direct slots
@defvr {Slot} backing-array
@slotsubindex{backing-array}@c
@table @strong
@item Type
@t{%cepl.types:gpu-array-bb}
@item Initform
@t{(error \"\")}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-TEXTURE-BACKING-ARRAY function, , @t{buffer-texture-backing-array}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-TEXTURE-BACKING-ARRAY) function, , @t{(setf buffer-texture-backing-array)}} (function)
@end table
@end defvr
@defvr {Slot} owns-array
@slotsubindex{owns-array}@c
@table @strong
@item Type
@t{boolean}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-TEXTURE-OWNS-ARRAY function, , @t{buffer-texture-owns-array}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-TEXTURE-OWNS-ARRAY) function, , @t{(setf buffer-texture-owns-array)}} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {c-array} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY structure}@c
@structuresubindex{c-array}@c

`C-ARRAY` is a structure that represents an array in foreign memory.

CEPL keeps not only the pointer to the foreign data in this structure
but also metadata that makes moving this data to (and from) the gpu or
lisp much easier.
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@t{structure-object} (structure)
@item Direct methods
@itemize @bullet
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G %CEPL<dot>TYPES<colon><colon>C-ARRAY %CEPL<dot>TYPES<colon><colon>SSBO method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PUSH-G %CEPL<dot>TYPES<colon><colon>C-ARRAY %CEPL<dot>TYPES<colon><colon>SSBO method, , @t{push-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G %CEPL<dot>TYPES<colon><colon>C-ARRAY %CEPL<dot>TYPES<colon><colon>UBO method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PUSH-G %CEPL<dot>TYPES<colon><colon>C-ARRAY %CEPL<dot>TYPES<colon><colon>UBO method, , @t{push-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G %CEPL<dot>TYPES<colon><colon>C-ARRAY %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PUSH-G %CEPL<dot>TYPES<colon><colon>C-ARRAY %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB method, , @t{push-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T %CEPL<dot>TYPES<colon><colon>C-ARRAY method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G %CEPL<dot>TYPES<colon><colon>C-ARRAY %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PUSH-G %CEPL<dot>TYPES<colon><colon>C-ARRAY %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T method, , @t{push-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PUSH-G %CEPL<dot>TYPES<colon><colon>C-ARRAY GLSL-SYMBOLS<dot>FUNCTIONS<colon><colon>TEXTURE method, , @t{push-g}} (method)
@item
@ref{go to the CEPL<dot>TEXTURES<colon><colon>PIXEL-FORMAT-FROM-ARRAY %CEPL<dot>TYPES<colon><colon>C-ARRAY method, , @t{pixel-format-from-array}} (method)
@item
@ref{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED<colon><colon>MAKE-GPU-ARRAY %CEPL<dot>TYPES<colon><colon>C-ARRAY method, , @t{make-gpu-array}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G %CEPL<dot>TYPES<colon><colon>C-ARRAY (eql KEYWORD<colon><colon>LISP) method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G COMMON-LISP<colon><colon>ARRAY %CEPL<dot>TYPES<colon><colon>C-ARRAY method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G COMMON-LISP<colon><colon>LIST %CEPL<dot>TYPES<colon><colon>C-ARRAY method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PUSH-G COMMON-LISP<colon><colon>T %CEPL<dot>TYPES<colon><colon>C-ARRAY method, , @t{push-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PULL-G %CEPL<dot>TYPES<colon><colon>C-ARRAY method, , @t{pull-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PULL1-G %CEPL<dot>TYPES<colon><colon>C-ARRAY method, , @t{pull1-g}} (method)
@item
@ref{go to the CEPL-UTILS<colon><colon>PRINT-MEM %CEPL<dot>TYPES<colon><colon>C-ARRAY method, , @t{print-mem}} (method)
@item
@t{print-object} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>FREE %CEPL<dot>TYPES<colon><colon>C-ARRAY method, , @t{free}} (method)
@item
@ref{go to the CEPL<dot>TYPES<colon><colon>ELEMENT-BYTE-SIZE %CEPL<dot>TYPES<colon><colon>C-ARRAY method, , @t{element-byte-size}} (method)
@item
@ref{go to the CEPL<dot>TYPES<colon><colon>ELEMENT-TYPE %CEPL<dot>TYPES<colon><colon>C-ARRAY method, , @t{element-type}} (method)
@item
@ref{go to the CEPL<dot>MEASUREMENTS<colon><colon>DIMENSIONS %CEPL<dot>TYPES<colon><colon>C-ARRAY method, , @t{dimensions}} (method)
@item
@ref{go to the CEPL<dot>C-ARRAYS<colon><colon>POINTER %CEPL<dot>TYPES<colon><colon>C-ARRAY method, , @t{pointer}} (method)
@end itemize
@item Direct slots
@defvr {Slot} pointer
@slotsubindex{pointer}@c
@table @strong
@item Type
@t{cffi-sys:foreign-pointer}
@item Initform
@t{(error \"cepl: c-array must be created with a pointer\")}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY-POINTER function, , @t{c-array-pointer}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF C-ARRAY-POINTER) function, , @t{(setf c-array-pointer)}} (function)
@end table
@end defvr
@defvr {Slot} dimensions
@slotsubindex{dimensions}@c
@table @strong
@item Type
@t{list}
@item Initform
@t{(error \"cepl: c-array must be created with dimensions\")}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY-DIMENSIONS function, , @t{c-array-dimensions}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF C-ARRAY-DIMENSIONS) function, , @t{(setf c-array-dimensions)}} (function)
@end table
@end defvr
@defvr {Slot} total-size
@slotsubindex{total-size}@c
@table @strong
@item Type
@t{%cepl.types:c-array-index}
@item Initform
@t{(error \"cepl: c-array must be created with total-size\")}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY-TOTAL-SIZE function, , @t{c-array-total-size}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF C-ARRAY-TOTAL-SIZE) function, , @t{(setf c-array-total-size)}} (function)
@end table
@end defvr
@defvr {Slot} element-type
@slotsubindex{element-type}@c
@table @strong
@item Type
@t{symbol}
@item Initform
@t{(error \"cepl: c-array must be created with an element-type\")}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY-ELEMENT-TYPE function, , @t{c-array-element-type}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF C-ARRAY-ELEMENT-TYPE) function, , @t{(setf c-array-element-type)}} (function)
@end table
@end defvr
@defvr {Slot} sizes
@slotsubindex{sizes}@c
@table @strong
@item Type
@t{(simple-array %cepl.types:c-array-index (4))}
@item Initform
@t{(error \"cepl (bug): c-array created without internal sizes\")}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY-SIZES function, , @t{c-array-sizes}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF C-ARRAY-SIZES) function, , @t{(setf c-array-sizes)}} (function)
@end table
@end defvr
@defvr {Slot} row-alignment
@slotsubindex{row-alignment}@c
@table @strong
@item Type
@t{(integer 1 8)}
@item Initform
@t{(error \"cepl: c-array must be created with a row-alignment\")}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY-ROW-ALIGNMENT function, , @t{c-array-row-alignment}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF C-ARRAY-ROW-ALIGNMENT) function, , @t{(setf c-array-row-alignment)}} (function)
@end table
@end defvr
@defvr {Slot} struct-element-typep
@slotsubindex{struct-element-typep}@c
@table @strong
@item Type
@t{boolean}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY-STRUCT-ELEMENT-TYPEP function, , @t{c-array-struct-element-typep}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF C-ARRAY-STRUCT-ELEMENT-TYPEP) function, , @t{(setf c-array-struct-element-typep)}} (function)
@end table
@end defvr
@defvr {Slot} element-pixel-format
@slotsubindex{element-pixel-format}@c
@table @strong
@item Type
@t{(or null %cepl.types:pixel-format)}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY-ELEMENT-PIXEL-FORMAT function, , @t{c-array-element-pixel-format}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF C-ARRAY-ELEMENT-PIXEL-FORMAT) function, , @t{(setf c-array-element-pixel-format)}} (function)
@end table
@end defvr
@defvr {Slot} element-from-foreign
@slotsubindex{element-from-foreign}@c
@table @strong
@item Type
@t{(function (cffi-sys:foreign-pointer) t)}
@item Initform
@t{(error \"cepl: c-array must be created with a from-foreign function\")}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY-ELEMENT-FROM-FOREIGN function, , @t{c-array-element-from-foreign}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF C-ARRAY-ELEMENT-FROM-FOREIGN) function, , @t{(setf c-array-element-from-foreign)}} (function)
@end table
@end defvr
@defvr {Slot} element-to-foreign
@slotsubindex{element-to-foreign}@c
@table @strong
@item Type
@t{(function (cffi-sys:foreign-pointer t) t)}
@item Initform
@t{(error \"cepl: c-array must be created with a to-foreign function\")}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY-ELEMENT-TO-FOREIGN function, , @t{c-array-element-to-foreign}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF C-ARRAY-ELEMENT-TO-FOREIGN) function, , @t{(setf c-array-element-to-foreign)}} (function)
@end table
@end defvr
@defvr {Slot} free
@slotsubindex{free}@c
@table @strong
@item Type
@t{function}
@item Initform
@t{(function cffi-sys:foreign-free)}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY-FREE function, , @t{c-array-free}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF C-ARRAY-FREE) function, , @t{(setf c-array-free)}} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {cepl-context} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>CEPL-CONTEXT structure}@c
@structuresubindex{cepl-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@item Direct superclasses
@t{structure-object} (structure)
@item Direct methods
@itemize @bullet
@item
@ref{go to the CEPL<dot>CONTEXT<colon><colon>VERSION-FLOAT CEPL<dot>CONTEXT<colon><colon>CEPL-CONTEXT method, , @t{version-float}} (method)
@item
@t{print-object} (method)
@end itemize
@item Direct slots
@defvr {Slot} id
@slotsubindex{id}@c
@table @strong
@item Type
@t{cepl.context:context-id}
@item Initform
@t{(error \"context missing an id\")}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-ID function, , @t{%cepl-context-id}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-ID) function, , @t{(setf %cepl-context-id)}} (function)
@end table
@end defvr
@defvr {Slot} gl-context
@slotsubindex{gl-context}@c
@table @strong
@item Type
@t{(or null cepl.context:gl-context)}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-GL-CONTEXT function, , @t{%cepl-context-gl-context}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-GL-CONTEXT) function, , @t{(setf %cepl-context-gl-context)}} (function)
@end table
@end defvr
@defvr {Slot} requested-gl-version
@slotsubindex{requested-gl-version}@c
@table @strong
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-REQUESTED-GL-VERSION function, , @t{%cepl-context-requested-gl-version}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-REQUESTED-GL-VERSION) function, , @t{(setf %cepl-context-requested-gl-version)}} (function)
@end table
@end defvr
@defvr {Slot} gl-version-float
@slotsubindex{gl-version-float}@c
@table @strong
@item Type
@t{single-float}
@item Initform
@t{0.0}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-GL-VERSION-FLOAT function, , @t{%cepl-context-gl-version-float}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-GL-VERSION-FLOAT) function, , @t{(setf %cepl-context-gl-version-float)}} (function)
@end table
@end defvr
@defvr {Slot} bound-thread
@slotsubindex{bound-thread}@c
@table @strong
@item Type
@t{(or null bordeaux-threads:thread)}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-BOUND-THREAD function, , @t{%cepl-context-bound-thread}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-BOUND-THREAD) function, , @t{(setf %cepl-context-bound-thread)}} (function)
@end table
@end defvr
@defvr {Slot} uninitialized-resources
@slotsubindex{uninitialized-resources}@c
@table @strong
@item Type
@t{list}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-UNINITIALIZED-RESOURCES function, , @t{%cepl-context-uninitialized-resources}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-UNINITIALIZED-RESOURCES) function, , @t{(setf %cepl-context-uninitialized-resources)}} (function)
@end table
@end defvr
@defvr {Slot} shared
@slotsubindex{shared}@c
@table @strong
@item Type
@t{(array cepl.context:cepl-context (*))}
@item Initform
@t{(error \"context must be initialized via #'make-context\")}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-SHARED function, , @t{%cepl-context-shared}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-SHARED) function, , @t{(setf %cepl-context-shared)}} (function)
@end table
@end defvr
@defvr {Slot} surfaces
@slotsubindex{surfaces}@c
@table @strong
@item Type
@t{list}
@item Initform
@t{(error \"context must be initialized via #'make-context\")}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-SURFACES function, , @t{%cepl-context-surfaces}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-SURFACES) function, , @t{(setf %cepl-context-surfaces)}} (function)
@end table
@end defvr
@defvr {Slot} current-program
@slotsubindex{current-program}@c
@table @strong
@item Type
@t{%cepl.types:gl-id}
@item Initform
@t{%cepl.types:+unknown-gl-id+}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-CURRENT-PROGRAM function, , @t{%cepl-context-current-program}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-CURRENT-PROGRAM) function, , @t{(setf %cepl-context-current-program)}} (function)
@end table
@end defvr
@defvr {Slot} current-tfs
@slotsubindex{current-tfs}@c
@table @strong
@item Type
@t{(or null %cepl.types:transform-feedback-stream)}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-CURRENT-TFS function, , @t{%cepl-context-current-tfs}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-CURRENT-TFS) function, , @t{(setf %cepl-context-current-tfs)}} (function)
@end table
@end defvr
@defvr {Slot} current-surface
@slotsubindex{current-surface}@c
@table @strong
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-CURRENT-SURFACE function, , @t{%cepl-context-current-surface}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-CURRENT-SURFACE) function, , @t{(setf %cepl-context-current-surface)}} (function)
@end table
@end defvr
@defvr {Slot} vao-binding-id
@slotsubindex{vao-binding-id}@c
@table @strong
@item Type
@t{%cepl.types:vao-id}
@item Initform
@t{%cepl.types:+unknown-gl-id+}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-VAO-BINDING-ID function, , @t{%cepl-context-vao-binding-id}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-VAO-BINDING-ID) function, , @t{(setf %cepl-context-vao-binding-id)}} (function)
@end table
@end defvr
@defvr {Slot} current-viewport
@slotsubindex{current-viewport}@c
@table @strong
@item Type
@t{(or null %cepl.types:viewport)}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-CURRENT-VIEWPORT function, , @t{%cepl-context-current-viewport}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-CURRENT-VIEWPORT) function, , @t{(setf %cepl-context-current-viewport)}} (function)
@end table
@end defvr
@defvr {Slot} default-viewport
@slotsubindex{default-viewport}@c
@table @strong
@item Type
@t{(or null %cepl.types:viewport)}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-DEFAULT-VIEWPORT function, , @t{%cepl-context-default-viewport}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-DEFAULT-VIEWPORT) function, , @t{(setf %cepl-context-default-viewport)}} (function)
@end table
@end defvr
@defvr {Slot} current-scissor-viewports
@slotsubindex{current-scissor-viewports}@c
@table @strong
@item Type
@t{(simple-array (or null %cepl.types:viewport) (32))}
@item Initform
@t{(make-array 32 :element-type (quote (or null %cepl.types:viewport)) :initial-element nil)}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-CURRENT-SCISSOR-VIEWPORTS function, , @t{%cepl-context-current-scissor-viewports}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-CURRENT-SCISSOR-VIEWPORTS) function, , @t{(setf %cepl-context-current-scissor-viewports)}} (function)
@end table
@end defvr
@defvr {Slot} default-framebuffer
@slotsubindex{default-framebuffer}@c
@table @strong
@item Type
@t{(or null %cepl.types:fbo)}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-DEFAULT-FRAMEBUFFER function, , @t{%cepl-context-default-framebuffer}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-DEFAULT-FRAMEBUFFER) function, , @t{(setf %cepl-context-default-framebuffer)}} (function)
@end table
@end defvr
@defvr {Slot} read-fbo-binding
@slotsubindex{read-fbo-binding}@c
@table @strong
@item Type
@t{(or null %cepl.types:fbo)}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-READ-FBO-BINDING function, , @t{%cepl-context-read-fbo-binding}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-READ-FBO-BINDING) function, , @t{(setf %cepl-context-read-fbo-binding)}} (function)
@end table
@end defvr
@defvr {Slot} draw-fbo-binding
@slotsubindex{draw-fbo-binding}@c
@table @strong
@item Type
@t{(or null %cepl.types:fbo)}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-DRAW-FBO-BINDING function, , @t{%cepl-context-draw-fbo-binding}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-DRAW-FBO-BINDING) function, , @t{(setf %cepl-context-draw-fbo-binding)}} (function)
@end table
@end defvr
@defvr {Slot} current-stencil-params-front
@slotsubindex{current-stencil-params-front}@c
@table @strong
@item Type
@t{(or null %cepl.types:stencil-params)}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-CURRENT-STENCIL-PARAMS-FRONT function, , @t{%cepl-context-current-stencil-params-front}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-CURRENT-STENCIL-PARAMS-FRONT) function, , @t{(setf %cepl-context-current-stencil-params-front)}} (function)
@end table
@end defvr
@defvr {Slot} current-stencil-params-back
@slotsubindex{current-stencil-params-back}@c
@table @strong
@item Type
@t{(or null %cepl.types:stencil-params)}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-CURRENT-STENCIL-PARAMS-BACK function, , @t{%cepl-context-current-stencil-params-back}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-CURRENT-STENCIL-PARAMS-BACK) function, , @t{(setf %cepl-context-current-stencil-params-back)}} (function)
@end table
@end defvr
@defvr {Slot} current-stencil-mask-front
@slotsubindex{current-stencil-mask-front}@c
@table @strong
@item Type
@t{%cepl.types:stencil-mask}
@item Initform
@t{255}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-CURRENT-STENCIL-MASK-FRONT function, , @t{%cepl-context-current-stencil-mask-front}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-CURRENT-STENCIL-MASK-FRONT) function, , @t{(setf %cepl-context-current-stencil-mask-front)}} (function)
@end table
@end defvr
@defvr {Slot} current-stencil-mask-back
@slotsubindex{current-stencil-mask-back}@c
@table @strong
@item Type
@t{%cepl.types:stencil-mask}
@item Initform
@t{255}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-CURRENT-STENCIL-MASK-BACK function, , @t{%cepl-context-current-stencil-mask-back}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-CURRENT-STENCIL-MASK-BACK) function, , @t{(setf %cepl-context-current-stencil-mask-back)}} (function)
@end table
@end defvr
@defvr {Slot} current-blend-params
@slotsubindex{current-blend-params}@c
@table @strong
@item Type
@t{(or null %cepl.types:blending-params)}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-CURRENT-BLEND-PARAMS function, , @t{%cepl-context-current-blend-params}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-CURRENT-BLEND-PARAMS) function, , @t{(setf %cepl-context-current-blend-params)}} (function)
@end table
@end defvr
@defvr {Slot} fbos
@slotsubindex{fbos}@c
@table @strong
@item Type
@t{(array %cepl.types:fbo (*))}
@item Initform
@t{(make-array 0 :element-type (quote %cepl.types:fbo) :initial-element %cepl.types:+null-fbo+ :adjustable t :fill-pointer 0)}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-FBOS function, , @t{%cepl-context-fbos}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-FBOS) function, , @t{(setf %cepl-context-fbos)}} (function)
@end table
@end defvr
@defvr {Slot} array-of-bound-gpu-buffers
@slotsubindex{array-of-bound-gpu-buffers}@c
@table @strong
@item Type
@t{(simple-array (or %cepl.types:gpu-buffer null) (12))}
@item Initform
@t{(make-array 12 :element-type (quote (or %cepl.types:gpu-buffer null)) :initial-element nil)}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-ARRAY-OF-BOUND-GPU-BUFFERS function, , @t{%cepl-context-array-of-bound-gpu-buffers}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-ARRAY-OF-BOUND-GPU-BUFFERS) function, , @t{(setf %cepl-context-array-of-bound-gpu-buffers)}} (function)
@end table
@end defvr
@defvr {Slot} array-of-gpu-buffers
@slotsubindex{array-of-gpu-buffers}@c
@table @strong
@item Type
@t{(array %cepl.types:gpu-buffer (*))}
@item Initform
@t{(make-array 0 :element-type (quote %cepl.types:gpu-buffer) :initial-element %cepl.types:+null-gpu-buffer+ :adjustable t :fill-pointer 0)}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-ARRAY-OF-GPU-BUFFERS function, , @t{%cepl-context-array-of-gpu-buffers}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-ARRAY-OF-GPU-BUFFERS) function, , @t{(setf %cepl-context-array-of-gpu-buffers)}} (function)
@end table
@end defvr
@defvr {Slot} array-of-ubo-bindings-buffer-ids
@slotsubindex{array-of-ubo-bindings-buffer-ids}@c
@table @strong
@item Type
@t{(array %cepl.types:gl-id (*))}
@item Initform
@t{(make-array 0 :element-type (quote %cepl.types:gl-id) :initial-element %cepl.types:+null-gl-id+ :adjustable t :fill-pointer 0)}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-ARRAY-OF-UBO-BINDINGS-BUFFER-IDS function, , @t{%cepl-context-array-of-ubo-bindings-buffer-ids}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-ARRAY-OF-UBO-BINDINGS-BUFFER-IDS) function, , @t{(setf %cepl-context-array-of-ubo-bindings-buffer-ids)}} (function)
@end table
@end defvr
@defvr {Slot} array-of-ubo-binding-ranges
@slotsubindex{array-of-ubo-binding-ranges}@c
@table @strong
@item Type
@t{(array (unsigned-byte 32) (*))}
@item Initform
@t{(make-array 0 :element-type (quote (unsigned-byte 32)) :initial-element 0 :adjustable t :fill-pointer 0)}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-ARRAY-OF-UBO-BINDING-RANGES function, , @t{%cepl-context-array-of-ubo-binding-ranges}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-ARRAY-OF-UBO-BINDING-RANGES) function, , @t{(setf %cepl-context-array-of-ubo-binding-ranges)}} (function)
@end table
@end defvr
@defvr {Slot} array-of-ssbo-bindings-buffer-ids
@slotsubindex{array-of-ssbo-bindings-buffer-ids}@c
@table @strong
@item Type
@t{(array %cepl.types:gl-id (*))}
@item Initform
@t{(make-array 0 :element-type (quote %cepl.types:gl-id) :initial-element %cepl.types:+null-gl-id+ :adjustable t :fill-pointer 0)}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-ARRAY-OF-SSBO-BINDINGS-BUFFER-IDS function, , @t{%cepl-context-array-of-ssbo-bindings-buffer-ids}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-ARRAY-OF-SSBO-BINDINGS-BUFFER-IDS) function, , @t{(setf %cepl-context-array-of-ssbo-bindings-buffer-ids)}} (function)
@end table
@end defvr
@defvr {Slot} array-of-ssbo-binding-ranges
@slotsubindex{array-of-ssbo-binding-ranges}@c
@table @strong
@item Type
@t{(array (unsigned-byte 32) (*))}
@item Initform
@t{(make-array 0 :element-type (quote (unsigned-byte 32)) :initial-element 0 :adjustable t :fill-pointer 0)}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-ARRAY-OF-SSBO-BINDING-RANGES function, , @t{%cepl-context-array-of-ssbo-binding-ranges}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-ARRAY-OF-SSBO-BINDING-RANGES) function, , @t{(setf %cepl-context-array-of-ssbo-binding-ranges)}} (function)
@end table
@end defvr
@defvr {Slot} array-of-transform-feedback-bindings-buffer-ids
@slotsubindex{array-of-transform-feedback-bindings-buffer-ids}@c
@table @strong
@item Type
@t{(array %cepl.types:gl-id (*))}
@item Initform
@t{(make-array 0 :element-type (quote %cepl.types:gl-id) :initial-element %cepl.types:+null-gl-id+ :adjustable t :fill-pointer 0)}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-ARRAY-OF-TRANSFORM-FEEDBACK-BINDINGS-BUFFER-IDS function, , @t{%cepl-context-array-of-transform-feedback-bindings-buffer-ids}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-ARRAY-OF-TRANSFORM-FEEDBACK-BINDINGS-BUFFER-IDS) function, , @t{(setf %cepl-context-array-of-transform-feedback-bindings-buffer-ids)}} (function)
@end table
@end defvr
@defvr {Slot} array-of-bound-samplers
@slotsubindex{array-of-bound-samplers}@c
@table @strong
@item Type
@t{(simple-array (or null %cepl.types:sampler) (*))}
@item Initform
@t{(make-array 0 :element-type (quote (or null %cepl.types:sampler)) :initial-element nil)}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-ARRAY-OF-BOUND-SAMPLERS function, , @t{%cepl-context-array-of-bound-samplers}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-ARRAY-OF-BOUND-SAMPLERS) function, , @t{(setf %cepl-context-array-of-bound-samplers)}} (function)
@end table
@end defvr
@defvr {Slot} array-of-bound-queries
@slotsubindex{array-of-bound-queries}@c
@table @strong
@item Type
@t{(simple-array (or null %cepl.types:gpu-query) (7))}
@item Initform
@t{(make-array 7 :element-type (quote (or null %cepl.types:gpu-query)) :initial-element nil)}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-ARRAY-OF-BOUND-QUERIES function, , @t{%cepl-context-array-of-bound-queries}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-ARRAY-OF-BOUND-QUERIES) function, , @t{(setf %cepl-context-array-of-bound-queries)}} (function)
@end table
@end defvr
@defvr {Slot} array-of-textures
@slotsubindex{array-of-textures}@c
@table @strong
@item Type
@t{(array glsl-symbols.functions:texture (*))}
@item Initform
@t{(make-array 0 :element-type (quote glsl-symbols.functions:texture) :initial-element %cepl.types:+null-texture+ :adjustable t :fill-pointer 0)}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-ARRAY-OF-TEXTURES function, , @t{%cepl-context-array-of-textures}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-ARRAY-OF-TEXTURES) function, , @t{(setf %cepl-context-array-of-textures)}} (function)
@end table
@end defvr
@defvr {Slot} depth-func
@slotsubindex{depth-func}@c
@table @strong
@item Type
@t{(or symbol function)}
@item Initform
@t{:unknown}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-DEPTH-FUNC function, , @t{%cepl-context-depth-func}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-DEPTH-FUNC) function, , @t{(setf %cepl-context-depth-func)}} (function)
@end table
@end defvr
@defvr {Slot} depth-mask
@slotsubindex{depth-mask}@c
@table @strong
@item Type
@t{boolean}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-DEPTH-MASK function, , @t{%cepl-context-depth-mask}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-DEPTH-MASK) function, , @t{(setf %cepl-context-depth-mask)}} (function)
@end table
@end defvr
@defvr {Slot} color-masks
@slotsubindex{color-masks}@c
@table @strong
@item Type
@t{(simple-array (simple-array boolean (4)) (*))}
@item Initform
@t{(make-array 0 :element-type (quote (simple-array boolean (4))))}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-COLOR-MASKS function, , @t{%cepl-context-color-masks}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-COLOR-MASKS) function, , @t{(setf %cepl-context-color-masks)}} (function)
@end table
@end defvr
@defvr {Slot} depth-range
@slotsubindex{depth-range}@c
@table @strong
@item Type
@t{glsl-symbols.types:vec2}
@item Initform
@t{(glsl-symbols.types:vec2 0.0 1.0)}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-DEPTH-RANGE function, , @t{%cepl-context-depth-range}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-DEPTH-RANGE) function, , @t{(setf %cepl-context-depth-range)}} (function)
@end table
@end defvr
@defvr {Slot} depth-clamp
@slotsubindex{depth-clamp}@c
@table @strong
@item Type
@t{boolean}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-DEPTH-CLAMP function, , @t{%cepl-context-depth-clamp}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-DEPTH-CLAMP) function, , @t{(setf %cepl-context-depth-clamp)}} (function)
@end table
@end defvr
@defvr {Slot} cull-face
@slotsubindex{cull-face}@c
@table @strong
@item Type
@t{(or symbol function)}
@item Initform
@t{:unknown}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-CULL-FACE function, , @t{%cepl-context-cull-face}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-CULL-FACE) function, , @t{(setf %cepl-context-cull-face)}} (function)
@end table
@end defvr
@defvr {Slot} front-face
@slotsubindex{front-face}@c
@table @strong
@item Type
@t{symbol}
@item Initform
@t{:unknown}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-FRONT-FACE function, , @t{%cepl-context-front-face}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-FRONT-FACE) function, , @t{(setf %cepl-context-front-face)}} (function)
@end table
@end defvr
@defvr {Slot} clear-color
@slotsubindex{clear-color}@c
@table @strong
@item Type
@t{glsl-symbols.types:vec4}
@item Initform
@t{(glsl-symbols.types:vec4 0.0 0.0 0.0 0.0)}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-CLEAR-COLOR function, , @t{%cepl-context-clear-color}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-CLEAR-COLOR) function, , @t{(setf %cepl-context-clear-color)}} (function)
@end table
@end defvr
@defvr {Slot} pack-alignment
@slotsubindex{pack-alignment}@c
@table @strong
@item Type
@t{(integer 1 8)}
@item Initform
@t{4}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-PACK-ALIGNMENT function, , @t{%cepl-context-pack-alignment}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-PACK-ALIGNMENT) function, , @t{(setf %cepl-context-pack-alignment)}} (function)
@end table
@end defvr
@defvr {Slot} unpack-alignment
@slotsubindex{unpack-alignment}@c
@table @strong
@item Type
@t{(integer 1 8)}
@item Initform
@t{4}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-UNPACK-ALIGNMENT function, , @t{%cepl-context-unpack-alignment}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-UNPACK-ALIGNMENT) function, , @t{(setf %cepl-context-unpack-alignment)}} (function)
@end table
@end defvr
@defvr {Slot} max-draw-buffer-count
@slotsubindex{max-draw-buffer-count}@c
@table @strong
@item Type
@t{(unsigned-byte 16)}
@item Initform
@t{0}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-MAX-DRAW-BUFFER-COUNT function, , @t{%cepl-context-max-draw-buffer-count}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-MAX-DRAW-BUFFER-COUNT) function, , @t{(setf %cepl-context-max-draw-buffer-count)}} (function)
@end table
@end defvr
@defvr {Slot} instance-count
@slotsubindex{instance-count}@c
@table @strong
@item Type
@t{%cepl.types:c-array-index}
@item Initform
@t{1}
@item Readers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-INSTANCE-COUNT function, , @t{%cepl-context-instance-count}} (function)
@item Writers
@ref{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-INSTANCE-COUNT) function, , @t{(setf %cepl-context-instance-count)}} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {compile-context} ()
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>COMPILE-CONTEXT structure}@c
@structuresubindex{compile-context}@c

In the `lambda-list` for a `gpu-function`, glsl-stage or gpu lambda you can
include the `&context` symbol which indicates that the remaining forms in the
lambda-list are information about the context for the gpu-function to be
compiled in.@*

In pipelines (either defiend by `defpipeline-g` or `pipeline-g`) there is a
context parameter which is a list of forms which represent information about
the context for the pipeline to be compiled in.@*

### The Data@*

The `compile-context` holds a few pieces of information:@*

- GLSL Versions@*
 - in the case of `gpu-function`s and glsl stages this is used to specify what
   GLSL versions this is valid for.@*
 - in the case of pipelines this is used to specify what version of GLSL will
   be used to compile this pipeline.@*
- Primitive@*
 - in the case of gpu-functions and glsl-stages this is used to specify what
   primitive is valid. This can be used to ensure that a specific
   `gpu-function` or glsl-stage that works on `:lines` is never used in a
   `pipeline` processing `:triangles`.@*
 - in the case of pipelines this is used to specify what primitive this
   pipeline takes. Any `buffer-stream` passed to this pipeline will be checked
   to ensure it contains the correct primitive. To specify this please refer
   to the  :primitive argument in `make-buffer-stream` or the
   `buffer-stream-primitive` function.@*
- Stage Restrictive@*
 - Not valid for pipelines. This lets the you declare what stage the
   gpu-function or glsl stage is valid for.@*
- Static@*
 - For all targets this tells CEPL that the function, glsl stage or@*
   pipeline is never going to be modified again. This allows CEPL to statically
   define some types and also elide the code that would usually cause
   recompilation when a gpu-function this is used by this
   pipeline/stage/function is recompiled.@*

Most compile-context information is optional and the following defaults are used
if the data is not provided:@*

- GLSL Versions@*
 - gpu-function/glsl-stage: When checking for errors CEPL will allow
   functions/types/etc from any glsl version to be used.@*
 - pipeline: CEPL will look at the GL version of the context to determine the
   most recent version of GLSL that it can used.@*
- Primitive@*
 - gpu-function/glsl-stage: By default there is no restriction applied@*
 - pipeline: By default :triangles are assumed@*
- Stage@*
 - pipelines/gpu-functions: Always NIL by default@*
 - glsl-stages: Mandatory@*
- Static@*
 - Always NIL by default@*

### How it is specified@*

The context designations are:@*

Static:@*

The symbol :static can appear at most once in the context list@*

Versions:@*

0 or more of the following can appear in the context list@*

- :140@*
- :150@*
- :330@*
- :400@*
- :410@*
- :420@*
- :430@*
- :440@*
- :450@*
- :460@*

Stage:@*

At most 1 of the following:@*
- :vertex@*
- :tessellation-control@*
- :tessellation-evaluation@*
- :geometry@*
- :fragment@*
- :compute@*

Primitive:@*

At most 1 of the following can appear in the context list@*
- :dynamic@*
- :points@*
- :lines@*
- :iso-lines@*
- :line-loop@*
- :line-strip@*
- :lines-adjacency@*
- :line-strip-adjacency@*
- :triangles@*
- :triangle-fan@*
- :triangle-strip@*
- :triangles-adjacency@*
- :triangle-strip-adjacency@*
- (:patch <patch length>)@*

Note: :dynamic is special. It means that the pipeline will take the primitive
kind from the buffer-stream being mapped over. This won't work for with
pipelines with geometry or tessellation stages, but it otherwise can be useful.

### Example@*

    (defpipeline-g draw-sphere ((:patch 3) :440 :static)@*
      :vertex (sphere-vert g-pnt)@*
      :tessellation-control (sphere-tess-con (:vec3 3))
      :tessellation-evaluation (sphere-tess-eval (:vec3 3))@*
      :geometry (sphere-geom (:vec3 3) (:vec3 3))@*
      :fragment (sphere-frag :vec3 :vec3 :vec3))@*

This pipeline takes 3 component patches, requires at least GLSL 440 and has
declared that it will not be recompiled (and as such will not take part in
live recompilation).@*

    (defun-g saturate ((val :dvec4) &context :410 :420 :430 :440 :450 :460)
      (clamp val 0d0 1d0))@*

This gpu-function is restricted to only work on version of GLSL between@*
410 & 460@*

    (def-glsl-stage frag-glsl ((\"color_in\" :vec4) &context :330 :fragment)
      \"void main() @lbracechar{}@*
           color_out = v_in.color_in;@*
       @rbracechar{}\"@*
      ((\"color_out\" :vec4)))@*

This glsl-stage has stated it is to be used as a fragment stage as it only
valid for GLSL version 330.
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/compile-context<dot>lisp file, , @t{core/pipelines/compile-context.lisp}} (file)
@item Direct superclasses
@t{structure-object} (structure)
@item Direct methods
@t{make-load-form} (method)
@item Direct slots
@defvr {Slot} primitive
@slotsubindex{primitive}@c
@table @strong
@item Initform
@t{(error \"bug: context without primitive\")}
@item Readers
@ref{go to the CEPL<dot>PIPELINES<colon><colon>COMPILE-CONTEXT-PRIMITIVE function, , @t{compile-context-primitive}} (function)
@item Writers
@ref{go to the CEPL<dot>PIPELINES<colon><colon>(SETF COMPILE-CONTEXT-PRIMITIVE) function, , @t{(setf compile-context-primitive)}} (function)
@end table
@end defvr
@defvr {Slot} versions
@slotsubindex{versions}@c
@table @strong
@item Initform
@t{(error \"bug: context without versions\")}
@item Readers
@ref{go to the CEPL<dot>PIPELINES<colon><colon>COMPILE-CONTEXT-VERSIONS function, , @t{compile-context-versions}} (function)
@item Writers
@ref{go to the CEPL<dot>PIPELINES<colon><colon>(SETF COMPILE-CONTEXT-VERSIONS) function, , @t{(setf compile-context-versions)}} (function)
@end table
@end defvr
@defvr {Slot} stage
@slotsubindex{stage}@c
@table @strong
@item Initform
@t{(error \"bug: context without stage\")}
@item Readers
@ref{go to the CEPL<dot>PIPELINES<colon><colon>COMPILE-CONTEXT-STAGE function, , @t{compile-context-stage}} (function)
@item Writers
@ref{go to the CEPL<dot>PIPELINES<colon><colon>(SETF COMPILE-CONTEXT-STAGE) function, , @t{(setf compile-context-stage)}} (function)
@end table
@end defvr
@defvr {Slot} static-p
@slotsubindex{static-p}@c
@table @strong
@item Initform
@t{(error \"bug: context without 'static' boolean\")}
@item Readers
@ref{go to the CEPL<dot>PIPELINES<colon><colon>COMPILE-CONTEXT-STATIC-P function, , @t{compile-context-static-p}} (function)
@item Writers
@ref{go to the CEPL<dot>PIPELINES<colon><colon>(SETF COMPILE-CONTEXT-STATIC-P) function, , @t{(setf compile-context-static-p)}} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {compute-space} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COMPUTE-SPACE structure}@c
@structuresubindex{compute-space}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@t{structure-object} (structure)
@item Direct methods
@itemize @bullet
@item
@t{dimensions} (method)
@item
@ref{go to the CEPL<dot>MEASUREMENTS<colon><colon>DIMENSIONS %CEPL<dot>TYPES<colon><colon>COMPUTE-SPACE method, , @t{dimensions}} (method)
@end itemize
@item Direct slots
@defvr {Slot} size-x
@slotsubindex{size-x}@c
@table @strong
@item Type
@t{(unsigned-byte 32)}
@item Initform
@t{1}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>COMPUTE-SPACE-SIZE-X function, , @t{compute-space-size-x}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF COMPUTE-SPACE-SIZE-X) function, , @t{(setf compute-space-size-x)}} (function)
@end table
@end defvr
@defvr {Slot} size-y
@slotsubindex{size-y}@c
@table @strong
@item Type
@t{(unsigned-byte 32)}
@item Initform
@t{1}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>COMPUTE-SPACE-SIZE-Y function, , @t{compute-space-size-y}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF COMPUTE-SPACE-SIZE-Y) function, , @t{(setf compute-space-size-y)}} (function)
@end table
@end defvr
@defvr {Slot} size-z
@slotsubindex{size-z}@c
@table @strong
@item Type
@t{(unsigned-byte 32)}
@item Initform
@t{1}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>COMPUTE-SPACE-SIZE-Z function, , @t{compute-space-size-z}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF COMPUTE-SPACE-SIZE-Z) function, , @t{(setf compute-space-size-z)}} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {elements-indirect-command} ()
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ELEMENTS-INDIRECT-COMMAND structure}@c
@structuresubindex{elements-indirect-command}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/multi-draw<dot>lisp file, , @t{core/pipelines/multi-draw.lisp}} (file)
@item Direct superclasses
@ref{go to the CEPL<dot>TYPES<colon><colon>BASE-GSTRUCT-WRAPPER structure, , @t{base-gstruct-wrapper}} (structure)
@item Direct methods
@itemize @bullet
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PUSH-G COMMON-LISP<colon><colon>LIST CEPL<dot>PIPELINES<colon><colon>ELEMENTS-INDIRECT-COMMAND method, , @t{push-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PULL1-G CEPL<dot>PIPELINES<colon><colon>ELEMENTS-INDIRECT-COMMAND method, , @t{pull1-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PULL-G CEPL<dot>PIPELINES<colon><colon>ELEMENTS-INDIRECT-COMMAND method, , @t{pull-g}} (method)
@item
@ref{go to the CEPL<dot>INTERNALS<colon><colon>POPULATE CEPL<dot>PIPELINES<colon><colon>ELEMENTS-INDIRECT-COMMAND COMMON-LISP<colon><colon>T method, , @t{populate}} (method)
@item
@t{print-object} (method)
@end itemize
@end table
@end deftp
@deftp {Structure} {empty-fbo-params} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>EMPTY-FBO-PARAMS structure}@c
@structuresubindex{empty-fbo-params}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@t{structure-object} (structure)
@item Direct methods
@t{print-object} (method)
@item Direct slots
@defvr {Slot} fbo
@slotsubindex{fbo}@c
@table @strong
@item Type
@t{(or null %cepl.types:fbo)}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%EMPTY-FBO-PARAMS-FBO function, , @t{%empty-fbo-params-fbo}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %EMPTY-FBO-PARAMS-FBO) function, , @t{(setf %empty-fbo-params-fbo)}} (function)
@end table
@end defvr
@defvr {Slot} dimensions
@slotsubindex{dimensions}@c
@table @strong
@item Type
@t{list}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%EMPTY-FBO-PARAMS-DIMENSIONS function, , @t{%empty-fbo-params-dimensions}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %EMPTY-FBO-PARAMS-DIMENSIONS) function, , @t{(setf %empty-fbo-params-dimensions)}} (function)
@end table
@end defvr
@defvr {Slot} viewport
@slotsubindex{viewport}@c
@table @strong
@item Type
@t{%cepl.types:viewport}
@item Initform
@t{(%cepl.types:%make-viewport)}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%EMPTY-FBO-PARAMS-VIEWPORT function, , @t{%empty-fbo-params-viewport}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %EMPTY-FBO-PARAMS-VIEWPORT) function, , @t{(setf %empty-fbo-params-viewport)}} (function)
@end table
@end defvr
@defvr {Slot} layer-count
@slotsubindex{layer-count}@c
@table @strong
@item Type
@t{unsigned-byte}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%EMPTY-FBO-PARAMS-LAYER-COUNT function, , @t{%empty-fbo-params-layer-count}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %EMPTY-FBO-PARAMS-LAYER-COUNT) function, , @t{(setf %empty-fbo-params-layer-count)}} (function)
@end table
@end defvr
@defvr {Slot} samples
@slotsubindex{samples}@c
@table @strong
@item Type
@t{unsigned-byte}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%EMPTY-FBO-PARAMS-SAMPLES function, , @t{%empty-fbo-params-samples}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %EMPTY-FBO-PARAMS-SAMPLES) function, , @t{(setf %empty-fbo-params-samples)}} (function)
@end table
@end defvr
@defvr {Slot} fixed-sample-locations-p
@slotsubindex{fixed-sample-locations-p}@c
@table @strong
@item Type
@t{boolean}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%EMPTY-FBO-PARAMS-FIXED-SAMPLE-LOCATIONS-P function, , @t{%empty-fbo-params-fixed-sample-locations-p}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %EMPTY-FBO-PARAMS-FIXED-SAMPLE-LOCATIONS-P) function, , @t{(setf %empty-fbo-params-fixed-sample-locations-p)}} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {fbo} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>FBO structure}@c
@structuresubindex{fbo}@c

A framebuffer object (`FBO`) is a structure that can be rendered into.@*

When a FBO is rendered into the data from the pipeline is written into one or
more of the `attachment`s of the FBO@*

An FBO attachment is a slot where a texture-backed `gpu-array` can be attached.
When the gpu-array is attached the data from a pipeline rendering into the fbo
is written into that gpu-array.@*

This is the heart of how multi-pass rendering is done in OpenGL. One pipeline
writes data into `texture`s that are then used as inputs to another pipeline[0].

A FBO can have:@*
- 0 or more 'color attachments'@*
- 0 or 1 'depth attachment'@*
- 0 or 1 'stencil attachment'@*
- 0 or 1 'depth-stencil attachment'@*

Let's look at these in more detail:@*

**-- Color Attachments --**@*

Color attachments can only contain gpu-arrays whose element-type can be found in
the *color-renderable-formats* list.@*

Note that while OpenGL terminology mentions 'color' and 'image' a lot you are
not limitted to only using textures or fbos for pictures. It is perfectly
valid (and incredibly useful) to return data meaning all kinds of things other
than colors.@*

**-- Depth Attachments --**@*

The depth attachment (when used) can only contain a gpu-array whos element-type
can be found in *depth-formats*@*

*Usage Tip:* Even if you don't plan on reading from this depth_attachment, any
fbo that will be rendered to should have a depth attachment.@*

**-- Stencil Attachments (NOT SUPPORTED IN CURRENT CEPL VERSION) --**@*

The stencil attachment (when used) can only contain a gpu-array whos
element-type can be found in *stencil-formats*@*

**-- Depth-Stencil Attachments (NOT SUPPORTED IN CURRENT CEPL VERSION) --**@*

The depth-stencil attachment (when used) can only contain a gpu-array whos
element-type can be found in *depth-stencil-formats*@*

This attachment is shorthand for 'both depth and stencil'. The gpu-array
attached here becomes both the depth and stencil attachment.@*


**-- Choosing which attachment to render into --**@*

Making these choices is done with the `with-fbo-bound` macro. See its docstring
for further details@*

[0] WARNING:@*

It is possible to bind a texture to an FBO, bind that same texture to a shader,
and then try to sample from it at the same time. You will get undefined results.

This means it may do what you want, the sampler may get old data, the sampler
may get half old and half new data, or it may get garbage data. Any of these are
possible outcomes.@*

Do Not Do This!
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@t{structure-object} (structure)
@item Direct methods
@itemize @bullet
@item
@t{print-object} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>FREE %CEPL<dot>TYPES<colon><colon>FBO method, , @t{free}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>INITIALIZED-P %CEPL<dot>TYPES<colon><colon>FBO method, , @t{initialized-p}} (method)
@item
@ref{go to the %CEPL<dot>TYPES<colon><colon>CAN-BE-SHARED-BETWEEN-CONTEXTS-P %CEPL<dot>TYPES<colon><colon>FBO method, , @t{can-be-shared-between-contexts-p}} (method)
@end itemize
@item Direct slots
@defvr {Slot} id
@slotsubindex{id}@c
@table @strong
@item Type
@t{%cepl.types:gl-id}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%FBO-ID function, , @t{%fbo-id}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %FBO-ID) function, , @t{(setf %fbo-id)}} (function)
@end table
@end defvr
@defvr {Slot} empty-params
@slotsubindex{empty-params}@c
@table @strong
@item Type
@t{(or null %cepl.types:empty-fbo-params)}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%FBO-EMPTY-PARAMS function, , @t{%fbo-empty-params}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %FBO-EMPTY-PARAMS) function, , @t{(setf %fbo-empty-params)}} (function)
@end table
@end defvr
@defvr {Slot} color-arrays
@slotsubindex{color-arrays}@c
@table @strong
@item Type
@t{(array %cepl.types:att *)}
@item Initform
@t{(make-array 0 :element-type (quote %cepl.types:att) :initial-element (symbol-value (quote %cepl.types::+null-att+)) :adjustable t :fill-pointer 0)}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%FBO-COLOR-ARRAYS function, , @t{%fbo-color-arrays}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %FBO-COLOR-ARRAYS) function, , @t{(setf %fbo-color-arrays)}} (function)
@end table
@end defvr
@defvr {Slot} depth-array
@slotsubindex{depth-array}@c
@table @strong
@item Type
@t{%cepl.types:att}
@item Initform
@t{(%cepl.types:make-att)}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%FBO-DEPTH-ARRAY function, , @t{%fbo-depth-array}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %FBO-DEPTH-ARRAY) function, , @t{(setf %fbo-depth-array)}} (function)
@end table
@end defvr
@defvr {Slot} stencil-array
@slotsubindex{stencil-array}@c
@table @strong
@item Type
@t{%cepl.types:att}
@item Initform
@t{(%cepl.types:make-att)}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%FBO-STENCIL-ARRAY function, , @t{%fbo-stencil-array}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %FBO-STENCIL-ARRAY) function, , @t{(setf %fbo-stencil-array)}} (function)
@end table
@end defvr
@defvr {Slot} draw-buffer-map
@slotsubindex{draw-buffer-map}@c
@table @strong
@item Initform
@t{(error \"draw-buffer array must be provided when initializing an fbo\")}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%FBO-DRAW-BUFFER-MAP function, , @t{%fbo-draw-buffer-map}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %FBO-DRAW-BUFFER-MAP) function, , @t{(setf %fbo-draw-buffer-map)}} (function)
@end table
@end defvr
@defvr {Slot} clear-mask
@slotsubindex{clear-mask}@c
@table @strong
@item Type
@t{fixnum}
@item Initform
@t{(cffi:foreign-bitfield-value (quote cl-opengl-bindings:clearbuffermask) (quote (:color-buffer-bit)))}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%FBO-CLEAR-MASK function, , @t{%fbo-clear-mask}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %FBO-CLEAR-MASK) function, , @t{(setf %fbo-clear-mask)}} (function)
@end table
@end defvr
@defvr {Slot} is-default
@slotsubindex{is-default}@c
@table @strong
@item Type
@t{boolean}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%FBO-IS-DEFAULT function, , @t{%fbo-is-default}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %FBO-IS-DEFAULT) function, , @t{(setf %fbo-is-default)}} (function)
@end table
@end defvr
@defvr {Slot} attachment-count
@slotsubindex{attachment-count}@c
@table @strong
@item Type
@t{(unsigned-byte 8)}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%FBO-ATTACHMENT-COUNT function, , @t{%fbo-attachment-count}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %FBO-ATTACHMENT-COUNT) function, , @t{(setf %fbo-attachment-count)}} (function)
@end table
@end defvr
@defvr {Slot} blending-params
@slotsubindex{blending-params}@c
@table @strong
@item Type
@t{%cepl.types:blending-params}
@item Initform
@t{(%cepl.types:make-blending-params :mode-rgb :func-add :mode-alpha :func-add :source-rgb :one :source-alpha :one :destination-rgb :zero :destination-alpha :zero)}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%FBO-BLENDING-PARAMS function, , @t{%fbo-blending-params}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %FBO-BLENDING-PARAMS) function, , @t{(setf %fbo-blending-params)}} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {g-pc} ()
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PC structure}@c
@structuresubindex{g-pc}@c

g-pc is a CEPL gpu struct with the following slots:

  position: of type vec3 with an accessor method: pos
  color: of type vec4 with an accessor method: col
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@item Direct superclasses
@ref{go to the CEPL<dot>TYPES<colon><colon>BASE-GSTRUCT-WRAPPER structure, , @t{base-gstruct-wrapper}} (structure)
@item Direct methods
@itemize @bullet
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PUSH-G COMMON-LISP<colon><colon>LIST CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PC method, , @t{push-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PULL1-G CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PC method, , @t{pull1-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PULL-G CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PC method, , @t{pull-g}} (method)
@item
@ref{go to the CEPL<dot>INTERNALS<colon><colon>POPULATE CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PC COMMON-LISP<colon><colon>T method, , @t{populate}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>(SETF COL) COMMON-LISP<colon><colon>T CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PC method, , @t{(setf col)}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>(SETF POS) COMMON-LISP<colon><colon>T CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PC method, , @t{(setf pos)}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>COL CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PC method, , @t{col}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>POS CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PC method, , @t{pos}} (method)
@item
@t{print-object} (method)
@end itemize
@end table
@end deftp
@deftp {Structure} {g-pn} ()
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PN structure}@c
@structuresubindex{g-pn}@c

g-pn is a CEPL gpu struct with the following slots:

  position: of type vec3 with an accessor method: pos
  normal: of type vec3 with an accessor method: norm
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@item Direct superclasses
@ref{go to the CEPL<dot>TYPES<colon><colon>BASE-GSTRUCT-WRAPPER structure, , @t{base-gstruct-wrapper}} (structure)
@item Direct methods
@itemize @bullet
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PUSH-G COMMON-LISP<colon><colon>LIST CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PN method, , @t{push-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PULL1-G CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PN method, , @t{pull1-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PULL-G CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PN method, , @t{pull-g}} (method)
@item
@ref{go to the CEPL<dot>INTERNALS<colon><colon>POPULATE CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PN COMMON-LISP<colon><colon>T method, , @t{populate}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>(SETF NORM) COMMON-LISP<colon><colon>T CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PN method, , @t{(setf norm)}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>(SETF POS) COMMON-LISP<colon><colon>T CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PN method, , @t{(setf pos)}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>NORM CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PN method, , @t{norm}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>POS CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PN method, , @t{pos}} (method)
@item
@t{print-object} (method)
@end itemize
@end table
@end deftp
@deftp {Structure} {g-pnc} ()
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNC structure}@c
@structuresubindex{g-pnc}@c

g-pnc is a CEPL gpu struct with the following slots:

  position: of type vec3 with an accessor method: pos
  normal: of type vec3 with an accessor method: norm
  color: of type vec4 with an accessor method: col
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@item Direct superclasses
@ref{go to the CEPL<dot>TYPES<colon><colon>BASE-GSTRUCT-WRAPPER structure, , @t{base-gstruct-wrapper}} (structure)
@item Direct methods
@itemize @bullet
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PUSH-G COMMON-LISP<colon><colon>LIST CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNC method, , @t{push-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PULL1-G CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNC method, , @t{pull1-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PULL-G CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNC method, , @t{pull-g}} (method)
@item
@ref{go to the CEPL<dot>INTERNALS<colon><colon>POPULATE CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNC COMMON-LISP<colon><colon>T method, , @t{populate}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>(SETF COL) COMMON-LISP<colon><colon>T CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNC method, , @t{(setf col)}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>(SETF NORM) COMMON-LISP<colon><colon>T CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNC method, , @t{(setf norm)}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>(SETF POS) COMMON-LISP<colon><colon>T CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNC method, , @t{(setf pos)}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>COL CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNC method, , @t{col}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>NORM CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNC method, , @t{norm}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>POS CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNC method, , @t{pos}} (method)
@item
@t{print-object} (method)
@end itemize
@end table
@end deftp
@deftp {Structure} {g-pnt} ()
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNT structure}@c
@structuresubindex{g-pnt}@c

g-pnt is a CEPL gpu struct with the following slots:

  position: of type vec3 with an accessor method: pos
  normal: of type vec3 with an accessor method: norm
  texture: of type vec2 with an accessor method: tex
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@item Direct superclasses
@ref{go to the CEPL<dot>TYPES<colon><colon>BASE-GSTRUCT-WRAPPER structure, , @t{base-gstruct-wrapper}} (structure)
@item Direct methods
@itemize @bullet
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PUSH-G COMMON-LISP<colon><colon>LIST CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNT method, , @t{push-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PULL1-G CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNT method, , @t{pull1-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PULL-G CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNT method, , @t{pull-g}} (method)
@item
@ref{go to the CEPL<dot>INTERNALS<colon><colon>POPULATE CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNT COMMON-LISP<colon><colon>T method, , @t{populate}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>(SETF TEX) COMMON-LISP<colon><colon>T CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNT method, , @t{(setf tex)}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>(SETF NORM) COMMON-LISP<colon><colon>T CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNT method, , @t{(setf norm)}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>(SETF POS) COMMON-LISP<colon><colon>T CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNT method, , @t{(setf pos)}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>TEX CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNT method, , @t{tex}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>NORM CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNT method, , @t{norm}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>POS CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNT method, , @t{pos}} (method)
@item
@t{print-object} (method)
@end itemize
@end table
@end deftp
@deftp {Structure} {g-pntc} ()
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNTC structure}@c
@structuresubindex{g-pntc}@c

g-pntc is a CEPL gpu struct with the following slots:

  position: of type vec3 with an accessor method: pos
  normal: of type vec3 with an accessor method: norm
  texture: of type vec2 with an accessor method: tex
  color: of type vec4 with an accessor method: col
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@item Direct superclasses
@ref{go to the CEPL<dot>TYPES<colon><colon>BASE-GSTRUCT-WRAPPER structure, , @t{base-gstruct-wrapper}} (structure)
@item Direct methods
@itemize @bullet
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PUSH-G COMMON-LISP<colon><colon>LIST CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNTC method, , @t{push-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PULL1-G CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNTC method, , @t{pull1-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PULL-G CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNTC method, , @t{pull-g}} (method)
@item
@ref{go to the CEPL<dot>INTERNALS<colon><colon>POPULATE CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNTC COMMON-LISP<colon><colon>T method, , @t{populate}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>(SETF COL) COMMON-LISP<colon><colon>T CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNTC method, , @t{(setf col)}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>(SETF TEX) COMMON-LISP<colon><colon>T CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNTC method, , @t{(setf tex)}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>(SETF NORM) COMMON-LISP<colon><colon>T CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNTC method, , @t{(setf norm)}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>(SETF POS) COMMON-LISP<colon><colon>T CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNTC method, , @t{(setf pos)}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>COL CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNTC method, , @t{col}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>TEX CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNTC method, , @t{tex}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>NORM CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNTC method, , @t{norm}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>POS CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNTC method, , @t{pos}} (method)
@item
@t{print-object} (method)
@end itemize
@end table
@end deftp
@deftp {Structure} {g-pt} ()
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PT structure}@c
@structuresubindex{g-pt}@c

g-pt is a CEPL gpu struct with the following slots:

  position: of type vec3 with an accessor method: pos
  texture: of type vec2 with an accessor method: tex
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@item Direct superclasses
@ref{go to the CEPL<dot>TYPES<colon><colon>BASE-GSTRUCT-WRAPPER structure, , @t{base-gstruct-wrapper}} (structure)
@item Direct methods
@itemize @bullet
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PUSH-G COMMON-LISP<colon><colon>LIST CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PT method, , @t{push-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PULL1-G CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PT method, , @t{pull1-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PULL-G CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PT method, , @t{pull-g}} (method)
@item
@ref{go to the CEPL<dot>INTERNALS<colon><colon>POPULATE CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PT COMMON-LISP<colon><colon>T method, , @t{populate}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>(SETF TEX) COMMON-LISP<colon><colon>T CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PT method, , @t{(setf tex)}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>(SETF POS) COMMON-LISP<colon><colon>T CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PT method, , @t{(setf pos)}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>TEX CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PT method, , @t{tex}} (method)
@item
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>POS CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PT method, , @t{pos}} (method)
@item
@t{print-object} (method)
@end itemize
@end table
@end deftp
@deftp {Structure} {gpu-array} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY structure}@c
@structuresubindex{gpu-array}@c

`GPU-ARRAY` is a structure that represents an array in gpu-memory.@*

Depending on how the array was created it is said that the gpu-array is either
'buffer-backed' or 'texture-backed'.@*

- buffer-backed: Means it was created with `make-gpu-array` or `make-gpu-arrays`
                 The data is stored in a gpu-buffer.@*
- texture-backed: Means it was created along with a `texture`. `Texture`s are
                  structures that contain some number of gpu-arrays.@*
                  The data is stored in `texture` memory.@*
                  See `texture` for more details.@*

Both have different use cases and allow different element types, however they
are both an ordered block of typed data. They can have multiple dimensions and
you can `push-g` and `pull-g` data to and from them.@*

Note for folks who are used to OpenGL:@*
texture-backed gpu-arrays are what opengl would normally call 'images'. This is
a pretty terrible name for them as it implies they only can hold image data, or
that they are 2d only. In fact 'images' can have 1 to 3 dimensions, can have
elements that are single bytes, floats, vectors of either or a large number of
other types.@*
'image' belies this nature and so CEPL chooses 'array'@*

This also matches how the GLWiki chooses to explain them:@*
> an image is defined as a single array of pixels of a certain@*
> dimensionality (1D, 2D, or 3D), with a particular size, and a specific format.
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@t{structure-object} (structure)
@item Direct subclasses
@itemize @bullet
@item
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB structure, , @t{gpu-array-bb}} (structure)
@item
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T structure, , @t{gpu-array-t}} (structure)
@end itemize
@item Direct methods
@itemize @bullet
@item
@ref{go to the CEPL<dot>MEASUREMENTS<colon><colon>DIMENSIONS %CEPL<dot>TYPES<colon><colon>GPU-ARRAY method, , @t{dimensions}} (method)
@item
@ref{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED<colon><colon>FREE-GPU-ARRAY %CEPL<dot>TYPES<colon><colon>GPU-ARRAY method, , @t{free-gpu-array}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>FREE %CEPL<dot>TYPES<colon><colon>GPU-ARRAY method, , @t{free}} (method)
@item
@t{print-object} (method)
@item
@ref{go to the %CEPL<dot>TYPES<colon><colon>CAN-BE-SHARED-BETWEEN-CONTEXTS-P %CEPL<dot>TYPES<colon><colon>GPU-ARRAY method, , @t{can-be-shared-between-contexts-p}} (method)
@end itemize
@item Direct slots
@defvr {Slot} dimensions
@slotsubindex{dimensions}@c
@table @strong
@item Type
@t{list}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-DIMENSIONS function, , @t{gpu-array-dimensions}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-DIMENSIONS) function, , @t{(setf gpu-array-dimensions)}} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {gpu-array-bb} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB structure}@c
@structuresubindex{gpu-array-bb}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY structure, , @t{gpu-array}} (structure)
@item Direct methods
@itemize @bullet
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB (eql KEYWORD<colon><colon>LISP) method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB (eql KEYWORD<colon><colon>C-ARRAY) method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G %CEPL<dot>TYPES<colon><colon>C-ARRAY %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G COMMON-LISP<colon><colon>ARRAY %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G COMMON-LISP<colon><colon>LIST %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PULL-G %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB method, , @t{pull-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PULL1-G %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB method, , @t{pull1-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PUSH-G %CEPL<dot>TYPES<colon><colon>C-ARRAY %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB method, , @t{push-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PUSH-G COMMON-LISP<colon><colon>LIST %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB method, , @t{push-g}} (method)
@item
@ref{go to the CEPL-UTILS<colon><colon>PRINT-MEM %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB method, , @t{print-mem}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>TEXTURES<colon><colon>PIXEL-FORMAT-FROM-ARRAY %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB method, , @t{pixel-format-from-array}} (method)
@item
@ref{go to the CEPL<dot>TYPES<colon><colon>ELEMENT-TYPE %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB method, , @t{element-type}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>INITIALIZED-P %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB method, , @t{initialized-p}} (method)
@end itemize
@item Direct slots
@defvr {Slot} buffer
@slotsubindex{buffer}@c
@table @strong
@item Type
@t{%cepl.types:gpu-buffer}
@item Initform
@t{(error \"\")}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB-BUFFER function, , @t{gpu-array-bb-buffer}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-BB-BUFFER) function, , @t{(setf gpu-array-bb-buffer)}} (function)
@end table
@end defvr
@defvr {Slot} access-style
@slotsubindex{access-style}@c
@table @strong
@item Type
@t{symbol}
@item Initform
@t{:static-draw}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB-ACCESS-STYLE function, , @t{gpu-array-bb-access-style}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-BB-ACCESS-STYLE) function, , @t{(setf gpu-array-bb-access-style)}} (function)
@end table
@end defvr
@defvr {Slot} element-type
@slotsubindex{element-type}@c
@table @strong
@item Type
@t{symbol}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB-ELEMENT-TYPE function, , @t{gpu-array-bb-element-type}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-BB-ELEMENT-TYPE) function, , @t{(setf gpu-array-bb-element-type)}} (function)
@end table
@end defvr
@defvr {Slot} byte-size
@slotsubindex{byte-size}@c
@table @strong
@item Type
@t{%cepl.types::gbuf-byte-size}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB-BYTE-SIZE function, , @t{gpu-array-bb-byte-size}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-BB-BYTE-SIZE) function, , @t{(setf gpu-array-bb-byte-size)}} (function)
@end table
@end defvr
@defvr {Slot} element-byte-size
@slotsubindex{element-byte-size}@c
@table @strong
@item Type
@t{%cepl.types::elem-byte-size}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB-ELEMENT-BYTE-SIZE function, , @t{gpu-array-bb-element-byte-size}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-BB-ELEMENT-BYTE-SIZE) function, , @t{(setf gpu-array-bb-element-byte-size)}} (function)
@end table
@end defvr
@defvr {Slot} offset-in-bytes-into-buffer
@slotsubindex{offset-in-bytes-into-buffer}@c
@table @strong
@item Type
@t{%cepl.types::gbuf-byte-size}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB-OFFSET-IN-BYTES-INTO-BUFFER function, , @t{gpu-array-bb-offset-in-bytes-into-buffer}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-BB-OFFSET-IN-BYTES-INTO-BUFFER) function, , @t{(setf gpu-array-bb-offset-in-bytes-into-buffer)}} (function)
@end table
@end defvr
@defvr {Slot} element-pixel-format
@slotsubindex{element-pixel-format}@c
@table @strong
@item Type
@t{(or null %cepl.types:pixel-format)}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB-ELEMENT-PIXEL-FORMAT function, , @t{gpu-array-bb-element-pixel-format}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-BB-ELEMENT-PIXEL-FORMAT) function, , @t{(setf gpu-array-bb-element-pixel-format)}} (function)
@end table
@end defvr
@defvr {Slot} row-alignment
@slotsubindex{row-alignment}@c
@table @strong
@item Type
@t{(integer 1 8)}
@item Initform
@t{1}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB-ROW-ALIGNMENT function, , @t{gpu-array-bb-row-alignment}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-BB-ROW-ALIGNMENT) function, , @t{(setf gpu-array-bb-row-alignment)}} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {gpu-array-t} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T structure}@c
@structuresubindex{gpu-array-t}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY structure, , @t{gpu-array}} (structure)
@item Direct methods
@itemize @bullet
@item
@ref{go to the CEPL<dot>MEASUREMENTS<colon><colon>RESOLUTION %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T method, , @t{resolution}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T (eql KEYWORD<colon><colon>GPU-ARRAY-BB) method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T (eql KEYWORD<colon><colon>LISP) method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T (eql KEYWORD<colon><colon>C-ARRAY) method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T %CEPL<dot>TYPES<colon><colon>C-ARRAY method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G COMMON-LISP<colon><colon>ARRAY %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G COMMON-LISP<colon><colon>LIST %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G %CEPL<dot>TYPES<colon><colon>C-ARRAY %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PULL1-G %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T method, , @t{pull1-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PULL-G %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T method, , @t{pull-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PUSH-G COMMON-LISP<colon><colon>ARRAY %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T method, , @t{push-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PUSH-G COMMON-LISP<colon><colon>LIST %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T method, , @t{push-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PUSH-G %CEPL<dot>TYPES<colon><colon>C-ARRAY %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T method, , @t{push-g}} (method)
@item
@ref{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED<colon><colon>FREE-GPU-ARRAY %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T method, , @t{free-gpu-array}} (method)
@item
@ref{go to the CEPL<dot>TYPES<colon><colon>ELEMENT-TYPE %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T method, , @t{element-type}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>FREE %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T method, , @t{free}} (method)
@item
@t{print-object} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>INITIALIZED-P %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T method, , @t{initialized-p}} (method)
@end itemize
@item Direct slots
@defvr {Slot} texture
@slotsubindex{texture}@c
@table @strong
@item Type
@t{glsl-symbols.functions:texture}
@item Initform
@t{(error \"\")}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T-TEXTURE function, , @t{gpu-array-t-texture}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-T-TEXTURE) function, , @t{(setf gpu-array-t-texture)}} (function)
@end table
@end defvr
@defvr {Slot} texture-type
@slotsubindex{texture-type}@c
@table @strong
@item Type
@t{symbol}
@item Initform
@t{(error \"\")}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T-TEXTURE-TYPE function, , @t{gpu-array-t-texture-type}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-T-TEXTURE-TYPE) function, , @t{(setf gpu-array-t-texture-type)}} (function)
@end table
@end defvr
@defvr {Slot} level-num
@slotsubindex{level-num}@c
@table @strong
@item Type
@t{(unsigned-byte 16)}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T-LEVEL-NUM function, , @t{gpu-array-t-level-num}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-T-LEVEL-NUM) function, , @t{(setf gpu-array-t-level-num)}} (function)
@end table
@end defvr
@defvr {Slot} layer-num
@slotsubindex{layer-num}@c
@table @strong
@item Type
@t{(unsigned-byte 16)}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T-LAYER-NUM function, , @t{gpu-array-t-layer-num}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-T-LAYER-NUM) function, , @t{(setf gpu-array-t-layer-num)}} (function)
@end table
@end defvr
@defvr {Slot} face-num
@slotsubindex{face-num}@c
@table @strong
@item Type
@t{(integer 0 5)}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T-FACE-NUM function, , @t{gpu-array-t-face-num}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-T-FACE-NUM) function, , @t{(setf gpu-array-t-face-num)}} (function)
@end table
@end defvr
@defvr {Slot} image-format
@slotsubindex{image-format}@c
@table @strong
@item Type
@t{symbol}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T-IMAGE-FORMAT function, , @t{gpu-array-t-image-format}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-T-IMAGE-FORMAT) function, , @t{(setf gpu-array-t-image-format)}} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {gpu-buffer} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-BUFFER structure}@c
@structuresubindex{gpu-buffer}@c

`gpu-buffer` is a struct that abstracts a OpenGL 'Buffer Object'@*

Along with the the ID of the GL Object itself it stores the unformatted data
as an array of `gpu-array`s.@*

Every `gpu-array` in the buffer will have an element-type of :uint8, even if this
buffer was created for a `gpu-array` with a different element-type.@*

For example:@*

    (make-gpu-array '(.1 .2 .3 .4))@*

will make a `gpu-array` of 4 floats. However the buffer backing this `gpu-array`
will contain a single array with element-type :uint8 and a length of 16.@*

It is not expected that users will be using `gpu-buffer`s directly. Instead they
are ususal interacted with via CEPL's `gpu-array` and ubo features.
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@t{structure-object} (structure)
@item Direct methods
@itemize @bullet
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>FREE %CEPL<dot>TYPES<colon><colon>GPU-BUFFER method, , @t{free}} (method)
@item
@t{print-object} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>INITIALIZED-P %CEPL<dot>TYPES<colon><colon>GPU-BUFFER method, , @t{initialized-p}} (method)
@item
@ref{go to the %CEPL<dot>TYPES<colon><colon>CAN-BE-SHARED-BETWEEN-CONTEXTS-P %CEPL<dot>TYPES<colon><colon>GPU-BUFFER method, , @t{can-be-shared-between-contexts-p}} (method)
@end itemize
@item Direct slots
@defvr {Slot} id
@slotsubindex{id}@c
@table @strong
@item Type
@t{%cepl.types:gl-id}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-BUFFER-ID function, , @t{gpu-buffer-id}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-BUFFER-ID) function, , @t{(setf gpu-buffer-id)}} (function)
@end table
@end defvr
@defvr {Slot} cache-id
@slotsubindex{cache-id}@c
@table @strong
@item Type
@t{(integer 0 13)}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-BUFFER-CACHE-ID function, , @t{gpu-buffer-cache-id}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-BUFFER-CACHE-ID) function, , @t{(setf gpu-buffer-cache-id)}} (function)
@end table
@end defvr
@defvr {Slot} arrays
@slotsubindex{arrays}@c
@table @strong
@item Type
@t{(array %cepl.types:gpu-array-bb (*))}
@item Initform
@t{(error \"\")}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-BUFFER-ARRAYS function, , @t{gpu-buffer-arrays}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-BUFFER-ARRAYS) function, , @t{(setf gpu-buffer-arrays)}} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {gpu-fence} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-FENCE structure}@c
@structuresubindex{gpu-fence}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@t{structure-object} (structure)
@item Direct methods
@ref{go to the CEPL<dot>MEMORY<colon><colon>FREE %CEPL<dot>TYPES<colon><colon>GPU-FENCE method, , @t{free}} (method)
@item Direct slots
@defvr {Slot} obj
@slotsubindex{obj}@c
@table @strong
@item Type
@t{cffi-sys:foreign-pointer}
@item Initform
@t{(cffi-sys:null-pointer)}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%GPU-FENCE-OBJ function, , @t{%gpu-fence-obj}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %GPU-FENCE-OBJ) function, , @t{(setf %gpu-fence-obj)}} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {gpu-query} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-QUERY structure}@c
@structuresubindex{gpu-query}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@t{structure-object} (structure)
@item Direct subclasses
@itemize @bullet
@item
@ref{go to the %CEPL<dot>TYPES<colon><colon>TIMESTAMP-QUERY structure, , @t{timestamp-query}} (structure)
@item
@ref{go to the %CEPL<dot>TYPES<colon><colon>SCOPED-GPU-QUERY structure, , @t{scoped-gpu-query}} (structure)
@end itemize
@item Direct slots
@defvr {Slot} id
@slotsubindex{id}@c
@table @strong
@item Type
@t{%cepl.types:gl-id}
@item Initform
@t{(%cepl.types::gen-query-id)}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-QUERY-ID function, , @t{gpu-query-id}} (function)
@item Writers
@t{(setf gpu-query-id)} (function)
@end table
@end defvr
@defvr {Slot} enum
@slotsubindex{enum}@c
@table @strong
@item Type
@t{(signed-byte 32)}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-QUERY-ENUM function, , @t{gpu-query-enum}} (function)
@item Writers
@t{(setf gpu-query-enum)} (function)
@end table
@end defvr
@defvr {Slot} cache-id
@slotsubindex{cache-id}@c
@table @strong
@item Type
@t{(integer 0 7)}
@item Initform
@t{7}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-QUERY-CACHE-ID function, , @t{gpu-query-cache-id}} (function)
@item Writers
@t{(setf gpu-query-cache-id)} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {pixel-format} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>PIXEL-FORMAT structure}@c
@structuresubindex{pixel-format}@c

`pixel-format`s exist to aid the handling and conversion of types in CEPL.@*

OpenGL does not make it easy to understand the types involved with textures.

First there is the name of the type you would use in lisp (or C)@*

Then there is the image-format (sometimes called internal-format) which
specifies the format on the GPU@*

Then there are the types and formats that must be specified when uploading or
downloading data to/from a texture (or rather a texture-backed gpu-array).@*

CEPL's pixel-fromat pulls together enough metadata that conversions to and from
these various representations is easy.@*

Technically you shouldnt need to use this directly as it will be handled by CEPL
however if you ever have to deal with the formats directly, this type can be a
boon.@*

It doesnt cover every combination yet, but will in time. Anything missing is
considered a bug, so please report it on Github so it can be added to the todo
list.@*


@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@t{structure-object} (structure)
@item Direct slots
@defvr {Slot} components
@slotsubindex{components}@c
@table @strong
@item Type
@t{symbol}
@item Initform
@t{(error \"\")}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>PIXEL-FORMAT-COMPONENTS function, , @t{pixel-format-components}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF PIXEL-FORMAT-COMPONENTS) function, , @t{(setf pixel-format-components)}} (function)
@end table
@end defvr
@defvr {Slot} type
@slotsubindex{type}@c
@table @strong
@item Type
@t{symbol}
@item Initform
@t{(error \"\")}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>PIXEL-FORMAT-TYPE function, , @t{pixel-format-type}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF PIXEL-FORMAT-TYPE) function, , @t{(setf pixel-format-type)}} (function)
@end table
@end defvr
@defvr {Slot} normalize
@slotsubindex{normalize}@c
@table @strong
@item Type
@t{boolean}
@item Initform
@t{t}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>PIXEL-FORMAT-NORMALIZE function, , @t{pixel-format-normalize}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF PIXEL-FORMAT-NORMALIZE) function, , @t{(setf pixel-format-normalize)}} (function)
@end table
@end defvr
@defvr {Slot} sizes
@slotsubindex{sizes}@c
@table @strong
@item Type
@t{list}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>PIXEL-FORMAT-SIZES function, , @t{pixel-format-sizes}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF PIXEL-FORMAT-SIZES) function, , @t{(setf pixel-format-sizes)}} (function)
@end table
@end defvr
@defvr {Slot} reversed
@slotsubindex{reversed}@c
@table @strong
@item Type
@t{boolean}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>PIXEL-FORMAT-REVERSED function, , @t{pixel-format-reversed}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF PIXEL-FORMAT-REVERSED) function, , @t{(setf pixel-format-reversed)}} (function)
@end table
@end defvr
@defvr {Slot} comp-length
@slotsubindex{comp-length}@c
@table @strong
@item Type
@t{(unsigned-byte 8)}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>PIXEL-FORMAT-COMP-LENGTH function, , @t{pixel-format-comp-length}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF PIXEL-FORMAT-COMP-LENGTH) function, , @t{(setf pixel-format-comp-length)}} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {primitives-generated-query} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>PRIMITIVES-GENERATED-QUERY structure}@c
@structuresubindex{primitives-generated-query}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@ref{go to the %CEPL<dot>TYPES<colon><colon>SCOPED-GPU-QUERY structure, , @t{scoped-gpu-query}} (structure)
@item Direct slots
@defvr {Slot} enum
@slotsubindex{enum}@c
@table @strong
@item Type
@t{(and (signed-byte 32) (signed-byte 32))}
@item Initform
@t{35975}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>PRIMITIVES-GENERATED-QUERY-ENUM function, , @t{primitives-generated-query-enum}} (function)
@item Writers
@t{(setf primitives-generated-query-enum)} (function)
@end table
@end defvr
@defvr {Slot} cache-id
@slotsubindex{cache-id}@c
@table @strong
@item Type
@t{(and (integer 0 7) (integer 0 7))}
@item Initform
@t{4}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>PRIMITIVES-GENERATED-QUERY-CACHE-ID function, , @t{primitives-generated-query-cache-id}} (function)
@item Writers
@t{(setf primitives-generated-query-cache-id)} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {render-buffer} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>RENDER-BUFFER structure}@c
@structuresubindex{render-buffer}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@t{structure-object} (structure)
@item Direct methods
@t{print-object} (method)
@item Direct slots
@defvr {Slot} id
@slotsubindex{id}@c
@table @strong
@item Type
@t{%cepl.types:gl-id}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%RENDER-BUFFER-ID function, , @t{%render-buffer-id}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %RENDER-BUFFER-ID) function, , @t{(setf %render-buffer-id)}} (function)
@end table
@end defvr
@defvr {Slot} image-format
@slotsubindex{image-format}@c
@table @strong
@item Type
@t{symbol}
@item Initform
@t{(error \"bug\")}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%RENDER-BUFFER-IMAGE-FORMAT function, , @t{%render-buffer-image-format}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %RENDER-BUFFER-IMAGE-FORMAT) function, , @t{(setf %render-buffer-image-format)}} (function)
@end table
@end defvr
@defvr {Slot} resolution
@slotsubindex{resolution}@c
@table @strong
@item Type
@t{glsl-symbols.types:vec2}
@item Initform
@t{(error \"bug: render-buffer resolution not provided\")}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%RENDER-BUFFER-RESOLUTION function, , @t{%render-buffer-resolution}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %RENDER-BUFFER-RESOLUTION) function, , @t{(setf %render-buffer-resolution)}} (function)
@end table
@end defvr
@defvr {Slot} multisample-p
@slotsubindex{multisample-p}@c
@table @strong
@item Type
@t{boolean}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%RENDER-BUFFER-MULTISAMPLE-P function, , @t{%render-buffer-multisample-p}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %RENDER-BUFFER-MULTISAMPLE-P) function, , @t{(setf %render-buffer-multisample-p)}} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {sampler} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>SAMPLER structure}@c
@structuresubindex{sampler}@c

As `sampler` is a structure which we pass to the a gpu-pipeline to specify how the
pipeline should read from a particular `texture` (also known as sampling the
texture).@*

They are created by calling `sample` on a texture. You can then modify the
various parameters and the pass the sampler to a pipeline as a uniform.@*

Sampling Parameters cover four main aspects of how the values are read:@*

- Wrapping@*
- Filtering@*
- LOD@*
- Comparison@*


We will dive into these topics below.@*

**-- Note for beginners --**@*

This area of GL can be incredibly confusing so don't worry if you don't grasp
it immediately. Lots can be done without messing with these values, tackle each
one when you have a usecase for it.@*


**-- Wrapping --**@*

When using normalized texture coordinates we are used to thinking about our
coordinate being between 0s0 and 1s0 and that value dictating where we are
sampling from.@*

However normalized texture coordinates are not limited to values between@*
0s0 and 1s0. They can be any floating-point number.@*

When a texture coordinate is not within the 0  1 range, some means must be
employed to decide what the color value will be.@*

The different approaches are as follows:@*

    :repeat: the texture coordinate wraps around the texture. so a texture
             coordinate of -0.2 becomes the equivalent of 0.8.@*

    :mirrored-repeat: the texture coordinate wraps around like a mirror.@*
                      -0.2 becomes 0.2, -1.2 becomes 0.8, etc.@*

    :clamp-to-edge: the texture coordinate is clamped to the 0  1 range.@*

    :clamp-to-border: the texture coordinate is clamped to the 0  1@*
                      range, but the edge texels are blended with a@*
                      constant border color.@*

    :mirror-clamp-to-edge: (only available with OpenGL 4.4 or
                           :arb-texture-mirror-clamp-to-edge) the texture@*
                           is clamped to the -1  1 range, but mirrors the
                           negative direction with the positive. Basically,@*
                           it acts as :clamp-to-edge, except that it@*
                           takes the absolute value of the texture@*
                           coordinates before clamping.@*

This also applies to Rectangle Textures, except that the range at which they
apply edge sampling is based on the texel width/height of the texture, not@*
the normalized 0  1 range.@*

This does not apply to Buffer Textures, as they must use the texelFetch sampling
functions and thus cannot sample outside of the texel range of the texture.@*

example:@*

    (setf (wrap texture-or-sampler)@*
          #(:clamp-to-edge :repeat-to-edge :clamp-to-edge))@*

    (setf (wrap texture-or-sampler) :clamp-to-edge)@*



**-- Filtering --**@*

Filtering is the process of accessing a particular sample from a `texture`.@*

There are two cases when filtering is relevant: minification and magnification.

Magnification means that the area of the fragment in texture space is smaller
than a texel, and minification means that the area of the fragment in texture
space is larger than a texel.@*

Filtering for these two cases can be set independently.@*

The magnification filter is controlled by the :magnify-filter texture parameter.
This value can be :linear or :nearest.@*

If :nearest is used, then the implementation will select the texel nearest the
texture coordinate; this is commonly called 'point sampling').@*

If :linear is used, the implementation will perform a weighted linear blend
between the nearest adjacent samples.@*

    (setf (magnify-filter tex-or-sampler) :linear)@*
    (setf (magnify-filter tex-or-sampler) :nearest)@*


The minification filter is controlled by the :texture-min-filter texture
parameter. To understand these values better, it is important to discuss what
the particular options are. Here is the full list:@*

    :nearest                 :linear@*
    :nearest-mipmap-nearest  :nearest-mipmap-linear@*
    :linear-mipmap-nearest   :linear-mipmap-linear@*

When doing minification, you can choose to use mipmapping or not. Using
mipmapping means selecting between multiple mipmaps based on the angle and size
of the texture relative to the screen. Whether you use mipmapping or not,@*
you can still select between linear blending of the particular layer or nearest.
And if you do use mipmapping, you can choose to either select a single mipmap to
sample from, or you can sample the two adjacent mipmaps and linearly blend the
resulting values to get the final result.@*

The OpenGL minification settings for these are as follows:@*

    Param Setting            Lin within mip-level@*
    :nearest                 No@*
    :linear                  Yes@*
    :nearest-mipmap-nearest  No@*
    :linear-mipmap-nearest   Yes@*
    :nearest-mipmap-linear   No@*
    :linear-mipmap-linear    Yes@*

    Param Setting            Has mipmapping@*
    :nearest                 No@*
    :linear                  No@*
    :nearest-mipmap-nearest  Yes@*
    :linear-mipmap-nearest   Yes@*
    :nearest-mipmap-linear   Yes@*
    :linear-mipmap-linear    Yes@*

    Param Setting            Linear between mip-levels@*
    :nearest                 -@*
    :linear                  -@*
    :nearest-mipmap-nearest  No@*
    :linear-mipmap-nearest   No@*
    :nearest-mipmap-linear   Yes@*
    :linear-mipmap-linear    Yes@*

Remembering these combinations can be annoying so CEPL provides an additional
function called #'set-minify-filter see the docstring for details@*

examples:@*

    (setf (minify-filter tex-or-sampler) :linear)@*
    (setf (minify-filter tex-or-sampler) :nearest-mipmap-nearest)
    (setf-minify-filter tex-or-sampler :nearest :nearest)@*


**-- LOD --**@*

There is a pair of sampling parameters that affect the mipmap image selection:
:max-lod and :min-lod (floating-point values).@*

The way these work in mipmap selection is quite complicated; the specification
goes into full detail about it.@*

example:@*

    (setf (min-lod texture-or-sampler) value)@*
    (setf (max-lod texture-or-sampler) value)@*


LOD bias:@*
The mipmap image selection process can be adjusted coarsely by using the
:lod-bias sampling parameter. This bias will be added to the mipmap@*
LOD calculation (as well as added to the bias specified in one of the `texture`
accessing functions in GLSL), which is used to select the image. A positive bias
means that larger mipmaps will be selected even when the texture is viewed from
farther away. This can cause visual aliasing, but in small quantities it can
make textures a bit more sharp.@*

    (setf (lod-bias texture-or-sampler) value)@*


**-- Comparison --**@*

-WARNING-@*

This feature is currently unsupported until shadow samplers are more fully
tested in CEPL. Use at your own risk@*


Depth `texture`s (textures that have a depth component image format) can be
sampled in one of two ways. They can be sampled as a normal texture, which
simply retrieves the depth value (with filtering applied). This will return a
vec4 containing a single floating-point value.@*

They can also be fetched in comparison mode. This means that sampling from@*
the texture requires a value to compare to those pulled from the texture;@*
this value is called the reference value. The result of the comparison@*
depends on the comparison function set in the texture. If the function
succeeds, the resulting value is 1s0; if it fails, it is 0s0.@*

When linear filtering is used, the actual returned value is
implementation-defined. However, the value will be on the range 0  1 and@*
will be proportional to the number of neighboring texels that pass the
comparison based on the single given value.@*

If the texture is a normalized integer depth format, then the reference value
is clamped to 0  1, to match the values from the texture. Otherwise, the value
is not clamped.@*

Using this mode requires two special settings. First, the `sampler` used in GLSL
must be a shadow sampler. Second, the texture used in that sampler must have
activated depth comparison mode. Attempting to use a texture without comparison
with a shadow sampler, or vice-versa, will result in an error upon rendering.@*

To set the texture to comparison mode, set the :texture-compare-mode@*
texture parameter to :compare-ref-to-texture. The comparison function to@*
use when comparing the reference to the texture is set with the
:texture-compare-func texture parameter. Acceptable values are:@*

    :never (always fails)@*
    :always (always succeeds)@*
    :less@*
    :lequal@*
    :equal,@*
    :not-equal@*
    :gequal@*
    :greater@*

The comparison works as follows:@*

    (funcall operator ref texture)@*

Where ref is the reference value given to the texture lookup function by@*
GLSL, and texture is the value fetched from the texture. So :LESS will be@*
true if the reference value is strictly less than the value pulled from the
texture.
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@t{structure-object} (structure)
@item Direct methods
@itemize @bullet
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>FREE %CEPL<dot>TYPES<colon><colon>SAMPLER method, , @t{free}} (method)
@item
@t{print-object} (method)
@item
@ref{go to the %CEPL<dot>TYPES<colon><colon>CAN-BE-SHARED-BETWEEN-CONTEXTS-P %CEPL<dot>TYPES<colon><colon>SAMPLER method, , @t{can-be-shared-between-contexts-p}} (method)
@end itemize
@item Direct slots
@defvr {Slot} context-id
@slotsubindex{context-id}@c
@table @strong
@item Type
@t{%cepl.types:gl-id}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-CONTEXT-ID function, , @t{%sampler-context-id}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-CONTEXT-ID) function, , @t{(setf %sampler-context-id)}} (function)
@end table
@end defvr
@defvr {Slot} id-box
@slotsubindex{id-box}@c
@table @strong
@item Type
@t{%cepl.types:sampler-id-box}
@item Initform
@t{(%cepl.types:make-sampler-id-box)}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-ID-BOX function, , @t{%sampler-id-box}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-ID-BOX) function, , @t{(setf %sampler-id-box)}} (function)
@end table
@end defvr
@defvr {Slot} type
@slotsubindex{type}@c
@table @strong
@item Type
@t{symbol}
@item Initform
@t{(error \"\")}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-TYPE function, , @t{%sampler-type}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-TYPE) function, , @t{(setf %sampler-type)}} (function)
@end table
@end defvr
@defvr {Slot} texture
@slotsubindex{texture}@c
@table @strong
@item Type
@t{glsl-symbols.functions:texture}
@item Initform
@t{(error \"\")}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-TEXTURE function, , @t{%sampler-texture}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-TEXTURE) function, , @t{(setf %sampler-texture)}} (function)
@end table
@end defvr
@defvr {Slot} lod-bias
@slotsubindex{lod-bias}@c
@table @strong
@item Type
@t{single-float}
@item Initform
@t{0.0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-LOD-BIAS function, , @t{%sampler-lod-bias}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-LOD-BIAS) function, , @t{(setf %sampler-lod-bias)}} (function)
@end table
@end defvr
@defvr {Slot} min-lod
@slotsubindex{min-lod}@c
@table @strong
@item Type
@t{single-float}
@item Initform
@t{-1000.0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-MIN-LOD function, , @t{%sampler-min-lod}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-MIN-LOD) function, , @t{(setf %sampler-min-lod)}} (function)
@end table
@end defvr
@defvr {Slot} max-lod
@slotsubindex{max-lod}@c
@table @strong
@item Type
@t{single-float}
@item Initform
@t{1000.0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-MAX-LOD function, , @t{%sampler-max-lod}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-MAX-LOD) function, , @t{(setf %sampler-max-lod)}} (function)
@end table
@end defvr
@defvr {Slot} border-color
@slotsubindex{border-color}@c
@table @strong
@item Type
@t{glsl-symbols.types:vec4}
@item Initform
@t{(glsl-symbols.types:vec4 0.0 0.0 0.0 0.0)}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-BORDER-COLOR function, , @t{%sampler-border-color}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-BORDER-COLOR) function, , @t{(setf %sampler-border-color)}} (function)
@end table
@end defvr
@defvr {Slot} expects-mipmap
@slotsubindex{expects-mipmap}@c
@table @strong
@item Type
@t{boolean}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-EXPECTS-MIPMAP function, , @t{%sampler-expects-mipmap}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-EXPECTS-MIPMAP) function, , @t{(setf %sampler-expects-mipmap)}} (function)
@end table
@end defvr
@defvr {Slot} minify-filter
@slotsubindex{minify-filter}@c
@table @strong
@item Type
@t{keyword}
@item Initform
@t{:linear}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-MINIFY-FILTER function, , @t{%sampler-minify-filter}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-MINIFY-FILTER) function, , @t{(setf %sampler-minify-filter)}} (function)
@end table
@end defvr
@defvr {Slot} magnify-filter
@slotsubindex{magnify-filter}@c
@table @strong
@item Type
@t{keyword}
@item Initform
@t{:linear}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-MAGNIFY-FILTER function, , @t{%sampler-magnify-filter}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-MAGNIFY-FILTER) function, , @t{(setf %sampler-magnify-filter)}} (function)
@end table
@end defvr
@defvr {Slot} wrap
@slotsubindex{wrap}@c
@table @strong
@item Type
@t{vector}
@item Initform
@t{#(:repeat :repeat :repeat)}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-WRAP function, , @t{%sampler-wrap}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-WRAP) function, , @t{(setf %sampler-wrap)}} (function)
@end table
@end defvr
@defvr {Slot} expects-depth
@slotsubindex{expects-depth}@c
@table @strong
@item Type
@t{boolean}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-EXPECTS-DEPTH function, , @t{%sampler-expects-depth}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-EXPECTS-DEPTH) function, , @t{(setf %sampler-expects-depth)}} (function)
@end table
@end defvr
@defvr {Slot} compare
@slotsubindex{compare}@c
@table @strong
@item Type
@t{symbol}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-COMPARE function, , @t{%sampler-compare}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-COMPARE) function, , @t{(setf %sampler-compare)}} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {sampler-id-box} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>SAMPLER-ID-BOX structure}@c
@structuresubindex{sampler-id-box}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@t{structure-object} (structure)
@item Direct slots
@defvr {Slot} id
@slotsubindex{id}@c
@table @strong
@item Type
@t{(signed-byte 32)}
@item Initform
@t{-1}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>SAMPLER-ID-BOX-ID function, , @t{sampler-id-box-id}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF SAMPLER-ID-BOX-ID) function, , @t{(setf sampler-id-box-id)}} (function)
@end table
@end defvr
@defvr {Slot} shared-p
@slotsubindex{shared-p}@c
@table @strong
@item Type
@t{boolean}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>SAMPLER-ID-BOX-SHARED-P function, , @t{sampler-id-box-shared-p}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF SAMPLER-ID-BOX-SHARED-P) function, , @t{(setf sampler-id-box-shared-p)}} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {samples-passed-query} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>SAMPLES-PASSED-QUERY structure}@c
@structuresubindex{samples-passed-query}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@ref{go to the %CEPL<dot>TYPES<colon><colon>SCOPED-GPU-QUERY structure, , @t{scoped-gpu-query}} (structure)
@item Direct slots
@defvr {Slot} enum
@slotsubindex{enum}@c
@table @strong
@item Type
@t{(and (signed-byte 32) (signed-byte 32))}
@item Initform
@t{35092}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>SAMPLES-PASSED-QUERY-ENUM function, , @t{samples-passed-query-enum}} (function)
@item Writers
@t{(setf samples-passed-query-enum)} (function)
@end table
@end defvr
@defvr {Slot} cache-id
@slotsubindex{cache-id}@c
@table @strong
@item Type
@t{(and (integer 0 7) (integer 0 7))}
@item Initform
@t{1}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>SAMPLES-PASSED-QUERY-CACHE-ID function, , @t{samples-passed-query-cache-id}} (function)
@item Writers
@t{(setf samples-passed-query-cache-id)} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {scoped-gpu-query} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>SCOPED-GPU-QUERY structure}@c
@structuresubindex{scoped-gpu-query}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-QUERY structure, , @t{gpu-query}} (structure)
@item Direct subclasses
@itemize @bullet
@item
@ref{go to the %CEPL<dot>TYPES<colon><colon>SAMPLES-PASSED-QUERY structure, , @t{samples-passed-query}} (structure)
@item
@ref{go to the %CEPL<dot>TYPES<colon><colon>ANY-SAMPLES-PASSED-QUERY structure, , @t{any-samples-passed-query}} (structure)
@item
@ref{go to the %CEPL<dot>TYPES<colon><colon>ANY-SAMPLES-PASSED-CONSERVATIVE-QUERY structure, , @t{any-samples-passed-conservative-query}} (structure)
@item
@ref{go to the %CEPL<dot>TYPES<colon><colon>PRIMITIVES-GENERATED-QUERY structure, , @t{primitives-generated-query}} (structure)
@item
@ref{go to the %CEPL<dot>TYPES<colon><colon>TRANSFORM-FEEDBACK-PRIMITIVES-WRITTEN-QUERY structure, , @t{transform-feedback-primitives-written-query}} (structure)
@item
@ref{go to the %CEPL<dot>TYPES<colon><colon>TIME-ELAPSED-QUERY structure, , @t{time-elapsed-query}} (structure)
@end itemize
@item Direct slots
@defvr {Slot} active-p
@slotsubindex{active-p}@c
@table @strong
@item Type
@t{boolean}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>SCOPED-GPU-QUERY-ACTIVE-P function, , @t{scoped-gpu-query-active-p}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF SCOPED-GPU-QUERY-ACTIVE-P) function, , @t{(setf scoped-gpu-query-active-p)}} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {ssbo} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>SSBO structure}@c
@structuresubindex{ssbo}@c

`SSBO` is a structure that abstracts an OpenGL Shader Storage Buffer Object

An SSBO is chunk of data stored in a `gpu-buffer`, which can be used in shader
pipelines. They are very similar to UBOs and are used in pretty much the same
way. The big differences between them are:@*


- SSBOs can be much larger. The OpenGL spec guarantees that UBOs can@*
  be up to 16KB in size (implementations can allow them to be@*
  bigger). The spec guarantees that SSBOs can be up to 128MB. Most
  implementations will let you allocate a size up to the limit of GPU
  memory.@*

- SSBOs are writable (even atomically) whereas UBOs are not.@*
  Be aware that SSBOs reads and writes use incoherent memory accesses,@*
  so they need the appropriate barriers.@*

- SSBO access, all things being equal, will likely be slower than UBO
  access. SSBOs generally are accesses like buffer textures, while UBO
  data is accessed through internal shader-accessible memory reads. At@*
  the very least, UBOs will be no slower than SSBOs.@*

- *Not yet supported in CEPL*@*
  SSBOs can have variable storage, up to whatever buffer range was@*
  bound for that particular buffer; UBOs must have a specific, fixed
  storage size. This means that you can have an array of arbitrary@*
  length in an SSBO (at the end, rather). The actual size of the@*
  array, based on the range of the buffer bound, can be queried at@*
  runtime in the shader using the length function on the unbounded@*
  array variable.
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@t{structure-object} (structure)
@item Direct methods
@itemize @bullet
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>FREE %CEPL<dot>TYPES<colon><colon>SSBO method, , @t{free}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G %CEPL<dot>TYPES<colon><colon>SSBO (eql KEYWORD<colon><colon>LISP) method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G COMMON-LISP<colon><colon>ARRAY %CEPL<dot>TYPES<colon><colon>SSBO method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G COMMON-LISP<colon><colon>LIST %CEPL<dot>TYPES<colon><colon>SSBO method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G %CEPL<dot>TYPES<colon><colon>C-ARRAY %CEPL<dot>TYPES<colon><colon>SSBO method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PULL-G %CEPL<dot>TYPES<colon><colon>SSBO method, , @t{pull-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PUSH-G COMMON-LISP<colon><colon>ARRAY %CEPL<dot>TYPES<colon><colon>SSBO method, , @t{push-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PUSH-G COMMON-LISP<colon><colon>LIST %CEPL<dot>TYPES<colon><colon>SSBO method, , @t{push-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PUSH-G %CEPL<dot>TYPES<colon><colon>C-ARRAY %CEPL<dot>TYPES<colon><colon>SSBO method, , @t{push-g}} (method)
@item
@t{print-object} (method)
@end itemize
@item Direct slots
@defvr {Slot} id
@slotsubindex{id}@c
@table @strong
@item Type
@t{%cepl.types:gl-id}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>SSBO-ID function, , @t{ssbo-id}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF SSBO-ID) function, , @t{(setf ssbo-id)}} (function)
@end table
@end defvr
@defvr {Slot} data
@slotsubindex{data}@c
@table @strong
@item Type
@t{%cepl.types:gpu-array-bb}
@item Initform
@t{(error \"gpu-array must be provided when making ssbo\")}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>SSBO-DATA function, , @t{ssbo-data}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF SSBO-DATA) function, , @t{(setf ssbo-data)}} (function)
@end table
@end defvr
@defvr {Slot} index
@slotsubindex{index}@c
@table @strong
@item Type
@t{%cepl.types:c-array-index}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>SSBO-INDEX function, , @t{ssbo-index}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF SSBO-INDEX) function, , @t{(setf ssbo-index)}} (function)
@end table
@end defvr
@defvr {Slot} owns-gpu-array
@slotsubindex{owns-gpu-array}@c
@table @strong
@item Type
@t{boolean}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>SSBO-OWNS-GPU-ARRAY function, , @t{ssbo-owns-gpu-array}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF SSBO-OWNS-GPU-ARRAY) function, , @t{(setf ssbo-owns-gpu-array)}} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {stencil-params} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>STENCIL-PARAMS structure}@c
@structuresubindex{stencil-params}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@t{structure-object} (structure)
@item Direct methods
@t{print-object} (method)
@item Direct slots
@defvr {Slot} test
@slotsubindex{test}@c
@table @strong
@item Type
@t{(signed-byte 32)}
@item Initform
@t{512}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%STENCIL-PARAMS-TEST function, , @t{%stencil-params-test}} (function)
@item Writers
@t{(setf %stencil-params-test)} (function)
@end table
@end defvr
@defvr {Slot} value
@slotsubindex{value}@c
@table @strong
@item Type
@t{%cepl.types:stencil-mask}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%STENCIL-PARAMS-VALUE function, , @t{%stencil-params-value}} (function)
@item Writers
@t{(setf %stencil-params-value)} (function)
@end table
@end defvr
@defvr {Slot} mask
@slotsubindex{mask}@c
@table @strong
@item Type
@t{%cepl.types:stencil-mask}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%STENCIL-PARAMS-MASK function, , @t{%stencil-params-mask}} (function)
@item Writers
@t{(setf %stencil-params-mask)} (function)
@end table
@end defvr
@defvr {Slot} on-stencil-test-fail
@slotsubindex{on-stencil-test-fail}@c
@table @strong
@item Type
@t{(signed-byte 32)}
@item Initform
@t{7680}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%STENCIL-PARAMS-ON-STENCIL-TEST-FAIL function, , @t{%stencil-params-on-stencil-test-fail}} (function)
@item Writers
@t{(setf %stencil-params-on-stencil-test-fail)} (function)
@end table
@end defvr
@defvr {Slot} on-stencil-pass-depth-test-fail
@slotsubindex{on-stencil-pass-depth-test-fail}@c
@table @strong
@item Type
@t{(signed-byte 32)}
@item Initform
@t{7680}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%STENCIL-PARAMS-ON-STENCIL-PASS-DEPTH-TEST-FAIL function, , @t{%stencil-params-on-stencil-pass-depth-test-fail}} (function)
@item Writers
@t{(setf %stencil-params-on-stencil-pass-depth-test-fail)} (function)
@end table
@end defvr
@defvr {Slot} on-stencil-pass-depth-test-pass
@slotsubindex{on-stencil-pass-depth-test-pass}@c
@table @strong
@item Type
@t{(signed-byte 32)}
@item Initform
@t{7680}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%STENCIL-PARAMS-ON-STENCIL-PASS-DEPTH-TEST-PASS function, , @t{%stencil-params-on-stencil-pass-depth-test-pass}} (function)
@item Writers
@t{(setf %stencil-params-on-stencil-pass-depth-test-pass)} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {time-elapsed-query} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TIME-ELAPSED-QUERY structure}@c
@structuresubindex{time-elapsed-query}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@ref{go to the %CEPL<dot>TYPES<colon><colon>SCOPED-GPU-QUERY structure, , @t{scoped-gpu-query}} (structure)
@item Direct slots
@defvr {Slot} enum
@slotsubindex{enum}@c
@table @strong
@item Type
@t{(and (signed-byte 32) (signed-byte 32))}
@item Initform
@t{35007}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>TIME-ELAPSED-QUERY-ENUM function, , @t{time-elapsed-query-enum}} (function)
@item Writers
@t{(setf time-elapsed-query-enum)} (function)
@end table
@end defvr
@defvr {Slot} cache-id
@slotsubindex{cache-id}@c
@table @strong
@item Type
@t{(and (integer 0 7) (integer 0 7))}
@item Initform
@t{6}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>TIME-ELAPSED-QUERY-CACHE-ID function, , @t{time-elapsed-query-cache-id}} (function)
@item Writers
@t{(setf time-elapsed-query-cache-id)} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {timestamp-query} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TIMESTAMP-QUERY structure}@c
@structuresubindex{timestamp-query}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@ref{go to the %CEPL<dot>TYPES<colon><colon>GPU-QUERY structure, , @t{gpu-query}} (structure)
@item Direct slots
@defvr {Slot} enum
@slotsubindex{enum}@c
@table @strong
@item Type
@t{(and (signed-byte 32) (signed-byte 32))}
@item Initform
@t{36392}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>TIMESTAMP-QUERY-ENUM function, , @t{timestamp-query-enum}} (function)
@item Writers
@t{(setf timestamp-query-enum)} (function)
@end table
@end defvr
@defvr {Slot} cache-id
@slotsubindex{cache-id}@c
@table @strong
@item Type
@t{(and (integer 0 7) (integer 0 7))}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>TIMESTAMP-QUERY-CACHE-ID function, , @t{timestamp-query-cache-id}} (function)
@item Writers
@t{(setf timestamp-query-cache-id)} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {transform-feedback-primitives-written-query} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TRANSFORM-FEEDBACK-PRIMITIVES-WRITTEN-QUERY structure}@c
@structuresubindex{transform-feedback-primitives-written-query}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@ref{go to the %CEPL<dot>TYPES<colon><colon>SCOPED-GPU-QUERY structure, , @t{scoped-gpu-query}} (structure)
@item Direct slots
@defvr {Slot} enum
@slotsubindex{enum}@c
@table @strong
@item Type
@t{(and (signed-byte 32) (signed-byte 32))}
@item Initform
@t{35976}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>TRANSFORM-FEEDBACK-PRIMITIVES-WRITTEN-QUERY-ENUM function, , @t{transform-feedback-primitives-written-query-enum}} (function)
@item Writers
@t{(setf transform-feedback-primitives-written-query-enum)} (function)
@end table
@end defvr
@defvr {Slot} cache-id
@slotsubindex{cache-id}@c
@table @strong
@item Type
@t{(and (integer 0 7) (integer 0 7))}
@item Initform
@t{5}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>TRANSFORM-FEEDBACK-PRIMITIVES-WRITTEN-QUERY-CACHE-ID function, , @t{transform-feedback-primitives-written-query-cache-id}} (function)
@item Writers
@t{(setf transform-feedback-primitives-written-query-cache-id)} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {transform-feedback-stream} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TRANSFORM-FEEDBACK-STREAM structure}@c
@structuresubindex{transform-feedback-stream}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@t{structure-object} (structure)
@item Direct methods
@itemize @bullet
@item
@t{print-object} (method)
@item
@ref{go to the %CEPL<dot>TYPES<colon><colon>CAN-BE-SHARED-BETWEEN-CONTEXTS-P %CEPL<dot>TYPES<colon><colon>TRANSFORM-FEEDBACK-STREAM method, , @t{can-be-shared-between-contexts-p}} (method)
@end itemize
@item Direct slots
@defvr {Slot} arrays
@slotsubindex{arrays}@c
@table @strong
@item Type
@t{(or null (array %cepl.types:gpu-array-bb (*)))}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%TFS-ARRAYS function, , @t{%tfs-arrays}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %TFS-ARRAYS) function, , @t{(setf %tfs-arrays)}} (function)
@end table
@end defvr
@defvr {Slot} pending-arrays
@slotsubindex{pending-arrays}@c
@table @strong
@item Type
@t{(or null (array %cepl.types:gpu-array-bb (*)))}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%TFS-PENDING-ARRAYS function, , @t{%tfs-pending-arrays}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %TFS-PENDING-ARRAYS) function, , @t{(setf %tfs-pending-arrays)}} (function)
@end table
@end defvr
@defvr {Slot} bound
@slotsubindex{bound}@c
@table @strong
@item Type
@t{boolean}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%TFS-BOUND function, , @t{%tfs-bound}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %TFS-BOUND) function, , @t{(setf %tfs-bound)}} (function)
@end table
@end defvr
@defvr {Slot} current-prog-id
@slotsubindex{current-prog-id}@c
@table @strong
@item Type
@t{%cepl.types:gl-id}
@item Initform
@t{%cepl.types:+unknown-gl-id+}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%TFS-CURRENT-PROG-ID function, , @t{%tfs-current-prog-id}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %TFS-CURRENT-PROG-ID) function, , @t{(setf %tfs-current-prog-id)}} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {ubo} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>UBO structure}@c
@structuresubindex{ubo}@c

A `UBO` is a structure that abstracts an OpenGL Uniform Buffer Object@*

A Ubo is chunk of data stored in a `gpu-buffer`, which can be used as a uniform
in shader pipelines.@*

The advantage of using a UBO over just passing the data as regular unforms is
that UBOs can be used to share uniforms between different programs, as well as
quickly change between sets of uniforms for the same pipeline.@*

Let's expand on that a little:@*

Switching between uniform buffer bindings is typically faster than switching
dozens of uniforms in a pipeline.@*

Also, uniform buffer objects can typically store more data than non-buffered
uniforms. So they can be used to store and access larger blocks of data than
unbuffered uniform values.@*

Lastly, they can be used to share information between different programs.@*
So modifying a single buffer can effectively allow uniforms in multiple programs
to be updated.
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@t{structure-object} (structure)
@item Direct methods
@itemize @bullet
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>FREE %CEPL<dot>TYPES<colon><colon>UBO method, , @t{free}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G %CEPL<dot>TYPES<colon><colon>UBO (eql KEYWORD<colon><colon>LISP) method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G COMMON-LISP<colon><colon>ARRAY %CEPL<dot>TYPES<colon><colon>UBO method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G COMMON-LISP<colon><colon>LIST %CEPL<dot>TYPES<colon><colon>UBO method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>COPY-G %CEPL<dot>TYPES<colon><colon>C-ARRAY %CEPL<dot>TYPES<colon><colon>UBO method, , @t{copy-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PULL-G %CEPL<dot>TYPES<colon><colon>UBO method, , @t{pull-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PUSH-G COMMON-LISP<colon><colon>ARRAY %CEPL<dot>TYPES<colon><colon>UBO method, , @t{push-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PUSH-G COMMON-LISP<colon><colon>LIST %CEPL<dot>TYPES<colon><colon>UBO method, , @t{push-g}} (method)
@item
@ref{go to the CEPL<dot>MEMORY<colon><colon>PUSH-G %CEPL<dot>TYPES<colon><colon>C-ARRAY %CEPL<dot>TYPES<colon><colon>UBO method, , @t{push-g}} (method)
@item
@t{print-object} (method)
@end itemize
@item Direct slots
@defvr {Slot} id
@slotsubindex{id}@c
@table @strong
@item Type
@t{%cepl.types:gl-id}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>UBO-ID function, , @t{ubo-id}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF UBO-ID) function, , @t{(setf ubo-id)}} (function)
@end table
@end defvr
@defvr {Slot} data
@slotsubindex{data}@c
@table @strong
@item Type
@t{%cepl.types:gpu-array-bb}
@item Initform
@t{(error \"gpu-array must be provided when making ubo\")}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>UBO-DATA function, , @t{ubo-data}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF UBO-DATA) function, , @t{(setf ubo-data)}} (function)
@end table
@end defvr
@defvr {Slot} index
@slotsubindex{index}@c
@table @strong
@item Type
@t{%cepl.types:c-array-index}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>UBO-INDEX function, , @t{ubo-index}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF UBO-INDEX) function, , @t{(setf ubo-index)}} (function)
@end table
@end defvr
@defvr {Slot} owns-gpu-array
@slotsubindex{owns-gpu-array}@c
@table @strong
@item Type
@t{boolean}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>UBO-OWNS-GPU-ARRAY function, , @t{ubo-owns-gpu-array}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF UBO-OWNS-GPU-ARRAY) function, , @t{(setf ubo-owns-gpu-array)}} (function)
@end table
@end defvr
@end table
@end deftp
@deftp {Structure} {viewport} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>VIEWPORT structure}@c
@structuresubindex{viewport}@c

`Viewport` is a structure that represents a retangular region of the surface
that CEPL can draw into.@*

There is always a viewport current when rendering. If one of your own is not
current then CEPL will use its default viewport, the resolution of which is the
same as that of the surface when it was created.@*

The default viewport can be modified, so feel free to update the resolution if
the surface size changes.
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@item Direct superclasses
@t{structure-object} (structure)
@item Direct methods
@itemize @bullet
@item
@t{origin} (method)
@item
@ref{go to the CEPL<dot>MEASUREMENTS<colon><colon>ORIGIN %CEPL<dot>TYPES<colon><colon>VIEWPORT method, , @t{origin}} (method)
@item
@t{resolution} (method)
@item
@ref{go to the CEPL<dot>MEASUREMENTS<colon><colon>RESOLUTION %CEPL<dot>TYPES<colon><colon>VIEWPORT method, , @t{resolution}} (method)
@item
@t{dimensions} (method)
@item
@ref{go to the CEPL<dot>MEASUREMENTS<colon><colon>DIMENSIONS %CEPL<dot>TYPES<colon><colon>VIEWPORT method, , @t{dimensions}} (method)
@end itemize
@item Direct slots
@defvr {Slot} resolution-x
@slotsubindex{resolution-x}@c
@table @strong
@item Type
@t{(unsigned-byte 16)}
@item Initform
@t{320}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%VIEWPORT-RESOLUTION-X function, , @t{%viewport-resolution-x}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %VIEWPORT-RESOLUTION-X) function, , @t{(setf %viewport-resolution-x)}} (function)
@end table
@end defvr
@defvr {Slot} resolution-y
@slotsubindex{resolution-y}@c
@table @strong
@item Type
@t{(unsigned-byte 16)}
@item Initform
@t{240}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%VIEWPORT-RESOLUTION-Y function, , @t{%viewport-resolution-y}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %VIEWPORT-RESOLUTION-Y) function, , @t{(setf %viewport-resolution-y)}} (function)
@end table
@end defvr
@defvr {Slot} origin-x
@slotsubindex{origin-x}@c
@table @strong
@item Type
@t{(unsigned-byte 16)}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%VIEWPORT-ORIGIN-X function, , @t{%viewport-origin-x}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %VIEWPORT-ORIGIN-X) function, , @t{(setf %viewport-origin-x)}} (function)
@end table
@end defvr
@defvr {Slot} origin-y
@slotsubindex{origin-y}@c
@table @strong
@item Type
@t{(unsigned-byte 16)}
@item Initform
@t{0}
@item Readers
@ref{go to the %CEPL<dot>TYPES<colon><colon>%VIEWPORT-ORIGIN-Y function, , @t{%viewport-origin-y}} (function)
@item Writers
@ref{go to the %CEPL<dot>TYPES<colon><colon>(SETF %VIEWPORT-ORIGIN-Y) function, , @t{(setf %viewport-origin-y)}} (function)
@end table
@end defvr
@end table
@end deftp
" :AFTER-MENU-CONTENTS NIL) :PREVIOUS #11# :UP #2# :CHILDREN NIL :BEFORE-MENU-CONTENTS "@deftp {Condition} {adjust-gpu-array-mismatched-dimensions} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>ADJUST-GPU-ARRAY-MISMATCHED-DIMENSIONS condition}@c
@conditionsubindex{adjust-gpu-array-mismatched-dimensions}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} current-dim
@slotsubindex{current-dim}@c
@table @strong
@item Initargs
@t{:current-dim}
@end table
@end defvr
@defvr {Slot} new-dim
@slotsubindex{new-dim}@c
@table @strong
@item Initargs
@t{:new-dim}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {adjust-gpu-array-shared-buffer} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>ADJUST-GPU-ARRAY-SHARED-BUFFER condition}@c
@conditionsubindex{adjust-gpu-array-shared-buffer}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} array
@slotsubindex{array}@c
@table @strong
@item Initargs
@t{:array}
@end table
@end defvr
@defvr {Slot} shared-count
@slotsubindex{shared-count}@c
@table @strong
@item Initargs
@t{:shared-count}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {another-query-is-active} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>ANOTHER-QUERY-IS-ACTIVE condition}@c
@conditionsubindex{another-query-is-active}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} query
@slotsubindex{query}@c
@table @strong
@item Initargs
@t{:query}
@end table
@end defvr
@defvr {Slot} current
@slotsubindex{current}@c
@table @strong
@item Initargs
@t{:current}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {attachment-viewport-empty-fbo} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>ATTACHMENT-VIEWPORT-EMPTY-FBO condition}@c
@conditionsubindex{attachment-viewport-empty-fbo}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} fbo
@slotsubindex{fbo}@c
@table @strong
@item Initargs
@t{:fbo}
@end table
@end defvr
@defvr {Slot} attachment
@slotsubindex{attachment}@c
@table @strong
@item Initargs
@t{:attachment}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {attachments-with-different-sizes} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>ATTACHMENTS-WITH-DIFFERENT-SIZES condition}@c
@conditionsubindex{attachments-with-different-sizes}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} args
@slotsubindex{args}@c
@table @strong
@item Initargs
@t{:args}
@end table
@end defvr
@defvr {Slot} sizes
@slotsubindex{sizes}@c
@table @strong
@item Initargs
@t{:sizes}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {bad-c-array-element} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>BAD-C-ARRAY-ELEMENT condition}@c
@conditionsubindex{bad-c-array-element}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} incorrect-type
@slotsubindex{incorrect-type}@c
@table @strong
@item Initargs
@t{:incorrect-type}
@end table
@end defvr
@defvr {Slot} correct-type
@slotsubindex{correct-type}@c
@table @strong
@item Initargs
@t{:correct-type}
@end table
@end defvr
@defvr {Slot} elem
@slotsubindex{elem}@c
@table @strong
@item Initargs
@t{:elem}
@end table
@end defvr
@defvr {Slot} initial-contents
@slotsubindex{initial-contents}@c
@table @strong
@item Initargs
@t{:initial-contents}
@end table
@end defvr
@defvr {Slot} extra-info-string
@slotsubindex{extra-info-string}@c
@table @strong
@item Initargs
@t{:extra-info-string}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {bad-type-for-buffer-stream-data} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>BAD-TYPE-FOR-BUFFER-STREAM-DATA condition}@c
@conditionsubindex{bad-type-for-buffer-stream-data}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} type
@slotsubindex{type}@c
@table @strong
@item Initargs
@t{:type}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {bake-invalid-pipeling-arg} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>BAKE-INVALID-PIPELING-ARG condition}@c
@conditionsubindex{bake-invalid-pipeling-arg}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} invalid-arg
@slotsubindex{invalid-arg}@c
@table @strong
@item Initargs
@t{:invalid-arg}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {bake-invalid-uniform-name} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>BAKE-INVALID-UNIFORM-NAME condition}@c
@conditionsubindex{bake-invalid-uniform-name}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} proposed
@slotsubindex{proposed}@c
@table @strong
@item Initargs
@t{:proposed}
@end table
@end defvr
@defvr {Slot} invalid
@slotsubindex{invalid}@c
@table @strong
@item Initargs
@t{:invalid}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {bake-uniform-invalid-values} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>BAKE-UNIFORM-INVALID-VALUES condition}@c
@conditionsubindex{bake-uniform-invalid-values}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} proposed
@slotsubindex{proposed}@c
@table @strong
@item Initargs
@t{:proposed}
@end table
@end defvr
@defvr {Slot} invalid
@slotsubindex{invalid}@c
@table @strong
@item Initargs
@t{:invalid}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {buffer-backed-texture-establish-image-format} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>BUFFER-BACKED-TEXTURE-ESTABLISH-IMAGE-FORMAT condition}@c
@conditionsubindex{buffer-backed-texture-establish-image-format}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} type-name
@slotsubindex{type-name}@c
@table @strong
@item Initargs
@t{:type-name}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {buffer-backed-texture-invalid-args} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>BUFFER-BACKED-TEXTURE-INVALID-ARGS condition}@c
@conditionsubindex{buffer-backed-texture-invalid-args}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@end table
@end deftp
@deftp {Condition} {buffer-backed-texture-invalid-image-format} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>BUFFER-BACKED-TEXTURE-INVALID-IMAGE-FORMAT condition}@c
@conditionsubindex{buffer-backed-texture-invalid-image-format}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} type-name
@slotsubindex{type-name}@c
@table @strong
@item Initargs
@t{:type-name}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {buffer-backed-texture-invalid-samplers} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>BUFFER-BACKED-TEXTURE-INVALID-SAMPLERS condition}@c
@conditionsubindex{buffer-backed-texture-invalid-samplers}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@end table
@end deftp
@deftp {Condition} {buffer-stream-has-invalid-primitive-for-stream} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>BUFFER-STREAM-HAS-INVALID-PRIMITIVE-FOR-STREAM condition}@c
@conditionsubindex{buffer-stream-has-invalid-primitive-for-stream}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} name
@slotsubindex{name}@c
@table @strong
@item Initargs
@t{:name}
@end table
@end defvr
@defvr {Slot} pline-prim
@slotsubindex{pline-prim}@c
@table @strong
@item Initargs
@t{:pline-prim}
@end table
@end defvr
@defvr {Slot} stream-prim
@slotsubindex{stream-prim}@c
@table @strong
@item Initargs
@t{:stream-prim}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {c-array-total-size-type-error} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>C-ARRAY-TOTAL-SIZE-TYPE-ERROR condition}@c
@conditionsubindex{c-array-total-size-type-error}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} size
@slotsubindex{size}@c
@table @strong
@item Initargs
@t{:size}
@end table
@end defvr
@defvr {Slot} required-type
@slotsubindex{required-type}@c
@table @strong
@item Initargs
@t{:required-type}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {cannot-extract-stream-length-from-layouts} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>CANNOT-EXTRACT-STREAM-LENGTH-FROM-LAYOUTS condition}@c
@conditionsubindex{cannot-extract-stream-length-from-layouts}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} layouts
@slotsubindex{layouts}@c
@table @strong
@item Initargs
@t{:layouts}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {cannot-keep-data-when-uploading} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>CANNOT-KEEP-DATA-WHEN-UPLOADING condition}@c
@conditionsubindex{cannot-keep-data-when-uploading}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} data
@slotsubindex{data}@c
@table @strong
@item Initargs
@t{:data}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {compile-g-missing-requested-feature} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>COMPILE-G-MISSING-REQUESTED-FEATURE condition}@c
@conditionsubindex{compile-g-missing-requested-feature}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} form
@slotsubindex{form}@c
@table @strong
@item Initargs
@t{:form}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {compute-pipeline-must-be-single-stage} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>COMPUTE-PIPELINE-MUST-BE-SINGLE-STAGE condition}@c
@conditionsubindex{compute-pipeline-must-be-single-stage}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} name
@slotsubindex{name}@c
@table @strong
@item Initargs
@t{:name}
@end table
@end defvr
@defvr {Slot} stages
@slotsubindex{stages}@c
@table @strong
@item Initargs
@t{:stages}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {could-not-layout-type} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>COULD-NOT-LAYOUT-TYPE condition}@c
@conditionsubindex{could-not-layout-type}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} type
@slotsubindex{type}@c
@table @strong
@item Initargs
@t{:type}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {delete-multi-func-error} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>DELETE-MULTI-FUNC-ERROR condition}@c
@conditionsubindex{delete-multi-func-error}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} name
@slotsubindex{name}@c
@table @strong
@item Initargs
@t{:name}
@end table
@end defvr
@defvr {Slot} choices
@slotsubindex{choices}@c
@table @strong
@item Initargs
@t{:choices}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {dispatch-called-outside-of-map-g} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>DISPATCH-CALLED-OUTSIDE-OF-MAP-G condition}@c
@conditionsubindex{dispatch-called-outside-of-map-g}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} name
@slotsubindex{name}@c
@table @strong
@item Initargs
@t{:name}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {dont-define-space-to-self} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>DONT-DEFINE-SPACE-TO-SELF condition}@c
@conditionsubindex{dont-define-space-to-self}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} space
@slotsubindex{space}@c
@table @strong
@item Initargs
@t{:space}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {failed-to-test-compile-gpu-func} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>FAILED-TO-TEST-COMPILE-GPU-FUNC condition}@c
@conditionsubindex{failed-to-test-compile-gpu-func}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{warning} (condition)
@item Direct slots
@defvr {Slot} gfunc-name
@slotsubindex{gfunc-name}@c
@table @strong
@item Initargs
@t{:gfunc-name}
@end table
@end defvr
@defvr {Slot} missing-func-names
@slotsubindex{missing-func-names}@c
@table @strong
@item Initargs
@t{:missing-func-names}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {fbo-binding-missing} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>FBO-BINDING-MISSING condition}@c
@conditionsubindex{fbo-binding-missing}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} kind
@slotsubindex{kind}@c
@table @strong
@item Initargs
@t{:kind}
@end table
@end defvr
@defvr {Slot} current-surface
@slotsubindex{current-surface}@c
@table @strong
@item Initargs
@t{:current-surface}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {fbo-target-not-valid-constant} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>FBO-TARGET-NOT-VALID-CONSTANT condition}@c
@conditionsubindex{fbo-target-not-valid-constant}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} target
@slotsubindex{target}@c
@table @strong
@item Initargs
@t{:target}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {func-keyed-pipeline-not-found} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>FUNC-KEYED-PIPELINE-NOT-FOUND condition}@c
@conditionsubindex{func-keyed-pipeline-not-found}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{warning} (condition)
@item Direct slots
@defvr {Slot} callee
@slotsubindex{callee}@c
@table @strong
@item Initargs
@t{:callee}
@end table
@end defvr
@defvr {Slot} func
@slotsubindex{func}@c
@table @strong
@item Initargs
@t{:func}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {functions-in-non-uniform-args} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>FUNCTIONS-IN-NON-UNIFORM-ARGS condition}@c
@conditionsubindex{functions-in-non-uniform-args}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} name
@slotsubindex{name}@c
@table @strong
@item Initargs
@t{:name}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {gfun-invalid-arg-format} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>GFUN-INVALID-ARG-FORMAT condition}@c
@conditionsubindex{gfun-invalid-arg-format}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} gfun-name
@slotsubindex{gfun-name}@c
@table @strong
@item Initargs
@t{:gfun-name}
@end table
@end defvr
@defvr {Slot} invalid-pair
@slotsubindex{invalid-pair}@c
@table @strong
@item Initargs
@t{:invalid-pair}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {gl-context-initialized-from-incorrect-thread} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>GL-CONTEXT-INITIALIZED-FROM-INCORRECT-THREAD condition}@c
@conditionsubindex{gl-context-initialized-from-incorrect-thread}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} ctx-thread
@slotsubindex{ctx-thread}@c
@table @strong
@item Initargs
@t{:ctx-thread}
@end table
@end defvr
@defvr {Slot} init-thread
@slotsubindex{init-thread}@c
@table @strong
@item Initargs
@t{:init-thread}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {glsl-geom-stage-no-out-layout} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>GLSL-GEOM-STAGE-NO-OUT-LAYOUT condition}@c
@conditionsubindex{glsl-geom-stage-no-out-layout}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} glsl-body
@slotsubindex{glsl-body}@c
@table @strong
@item Initargs
@t{:glsl-body}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {glsl-version-conflict} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>GLSL-VERSION-CONFLICT condition}@c
@conditionsubindex{glsl-version-conflict}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} issue
@slotsubindex{issue}@c
@table @strong
@item Initargs
@t{:issue}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {glsl-version-conflict-in-gpu-func} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>GLSL-VERSION-CONFLICT-IN-GPU-FUNC condition}@c
@conditionsubindex{glsl-version-conflict-in-gpu-func}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} name
@slotsubindex{name}@c
@table @strong
@item Initargs
@t{:name}
@end table
@end defvr
@defvr {Slot} context
@slotsubindex{context}@c
@table @strong
@item Initargs
@t{:context}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {gpu-array-from-buffer-missing-args} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>GPU-ARRAY-FROM-BUFFER-MISSING-ARGS condition}@c
@conditionsubindex{gpu-array-from-buffer-missing-args}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} element-type
@slotsubindex{element-type}@c
@table @strong
@item Initargs
@t{:element-type}
@end table
@end defvr
@defvr {Slot} dimensions
@slotsubindex{dimensions}@c
@table @strong
@item Initargs
@t{:dimensions}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {gpu-array-from-id-missing-args} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>GPU-ARRAY-FROM-ID-MISSING-ARGS condition}@c
@conditionsubindex{gpu-array-from-id-missing-args}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} element-type
@slotsubindex{element-type}@c
@table @strong
@item Initargs
@t{:element-type}
@end table
@end defvr
@defvr {Slot} dimensions
@slotsubindex{dimensions}@c
@table @strong
@item Initargs
@t{:dimensions}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {gpu-func-spec-not-found} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>GPU-FUNC-SPEC-NOT-FOUND condition}@c
@conditionsubindex{gpu-func-spec-not-found}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} name
@slotsubindex{name}@c
@table @strong
@item Initargs
@t{:name}
@end table
@end defvr
@defvr {Slot} types
@slotsubindex{types}@c
@table @strong
@item Initargs
@t{:types}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {gpu-func-symbol-name} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>GPU-FUNC-SYMBOL-NAME condition}@c
@conditionsubindex{gpu-func-symbol-name}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} name
@slotsubindex{name}@c
@table @strong
@item Initargs
@t{:name}
@end table
@end defvr
@defvr {Slot} alternatives
@slotsubindex{alternatives}@c
@table @strong
@item Initargs
@t{:alternatives}
@end table
@end defvr
@defvr {Slot} env
@slotsubindex{env}@c
@table @strong
@item Initargs
@t{:env}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {image-format->lisp-type-failed} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>IMAGE-FORMAT->LISP-TYPE-FAILED condition}@c
@conditionsubindex{image-format->lisp-type-failed}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} type-name
@slotsubindex{type-name}@c
@table @strong
@item Initargs
@t{:type-name}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {image-format->pixel-format-failed} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>IMAGE-FORMAT->PIXEL-FORMAT-FAILED condition}@c
@conditionsubindex{image-format->pixel-format-failed}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} type-name
@slotsubindex{type-name}@c
@table @strong
@item Initargs
@t{:type-name}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {inconsistent-struct-layout} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>INCONSISTENT-STRUCT-LAYOUT condition}@c
@conditionsubindex{inconsistent-struct-layout}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} name
@slotsubindex{name}@c
@table @strong
@item Initargs
@t{:name}
@end table
@end defvr
@defvr {Slot} target
@slotsubindex{target}@c
@table @strong
@item Initargs
@t{:target}
@end table
@end defvr
@defvr {Slot} slots
@slotsubindex{slots}@c
@table @strong
@item Initargs
@t{:slots}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {incorrect-number-of-arrays-in-tfs} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>INCORRECT-NUMBER-OF-ARRAYS-IN-TFS condition}@c
@conditionsubindex{incorrect-number-of-arrays-in-tfs}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} tfs
@slotsubindex{tfs}@c
@table @strong
@item Initargs
@t{:tfs}
@end table
@end defvr
@defvr {Slot} tfs-count
@slotsubindex{tfs-count}@c
@table @strong
@item Initargs
@t{:tfs-count}
@end table
@end defvr
@defvr {Slot} count
@slotsubindex{count}@c
@table @strong
@item Initargs
@t{:count}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {index-layout-with-unknown-length} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>INDEX-LAYOUT-WITH-UNKNOWN-LENGTH condition}@c
@conditionsubindex{index-layout-with-unknown-length}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} layout
@slotsubindex{layout}@c
@table @strong
@item Initargs
@t{:layout}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {index-on-buffer-stream-with-no-gpu-arrays} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>INDEX-ON-BUFFER-STREAM-WITH-NO-GPU-ARRAYS condition}@c
@conditionsubindex{index-on-buffer-stream-with-no-gpu-arrays}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@end table
@end deftp
@deftp {Condition} {index-on-buffer-stream-with-no-gpu-layouts} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>INDEX-ON-BUFFER-STREAM-WITH-NO-GPU-LAYOUTS condition}@c
@conditionsubindex{index-on-buffer-stream-with-no-gpu-layouts}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@end table
@end deftp
@deftp {Condition} {invalid-args-in-make-tfs} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>INVALID-ARGS-IN-MAKE-TFS condition}@c
@conditionsubindex{invalid-args-in-make-tfs}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} args
@slotsubindex{args}@c
@table @strong
@item Initargs
@t{:args}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {invalid-attachments-for-empty-fbo} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>INVALID-ATTACHMENTS-FOR-EMPTY-FBO condition}@c
@conditionsubindex{invalid-attachments-for-empty-fbo}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} args
@slotsubindex{args}@c
@table @strong
@item Initargs
@t{:args}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {invalid-compose-gpipe-form} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>INVALID-COMPOSE-GPIPE-FORM condition}@c
@conditionsubindex{invalid-compose-gpipe-form}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} pipeline-name
@slotsubindex{pipeline-name}@c
@table @strong
@item Initargs
@t{:pipeline-name}
@end table
@end defvr
@defvr {Slot} clauses
@slotsubindex{clauses}@c
@table @strong
@item Initargs
@t{:clauses}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {invalid-context-for-assert-gpipe} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>INVALID-CONTEXT-FOR-ASSERT-GPIPE condition}@c
@conditionsubindex{invalid-context-for-assert-gpipe}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} context
@slotsubindex{context}@c
@table @strong
@item Initargs
@t{:context}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {invalid-context-for-assert-options} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>INVALID-CONTEXT-FOR-ASSERT-OPTIONS condition}@c
@conditionsubindex{invalid-context-for-assert-options}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} context
@slotsubindex{context}@c
@table @strong
@item Initargs
@t{:context}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {invalid-cube-fbo-args} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>INVALID-CUBE-FBO-ARGS condition}@c
@conditionsubindex{invalid-cube-fbo-args}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} args
@slotsubindex{args}@c
@table @strong
@item Initargs
@t{:args}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {invalid-data-layout-specifier} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>INVALID-DATA-LAYOUT-SPECIFIER condition}@c
@conditionsubindex{invalid-data-layout-specifier}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} specifier
@slotsubindex{specifier}@c
@table @strong
@item Initargs
@t{:specifier}
@end table
@end defvr
@defvr {Slot} valid-specifiers
@slotsubindex{valid-specifiers}@c
@table @strong
@item Initargs
@t{:valid-specifiers}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {invalid-defpipeline-options} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>INVALID-DEFPIPELINE-OPTIONS condition}@c
@conditionsubindex{invalid-defpipeline-options}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} pipeline-name
@slotsubindex{pipeline-name}@c
@table @strong
@item Initargs
@t{:pipeline-name}
@end table
@end defvr
@defvr {Slot} invalid-options
@slotsubindex{invalid-options}@c
@table @strong
@item Initargs
@t{:invalid-options}
@end table
@end defvr
@defvr {Slot} valid-options
@slotsubindex{valid-options}@c
@table @strong
@item Initargs
@t{:valid-options}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {invalid-empty-fbo-declaration} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>INVALID-EMPTY-FBO-DECLARATION condition}@c
@conditionsubindex{invalid-empty-fbo-declaration}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} decl
@slotsubindex{decl}@c
@table @strong
@item Initargs
@t{:decl}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {invalid-gpu-arrays-layout} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>INVALID-GPU-ARRAYS-LAYOUT condition}@c
@conditionsubindex{invalid-gpu-arrays-layout}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} layout
@slotsubindex{layout}@c
@table @strong
@item Initargs
@t{:layout}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {invalid-gpu-buffer-layout} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>INVALID-GPU-BUFFER-LAYOUT condition}@c
@conditionsubindex{invalid-gpu-buffer-layout}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} layout
@slotsubindex{layout}@c
@table @strong
@item Initargs
@t{:layout}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {invalid-inline-glsl-stage-arg-layout} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>INVALID-INLINE-GLSL-STAGE-ARG-LAYOUT condition}@c
@conditionsubindex{invalid-inline-glsl-stage-arg-layout}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} name
@slotsubindex{name}@c
@table @strong
@item Initargs
@t{:name}
@end table
@end defvr
@defvr {Slot} arg
@slotsubindex{arg}@c
@table @strong
@item Initargs
@t{:arg}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {invalid-keywords-for-shader-gpipe-args} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>INVALID-KEYWORDS-FOR-SHADER-GPIPE-ARGS condition}@c
@conditionsubindex{invalid-keywords-for-shader-gpipe-args}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} pipeline-name
@slotsubindex{pipeline-name}@c
@table @strong
@item Initargs
@t{:pipeline-name}
@end table
@end defvr
@defvr {Slot} keys
@slotsubindex{keys}@c
@table @strong
@item Initargs
@t{:keys}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {invalid-layout-for-inargs} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>INVALID-LAYOUT-FOR-INARGS condition}@c
@conditionsubindex{invalid-layout-for-inargs}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} name
@slotsubindex{name}@c
@table @strong
@item Initargs
@t{:name}
@end table
@end defvr
@defvr {Slot} type-name
@slotsubindex{type-name}@c
@table @strong
@item Initargs
@t{:type-name}
@end table
@end defvr
@defvr {Slot} layout
@slotsubindex{layout}@c
@table @strong
@item Initargs
@t{:layout}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {invalid-layout-for-uniform} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>INVALID-LAYOUT-FOR-UNIFORM condition}@c
@conditionsubindex{invalid-layout-for-uniform}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} name
@slotsubindex{name}@c
@table @strong
@item Initargs
@t{:name}
@end table
@end defvr
@defvr {Slot} type-name
@slotsubindex{type-name}@c
@table @strong
@item Initargs
@t{:type-name}
@end table
@end defvr
@defvr {Slot} layout
@slotsubindex{layout}@c
@table @strong
@item Initargs
@t{:layout}
@end table
@end defvr
@defvr {Slot} func-p
@slotsubindex{func-p}@c
@table @strong
@item Initargs
@t{:func-p}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {invalid-options-for-texture} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>INVALID-OPTIONS-FOR-TEXTURE condition}@c
@conditionsubindex{invalid-options-for-texture}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} buffer-storage
@slotsubindex{buffer-storage}@c
@table @strong
@item Initargs
@t{:buffer-storage}
@end table
@end defvr
@defvr {Slot} cubes
@slotsubindex{cubes}@c
@table @strong
@item Initargs
@t{:cubes}
@end table
@end defvr
@defvr {Slot} dimensions
@slotsubindex{dimensions}@c
@table @strong
@item Initargs
@t{:dimensions}
@end table
@end defvr
@defvr {Slot} layer-count
@slotsubindex{layer-count}@c
@table @strong
@item Initargs
@t{:layer-count}
@end table
@end defvr
@defvr {Slot} mipmap
@slotsubindex{mipmap}@c
@table @strong
@item Initargs
@t{:mipmap}
@end table
@end defvr
@defvr {Slot} multisample
@slotsubindex{multisample}@c
@table @strong
@item Initargs
@t{:multisample}
@end table
@end defvr
@defvr {Slot} rectangle
@slotsubindex{rectangle}@c
@table @strong
@item Initargs
@t{:rectangle}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {invalid-sampler-wrap-value} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>INVALID-SAMPLER-WRAP-VALUE condition}@c
@conditionsubindex{invalid-sampler-wrap-value}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} sampler
@slotsubindex{sampler}@c
@table @strong
@item Initargs
@t{:sampler}
@end table
@end defvr
@defvr {Slot} value
@slotsubindex{value}@c
@table @strong
@item Initargs
@t{:value}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {invalid-shader-gpipe-form} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>INVALID-SHADER-GPIPE-FORM condition}@c
@conditionsubindex{invalid-shader-gpipe-form}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} pipeline-name
@slotsubindex{pipeline-name}@c
@table @strong
@item Initargs
@t{:pipeline-name}
@end table
@end defvr
@defvr {Slot} valid-forms
@slotsubindex{valid-forms}@c
@table @strong
@item Initargs
@t{:valid-forms}
@end table
@end defvr
@defvr {Slot} invalid-forms
@slotsubindex{invalid-forms}@c
@table @strong
@item Initargs
@t{:invalid-forms}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {invalid-shader-gpipe-stage-keys} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>INVALID-SHADER-GPIPE-STAGE-KEYS condition}@c
@conditionsubindex{invalid-shader-gpipe-stage-keys}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} pipeline-name
@slotsubindex{pipeline-name}@c
@table @strong
@item Initargs
@t{:pipeline-name}
@end table
@end defvr
@defvr {Slot} keys
@slotsubindex{keys}@c
@table @strong
@item Initargs
@t{:keys}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {invalid-sizes-in-make-tfs} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>INVALID-SIZES-IN-MAKE-TFS condition}@c
@conditionsubindex{invalid-sizes-in-make-tfs}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} args
@slotsubindex{args}@c
@table @strong
@item Initargs
@t{:args}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {invalid-stage-for-single-stage-pipeline} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>INVALID-STAGE-FOR-SINGLE-STAGE-PIPELINE condition}@c
@conditionsubindex{invalid-stage-for-single-stage-pipeline}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} kind
@slotsubindex{kind}@c
@table @strong
@item Initargs
@t{:kind}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {invalid-stream-layout} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>INVALID-STREAM-LAYOUT condition}@c
@conditionsubindex{invalid-stream-layout}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} layout
@slotsubindex{layout}@c
@table @strong
@item Initargs
@t{:layout}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {lisp-type->image-format-failed} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>LISP-TYPE->IMAGE-FORMAT-FAILED condition}@c
@conditionsubindex{lisp-type->image-format-failed}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} type-name
@slotsubindex{type-name}@c
@table @strong
@item Initargs
@t{:type-name}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {make-arrays-layout-count-mismatch} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>MAKE-ARRAYS-LAYOUT-COUNT-MISMATCH condition}@c
@conditionsubindex{make-arrays-layout-count-mismatch}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} current-count
@slotsubindex{current-count}@c
@table @strong
@item Initargs
@t{:current-count}
@end table
@end defvr
@defvr {Slot} layouts
@slotsubindex{layouts}@c
@table @strong
@item Initargs
@t{:layouts}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {make-arrays-layout-mismatch} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>MAKE-ARRAYS-LAYOUT-MISMATCH condition}@c
@conditionsubindex{make-arrays-layout-mismatch}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} current-sizes
@slotsubindex{current-sizes}@c
@table @strong
@item Initargs
@t{:current-sizes}
@end table
@end defvr
@defvr {Slot} requested-sizes
@slotsubindex{requested-sizes}@c
@table @strong
@item Initargs
@t{:requested-sizes}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {make-gpu-array-from-c-array-mismatched-dimensions} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>MAKE-GPU-ARRAY-FROM-C-ARRAY-MISMATCHED-DIMENSIONS condition}@c
@conditionsubindex{make-gpu-array-from-c-array-mismatched-dimensions}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} c-arr-dimensions
@slotsubindex{c-arr-dimensions}@c
@table @strong
@item Initargs
@t{:c-arr-dimensions}
@end table
@end defvr
@defvr {Slot} provided-dimensions
@slotsubindex{provided-dimensions}@c
@table @strong
@item Initargs
@t{:provided-dimensions}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {make-gpu-buffer-from-id-clashing-keys} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>MAKE-GPU-BUFFER-FROM-ID-CLASHING-KEYS condition}@c
@conditionsubindex{make-gpu-buffer-from-id-clashing-keys}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} args
@slotsubindex{args}@c
@table @strong
@item Initargs
@t{:args}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {make-tex-array-not-match-type} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>MAKE-TEX-ARRAY-NOT-MATCH-TYPE condition}@c
@conditionsubindex{make-tex-array-not-match-type}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} element-type
@slotsubindex{element-type}@c
@table @strong
@item Initargs
@t{:element-type}
@end table
@end defvr
@defvr {Slot} pixel-format
@slotsubindex{pixel-format}@c
@table @strong
@item Initargs
@t{:pixel-format}
@end table
@end defvr
@defvr {Slot} supposed-type
@slotsubindex{supposed-type}@c
@table @strong
@item Initargs
@t{:supposed-type}
@end table
@end defvr
@defvr {Slot} array-type
@slotsubindex{array-type}@c
@table @strong
@item Initargs
@t{:array-type}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {make-tex-array-not-match-type2} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>MAKE-TEX-ARRAY-NOT-MATCH-TYPE2 condition}@c
@conditionsubindex{make-tex-array-not-match-type2}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} element-type
@slotsubindex{element-type}@c
@table @strong
@item Initargs
@t{:element-type}
@end table
@end defvr
@defvr {Slot} initial-contents
@slotsubindex{initial-contents}@c
@table @strong
@item Initargs
@t{:initial-contents}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {make-tex-no-content-no-type} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>MAKE-TEX-NO-CONTENT-NO-TYPE condition}@c
@conditionsubindex{make-tex-no-content-no-type}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@end table
@end deftp
@deftp {Condition} {mapping-over-partial-pipeline} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>MAPPING-OVER-PARTIAL-PIPELINE condition}@c
@conditionsubindex{mapping-over-partial-pipeline}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} name
@slotsubindex{name}@c
@table @strong
@item Initargs
@t{:name}
@end table
@end defvr
@defvr {Slot} args
@slotsubindex{args}@c
@table @strong
@item Initargs
@t{:args}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {max-context-count-reached} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>MAX-CONTEXT-COUNT-REACHED condition}@c
@conditionsubindex{max-context-count-reached}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} max
@slotsubindex{max}@c
@table @strong
@item Initargs
@t{:max}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {mixed-pipelines-in-with-tb} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>MIXED-PIPELINES-IN-WITH-TB condition}@c
@conditionsubindex{mixed-pipelines-in-with-tb}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@end table
@end deftp
@deftp {Condition} {multi-func-error} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>MULTI-FUNC-ERROR condition}@c
@conditionsubindex{multi-func-error}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} name
@slotsubindex{name}@c
@table @strong
@item Initargs
@t{:name}
@end table
@end defvr
@defvr {Slot} choices
@slotsubindex{choices}@c
@table @strong
@item Initargs
@t{:choices}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {nested-with-transform-feedback} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>NESTED-WITH-TRANSFORM-FEEDBACK condition}@c
@conditionsubindex{nested-with-transform-feedback}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@end table
@end deftp
@deftp {Condition} {no-named-stages} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>NO-NAMED-STAGES condition}@c
@conditionsubindex{no-named-stages}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} stages
@slotsubindex{stages}@c
@table @strong
@item Initargs
@t{:stages}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {non-consecutive-feedback-groups} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>NON-CONSECUTIVE-FEEDBACK-GROUPS condition}@c
@conditionsubindex{non-consecutive-feedback-groups}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} groups
@slotsubindex{groups}@c
@table @strong
@item Initargs
@t{:groups}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {not-a-gpu-lambda} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>NOT-A-GPU-LAMBDA condition}@c
@conditionsubindex{not-a-gpu-lambda}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} thing
@slotsubindex{thing}@c
@table @strong
@item Initargs
@t{:thing}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {not-enough-args-for-implicit-gpipe-stages} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>NOT-ENOUGH-ARGS-FOR-IMPLICIT-GPIPE-STAGES condition}@c
@conditionsubindex{not-enough-args-for-implicit-gpipe-stages}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} pipeline-name
@slotsubindex{pipeline-name}@c
@table @strong
@item Initargs
@t{:pipeline-name}
@end table
@end defvr
@defvr {Slot} clauses
@slotsubindex{clauses}@c
@table @strong
@item Initargs
@t{:clauses}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {one-stage-non-explicit} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>ONE-STAGE-NON-EXPLICIT condition}@c
@conditionsubindex{one-stage-non-explicit}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@end table
@end deftp
@deftp {Condition} {partial-lambda-pipeline} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>PARTIAL-LAMBDA-PIPELINE condition}@c
@conditionsubindex{partial-lambda-pipeline}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} partial-stages
@slotsubindex{partial-stages}@c
@table @strong
@item Initargs
@t{:partial-stages}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {pipeline-recompile-in-tfb-scope} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>PIPELINE-RECOMPILE-IN-TFB-SCOPE condition}@c
@conditionsubindex{pipeline-recompile-in-tfb-scope}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} name
@slotsubindex{name}@c
@table @strong
@item Initargs
@t{:name}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {pixel-format->image-format-failed} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>PIXEL-FORMAT->IMAGE-FORMAT-FAILED condition}@c
@conditionsubindex{pixel-format->image-format-failed}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} type-name
@slotsubindex{type-name}@c
@table @strong
@item Initargs
@t{:type-name}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {pixel-format-in-bb-texture} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>PIXEL-FORMAT-IN-BB-TEXTURE condition}@c
@conditionsubindex{pixel-format-in-bb-texture}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} pixel-format
@slotsubindex{pixel-format}@c
@table @strong
@item Initargs
@t{:pixel-format}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {pull*-g-not-enabled} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>PULL*-G-NOT-ENABLED condition}@c
@conditionsubindex{pull*-g-not-enabled}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@end table
@end deftp
@deftp {Condition} {pull-g-not-cached} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>PULL-G-NOT-CACHED condition}@c
@conditionsubindex{pull-g-not-cached}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{warning} (condition)
@item Direct slots
@defvr {Slot} asset-name
@slotsubindex{asset-name}@c
@table @strong
@item Initargs
@t{:asset-name}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {query-is-active-bug} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>QUERY-IS-ACTIVE-BUG condition}@c
@conditionsubindex{query-is-active-bug}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} query
@slotsubindex{query}@c
@table @strong
@item Initargs
@t{:query}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {query-is-already-active} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>QUERY-IS-ALREADY-ACTIVE condition}@c
@conditionsubindex{query-is-already-active}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} query
@slotsubindex{query}@c
@table @strong
@item Initargs
@t{:query}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {query-not-active} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>QUERY-NOT-ACTIVE condition}@c
@conditionsubindex{query-not-active}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} query
@slotsubindex{query}@c
@table @strong
@item Initargs
@t{:query}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {quote-in-buffer-layout} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>QUOTE-IN-BUFFER-LAYOUT condition}@c
@conditionsubindex{quote-in-buffer-layout}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} layout
@slotsubindex{layout}@c
@table @strong
@item Initargs
@t{:layout}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {quote-symbol-found-in-fbo-dimensions} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>QUOTE-SYMBOL-FOUND-IN-FBO-DIMENSIONS condition}@c
@conditionsubindex{quote-symbol-found-in-fbo-dimensions}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} form
@slotsubindex{form}@c
@table @strong
@item Initargs
@t{:form}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {shader-pipeline-non-null-args} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>SHADER-PIPELINE-NON-NULL-ARGS condition}@c
@conditionsubindex{shader-pipeline-non-null-args}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} pipeline-name
@slotsubindex{pipeline-name}@c
@table @strong
@item Initargs
@t{:pipeline-name}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {shared-context-created-from-incorrect-thread} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>SHARED-CONTEXT-CREATED-FROM-INCORRECT-THREAD condition}@c
@conditionsubindex{shared-context-created-from-incorrect-thread}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} ctx-thread
@slotsubindex{ctx-thread}@c
@table @strong
@item Initargs
@t{:ctx-thread}
@end table
@end defvr
@defvr {Slot} init-thread
@slotsubindex{init-thread}@c
@table @strong
@item Initargs
@t{:init-thread}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {stage-in-context-only-valid-for-glsl-stages} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>STAGE-IN-CONTEXT-ONLY-VALID-FOR-GLSL-STAGES condition}@c
@conditionsubindex{stage-in-context-only-valid-for-glsl-stages}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} name
@slotsubindex{name}@c
@table @strong
@item Initargs
@t{:name}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {stage-not-found} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>STAGE-NOT-FOUND condition}@c
@conditionsubindex{stage-not-found}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} designator
@slotsubindex{designator}@c
@table @strong
@item Initargs
@t{:designator}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {stage-not-valid-for-function-restriction} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>STAGE-NOT-VALID-FOR-FUNCTION-RESTRICTION condition}@c
@conditionsubindex{stage-not-valid-for-function-restriction}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} name
@slotsubindex{name}@c
@table @strong
@item Initargs
@t{:name}
@end table
@end defvr
@defvr {Slot} stage
@slotsubindex{stage}@c
@table @strong
@item Initargs
@t{:stage}
@end table
@end defvr
@defvr {Slot} func-stage
@slotsubindex{func-stage}@c
@table @strong
@item Initargs
@t{:func-stage}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {state-restore-limitation-blending} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>STATE-RESTORE-LIMITATION-BLENDING condition}@c
@conditionsubindex{state-restore-limitation-blending}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@end table
@end deftp
@deftp {Condition} {state-restore-limitation-transform-feedback} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>STATE-RESTORE-LIMITATION-TRANSFORM-FEEDBACK condition}@c
@conditionsubindex{state-restore-limitation-transform-feedback}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@end table
@end deftp
@deftp {Condition} {struct-in-glsl-stage-args} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>STRUCT-IN-GLSL-STAGE-ARGS condition}@c
@conditionsubindex{struct-in-glsl-stage-args}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} arg-names
@slotsubindex{arg-names}@c
@table @strong
@item Initargs
@t{:arg-names}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {symbol-stage-designator} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>SYMBOL-STAGE-DESIGNATOR condition}@c
@conditionsubindex{symbol-stage-designator}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} designator
@slotsubindex{designator}@c
@table @strong
@item Initargs
@t{:designator}
@end table
@end defvr
@defvr {Slot} possible-choices
@slotsubindex{possible-choices}@c
@table @strong
@item Initargs
@t{:possible-choices}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {symbol-stage-designators} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>SYMBOL-STAGE-DESIGNATORS condition}@c
@conditionsubindex{symbol-stage-designators}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} designator-choice-pairs
@slotsubindex{designator-choice-pairs}@c
@table @strong
@item Initargs
@t{:designator-choice-pairs}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {texture-dimensions-lequal-zero} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>TEXTURE-DIMENSIONS-LEQUAL-ZERO condition}@c
@conditionsubindex{texture-dimensions-lequal-zero}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} dimensions
@slotsubindex{dimensions}@c
@table @strong
@item Initargs
@t{:dimensions}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {tfs-setf-arrays-whilst-bound} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>TFS-SETF-ARRAYS-WHILST-BOUND condition}@c
@conditionsubindex{tfs-setf-arrays-whilst-bound}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{warning} (condition)
@end table
@end deftp
@deftp {Condition} {tried-to-make-context-on-thread-that-already-has-one} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>TRIED-TO-MAKE-CONTEXT-ON-THREAD-THAT-ALREADY-HAS-ONE condition}@c
@conditionsubindex{tried-to-make-context-on-thread-that-already-has-one}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} context
@slotsubindex{context}@c
@table @strong
@item Initargs
@t{:context}
@end table
@end defvr
@defvr {Slot} thread
@slotsubindex{thread}@c
@table @strong
@item Initargs
@t{:thread}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {unknown-stage-kind} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>UNKNOWN-STAGE-KIND condition}@c
@conditionsubindex{unknown-stage-kind}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} stage
@slotsubindex{stage}@c
@table @strong
@item Initargs
@t{:stage}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {unknown-symbols-in-pipeline-context} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>UNKNOWN-SYMBOLS-IN-PIPELINE-CONTEXT condition}@c
@conditionsubindex{unknown-symbols-in-pipeline-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} name
@slotsubindex{name}@c
@table @strong
@item Initargs
@t{:name}
@end table
@end defvr
@defvr {Slot} full
@slotsubindex{full}@c
@table @strong
@item Initargs
@t{:full}
@end table
@end defvr
@defvr {Slot} issue
@slotsubindex{issue}@c
@table @strong
@item Initargs
@t{:issue}
@end table
@end defvr
@defvr {Slot} for
@slotsubindex{for}@c
@table @strong
@item Initargs
@t{:for}
@end table
@end defvr
@end table
@end deftp
" :AFTER-MENU-CONTENTS NIL) #13# #14# #S(NET.DIDIERVERNA.DECLT::NODE :NAME "Exported types" :SYNOPSIS NIL :SECTION-TYPE :NUMBERED :SECTION-NAME "Types" :NEXT NIL :PREVIOUS #14# :UP #2# :CHILDREN NIL :BEFORE-MENU-CONTENTS "@deftp {Type} {array-index} ()
@anchor{go to the CEPL-UTILS<colon><colon>ARRAY-INDEX type}@c
@typesubindex{array-index}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deftp
@deftp {Type} {attachment-name} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>ATTACHMENT-NAME type}@c
@typesubindex{attachment-name}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deftp
@deftp {Type} {attachment-num} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>ATTACHMENT-NUM type}@c
@typesubindex{attachment-num}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deftp
@deftp {Type} {c-array-index} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>C-ARRAY-INDEX type}@c
@typesubindex{c-array-index}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deftp
@deftp {Type} {context-id} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>CONTEXT-ID type}@c
@typesubindex{context-id}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deftp
@deftp {Type} {gl-enum-value} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GL-ENUM-VALUE type}@c
@typesubindex{gl-enum-value}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deftp
@deftp {Type} {gl-id} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GL-ID type}@c
@typesubindex{gl-id}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deftp
@deftp {Type} {gl-sizei} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GL-SIZEI type}@c
@typesubindex{gl-sizei}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deftp
@deftp {Type} {stencil-mask} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>STENCIL-MASK type}@c
@typesubindex{stencil-mask}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deftp
@deftp {Type} {tex-unit} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TEX-UNIT type}@c
@typesubindex{tex-unit}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deftp
@deftp {Type} {uploadable-lisp-seq} ()
@anchor{go to the CEPL<dot>INTERNALS<colon><colon>UPLOADABLE-LISP-SEQ type}@c
@typesubindex{uploadable-lisp-seq}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>INTERNALS package, , @t{cepl.internals}}
@item Source
@ref{go to the cepl/core/internals<dot>lisp file, , @t{core/internals.lisp}} (file)
@end table
@end deftp
@deftp {Type} {vao-id} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>VAO-ID type}@c
@typesubindex{vao-id}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deftp
" :AFTER-MENU-CONTENTS NIL)) :BEFORE-MENU-CONTENTS NIL :AFTER-MENU-CONTENTS NIL) :UP #3# :CHILDREN (#15=#S(NET.DIDIERVERNA.DECLT::NODE :NAME "Internal constants" :SYNOPSIS NIL :SECTION-TYPE :NUMBERED :SECTION-NAME "Constants" :NEXT #16=#S(NET.DIDIERVERNA.DECLT::NODE :NAME "Internal special variables" :SYNOPSIS NIL :SECTION-TYPE :NUMBERED :SECTION-NAME "Special variables" :NEXT #17=#S(NET.DIDIERVERNA.DECLT::NODE :NAME "Internal macros" :SYNOPSIS NIL :SECTION-TYPE :NUMBERED :SECTION-NAME "Macros" :NEXT #18=# :PREVIOUS #16# :UP #1# :CHILDREN NIL :BEFORE-MENU-CONTENTS "@deffn {Macro} {%with-blending} FBO PATTERN EXPLICIT-BLEND-PARAMS &body BODY
@anchor{go to the CEPL<dot>BLENDING<colon><colon>%WITH-BLENDING macro}@c
@macrosubindex{%with-blending}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {%with-cepl-context-slots} SLOTS CONTEXT &body BODY
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%WITH-CEPL-CONTEXT-SLOTS macro}@c
@macrosubindex{%with-cepl-context-slots}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {%with-scratch-texture-bound} TEXTURE &body BODY
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>%WITH-SCRATCH-TEXTURE-BOUND macro}@c
@macrosubindex{%with-scratch-texture-bound}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/def<dot>lisp file, , @t{core/textures/def.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {---block-doc---} DOC-STRING &body BODY
@anchor{go to the CEPL-UTILS<colon><colon>---BLOCK-DOC--- macro}@c
@macrosubindex{---block-doc---}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {define-context-func} NAME ARGS RET-TYPE CONTEXT-SLOTS &body BODY
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>DEFINE-CONTEXT-FUNC macro}@c
@macrosubindex{define-context-func}@c
This simple encodes a pattern I was writing too many times.@*
   Basically we want to have the call to #'cepl-context inline@*
   at the callsite as then a surrounding with-cepl-context block@*
   will be able to replace it with a local version (improving performance)
   the way we have taken to doing this 
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {if-gl-context} INIT-FUNC-CALL PRE-CONTEXT-FORM &optional DEPENDS-ON
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>IF-GL-CONTEXT macro}@c
@macrosubindex{if-gl-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/delayed-resource-init<dot>lisp file, , @t{core/context/delayed-resource-init.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {l-identity} CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>L-IDENTITY macro}@c
@macrosubindex{l-identity}@c
An identity macro. Exists so it can be shadowed in certain contexts
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {make-typed-from-foreign} ()
@anchor{go to the CEPL<dot>TYPES<colon><colon>MAKE-TYPED-FROM-FOREIGN macro}@c
@macrosubindex{make-typed-from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {map-g-into*} (FBO &key WITH-VIEWPORT ATTACHMENT-FOR-SIZE WITH-BLENDING) PIPELINE-FUNC STREAM &rest UNIFORMS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>MAP-G-INTO* macro}@c
@macrosubindex{map-g-into*}@c

The `map-g-into*` macro is a variant of `map-g-into` which differs in that you have
more control over how the `fbo` is bound.@*

Like map-g-into, map-g-into* maps a `buffer-stream` over our pipeline and the
results of the pipeline are fed into the supplied fbo.@*

This is how we run our pipelines and thus is how we render in CEPL.@*

The arguments to map-g-into* are going to depend on what gpu-functions were
composed in the pipeline you are calling. However the layout is always as
follows.@*

- fbo: This is where the results of the pipeline will be written.@*

- with-viewport: If with-viewport is t then `with-fbo-bound` adds a
                 `with-fbo-viewport` that uses this fbo to this scope. This means
                 that the `current-viewport` within this scope will be set to the
                 equivalent of:@*

                     (make-viewport dimensions-of-fbo '(0 0))@*

                 See the docstruct with-fbo-viewport for details on this
                 behavior.@*

                 One last detail is that you may want to take the `dimensions` of
                 the `viewport` from an attachment other than attachment-0.@*
                 To do this use the 'attachment-for-size argument and give the
                 index of the color-attachment to use.@*

- with-blending: If with-blending is t then with-fbo-bound adds a with-blending
                 that uses this fbo to this scope.@*
                 This means that the blending parameters from your fbo will be
                 used while rendering. For the details and version specific
                 behaviours check out the docstring for with-blending@*

- attachment-for-size: see above@*

- the pipeline function: The first argument is always the pipeline you wish to
  map the data over.@*

- The stream: The next argument will be the buffer-stream which will be used as the
  inputs to the vertex-shader of the pipeline. The type of the buffer-stream  must
  be mappable onto types of the non uniform args of the gpu-function being used
  as the vertex-shader.@*

- Uniform args: Next you must provide the uniform arguments. These are passed in
  the same fashion as regular &key arguments.@*

CEPL will then run the pipeline with the given args and the results will be fed
into the specified FBO. The value/s from the fragment shader will be@*
written into the attachments of the FBO. If you need to control this in the
fashion usualy provided by with-fbo-bound then please see the doc-string for
 `map-g-into*`.@*

The default behaviour is that each of the multiple returns values from the
gpu-function used as the fragment shader will be written into the respective
attachments of the `FBO` (first value to first attachment, second value to
second attachment, etc)@*

Internally map-g-into* wraps call to `map-g` in with-fbo-bound. The with-fbo-bound
has its default configuration which means that:
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/map-g<dot>lisp file, , @t{core/pipelines/map-g.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {with-blending-param-slots} BLENDING-PARAMS &body BODY
@anchor{go to the CEPL<dot>BLENDING<colon><colon>WITH-BLENDING-PARAM-SLOTS macro}@c
@macrosubindex{with-blending-param-slots}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {with-buffer-range-mapped} (P TARGET OFFSET LENGTH ACCESS) &body BODY
@anchor{go to the CEPL<dot>GPU-ARRAYS<colon><colon>WITH-BUFFER-RANGE-MAPPED macro}@c
@macrosubindex{with-buffer-range-mapped}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS package, , @t{cepl.gpu-arrays}}
@item Source
@ref{go to the cepl/core/gpu-arrays/with-and-push<dot>lisp file, , @t{core/gpu-arrays/with-and-push.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {with-fbo-slots} ATTACHMENT-BINDINGS EXPRESSION &body BODY
@anchor{go to the CEPL<dot>FBOS<colon><colon>WITH-FBO-SLOTS macro}@c
@macrosubindex{with-fbo-slots}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {with-glsl-stage-spec} GLSL-STAGE-SPEC &body BODY
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>WITH-GLSL-STAGE-SPEC macro}@c
@macrosubindex{with-glsl-stage-spec}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {with-gpu-array-t} GPU-ARRAY-T &body BODY
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>WITH-GPU-ARRAY-T macro}@c
@macrosubindex{with-gpu-array-t}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/def<dot>lisp file, , @t{core/textures/def.lisp}} (file)
@end table
@end deffn
@deffn {Macro} {with-gpu-func-spec} FUNC-SPEC &body BODY
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>WITH-GPU-FUNC-SPEC macro}@c
@macrosubindex{with-gpu-func-spec}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
" :AFTER-MENU-CONTENTS NIL) :PREVIOUS #15# :UP #1# :CHILDREN NIL :BEFORE-MENU-CONTENTS "@defvr {Special Variable} *active-listeners*
@anchor{go to the CEPL<dot>LIFECYCLE<colon><colon>*ACTIVE-LISTENERS* special variable}@c
@specialsubindex{*active-listeners*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>LIFECYCLE package, , @t{cepl.lifecycle}}
@item Source
@ref{go to the cepl/core/lifecycle<dot>lisp file, , @t{core/lifecycle.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *api-0-context-singleton*
@anchor{go to the CEPL<dot>HOST<colon><colon>*API-0-CONTEXT-SINGLETON* special variable}@c
@specialsubindex{*api-0-context-singleton*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-0<dot>lisp file, , @t{host/api-0.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *api-0-make-context-called*
@anchor{go to the CEPL<dot>HOST<colon><colon>*API-0-MAKE-CONTEXT-CALLED* special variable}@c
@specialsubindex{*api-0-make-context-called*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-0<dot>lisp file, , @t{host/api-0.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *api-0-make-window-called*
@anchor{go to the CEPL<dot>HOST<colon><colon>*API-0-MAKE-WINDOW-CALLED* special variable}@c
@specialsubindex{*api-0-make-window-called*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-0<dot>lisp file, , @t{host/api-0.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *api-0-window-singleton*
@anchor{go to the CEPL<dot>HOST<colon><colon>*API-0-WINDOW-SINGLETON* special variable}@c
@specialsubindex{*api-0-window-singleton*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-0<dot>lisp file, , @t{host/api-0.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *cache-last-compile-result*
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>*CACHE-LAST-COMPILE-RESULT* special variable}@c
@specialsubindex{*cache-last-compile-result*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *cepl-context*
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>*CEPL-CONTEXT* special variable}@c
@specialsubindex{*cepl-context*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *cepl-release-mode*
@anchor{go to the CEPL<dot>BUILD<colon><colon>*CEPL-RELEASE-MODE* special variable}@c
@specialsubindex{*cepl-release-mode*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>BUILD package, , @t{cepl.build}}
@item Source
@ref{go to the cepl<dot>build/build/build<dot>lisp file, , @t{build/build.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *contexts*
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>*CONTEXTS* special variable}@c
@specialsubindex{*contexts*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *contexts-lock*
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>*CONTEXTS-LOCK* special variable}@c
@specialsubindex{*contexts-lock*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *current-host*
@anchor{go to the CEPL<dot>HOST<colon><colon>*CURRENT-HOST* special variable}@c
@specialsubindex{*current-host*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-api<dot>lisp file, , @t{host/api-api.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *declared-host*
@anchor{go to the CEPL<dot>HOST<colon><colon>*DECLARED-HOST* special variable}@c
@specialsubindex{*declared-host*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-api<dot>lisp file, , @t{host/api-api.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *default-sampler-id-box*
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>*DEFAULT-SAMPLER-ID-BOX* special variable}@c
@specialsubindex{*default-sampler-id-box*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *dependent-gpu-functions*
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>*DEPENDENT-GPU-FUNCTIONS* special variable}@c
@specialsubindex{*dependent-gpu-functions*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *dependent-gpu-functions-lock*
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>*DEPENDENT-GPU-FUNCTIONS-LOCK* special variable}@c
@specialsubindex{*dependent-gpu-functions-lock*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *expand-fbo-pattern-to-c-array*
@anchor{go to the CEPL<dot>FBOS<colon><colon>*EXPAND-FBO-PATTERN-TO-C-ARRAY* special variable}@c
@specialsubindex{*expand-fbo-pattern-to-c-array*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *extra-cffi-type-equivalents*
@anchor{go to the CEPL<dot>TYPES<colon><colon>*EXTRA-CFFI-TYPE-EQUIVALENTS* special variable}@c
@specialsubindex{*extra-cffi-type-equivalents*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *fake-sampler-id*
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>*FAKE-SAMPLER-ID* special variable}@c
@specialsubindex{*fake-sampler-id*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *fake-sampler-id-lock*
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>*FAKE-SAMPLER-ID-LOCK* special variable}@c
@specialsubindex{*fake-sampler-id-lock*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *free-context-ids*
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>*FREE-CONTEXT-IDS* special variable}@c
@specialsubindex{*free-context-ids*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *free-context-ids-lock*
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>*FREE-CONTEXT-IDS-LOCK* special variable}@c
@specialsubindex{*free-context-ids-lock*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *freed-ssbo-id*
@anchor{go to the CEPL<dot>SSBOS<colon><colon>*FREED-SSBO-ID* special variable}@c
@specialsubindex{*freed-ssbo-id*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SSBOS package, , @t{cepl.ssbos}}
@item Source
@ref{go to the cepl/core/ssbos/ssbos<dot>lisp file, , @t{core/ssbos/ssbos.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *freed-ubo-id*
@anchor{go to the CEPL<dot>UBOS<colon><colon>*FREED-UBO-ID* special variable}@c
@specialsubindex{*freed-ubo-id*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>UBOS package, , @t{cepl.ubos}}
@item Source
@ref{go to the cepl/core/ubos/ubo<dot>lisp file, , @t{core/ubos/ubo.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *get-gpu-lambda-state*
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>*GET-GPU-LAMBDA-STATE* special variable}@c
@specialsubindex{*get-gpu-lambda-state*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-lambda<dot>lisp file, , @t{core/pipelines/gpu-lambda.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *gpu-func-diff-tag*
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>*GPU-FUNC-DIFF-TAG* special variable}@c
@specialsubindex{*gpu-func-diff-tag*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *gpu-func-specs*
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>*GPU-FUNC-SPECS* special variable}@c
@specialsubindex{*gpu-func-specs*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *gpu-func-specs-lock*
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>*GPU-FUNC-SPECS-LOCK* special variable}@c
@specialsubindex{*gpu-func-specs-lock*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *gpu-pipeline-specs*
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>*GPU-PIPELINE-SPECS* special variable}@c
@specialsubindex{*gpu-pipeline-specs*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *gpu-pipeline-specs-lock*
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>*GPU-PIPELINE-SPECS-LOCK* special variable}@c
@specialsubindex{*gpu-pipeline-specs-lock*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *init-pipeline-lock*
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>*INIT-PIPELINE-LOCK* special variable}@c
@specialsubindex{*init-pipeline-lock*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *lifecycle-state*
@anchor{go to the CEPL<dot>LIFECYCLE<colon><colon>*LIFECYCLE-STATE* special variable}@c
@specialsubindex{*lifecycle-state*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>LIFECYCLE package, , @t{cepl.lifecycle}}
@item Source
@ref{go to the cepl/core/lifecycle<dot>lisp file, , @t{core/lifecycle.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *lowest-unused-ssbo-id*
@anchor{go to the CEPL<dot>SSBOS<colon><colon>*LOWEST-UNUSED-SSBO-ID* special variable}@c
@specialsubindex{*lowest-unused-ssbo-id*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SSBOS package, , @t{cepl.ssbos}}
@item Source
@ref{go to the cepl/core/ssbos/ssbos<dot>lisp file, , @t{core/ssbos/ssbos.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *lowest-unused-ubo-id*
@anchor{go to the CEPL<dot>UBOS<colon><colon>*LOWEST-UNUSED-UBO-ID* special variable}@c
@specialsubindex{*lowest-unused-ubo-id*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>UBOS package, , @t{cepl.ubos}}
@item Source
@ref{go to the cepl/core/ubos/ubo<dot>lisp file, , @t{core/ubos/ubo.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *map-of-pipeline-names-to-gl-ids*
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>*MAP-OF-PIPELINE-NAMES-TO-GL-IDS* special variable}@c
@specialsubindex{*map-of-pipeline-names-to-gl-ids*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *map-of-pipeline-names-to-gl-ids-lock*
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>*MAP-OF-PIPELINE-NAMES-TO-GL-IDS-LOCK* special variable}@c
@specialsubindex{*map-of-pipeline-names-to-gl-ids-lock*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *pipeline-body-context-var*
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>*PIPELINE-BODY-CONTEXT-VAR* special variable}@c
@specialsubindex{*pipeline-body-context-var*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/mapg-context<dot>lisp file, , @t{core/pipelines/mapg-context.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *post-context-init*
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>*POST-CONTEXT-INIT* special variable}@c
@specialsubindex{*post-context-init*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/delayed-resource-init<dot>lisp file, , @t{core/context/delayed-resource-init.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *primary-context*
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>*PRIMARY-CONTEXT* special variable}@c
@specialsubindex{*primary-context*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *print-gpu-function-subscriptions*
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>*PRINT-GPU-FUNCTION-SUBSCRIPTIONS* special variable}@c
@specialsubindex{*print-gpu-function-subscriptions*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *samplers-available*
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>*SAMPLERS-AVAILABLE* special variable}@c
@specialsubindex{*samplers-available*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *shutting-down-listeners*
@anchor{go to the CEPL<dot>LIFECYCLE<colon><colon>*SHUTTING-DOWN-LISTENERS* special variable}@c
@specialsubindex{*shutting-down-listeners*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>LIFECYCLE package, , @t{cepl.lifecycle}}
@item Source
@ref{go to the cepl/core/lifecycle<dot>lisp file, , @t{core/lifecycle.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *ssbo-id-lock*
@anchor{go to the CEPL<dot>SSBOS<colon><colon>*SSBO-ID-LOCK* special variable}@c
@specialsubindex{*ssbo-id-lock*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SSBOS package, , @t{cepl.ssbos}}
@item Source
@ref{go to the cepl/core/ssbos/ssbos<dot>lisp file, , @t{core/ssbos/ssbos.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *standard-declarations*
@anchor{go to the CEPL<dot>DEFN<colon><colon>*STANDARD-DECLARATIONS* special variable}@c
@specialsubindex{*standard-declarations*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>DEFN package, , @t{cepl.defn}}
@item Source
@ref{go to the cepl<dot>build/defn/defn<dot>lisp file, , @t{defn/defn.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *struct-slot-defs*
@anchor{go to the CEPL<dot>TYPES<colon><colon>*STRUCT-SLOT-DEFS* special variable}@c
@specialsubindex{*struct-slot-defs*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *suppress-upload-message*
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>*SUPPRESS-UPLOAD-MESSAGE* special variable}@c
@specialsubindex{*suppress-upload-message*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *suspended-listeners*
@anchor{go to the CEPL<dot>LIFECYCLE<colon><colon>*SUSPENDED-LISTENERS* special variable}@c
@specialsubindex{*suspended-listeners*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>LIFECYCLE package, , @t{cepl.lifecycle}}
@item Source
@ref{go to the cepl/core/lifecycle<dot>lisp file, , @t{core/lifecycle.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *template-dir*
@anchor{go to the CEPL<colon><colon>*TEMPLATE-DIR* special variable}@c
@specialsubindex{*template-dir*}@c
@table @strong
@item Package
@ref{go to the CEPL package, , @t{cepl}}
@item Source
@ref{go to the cepl/project<dot>lisp file, , @t{project.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *ubo-id-lock*
@anchor{go to the CEPL<dot>UBOS<colon><colon>*UBO-ID-LOCK* special variable}@c
@specialsubindex{*ubo-id-lock*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>UBOS package, , @t{cepl.ubos}}
@item Source
@ref{go to the cepl/core/ubos/ubo<dot>lisp file, , @t{core/ubos/ubo.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *valid-layout-specifiers*
@anchor{go to the %CEPL<dot>TYPES<colon><colon>*VALID-LAYOUT-SPECIFIERS* special variable}@c
@specialsubindex{*valid-layout-specifiers*}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/layout<dot>lisp file, , @t{core/types/layout.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} *warn-when-cant-test-compile*
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>*WARN-WHEN-CANT-TEST-COMPILE* special variable}@c
@specialsubindex{*warn-when-cant-test-compile*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} +null-att+
@anchor{go to the %CEPL<dot>TYPES<colon><colon>+NULL-ATT+ special variable}@c
@specialsubindex{+null-att+}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/nulls-and-uninitialized<dot>lisp file, , @t{core/types/nulls-and-uninitialized.lisp}} (file)
@end table
@end defvr
@defvr {Special Variable} +uninitialized-buffer-array+
@anchor{go to the %CEPL<dot>TYPES<colon><colon>+UNINITIALIZED-BUFFER-ARRAY+ special variable}@c
@specialsubindex{+uninitialized-buffer-array+}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/nulls-and-uninitialized<dot>lisp file, , @t{core/types/nulls-and-uninitialized.lisp}} (file)
@end table
@end defvr
" :AFTER-MENU-CONTENTS NIL) :PREVIOUS NIL :UP #1# :CHILDREN NIL :BEFORE-MENU-CONTENTS "@defvr {Constant} +cpu->gpu-vec-mappings+
@anchor{go to the CEPL<dot>TYPES<colon><colon>+CPU->GPU-VEC-MAPPINGS+ constant}@c
@constantsubindex{+cpu->gpu-vec-mappings+}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end defvr
@defvr {Constant} +cube-face-order+
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>+CUBE-FACE-ORDER+ constant}@c
@constantsubindex{+cube-face-order+}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end defvr
@defvr {Constant} +cube-face-order-enums+
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>+CUBE-FACE-ORDER-ENUMS+ constant}@c
@constantsubindex{+cube-face-order-enums+}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end defvr
@defvr {Constant} +gl-enum-size+
@anchor{go to the CEPL-UTILS<colon><colon>+GL-ENUM-SIZE+ constant}@c
@constantsubindex{+gl-enum-size+}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/early<dot>lisp file, , @t{core/early.lisp}} (file)
@end table
@end defvr
@defvr {Constant} +gl-integral-pixel-types+
@anchor{go to the CEPL<dot>PIXEL-FORMATS<colon><colon>+GL-INTEGRAL-PIXEL-TYPES+ constant}@c
@constantsubindex{+gl-integral-pixel-types+}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIXEL-FORMATS package, , @t{cepl.pixel-formats}}
@item Source
@ref{go to the cepl/core/types/pixel-format<dot>lisp file, , @t{core/types/pixel-format.lisp}} (file)
@end table
@end defvr
@defvr {Constant} +gl-pixel-to-internal-map+
@anchor{go to the CEPL<dot>PIXEL-FORMATS<colon><colon>+GL-PIXEL-TO-INTERNAL-MAP+ constant}@c
@constantsubindex{+gl-pixel-to-internal-map+}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIXEL-FORMATS package, , @t{cepl.pixel-formats}}
@item Source
@ref{go to the cepl/core/types/pixel-format<dot>lisp file, , @t{core/types/pixel-format.lisp}} (file)
@end table
@end defvr
@defvr {Constant} +lifecycle-states+
@anchor{go to the CEPL<dot>LIFECYCLE<colon><colon>+LIFECYCLE-STATES+ constant}@c
@constantsubindex{+lifecycle-states+}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>LIFECYCLE package, , @t{cepl.lifecycle}}
@item Source
@ref{go to the cepl/core/lifecycle<dot>lisp file, , @t{core/lifecycle.lisp}} (file)
@end table
@end defvr
@defvr {Constant} +possible-texture-keys+
@anchor{go to the CEPL<dot>FBOS<colon><colon>+POSSIBLE-TEXTURE-KEYS+ constant}@c
@constantsubindex{+possible-texture-keys+}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end defvr
@defvr {Constant} +sampler-types+
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>+SAMPLER-TYPES+ constant}@c
@constantsubindex{+sampler-types+}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end defvr
@defvr {Constant} +unknown-uniform-int-id+
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>+UNKNOWN-UNIFORM-INT-ID+ constant}@c
@constantsubindex{+unknown-uniform-int-id+}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end defvr
@defvr {Constant} +unknown-uniform-uint-id+
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>+UNKNOWN-UNIFORM-UINT-ID+ constant}@c
@constantsubindex{+unknown-uniform-uint-id+}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end defvr
@defvr {Constant} +valid-fbo-targets+
@anchor{go to the CEPL<dot>FBOS<colon><colon>+VALID-FBO-TARGETS+ constant}@c
@constantsubindex{+valid-fbo-targets+}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end defvr
@defvr {Constant} +valid-pixel-components+
@anchor{go to the CEPL<dot>PIXEL-FORMATS<colon><colon>+VALID-PIXEL-COMPONENTS+ constant}@c
@constantsubindex{+valid-pixel-components+}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIXEL-FORMATS package, , @t{cepl.pixel-formats}}
@item Source
@ref{go to the cepl/core/types/pixel-format<dot>lisp file, , @t{core/types/pixel-format.lisp}} (file)
@end table
@end defvr
@defvr {Constant} +valid-pixel-packed-sizes+
@anchor{go to the CEPL<dot>PIXEL-FORMATS<colon><colon>+VALID-PIXEL-PACKED-SIZES+ constant}@c
@constantsubindex{+valid-pixel-packed-sizes+}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIXEL-FORMATS package, , @t{cepl.pixel-formats}}
@item Source
@ref{go to the cepl/core/types/pixel-format<dot>lisp file, , @t{core/types/pixel-format.lisp}} (file)
@end table
@end defvr
@defvr {Constant} +valid-pixel-types+
@anchor{go to the CEPL<dot>PIXEL-FORMATS<colon><colon>+VALID-PIXEL-TYPES+ constant}@c
@constantsubindex{+valid-pixel-types+}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIXEL-FORMATS package, , @t{cepl.pixel-formats}}
@item Source
@ref{go to the cepl/core/types/pixel-format<dot>lisp file, , @t{core/types/pixel-format.lisp}} (file)
@end table
@end defvr
@defvr {Constant} +valid-stencil-tests+
@anchor{go to the CEPL<dot>STENCIL<colon><colon>+VALID-STENCIL-TESTS+ constant}@c
@constantsubindex{+valid-stencil-tests+}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>STENCIL package, , @t{cepl.stencil}}
@item Source
@ref{go to the cepl/core/stencil/stencil<dot>lisp file, , @t{core/stencil/stencil.lisp}} (file)
@end table
@end defvr
@defvr {Constant} +valid-texture-storage-options+
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>+VALID-TEXTURE-STORAGE-OPTIONS+ constant}@c
@constantsubindex{+valid-texture-storage-options+}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end defvr
@defvr {Constant} +valid-texture-subset+
@anchor{go to the CEPL<dot>FBOS<colon><colon>+VALID-TEXTURE-SUBSET+ constant}@c
@constantsubindex{+valid-texture-subset+}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end defvr
" :AFTER-MENU-CONTENTS NIL) #16# #17# #18# #19=#S(NET.DIDIERVERNA.DECLT::NODE :NAME "Internal functions" :SYNOPSIS NIL :SECTION-TYPE :NUMBERED :SECTION-NAME "Functions" :NEXT #20=#S(NET.DIDIERVERNA.DECLT::NODE :NAME "Internal generic functions" :SYNOPSIS NIL :SECTION-TYPE :NUMBERED :SECTION-NAME "Generic functions" :NEXT #21=#S(NET.DIDIERVERNA.DECLT::NODE :NAME "Internal conditions" :SYNOPSIS NIL :SECTION-TYPE :NUMBERED :SECTION-NAME "Conditions" :NEXT #22=# :PREVIOUS #20# :UP #1# :CHILDREN NIL :BEFORE-MENU-CONTENTS "@deftp {Condition} {c-array-4d-limit} ()
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>C-ARRAY-4D-LIMIT condition}@c
@conditionsubindex{c-array-4d-limit}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/aref-c<dot>lisp file, , @t{core/c-arrays/aref-c.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} dimensions
@slotsubindex{dimensions}@c
@table @strong
@item Initargs
@t{:dimensions}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {c-array-4d-limit-aref} ()
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>C-ARRAY-4D-LIMIT-AREF condition}@c
@conditionsubindex{c-array-4d-limit-aref}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/aref-c<dot>lisp file, , @t{core/c-arrays/aref-c.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} c-arr
@slotsubindex{c-arr}@c
@table @strong
@item Initargs
@t{:c-arr}
@end table
@end defvr
@defvr {Slot} indices
@slotsubindex{indices}@c
@table @strong
@item Initargs
@t{:indices}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {gl-version-too-low-for-empty-fbos} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>GL-VERSION-TOO-LOW-FOR-EMPTY-FBOS condition}@c
@conditionsubindex{gl-version-too-low-for-empty-fbos}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} version
@slotsubindex{version}@c
@table @strong
@item Initargs
@t{:version}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {invalid-fbo-args} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>INVALID-FBO-ARGS condition}@c
@conditionsubindex{invalid-fbo-args}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} args
@slotsubindex{args}@c
@table @strong
@item Initargs
@t{:args}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {make-project-needs-quickproject} ()
@anchor{go to the CEPL<colon><colon>MAKE-PROJECT-NEEDS-QUICKPROJECT condition}@c
@conditionsubindex{make-project-needs-quickproject}@c
@table @strong
@item Package
@ref{go to the CEPL package, , @t{cepl}}
@item Source
@ref{go to the cepl/project<dot>lisp file, , @t{project.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@end table
@end deftp
@deftp {Condition} {make-project-no-such-dir} ()
@anchor{go to the CEPL<colon><colon>MAKE-PROJECT-NO-SUCH-DIR condition}@c
@conditionsubindex{make-project-no-such-dir}@c
@table @strong
@item Package
@ref{go to the CEPL package, , @t{cepl}}
@item Source
@ref{go to the cepl/project<dot>lisp file, , @t{project.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} dir
@slotsubindex{dir}@c
@table @strong
@item Initargs
@t{:dir}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {make-ssbo-from-array-bad-type} ()
@anchor{go to the CEPL<dot>SSBOS<colon><colon>MAKE-SSBO-FROM-ARRAY-BAD-TYPE condition}@c
@conditionsubindex{make-ssbo-from-array-bad-type}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SSBOS package, , @t{cepl.ssbos}}
@item Source
@ref{go to the cepl/core/ssbos/ssbos<dot>lisp file, , @t{core/ssbos/ssbos.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} data
@slotsubindex{data}@c
@table @strong
@item Initargs
@t{:data}
@end table
@end defvr
@defvr {Slot} element-type
@slotsubindex{element-type}@c
@table @strong
@item Initargs
@t{:element-type}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {make-ubo-from-array-bad-type} ()
@anchor{go to the CEPL<dot>UBOS<colon><colon>MAKE-UBO-FROM-ARRAY-BAD-TYPE condition}@c
@conditionsubindex{make-ubo-from-array-bad-type}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>UBOS package, , @t{cepl.ubos}}
@item Source
@ref{go to the cepl/core/ubos/ubo<dot>lisp file, , @t{core/ubos/ubo.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@item Direct slots
@defvr {Slot} data
@slotsubindex{data}@c
@table @strong
@item Initargs
@t{:data}
@end table
@end defvr
@defvr {Slot} element-type
@slotsubindex{element-type}@c
@table @strong
@item Initargs
@t{:element-type}
@end table
@end defvr
@end table
@end deftp
@deftp {Condition} {state-restore-limitation-queries} ()
@anchor{go to the CEPL<dot>ERRORS<colon><colon>STATE-RESTORE-LIMITATION-QUERIES condition}@c
@conditionsubindex{state-restore-limitation-queries}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>ERRORS package, , @t{cepl.errors}}
@item Source
@ref{go to the cepl/core/errors<dot>lisp file, , @t{core/errors.lisp}} (file)
@item Direct superclasses
@t{error} (condition)
@end table
@end deftp
" :AFTER-MENU-CONTENTS NIL) :PREVIOUS #19# :UP #1# :CHILDREN NIL :BEFORE-MENU-CONTENTS "@deffn {Generic Function} {%destroy-surface} HOST SURFACE &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%DESTROY-SURFACE generic function}@c
@genericsubindex{%destroy-surface}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-generics<dot>lisp file, , @t{host/api-generics.lisp}} (file)
@item Methods
@deffn {Method} {%destroy-surface} HOST SURFACE &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%DESTROY-SURFACE COMMON-LISP<colon><colon>T COMMON-LISP<colon><colon>T method}@c
@methodsubindex{%destroy-surface}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Method} {%destroy-surface} (HOST @t{api-1}) SURFACE &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%DESTROY-SURFACE CEPL<dot>HOST<colon><colon>API-1 COMMON-LISP<colon><colon>T method}@c
@methodsubindex{%destroy-surface}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-1<dot>lisp file, , @t{host/api-1.lisp}} (file)
@end table
@end deffn
@deffn {Method} {%destroy-surface} (HOST @t{api-0}) SURFACE &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%DESTROY-SURFACE CEPL<dot>HOST<colon><colon>API-0 COMMON-LISP<colon><colon>T method}@c
@methodsubindex{%destroy-surface}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-0<dot>lisp file, , @t{host/api-0.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {%funcs-this-func-uses} KEY &optional DEPTH
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%FUNCS-THIS-FUNC-USES generic function}@c
@genericsubindex{%funcs-this-func-uses}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/generics<dot>lisp file, , @t{core/pipelines/generics.lisp}} (file)
@item Methods
@deffn {Method} {%funcs-this-func-uses} (KEY @t{func-key}) &optional DEPTH
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%FUNCS-THIS-FUNC-USES CEPL<dot>PIPELINES<colon><colon>FUNC-KEY method}@c
@methodsubindex{%funcs-this-func-uses}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {%gpu-function} NAME
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%GPU-FUNCTION generic function}@c
@genericsubindex{%gpu-function}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/generics<dot>lisp file, , @t{core/pipelines/generics.lisp}} (file)
@item Methods
@deffn {Method} {%gpu-function} (NAME @t{list})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%GPU-FUNCTION COMMON-LISP<colon><colon>LIST method}@c
@methodsubindex{%gpu-function}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Method} {%gpu-function} (NAME @t{null})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%GPU-FUNCTION COMMON-LISP<colon><colon>NULL method}@c
@methodsubindex{%gpu-function}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Method} {%gpu-function} (NAME @t{symbol})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%GPU-FUNCTION COMMON-LISP<colon><colon>SYMBOL method}@c
@methodsubindex{%gpu-function}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {%init} HOST ARGS
@anchor{go to the CEPL<dot>HOST<colon><colon>%INIT generic function}@c
@genericsubindex{%init}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-generics<dot>lisp file, , @t{host/api-generics.lisp}} (file)
@item Methods
@deffn {Method} {%init} (HOST @t{api-1}) (ARGS @t{list})
@anchor{go to the CEPL<dot>HOST<colon><colon>%INIT CEPL<dot>HOST<colon><colon>API-1 COMMON-LISP<colon><colon>LIST method}@c
@methodsubindex{%init}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-1<dot>lisp file, , @t{host/api-1.lisp}} (file)
@end table
@end deffn
@deffn {Method} {%init} (HOST @t{api-0}) (ARGS @t{list})
@anchor{go to the CEPL<dot>HOST<colon><colon>%INIT CEPL<dot>HOST<colon><colon>API-0 COMMON-LISP<colon><colon>LIST method}@c
@methodsubindex{%init}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-0<dot>lisp file, , @t{host/api-0.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {%make-gl-context} HOST &key SURFACE VERSION DOUBLE-BUFFER ALPHA-SIZE RED-SIZE GREEN-SIZE BLUE-SIZE DEPTH-SIZE STENCIL-SIZE BUFFER-SIZE &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%MAKE-GL-CONTEXT generic function}@c
@genericsubindex{%make-gl-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-generics<dot>lisp file, , @t{host/api-generics.lisp}} (file)
@item Methods
@deffn {Method} {%make-gl-context} (HOST @t{api-1}) &key SURFACE VERSION DOUBLE-BUFFER ALPHA-SIZE RED-SIZE GREEN-SIZE BLUE-SIZE DEPTH-SIZE STENCIL-SIZE BUFFER-SIZE &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%MAKE-GL-CONTEXT CEPL<dot>HOST<colon><colon>API-1 method}@c
@methodsubindex{%make-gl-context}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-1<dot>lisp file, , @t{host/api-1.lisp}} (file)
@end table
@end deffn
@deffn {Method} {%make-gl-context} (HOST @t{api-0}) &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%MAKE-GL-CONTEXT CEPL<dot>HOST<colon><colon>API-0 method}@c
@methodsubindex{%make-gl-context}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-0<dot>lisp file, , @t{host/api-0.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {%make-gl-context-shared-with-current-context} HOST &key CURRENT-GL-CONTEXT SURFACE VERSION DOUBLE-BUFFER ALPHA-SIZE RED-SIZE GREEN-SIZE BLUE-SIZE DEPTH-SIZE STENCIL-SIZE BUFFER-SIZE &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%MAKE-GL-CONTEXT-SHARED-WITH-CURRENT-CONTEXT generic function}@c
@genericsubindex{%make-gl-context-shared-with-current-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-generics<dot>lisp file, , @t{host/api-generics.lisp}} (file)
@item Methods
@deffn {Method} {%make-gl-context-shared-with-current-context} (HOST @t{api-2}) &key CURRENT-GL-CONTEXT SURFACE VERSION DOUBLE-BUFFER ALPHA-SIZE RED-SIZE GREEN-SIZE BLUE-SIZE DEPTH-SIZE STENCIL-SIZE BUFFER-SIZE &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%MAKE-GL-CONTEXT-SHARED-WITH-CURRENT-CONTEXT CEPL<dot>HOST<colon><colon>API-2 method}@c
@methodsubindex{%make-gl-context-shared-with-current-context}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-2<dot>lisp file, , @t{host/api-2.lisp}} (file)
@end table
@end deffn
@deffn {Method} {%make-gl-context-shared-with-current-context} (HOST @t{api-1}) &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%MAKE-GL-CONTEXT-SHARED-WITH-CURRENT-CONTEXT CEPL<dot>HOST<colon><colon>API-1 method}@c
@methodsubindex{%make-gl-context-shared-with-current-context}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-1<dot>lisp file, , @t{host/api-1.lisp}} (file)
@end table
@end deffn
@deffn {Method} {%make-gl-context-shared-with-current-context} (HOST @t{api-0}) &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%MAKE-GL-CONTEXT-SHARED-WITH-CURRENT-CONTEXT CEPL<dot>HOST<colon><colon>API-0 method}@c
@methodsubindex{%make-gl-context-shared-with-current-context}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-0<dot>lisp file, , @t{host/api-0.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {%make-surface} HOST &rest ARGS &key WIDTH HEIGHT TITLE FULLSCREEN NO-FRAME ALPHA-SIZE RED-SIZE GREEN-SIZE BLUE-SIZE DEPTH-SIZE STENCIL-SIZE BUFFER-SIZE DOUBLE-BUFFER HIDDEN RESIZABLE &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%MAKE-SURFACE generic function}@c
@genericsubindex{%make-surface}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-generics<dot>lisp file, , @t{host/api-generics.lisp}} (file)
@item Methods
@deffn {Method} {%make-surface} (HOST @t{api-1}) &key WIDTH HEIGHT TITLE FULLSCREEN NO-FRAME ALPHA-SIZE RED-SIZE GREEN-SIZE BLUE-SIZE DEPTH-SIZE STENCIL-SIZE BUFFER-SIZE DOUBLE-BUFFER HIDDEN RESIZABLE &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%MAKE-SURFACE CEPL<dot>HOST<colon><colon>API-1 method}@c
@methodsubindex{%make-surface}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-1<dot>lisp file, , @t{host/api-1.lisp}} (file)
@end table
@end deffn
@deffn {Method} {%make-surface} (HOST @t{api-0}) &rest ARGS &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%MAKE-SURFACE CEPL<dot>HOST<colon><colon>API-0 method}@c
@methodsubindex{%make-surface}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-0<dot>lisp file, , @t{host/api-0.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {%recompile-gpu-function-and-pipelines} KEY
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%RECOMPILE-GPU-FUNCTION-AND-PIPELINES generic function}@c
@genericsubindex{%recompile-gpu-function-and-pipelines}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/generics<dot>lisp file, , @t{core/pipelines/generics.lisp}} (file)
@item Methods
@deffn {Method} {%recompile-gpu-function-and-pipelines} (KEY @t{func-key})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%RECOMPILE-GPU-FUNCTION-AND-PIPELINES CEPL<dot>PIPELINES<colon><colon>FUNC-KEY method}@c
@methodsubindex{%recompile-gpu-function-and-pipelines}@c
Recompile all pipelines that depend on the named gpu function or any other
   gpu function that depends on the named gpu function. It does this by doing
   the following:@*

   [0] Recursively call this function on all gpu functions that use the
       gpu function named in the argument@*

   [1] Trigger a recompile on all pipelines that depend on this gpu function
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Method} {%recompile-gpu-function-and-pipelines} KEY
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%RECOMPILE-GPU-FUNCTION-AND-PIPELINES COMMON-LISP<colon><colon>T method}@c
@methodsubindex{%recompile-gpu-function-and-pipelines}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {%set-surface-fullscreen} HOST SURFACE STATE &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SET-SURFACE-FULLSCREEN generic function}@c
@genericsubindex{%set-surface-fullscreen}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-generics<dot>lisp file, , @t{host/api-generics.lisp}} (file)
@item Methods
@deffn {Method} {%set-surface-fullscreen} HOST SURFACE STATE &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SET-SURFACE-FULLSCREEN COMMON-LISP<colon><colon>T COMMON-LISP<colon><colon>T COMMON-LISP<colon><colon>T method}@c
@methodsubindex{%set-surface-fullscreen}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Method} {%set-surface-fullscreen} (HOST @t{api-1}) SURFACE STATE &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SET-SURFACE-FULLSCREEN CEPL<dot>HOST<colon><colon>API-1 COMMON-LISP<colon><colon>T COMMON-LISP<colon><colon>T method}@c
@methodsubindex{%set-surface-fullscreen}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-1<dot>lisp file, , @t{host/api-1.lisp}} (file)
@end table
@end deffn
@deffn {Method} {%set-surface-fullscreen} (HOST @t{api-0}) SURFACE STATE &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SET-SURFACE-FULLSCREEN CEPL<dot>HOST<colon><colon>API-0 COMMON-LISP<colon><colon>T COMMON-LISP<colon><colon>T method}@c
@methodsubindex{%set-surface-fullscreen}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-0<dot>lisp file, , @t{host/api-0.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {%set-surface-size} HOST SURFACE WIDTH HEIGHT &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SET-SURFACE-SIZE generic function}@c
@genericsubindex{%set-surface-size}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-generics<dot>lisp file, , @t{host/api-generics.lisp}} (file)
@item Methods
@deffn {Method} {%set-surface-size} HOST SURFACE WIDTH HEIGHT &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SET-SURFACE-SIZE COMMON-LISP<colon><colon>T COMMON-LISP<colon><colon>T COMMON-LISP<colon><colon>T COMMON-LISP<colon><colon>T method}@c
@methodsubindex{%set-surface-size}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Method} {%set-surface-size} (HOST @t{api-1}) SURFACE WIDTH HEIGHT &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SET-SURFACE-SIZE CEPL<dot>HOST<colon><colon>API-1 COMMON-LISP<colon><colon>T COMMON-LISP<colon><colon>T COMMON-LISP<colon><colon>T method}@c
@methodsubindex{%set-surface-size}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-1<dot>lisp file, , @t{host/api-1.lisp}} (file)
@end table
@end deffn
@deffn {Method} {%set-surface-size} (HOST @t{api-0}) SURFACE WIDTH HEIGHT &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SET-SURFACE-SIZE CEPL<dot>HOST<colon><colon>API-0 COMMON-LISP<colon><colon>T COMMON-LISP<colon><colon>T COMMON-LISP<colon><colon>T method}@c
@methodsubindex{%set-surface-size}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-0<dot>lisp file, , @t{host/api-0.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {%set-surface-title} HOST SURFACE TITLE &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SET-SURFACE-TITLE generic function}@c
@genericsubindex{%set-surface-title}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-generics<dot>lisp file, , @t{host/api-generics.lisp}} (file)
@item Methods
@deffn {Method} {%set-surface-title} HOST SURFACE TITLE &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SET-SURFACE-TITLE COMMON-LISP<colon><colon>T COMMON-LISP<colon><colon>T COMMON-LISP<colon><colon>T method}@c
@methodsubindex{%set-surface-title}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Method} {%set-surface-title} (HOST @t{api-1}) SURFACE TITLE &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SET-SURFACE-TITLE CEPL<dot>HOST<colon><colon>API-1 COMMON-LISP<colon><colon>T COMMON-LISP<colon><colon>T method}@c
@methodsubindex{%set-surface-title}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-1<dot>lisp file, , @t{host/api-1.lisp}} (file)
@end table
@end deffn
@deffn {Method} {%set-surface-title} (HOST @t{api-0}) SURFACE TITLE &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SET-SURFACE-TITLE CEPL<dot>HOST<colon><colon>API-0 COMMON-LISP<colon><colon>T COMMON-LISP<colon><colon>T method}@c
@methodsubindex{%set-surface-title}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-0<dot>lisp file, , @t{host/api-0.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {%shutdown} HOST &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SHUTDOWN generic function}@c
@genericsubindex{%shutdown}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-generics<dot>lisp file, , @t{host/api-generics.lisp}} (file)
@item Methods
@deffn {Method} {%shutdown} (HOST @t{api-1}) &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SHUTDOWN CEPL<dot>HOST<colon><colon>API-1 method}@c
@methodsubindex{%shutdown}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-1<dot>lisp file, , @t{host/api-1.lisp}} (file)
@end table
@end deffn
@deffn {Method} {%shutdown} (HOST @t{api-0}) &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SHUTDOWN CEPL<dot>HOST<colon><colon>API-0 method}@c
@methodsubindex{%shutdown}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-0<dot>lisp file, , @t{host/api-0.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {%subscribe-to-gpu-func} FUNC SUBSCRIBE-TO
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%SUBSCRIBE-TO-GPU-FUNC generic function}@c
@genericsubindex{%subscribe-to-gpu-func}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/generics<dot>lisp file, , @t{core/pipelines/generics.lisp}} (file)
@item Methods
@deffn {Method} {%subscribe-to-gpu-func} FUNC SUBSCRIBE-TO
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%SUBSCRIBE-TO-GPU-FUNC COMMON-LISP<colon><colon>T COMMON-LISP<colon><colon>T method}@c
@methodsubindex{%subscribe-to-gpu-func}@c
As the name would suggest this makes one function dependent on another
   It is used by #'%test-&-process-spec via #'%update-gpu-function-data 
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {%supports-multiple-contexts-p} HOST &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SUPPORTS-MULTIPLE-CONTEXTS-P generic function}@c
@genericsubindex{%supports-multiple-contexts-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-generics<dot>lisp file, , @t{host/api-generics.lisp}} (file)
@item Methods
@deffn {Method} {%supports-multiple-contexts-p} HOST &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SUPPORTS-MULTIPLE-CONTEXTS-P COMMON-LISP<colon><colon>T method}@c
@methodsubindex{%supports-multiple-contexts-p}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Method} {%supports-multiple-contexts-p} (HOST @t{api-1}) &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SUPPORTS-MULTIPLE-CONTEXTS-P CEPL<dot>HOST<colon><colon>API-1 method}@c
@methodsubindex{%supports-multiple-contexts-p}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-1<dot>lisp file, , @t{host/api-1.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {%supports-multiple-surfaces-p} HOST &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SUPPORTS-MULTIPLE-SURFACES-P generic function}@c
@genericsubindex{%supports-multiple-surfaces-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-generics<dot>lisp file, , @t{host/api-generics.lisp}} (file)
@item Methods
@deffn {Method} {%supports-multiple-surfaces-p} HOST &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SUPPORTS-MULTIPLE-SURFACES-P COMMON-LISP<colon><colon>T method}@c
@methodsubindex{%supports-multiple-surfaces-p}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Method} {%supports-multiple-surfaces-p} (HOST @t{api-1}) &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SUPPORTS-MULTIPLE-SURFACES-P CEPL<dot>HOST<colon><colon>API-1 method}@c
@methodsubindex{%supports-multiple-surfaces-p}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-1<dot>lisp file, , @t{host/api-1.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {%surface-fullscreen-p} HOST SURFACE &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SURFACE-FULLSCREEN-P generic function}@c
@genericsubindex{%surface-fullscreen-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-generics<dot>lisp file, , @t{host/api-generics.lisp}} (file)
@item Methods
@deffn {Method} {%surface-fullscreen-p} HOST SURFACE &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SURFACE-FULLSCREEN-P COMMON-LISP<colon><colon>T COMMON-LISP<colon><colon>T method}@c
@methodsubindex{%surface-fullscreen-p}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Method} {%surface-fullscreen-p} (HOST @t{api-1}) SURFACE &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SURFACE-FULLSCREEN-P CEPL<dot>HOST<colon><colon>API-1 COMMON-LISP<colon><colon>T method}@c
@methodsubindex{%surface-fullscreen-p}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-1<dot>lisp file, , @t{host/api-1.lisp}} (file)
@end table
@end deffn
@deffn {Method} {%surface-fullscreen-p} (HOST @t{api-0}) SURFACE &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SURFACE-FULLSCREEN-P CEPL<dot>HOST<colon><colon>API-0 COMMON-LISP<colon><colon>T method}@c
@methodsubindex{%surface-fullscreen-p}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-0<dot>lisp file, , @t{host/api-0.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {%surface-title} HOST SURFACE &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SURFACE-TITLE generic function}@c
@genericsubindex{%surface-title}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-generics<dot>lisp file, , @t{host/api-generics.lisp}} (file)
@item Methods
@deffn {Method} {%surface-title} HOST SURFACE &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SURFACE-TITLE COMMON-LISP<colon><colon>T COMMON-LISP<colon><colon>T method}@c
@methodsubindex{%surface-title}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Method} {%surface-title} (HOST @t{api-1}) SURFACE &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SURFACE-TITLE CEPL<dot>HOST<colon><colon>API-1 COMMON-LISP<colon><colon>T method}@c
@methodsubindex{%surface-title}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-1<dot>lisp file, , @t{host/api-1.lisp}} (file)
@end table
@end deffn
@deffn {Method} {%surface-title} (HOST @t{api-0}) SURFACE &key &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%SURFACE-TITLE CEPL<dot>HOST<colon><colon>API-0 COMMON-LISP<colon><colon>T method}@c
@methodsubindex{%surface-title}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-0<dot>lisp file, , @t{host/api-0.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {%unsubscibe-from-all} SPEC
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%UNSUBSCIBE-FROM-ALL generic function}@c
@genericsubindex{%unsubscibe-from-all}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/generics<dot>lisp file, , @t{core/pipelines/generics.lisp}} (file)
@item Methods
@deffn {Method} {%unsubscibe-from-all} (FUNC-KEY @t{func-key})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%UNSUBSCIBE-FROM-ALL CEPL<dot>PIPELINES<colon><colon>FUNC-KEY method}@c
@methodsubindex{%unsubscibe-from-all}@c
As the name would suggest this removes one function's dependency on another
   It is used by #'%test-&-process-spec via #'%update-gpu-function-data
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Method} {%unsubscibe-from-all} SPEC
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%UNSUBSCIBE-FROM-ALL COMMON-LISP<colon><colon>T method}@c
@methodsubindex{%unsubscibe-from-all}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {always-uploadp} OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ALWAYS-UPLOADP generic function}@c
@genericsubindex{always-uploadp}@c
@deffnx {Generic Function} {(setf always-uploadp)} NEW-VALUE OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF ALWAYS-UPLOADP) generic function}@c
@genericsubindex{(setf always-uploadp)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Methods
@deffn {Method} {always-uploadp} (ASSIGNER @t{assigner})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ALWAYS-UPLOADP CEPL<dot>PIPELINES<colon><colon>ASSIGNER method}@c
@methodsubindex{always-uploadp}@c
automatically generated reader method
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Method} {(setf always-uploadp)} NEW-VALUE (ASSIGNER @t{assigner})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF ALWAYS-UPLOADP) COMMON-LISP<colon><colon>T CEPL<dot>PIPELINES<colon><colon>ASSIGNER method}@c
@methodsubindex{(setf always-uploadp)}@c
automatically generated writer method
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {arg-name} OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ARG-NAME generic function}@c
@genericsubindex{arg-name}@c
@deffnx {Generic Function} {(setf arg-name)} NEW-VALUE OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF ARG-NAME) generic function}@c
@genericsubindex{(setf arg-name)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Methods
@deffn {Method} {arg-name} (ASSIGNER @t{assigner})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ARG-NAME CEPL<dot>PIPELINES<colon><colon>ASSIGNER method}@c
@methodsubindex{arg-name}@c
automatically generated reader method
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Method} {(setf arg-name)} NEW-VALUE (ASSIGNER @t{assigner})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF ARG-NAME) COMMON-LISP<colon><colon>T CEPL<dot>PIPELINES<colon><colon>ASSIGNER method}@c
@methodsubindex{(setf arg-name)}@c
automatically generated writer method
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {assigner-body} OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ASSIGNER-BODY generic function}@c
@genericsubindex{assigner-body}@c
@deffnx {Generic Function} {(setf assigner-body)} NEW-VALUE OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF ASSIGNER-BODY) generic function}@c
@genericsubindex{(setf assigner-body)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Methods
@deffn {Method} {assigner-body} (ASSIGNER-LET-FORM @t{assigner-let-form})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ASSIGNER-BODY CEPL<dot>PIPELINES<colon><colon>ASSIGNER-LET-FORM method}@c
@methodsubindex{assigner-body}@c
automatically generated reader method
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Method} {(setf assigner-body)} NEW-VALUE (ASSIGNER-LET-FORM @t{assigner-let-form})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF ASSIGNER-BODY) COMMON-LISP<colon><colon>T CEPL<dot>PIPELINES<colon><colon>ASSIGNER-LET-FORM method}@c
@methodsubindex{(setf assigner-body)}@c
automatically generated writer method
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {assigner-index} OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ASSIGNER-INDEX generic function}@c
@genericsubindex{assigner-index}@c
@deffnx {Generic Function} {(setf assigner-index)} NEW-VALUE OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF ASSIGNER-INDEX) generic function}@c
@genericsubindex{(setf assigner-index)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Methods
@deffn {Method} {assigner-index} (ASSIGNER-LET-FORM @t{assigner-let-form})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ASSIGNER-INDEX CEPL<dot>PIPELINES<colon><colon>ASSIGNER-LET-FORM method}@c
@methodsubindex{assigner-index}@c
automatically generated reader method
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Method} {(setf assigner-index)} NEW-VALUE (ASSIGNER-LET-FORM @t{assigner-let-form})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF ASSIGNER-INDEX) COMMON-LISP<colon><colon>T CEPL<dot>PIPELINES<colon><colon>ASSIGNER-LET-FORM method}@c
@methodsubindex{(setf assigner-index)}@c
automatically generated writer method
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {assigner-name} OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ASSIGNER-NAME generic function}@c
@genericsubindex{assigner-name}@c
@deffnx {Generic Function} {(setf assigner-name)} NEW-VALUE OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF ASSIGNER-NAME) generic function}@c
@genericsubindex{(setf assigner-name)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Methods
@deffn {Method} {assigner-name} (ASSIGNER-LET-FORM @t{assigner-let-form})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ASSIGNER-NAME CEPL<dot>PIPELINES<colon><colon>ASSIGNER-LET-FORM method}@c
@methodsubindex{assigner-name}@c
automatically generated reader method
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Method} {(setf assigner-name)} NEW-VALUE (ASSIGNER-LET-FORM @t{assigner-let-form})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF ASSIGNER-NAME) COMMON-LISP<colon><colon>T CEPL<dot>PIPELINES<colon><colon>ASSIGNER-LET-FORM method}@c
@methodsubindex{(setf assigner-name)}@c
automatically generated writer method
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {assigner-type} OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ASSIGNER-TYPE generic function}@c
@genericsubindex{assigner-type}@c
@deffnx {Generic Function} {(setf assigner-type)} NEW-VALUE OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF ASSIGNER-TYPE) generic function}@c
@genericsubindex{(setf assigner-type)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Methods
@deffn {Method} {assigner-type} (ASSIGNER-LET-FORM @t{assigner-let-form})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ASSIGNER-TYPE CEPL<dot>PIPELINES<colon><colon>ASSIGNER-LET-FORM method}@c
@methodsubindex{assigner-type}@c
automatically generated reader method
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Method} {(setf assigner-type)} NEW-VALUE (ASSIGNER-LET-FORM @t{assigner-let-form})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF ASSIGNER-TYPE) COMMON-LISP<colon><colon>T CEPL<dot>PIPELINES<colon><colon>ASSIGNER-LET-FORM method}@c
@methodsubindex{(setf assigner-type)}@c
automatically generated writer method
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {check-host} HOST
@anchor{go to the CEPL<dot>HOST<colon><colon>CHECK-HOST generic function}@c
@genericsubindex{check-host}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-api<dot>lisp file, , @t{host/api-api.lisp}} (file)
@item Methods
@deffn {Method} {check-host} (HOST @t{api-2})
@anchor{go to the CEPL<dot>HOST<colon><colon>CHECK-HOST CEPL<dot>HOST<colon><colon>API-2 method}@c
@methodsubindex{check-host}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-2<dot>lisp file, , @t{host/api-2.lisp}} (file)
@end table
@end deffn
@deffn {Method} {check-host} (HOST @t{api-1})
@anchor{go to the CEPL<dot>HOST<colon><colon>CHECK-HOST CEPL<dot>HOST<colon><colon>API-1 method}@c
@methodsubindex{check-host}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-1<dot>lisp file, , @t{host/api-1.lisp}} (file)
@end table
@end deffn
@deffn {Method} {check-host} (HOST @t{api-0})
@anchor{go to the CEPL<dot>HOST<colon><colon>CHECK-HOST CEPL<dot>HOST<colon><colon>API-0 method}@c
@methodsubindex{check-host}@c
@table @strong
@item Source
@ref{go to the cepl/host/api-0<dot>lisp file, , @t{host/api-0.lisp}} (file)
@end table
@end deffn
@deffn {Method} {check-host} HOST
@anchor{go to the CEPL<dot>HOST<colon><colon>CHECK-HOST COMMON-LISP<colon><colon>T method}@c
@methodsubindex{check-host}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {check-mipmap-level-count-valid} LEVEL-COUNT DIMENSIONS
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>CHECK-MIPMAP-LEVEL-COUNT-VALID generic function}@c
@genericsubindex{check-mipmap-level-count-valid}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@item Methods
@deffn {Method} {check-mipmap-level-count-valid} (LEVEL-COUNT @t{integer}) (DIMENSIONS @t{list})
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>CHECK-MIPMAP-LEVEL-COUNT-VALID COMMON-LISP<colon><colon>INTEGER COMMON-LISP<colon><colon>LIST method}@c
@methodsubindex{check-mipmap-level-count-valid}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {cleanup} OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>CLEANUP generic function}@c
@genericsubindex{cleanup}@c
@deffnx {Generic Function} {(setf cleanup)} NEW-VALUE OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF CLEANUP) generic function}@c
@genericsubindex{(setf cleanup)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Methods
@deffn {Method} {cleanup} (ASSIGNER @t{assigner})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>CLEANUP CEPL<dot>PIPELINES<colon><colon>ASSIGNER method}@c
@methodsubindex{cleanup}@c
automatically generated reader method
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Method} {(setf cleanup)} NEW-VALUE (ASSIGNER @t{assigner})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF CLEANUP) COMMON-LISP<colon><colon>T CEPL<dot>PIPELINES<colon><colon>ASSIGNER method}@c
@methodsubindex{(setf cleanup)}@c
automatically generated writer method
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {delete-func-spec} FUNC-KEY
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>DELETE-FUNC-SPEC generic function}@c
@genericsubindex{delete-func-spec}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@item Methods
@deffn {Method} {delete-func-spec} FUNC-KEY
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>DELETE-FUNC-SPEC COMMON-LISP<colon><colon>T method}@c
@methodsubindex{delete-func-spec}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {draw-buffer-i} CONTEXT BUFFER-NUM
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>DRAW-BUFFER-I generic function}@c
@genericsubindex{draw-buffer-i}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/gl-context<dot>lisp file, , @t{core/context/gl-context.lisp}} (file)
@item Methods
@deffn {Method} {draw-buffer-i} (CONTEXT @t{gl-context}) (BUFFER-NUM @t{integer})
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>DRAW-BUFFER-I CEPL<dot>CONTEXT<colon><colon>GL-CONTEXT COMMON-LISP<colon><colon>INTEGER method}@c
@methodsubindex{draw-buffer-i}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {func-key} SOURCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>FUNC-KEY generic function}@c
@genericsubindex{func-key}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/generics<dot>lisp file, , @t{core/pipelines/generics.lisp}} (file)
@item Methods
@deffn {Method} {func-key} (KEY @t{func-key})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>FUNC-KEY CEPL<dot>PIPELINES<colon><colon>FUNC-KEY method}@c
@methodsubindex{func-key}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Method} {func-key} (SPEC @t{external-function})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>FUNC-KEY VARJO<dot>INTERNALS<colon><colon>EXTERNAL-FUNCTION method}@c
@methodsubindex{func-key}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Method} {func-key} (SPEC @t{gpu-func-spec})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>FUNC-KEY CEPL<dot>PIPELINES<colon><colon>GPU-FUNC-SPEC method}@c
@methodsubindex{func-key}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {func-key->name} KEY
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>FUNC-KEY->NAME generic function}@c
@genericsubindex{func-key->name}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/generics<dot>lisp file, , @t{core/pipelines/generics.lisp}} (file)
@item Methods
@deffn {Method} {func-key->name} (KEY @t{func-key})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>FUNC-KEY->NAME CEPL<dot>PIPELINES<colon><colon>FUNC-KEY method}@c
@methodsubindex{func-key->name}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {func-key=} X Y
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>FUNC-KEY= generic function}@c
@genericsubindex{func-key=}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/generics<dot>lisp file, , @t{core/pipelines/generics.lisp}} (file)
@item Methods
@deffn {Method} {func-key=} X Y
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>FUNC-KEY= COMMON-LISP<colon><colon>T COMMON-LISP<colon><colon>T method}@c
@methodsubindex{func-key=}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Method} {func-key=} (X @t{func-key}) Y
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>FUNC-KEY= CEPL<dot>PIPELINES<colon><colon>FUNC-KEY COMMON-LISP<colon><colon>T method}@c
@methodsubindex{func-key=}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Method} {func-key=} X (Y @t{func-key})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>FUNC-KEY= COMMON-LISP<colon><colon>T CEPL<dot>PIPELINES<colon><colon>FUNC-KEY method}@c
@methodsubindex{func-key=}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Method} {func-key=} (X @t{func-key}) (Y @t{func-key})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>FUNC-KEY= CEPL<dot>PIPELINES<colon><colon>FUNC-KEY CEPL<dot>PIPELINES<colon><colon>FUNC-KEY method}@c
@methodsubindex{func-key=}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {funcs-that-use-this-func} KEY
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>FUNCS-THAT-USE-THIS-FUNC generic function}@c
@genericsubindex{funcs-that-use-this-func}@c
@deffnx {Generic Function} {(setf funcs-that-use-this-func)} VALUE KEY
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF FUNCS-THAT-USE-THIS-FUNC) generic function}@c
@genericsubindex{(setf funcs-that-use-this-func)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/generics<dot>lisp file, , @t{core/pipelines/generics.lisp}} (file)
@item Methods
@deffn {Method} {funcs-that-use-this-func} (KEY @t{func-key})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>FUNCS-THAT-USE-THIS-FUNC CEPL<dot>PIPELINES<colon><colon>FUNC-KEY method}@c
@methodsubindex{funcs-that-use-this-func}@c
@deffnx {Method} {(setf funcs-that-use-this-func)} VALUE (KEY @t{func-key})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF FUNCS-THAT-USE-THIS-FUNC) COMMON-LISP<colon><colon>T CEPL<dot>PIPELINES<colon><colon>FUNC-KEY method}@c
@methodsubindex{(setf funcs-that-use-this-func)}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Method} {funcs-that-use-this-func} KEY
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>FUNCS-THAT-USE-THIS-FUNC COMMON-LISP<colon><colon>T method}@c
@methodsubindex{funcs-that-use-this-func}@c
@deffnx {Method} {(setf funcs-that-use-this-func)} VALUE KEY
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF FUNCS-THAT-USE-THIS-FUNC) COMMON-LISP<colon><colon>T COMMON-LISP<colon><colon>T method}@c
@methodsubindex{(setf funcs-that-use-this-func)}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {gen-cleanup-block} ASSIGNERS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GEN-CLEANUP-BLOCK generic function}@c
@genericsubindex{gen-cleanup-block}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/generics<dot>lisp file, , @t{core/pipelines/generics.lisp}} (file)
@item Methods
@deffn {Method} {gen-cleanup-block} (ASSIGNER @t{assigner})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GEN-CLEANUP-BLOCK CEPL<dot>PIPELINES<colon><colon>ASSIGNER method}@c
@methodsubindex{gen-cleanup-block}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {gen-uploaders-block} ASSIGNERS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GEN-UPLOADERS-BLOCK generic function}@c
@genericsubindex{gen-uploaders-block}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/generics<dot>lisp file, , @t{core/pipelines/generics.lisp}} (file)
@item Methods
@deffn {Method} {gen-uploaders-block} (ASSIGNER @t{assigner})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GEN-UPLOADERS-BLOCK CEPL<dot>PIPELINES<colon><colon>ASSIGNER method}@c
@methodsubindex{gen-uploaders-block}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {gpu-func-spec} KEY &optional ERROR-IF-MISSING
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GPU-FUNC-SPEC generic function}@c
@genericsubindex{gpu-func-spec}@c
@deffnx {Generic Function} {(setf gpu-func-spec)} VALUE FUNC-KEY &optional ERROR-IF-MISSING
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF GPU-FUNC-SPEC) generic function}@c
@genericsubindex{(setf gpu-func-spec)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/generics<dot>lisp file, , @t{core/pipelines/generics.lisp}} (file)
@item Methods
@deffn {Method} {gpu-func-spec} (FUNC-KEY @t{func-key}) &optional ERROR-IF-MISSING
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GPU-FUNC-SPEC CEPL<dot>PIPELINES<colon><colon>FUNC-KEY method}@c
@methodsubindex{gpu-func-spec}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Method} {gpu-func-spec} (FUNC-KEY @t{gpu-func-spec}) &optional ERROR-IF-MISSING
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GPU-FUNC-SPEC CEPL<dot>PIPELINES<colon><colon>GPU-FUNC-SPEC method}@c
@methodsubindex{gpu-func-spec}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Method} {gpu-func-spec} KEY &optional ERROR-IF-MISSING
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GPU-FUNC-SPEC COMMON-LISP<colon><colon>T method}@c
@methodsubindex{gpu-func-spec}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Method} {(setf gpu-func-spec)} VALUE (KEY @t{func-key}) &optional ERROR-IF-MISSING
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF GPU-FUNC-SPEC) COMMON-LISP<colon><colon>T CEPL<dot>PIPELINES<colon><colon>FUNC-KEY method}@c
@methodsubindex{(setf gpu-func-spec)}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Method} {(setf gpu-func-spec)} VALUE KEY &optional ERROR-IF-MISSING
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF GPU-FUNC-SPEC) COMMON-LISP<colon><colon>T COMMON-LISP<colon><colon>T method}@c
@methodsubindex{(setf gpu-func-spec)}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {handle} OBJECT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>HANDLE generic function}@c
@genericsubindex{handle}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Methods
@deffn {Method} {handle} (GL-CONTEXT @t{gl-context})
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>HANDLE CEPL<dot>CONTEXT<colon><colon>GL-CONTEXT method}@c
@methodsubindex{handle}@c
automatically generated reader method
@table @strong
@item Source
@ref{go to the cepl/core/context/gl-context<dot>lisp file, , @t{core/context/gl-context.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {handle-defn-declaration} NAME %FUNC-NAME ARGS
@anchor{go to the CEPL<dot>DEFN<colon><colon>HANDLE-DEFN-DECLARATION generic function}@c
@genericsubindex{handle-defn-declaration}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>DEFN package, , @t{cepl.defn}}
@item Source
@ref{go to the cepl<dot>build/defn/defn<dot>lisp file, , @t{defn/defn.lisp}} (file)
@item Methods
@deffn {Method} {handle-defn-declaration} NAME %FUNC-NAME ARGS
@anchor{go to the CEPL<dot>DEFN<colon><colon>HANDLE-DEFN-DECLARATION COMMON-LISP<colon><colon>T COMMON-LISP<colon><colon>T COMMON-LISP<colon><colon>T method}@c
@methodsubindex{handle-defn-declaration}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {in-args} OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>IN-ARGS generic function}@c
@genericsubindex{in-args}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Methods
@deffn {Method} {in-args} (FUNC-KEY @t{func-key})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>IN-ARGS CEPL<dot>PIPELINES<colon><colon>FUNC-KEY method}@c
@methodsubindex{in-args}@c
automatically generated reader method
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {infer-implicit-uniform-type} THING
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>INFER-IMPLICIT-UNIFORM-TYPE generic function}@c
@genericsubindex{infer-implicit-uniform-type}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@item Methods
@deffn {Method} {infer-implicit-uniform-type} THING
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>INFER-IMPLICIT-UNIFORM-TYPE COMMON-LISP<colon><colon>T method}@c
@methodsubindex{infer-implicit-uniform-type}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {lambda-g->func-spec} LAMBDA-G
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>LAMBDA-G->FUNC-SPEC generic function}@c
@genericsubindex{lambda-g->func-spec}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/generics<dot>lisp file, , @t{core/pipelines/generics.lisp}} (file)
@item Methods
@deffn {Method} {lambda-g->func-spec} (LAMBDA-G @t{function})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>LAMBDA-G->FUNC-SPEC COMMON-LISP<colon><colon>FUNCTION method}@c
@methodsubindex{lambda-g->func-spec}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-lambda<dot>lisp file, , @t{core/pipelines/gpu-lambda.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {let-forms} OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>LET-FORMS generic function}@c
@genericsubindex{let-forms}@c
@deffnx {Generic Function} {(setf let-forms)} NEW-VALUE OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF LET-FORMS) generic function}@c
@genericsubindex{(setf let-forms)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Methods
@deffn {Method} {let-forms} (ASSIGNER @t{assigner})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>LET-FORMS CEPL<dot>PIPELINES<colon><colon>ASSIGNER method}@c
@methodsubindex{let-forms}@c
automatically generated reader method
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Method} {(setf let-forms)} NEW-VALUE (ASSIGNER @t{assigner})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF LET-FORMS) COMMON-LISP<colon><colon>T CEPL<dot>PIPELINES<colon><colon>ASSIGNER method}@c
@methodsubindex{(setf let-forms)}@c
automatically generated writer method
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {local-arg-name} OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>LOCAL-ARG-NAME generic function}@c
@genericsubindex{local-arg-name}@c
@deffnx {Generic Function} {(setf local-arg-name)} NEW-VALUE OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF LOCAL-ARG-NAME) generic function}@c
@genericsubindex{(setf local-arg-name)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Methods
@deffn {Method} {local-arg-name} (ASSIGNER @t{assigner})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>LOCAL-ARG-NAME CEPL<dot>PIPELINES<colon><colon>ASSIGNER method}@c
@methodsubindex{local-arg-name}@c
automatically generated reader method
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Method} {(setf local-arg-name)} NEW-VALUE (ASSIGNER @t{assigner})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF LOCAL-ARG-NAME) COMMON-LISP<colon><colon>T CEPL<dot>PIPELINES<colon><colon>ASSIGNER method}@c
@methodsubindex{(setf local-arg-name)}@c
automatically generated writer method
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {pipeline-stage-pairs} SPEC
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>PIPELINE-STAGE-PAIRS generic function}@c
@genericsubindex{pipeline-stage-pairs}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/generics<dot>lisp file, , @t{core/pipelines/generics.lisp}} (file)
@item Methods
@deffn {Method} {pipeline-stage-pairs} (SPEC @t{pipeline-spec-base})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>PIPELINE-STAGE-PAIRS CEPL<dot>PIPELINES<colon><colon>PIPELINE-SPEC-BASE method}@c
@methodsubindex{pipeline-stage-pairs}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {pipeline-stages} SPEC
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>PIPELINE-STAGES generic function}@c
@genericsubindex{pipeline-stages}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/generics<dot>lisp file, , @t{core/pipelines/generics.lisp}} (file)
@item Methods
@deffn {Method} {pipeline-stages} (SPEC @t{pipeline-spec-base})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>PIPELINE-STAGES CEPL<dot>PIPELINES<colon><colon>PIPELINE-SPEC-BASE method}@c
@methodsubindex{pipeline-stages}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {pipelines-that-use-this-as-a-stage} FUNC-KEY
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>PIPELINES-THAT-USE-THIS-AS-A-STAGE generic function}@c
@genericsubindex{pipelines-that-use-this-as-a-stage}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/generics<dot>lisp file, , @t{core/pipelines/generics.lisp}} (file)
@end table
@end deffn
@deffn {Generic Function} {pixel-format-from-array} ARRAY
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>PIXEL-FORMAT-FROM-ARRAY generic function}@c
@genericsubindex{pixel-format-from-array}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@item Methods
@deffn {Method} {pixel-format-from-array} (ARR @t{c-array})
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>PIXEL-FORMAT-FROM-ARRAY %CEPL<dot>TYPES<colon><colon>C-ARRAY method}@c
@methodsubindex{pixel-format-from-array}@c
@end deffn
@deffn {Method} {pixel-format-from-array} (ARR @t{gpu-array-bb})
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>PIXEL-FORMAT-FROM-ARRAY %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB method}@c
@methodsubindex{pixel-format-from-array}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {pointer-arg} OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>POINTER-ARG generic function}@c
@genericsubindex{pointer-arg}@c
@deffnx {Generic Function} {(setf pointer-arg)} NEW-VALUE OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF POINTER-ARG) generic function}@c
@genericsubindex{(setf pointer-arg)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Methods
@deffn {Method} {pointer-arg} (ASSIGNER @t{assigner})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>POINTER-ARG CEPL<dot>PIPELINES<colon><colon>ASSIGNER method}@c
@methodsubindex{pointer-arg}@c
automatically generated reader method
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Method} {(setf pointer-arg)} NEW-VALUE (ASSIGNER @t{assigner})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF POINTER-ARG) COMMON-LISP<colon><colon>T CEPL<dot>PIPELINES<colon><colon>ASSIGNER method}@c
@methodsubindex{(setf pointer-arg)}@c
automatically generated writer method
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {recompile-pipelines-that-use-this-as-a-stage} KEY
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>RECOMPILE-PIPELINES-THAT-USE-THIS-AS-A-STAGE generic function}@c
@genericsubindex{recompile-pipelines-that-use-this-as-a-stage}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/generics<dot>lisp file, , @t{core/pipelines/generics.lisp}} (file)
@item Methods
@deffn {Method} {recompile-pipelines-that-use-this-as-a-stage} (KEY @t{func-key})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>RECOMPILE-PIPELINES-THAT-USE-THIS-AS-A-STAGE CEPL<dot>PIPELINES<colon><colon>FUNC-KEY method}@c
@methodsubindex{recompile-pipelines-that-use-this-as-a-stage}@c
Recompile all pipelines that depend on the named gpu function or any other
   gpu function that depends on the named gpu function. It does this by
   triggering a recompile on all pipelines that depend on this glsl-stage
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {s-arrayp} OBJECT
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-ARRAYP generic function}@c
@genericsubindex{s-arrayp}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@item Methods
@deffn {Method} {s-arrayp} (OBJECT @t{gl-struct-slot})
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-ARRAYP CEPL<dot>TYPES<colon><colon>GL-STRUCT-SLOT method}@c
@methodsubindex{s-arrayp}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {s-def} OBJECT
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-DEF generic function}@c
@genericsubindex{s-def}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@item Methods
@deffn {Method} {s-def} (OBJECT @t{gl-struct-slot})
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-DEF CEPL<dot>TYPES<colon><colon>GL-STRUCT-SLOT method}@c
@methodsubindex{s-def}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {s-dimensions} OBJECT
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-DIMENSIONS generic function}@c
@genericsubindex{s-dimensions}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Methods
@deffn {Method} {s-dimensions} (GL-STRUCT-SLOT @t{gl-struct-slot})
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-DIMENSIONS CEPL<dot>TYPES<colon><colon>GL-STRUCT-SLOT method}@c
@methodsubindex{s-dimensions}@c
automatically generated reader method
@table @strong
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {s-element-type} OBJECT
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-ELEMENT-TYPE generic function}@c
@genericsubindex{s-element-type}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Methods
@deffn {Method} {s-element-type} (GL-STRUCT-SLOT @t{gl-struct-slot})
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-ELEMENT-TYPE CEPL<dot>TYPES<colon><colon>GL-STRUCT-SLOT method}@c
@methodsubindex{s-element-type}@c
automatically generated reader method
@table @strong
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {s-foreign-name} OBJECT
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-FOREIGN-NAME generic function}@c
@genericsubindex{s-foreign-name}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Methods
@deffn {Method} {s-foreign-name} (CEPL-STRUCT-DEFINITION @t{cepl-struct-definition})
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-FOREIGN-NAME CEPL<dot>TYPES<colon><colon>CEPL-STRUCT-DEFINITION method}@c
@methodsubindex{s-foreign-name}@c
automatically generated reader method
@table @strong
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {s-layout} OBJECT
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-LAYOUT generic function}@c
@genericsubindex{s-layout}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Methods
@deffn {Method} {s-layout} (GL-STRUCT-SLOT @t{gl-struct-slot})
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-LAYOUT CEPL<dot>TYPES<colon><colon>GL-STRUCT-SLOT method}@c
@methodsubindex{s-layout}@c
automatically generated reader method
@table @strong
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Method} {s-layout} (CEPL-STRUCT-DEFINITION @t{cepl-struct-definition})
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-LAYOUT CEPL<dot>TYPES<colon><colon>CEPL-STRUCT-DEFINITION method}@c
@methodsubindex{s-layout}@c
automatically generated reader method
@table @strong
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {s-name} OBJECT
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-NAME generic function}@c
@genericsubindex{s-name}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Methods
@deffn {Method} {s-name} (GL-STRUCT-SLOT @t{gl-struct-slot})
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-NAME CEPL<dot>TYPES<colon><colon>GL-STRUCT-SLOT method}@c
@methodsubindex{s-name}@c
automatically generated reader method
@table @strong
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Method} {s-name} (CEPL-STRUCT-DEFINITION @t{cepl-struct-definition})
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-NAME CEPL<dot>TYPES<colon><colon>CEPL-STRUCT-DEFINITION method}@c
@methodsubindex{s-name}@c
automatically generated reader method
@table @strong
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {s-normalizedp} OBJECT
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-NORMALIZEDP generic function}@c
@genericsubindex{s-normalizedp}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Methods
@deffn {Method} {s-normalizedp} (GL-STRUCT-SLOT @t{gl-struct-slot})
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-NORMALIZEDP CEPL<dot>TYPES<colon><colon>GL-STRUCT-SLOT method}@c
@methodsubindex{s-normalizedp}@c
automatically generated reader method
@table @strong
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {s-parent-ffi-name} OBJECT
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-PARENT-FFI-NAME generic function}@c
@genericsubindex{s-parent-ffi-name}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Methods
@deffn {Method} {s-parent-ffi-name} (GL-STRUCT-SLOT @t{gl-struct-slot})
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-PARENT-FFI-NAME CEPL<dot>TYPES<colon><colon>GL-STRUCT-SLOT method}@c
@methodsubindex{s-parent-ffi-name}@c
automatically generated reader method
@table @strong
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {s-reader} OBJECT
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-READER generic function}@c
@genericsubindex{s-reader}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Methods
@deffn {Method} {s-reader} (GL-STRUCT-SLOT @t{gl-struct-slot})
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-READER CEPL<dot>TYPES<colon><colon>GL-STRUCT-SLOT method}@c
@methodsubindex{s-reader}@c
automatically generated reader method
@table @strong
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {s-slot-args} SLOT ARGS
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-SLOT-ARGS generic function}@c
@genericsubindex{s-slot-args}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@item Methods
@deffn {Method} {s-slot-args} (SLOT @t{gl-struct-slot}) (ARGS @t{list})
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-SLOT-ARGS CEPL<dot>TYPES<colon><colon>GL-STRUCT-SLOT COMMON-LISP<colon><colon>LIST method}@c
@methodsubindex{s-slot-args}@c
@end deffn
@end table
@end deffn
@deffn {Generic Function} {s-slots} OBJECT
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-SLOTS generic function}@c
@genericsubindex{s-slots}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Methods
@deffn {Method} {s-slots} (CEPL-STRUCT-DEFINITION @t{cepl-struct-definition})
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-SLOTS CEPL<dot>TYPES<colon><colon>CEPL-STRUCT-DEFINITION method}@c
@methodsubindex{s-slots}@c
automatically generated reader method
@table @strong
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {s-type} OBJECT
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-TYPE generic function}@c
@genericsubindex{s-type}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Methods
@deffn {Method} {s-type} (GL-STRUCT-SLOT @t{gl-struct-slot})
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-TYPE CEPL<dot>TYPES<colon><colon>GL-STRUCT-SLOT method}@c
@methodsubindex{s-type}@c
automatically generated reader method
@table @strong
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {s-uses-method-p} OBJECT
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-USES-METHOD-P generic function}@c
@genericsubindex{s-uses-method-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Methods
@deffn {Method} {s-uses-method-p} (GL-STRUCT-SLOT @t{gl-struct-slot})
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-USES-METHOD-P CEPL<dot>TYPES<colon><colon>GL-STRUCT-SLOT method}@c
@methodsubindex{s-uses-method-p}@c
automatically generated reader method
@table @strong
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {s-writer} OBJECT
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-WRITER generic function}@c
@genericsubindex{s-writer}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Methods
@deffn {Method} {s-writer} (GL-STRUCT-SLOT @t{gl-struct-slot})
@anchor{go to the CEPL<dot>TYPES<colon><colon>S-WRITER CEPL<dot>TYPES<colon><colon>GL-STRUCT-SLOT method}@c
@methodsubindex{s-writer}@c
automatically generated reader method
@table @strong
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {set-primary-thread-and-run} FUNC &rest ARGS
@anchor{go to the CEPL<dot>HOST<colon><colon>SET-PRIMARY-THREAD-AND-RUN generic function}@c
@genericsubindex{set-primary-thread-and-run}@c
This will be called from the UI thread (if required by the OS)
    Implement and use this if you need to do some setup from that thread
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-0<dot>lisp file, , @t{host/api-0.lisp}} (file)
@end table
@end deffn
@deffn {Generic Function} {spec->func-key} SPEC
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>SPEC->FUNC-KEY generic function}@c
@genericsubindex{spec->func-key}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/generics<dot>lisp file, , @t{core/pipelines/generics.lisp}} (file)
@item Methods
@deffn {Method} {spec->func-key} (SPEC @t{func-key})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>SPEC->FUNC-KEY CEPL<dot>PIPELINES<colon><colon>FUNC-KEY method}@c
@methodsubindex{spec->func-key}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Method} {spec->func-key} (SPEC @t{gpu-func-spec})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>SPEC->FUNC-KEY CEPL<dot>PIPELINES<colon><colon>GPU-FUNC-SPEC method}@c
@methodsubindex{spec->func-key}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {unpack-arrayd-assigner} ASSIGNER
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>UNPACK-ARRAYD-ASSIGNER generic function}@c
@genericsubindex{unpack-arrayd-assigner}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/generics<dot>lisp file, , @t{core/pipelines/generics.lisp}} (file)
@item Methods
@deffn {Method} {unpack-arrayd-assigner} (ASSIGNER @t{assigner})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>UNPACK-ARRAYD-ASSIGNER CEPL<dot>PIPELINES<colon><colon>ASSIGNER method}@c
@methodsubindex{unpack-arrayd-assigner}@c
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
@deffn {Generic Function} {uploaders} OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>UPLOADERS generic function}@c
@genericsubindex{uploaders}@c
@deffnx {Generic Function} {(setf uploaders)} NEW-VALUE OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF UPLOADERS) generic function}@c
@genericsubindex{(setf uploaders)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Methods
@deffn {Method} {uploaders} (ASSIGNER @t{assigner})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>UPLOADERS CEPL<dot>PIPELINES<colon><colon>ASSIGNER method}@c
@methodsubindex{uploaders}@c
automatically generated reader method
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Method} {(setf uploaders)} NEW-VALUE (ASSIGNER @t{assigner})
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF UPLOADERS) COMMON-LISP<colon><colon>T CEPL<dot>PIPELINES<colon><colon>ASSIGNER method}@c
@methodsubindex{(setf uploaders)}@c
automatically generated writer method
@table @strong
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@end table
@end deffn
" :AFTER-MENU-CONTENTS NIL) :PREVIOUS #18# :UP #1# :CHILDREN NIL :BEFORE-MENU-CONTENTS "@deffn {Function} {%across-c-1d} FUNC ARR
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>%ACROSS-C-1D function}@c
@functionsubindex{%across-c-1d}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/map<dot>lisp file, , @t{core/c-arrays/map.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%across-c-2d} FUNC ARR
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>%ACROSS-C-2D function}@c
@functionsubindex{%across-c-2d}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/map<dot>lisp file, , @t{core/c-arrays/map.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%across-c-3d} FUNC ARR
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>%ACROSS-C-3D function}@c
@functionsubindex{%across-c-3d}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/map<dot>lisp file, , @t{core/c-arrays/map.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%across-c-4d} FUNC ARR
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>%ACROSS-C-4D function}@c
@functionsubindex{%across-c-4d}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/map<dot>lisp file, , @t{core/c-arrays/map.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%across-c-ptr-1d} FUNC ARR
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>%ACROSS-C-PTR-1D function}@c
@functionsubindex{%across-c-ptr-1d}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/map<dot>lisp file, , @t{core/c-arrays/map.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%across-c-ptr-2d} FUNC ARR
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>%ACROSS-C-PTR-2D function}@c
@functionsubindex{%across-c-ptr-2d}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/map<dot>lisp file, , @t{core/c-arrays/map.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%across-c-ptr-3d} FUNC ARR
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>%ACROSS-C-PTR-3D function}@c
@functionsubindex{%across-c-ptr-3d}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/map<dot>lisp file, , @t{core/c-arrays/map.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%across-c-ptr-4d} FUNC ARR
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>%ACROSS-C-PTR-4D function}@c
@functionsubindex{%across-c-ptr-4d}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/map<dot>lisp file, , @t{core/c-arrays/map.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%api-0-populate-singletons} &key WIDTH HEIGHT TITLE FULLSCREEN NO-FRAME ALPHA-SIZE DEPTH-SIZE STENCIL-SIZE RED-SIZE GREEN-SIZE BLUE-SIZE BUFFER-SIZE DOUBLE-BUFFER HIDDEN RESIZABLE GL-VERSION &allow-other-keys
@anchor{go to the CEPL<dot>HOST<colon><colon>%API-0-POPULATE-SINGLETONS function}@c
@functionsubindex{%api-0-populate-singletons}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-0<dot>lisp file, , @t{host/api-0.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%apply-stencil-mask} FACE MASK CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%APPLY-STENCIL-MASK function}@c
@functionsubindex{%apply-stencil-mask}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/stencil/mask<dot>lisp file, , @t{core/stencil/mask.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%apply-stencil-params} FACE PARAMS CEPL-CONTEXT
@anchor{go to the CEPL<dot>STENCIL<colon><colon>%APPLY-STENCIL-PARAMS function}@c
@functionsubindex{%apply-stencil-params}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>STENCIL package, , @t{cepl.stencil}}
@item Source
@ref{go to the cepl/core/stencil/stencil<dot>lisp file, , @t{core/stencil/stencil.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%attachment} FBO ATTACHMENT-NAME
@anchor{go to the CEPL<dot>FBOS<colon><colon>%ATTACHMENT function}@c
@functionsubindex{%attachment}@c
@deffnx {Function} {(setf %attachment)} VALUE FBO ATTACHMENT-NAME
@anchor{go to the CEPL<dot>FBOS<colon><colon>(SETF %ATTACHMENT) function}@c
@functionsubindex{(setf %attachment)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%bind-fbo} FBO TARGET
@anchor{go to the CEPL<dot>FBOS<colon><colon>%BIND-FBO function}@c
@functionsubindex{%bind-fbo}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%bind-ssbo} SSBO
@anchor{go to the CEPL<dot>SSBOS<colon><colon>%BIND-SSBO function}@c
@functionsubindex{%bind-ssbo}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SSBOS package, , @t{cepl.ssbos}}
@item Source
@ref{go to the cepl/core/ssbos/ssbos<dot>lisp file, , @t{core/ssbos/ssbos.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%bind-tfs-arrays} CTX TFS
@anchor{go to the CEPL<dot>TRANSFORM-FEEDBACK<colon><colon>%BIND-TFS-ARRAYS function}@c
@functionsubindex{%bind-tfs-arrays}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TRANSFORM-FEEDBACK package, , @t{cepl.transform-feedback}}
@item Source
@ref{go to the cepl/core/transform-feedback/transform-feedback<dot>lisp file, , @t{core/transform-feedback/transform-feedback.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%bind-ubo} UBO
@anchor{go to the CEPL<dot>UBOS<colon><colon>%BIND-UBO function}@c
@functionsubindex{%bind-ubo}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>UBOS package, , @t{cepl.ubos}}
@item Source
@ref{go to the cepl/core/ubos/ubo<dot>lisp file, , @t{core/ubos/ubo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%blend-fbo} FBO
@anchor{go to the CEPL<dot>BLENDING<colon><colon>%BLEND-FBO function}@c
@functionsubindex{%blend-fbo}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%blend-i} PARAMS I
@anchor{go to the CEPL<dot>BLENDING<colon><colon>%BLEND-I function}@c
@functionsubindex{%blend-i}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%blend-using-params} PARAMS
@anchor{go to the CEPL<dot>BLENDING<colon><colon>%BLEND-USING-PARAMS function}@c
@functionsubindex{%blend-using-params}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%calc-image-format-with-declared-format} ELEMENT-TYPE IMAGE-FORMAT INITIAL-CONTENTS
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>%CALC-IMAGE-FORMAT-WITH-DECLARED-FORMAT function}@c
@functionsubindex{%calc-image-format-with-declared-format}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%calc-image-format-with-lisp-type} ELEMENT-TYPE INITIAL-CONTENTS
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>%CALC-IMAGE-FORMAT-WITH-LISP-TYPE function}@c
@functionsubindex{%calc-image-format-with-lisp-type}@c
Convert the lisp type to an internal format and delegate to
   %calc-image-format
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%calc-image-format-with-pixel-format} PIXEL-FORMAT INITIAL-CONTENTS
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>%CALC-IMAGE-FORMAT-WITH-PIXEL-FORMAT function}@c
@functionsubindex{%calc-image-format-with-pixel-format}@c
Convert the pixel-format to an internal format and delegate to
   %calc-image-format
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%calc-image-format-without-declared-format} INITIAL-CONTENTS
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>%CALC-IMAGE-FORMAT-WITHOUT-DECLARED-FORMAT function}@c
@functionsubindex{%calc-image-format-without-declared-format}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-array-of-bound-gpu-buffers} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-ARRAY-OF-BOUND-GPU-BUFFERS function}@c
@functionsubindex{%cepl-context-array-of-bound-gpu-buffers}@c
@deffnx {Function} {(setf %cepl-context-array-of-bound-gpu-buffers)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-ARRAY-OF-BOUND-GPU-BUFFERS) function}@c
@functionsubindex{(setf %cepl-context-array-of-bound-gpu-buffers)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-array-of-bound-queries} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-ARRAY-OF-BOUND-QUERIES function}@c
@functionsubindex{%cepl-context-array-of-bound-queries}@c
@deffnx {Function} {(setf %cepl-context-array-of-bound-queries)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-ARRAY-OF-BOUND-QUERIES) function}@c
@functionsubindex{(setf %cepl-context-array-of-bound-queries)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-array-of-bound-samplers} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-ARRAY-OF-BOUND-SAMPLERS function}@c
@functionsubindex{%cepl-context-array-of-bound-samplers}@c
@deffnx {Function} {(setf %cepl-context-array-of-bound-samplers)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-ARRAY-OF-BOUND-SAMPLERS) function}@c
@functionsubindex{(setf %cepl-context-array-of-bound-samplers)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-array-of-gpu-buffers} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-ARRAY-OF-GPU-BUFFERS function}@c
@functionsubindex{%cepl-context-array-of-gpu-buffers}@c
@deffnx {Function} {(setf %cepl-context-array-of-gpu-buffers)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-ARRAY-OF-GPU-BUFFERS) function}@c
@functionsubindex{(setf %cepl-context-array-of-gpu-buffers)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-array-of-ssbo-binding-ranges} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-ARRAY-OF-SSBO-BINDING-RANGES function}@c
@functionsubindex{%cepl-context-array-of-ssbo-binding-ranges}@c
@deffnx {Function} {(setf %cepl-context-array-of-ssbo-binding-ranges)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-ARRAY-OF-SSBO-BINDING-RANGES) function}@c
@functionsubindex{(setf %cepl-context-array-of-ssbo-binding-ranges)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-array-of-ssbo-bindings-buffer-ids} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-ARRAY-OF-SSBO-BINDINGS-BUFFER-IDS function}@c
@functionsubindex{%cepl-context-array-of-ssbo-bindings-buffer-ids}@c
@deffnx {Function} {(setf %cepl-context-array-of-ssbo-bindings-buffer-ids)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-ARRAY-OF-SSBO-BINDINGS-BUFFER-IDS) function}@c
@functionsubindex{(setf %cepl-context-array-of-ssbo-bindings-buffer-ids)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-array-of-textures} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-ARRAY-OF-TEXTURES function}@c
@functionsubindex{%cepl-context-array-of-textures}@c
@deffnx {Function} {(setf %cepl-context-array-of-textures)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-ARRAY-OF-TEXTURES) function}@c
@functionsubindex{(setf %cepl-context-array-of-textures)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-array-of-transform-feedback-bindings-buffer-ids} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-ARRAY-OF-TRANSFORM-FEEDBACK-BINDINGS-BUFFER-IDS function}@c
@functionsubindex{%cepl-context-array-of-transform-feedback-bindings-buffer-ids}@c
@deffnx {Function} {(setf %cepl-context-array-of-transform-feedback-bindings-buffer-ids)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-ARRAY-OF-TRANSFORM-FEEDBACK-BINDINGS-BUFFER-IDS) function}@c
@functionsubindex{(setf %cepl-context-array-of-transform-feedback-bindings-buffer-ids)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-array-of-ubo-binding-ranges} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-ARRAY-OF-UBO-BINDING-RANGES function}@c
@functionsubindex{%cepl-context-array-of-ubo-binding-ranges}@c
@deffnx {Function} {(setf %cepl-context-array-of-ubo-binding-ranges)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-ARRAY-OF-UBO-BINDING-RANGES) function}@c
@functionsubindex{(setf %cepl-context-array-of-ubo-binding-ranges)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-array-of-ubo-bindings-buffer-ids} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-ARRAY-OF-UBO-BINDINGS-BUFFER-IDS function}@c
@functionsubindex{%cepl-context-array-of-ubo-bindings-buffer-ids}@c
@deffnx {Function} {(setf %cepl-context-array-of-ubo-bindings-buffer-ids)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-ARRAY-OF-UBO-BINDINGS-BUFFER-IDS) function}@c
@functionsubindex{(setf %cepl-context-array-of-ubo-bindings-buffer-ids)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-bound-thread} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-BOUND-THREAD function}@c
@functionsubindex{%cepl-context-bound-thread}@c
@deffnx {Function} {(setf %cepl-context-bound-thread)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-BOUND-THREAD) function}@c
@functionsubindex{(setf %cepl-context-bound-thread)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-clear-color} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-CLEAR-COLOR function}@c
@functionsubindex{%cepl-context-clear-color}@c
@deffnx {Function} {(setf %cepl-context-clear-color)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-CLEAR-COLOR) function}@c
@functionsubindex{(setf %cepl-context-clear-color)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-color-masks} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-COLOR-MASKS function}@c
@functionsubindex{%cepl-context-color-masks}@c
@deffnx {Function} {(setf %cepl-context-color-masks)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-COLOR-MASKS) function}@c
@functionsubindex{(setf %cepl-context-color-masks)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-cull-face} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-CULL-FACE function}@c
@functionsubindex{%cepl-context-cull-face}@c
@deffnx {Function} {(setf %cepl-context-cull-face)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-CULL-FACE) function}@c
@functionsubindex{(setf %cepl-context-cull-face)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-current-blend-params} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-CURRENT-BLEND-PARAMS function}@c
@functionsubindex{%cepl-context-current-blend-params}@c
@deffnx {Function} {(setf %cepl-context-current-blend-params)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-CURRENT-BLEND-PARAMS) function}@c
@functionsubindex{(setf %cepl-context-current-blend-params)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-current-program} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-CURRENT-PROGRAM function}@c
@functionsubindex{%cepl-context-current-program}@c
@deffnx {Function} {(setf %cepl-context-current-program)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-CURRENT-PROGRAM) function}@c
@functionsubindex{(setf %cepl-context-current-program)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-current-scissor-viewports} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-CURRENT-SCISSOR-VIEWPORTS function}@c
@functionsubindex{%cepl-context-current-scissor-viewports}@c
@deffnx {Function} {(setf %cepl-context-current-scissor-viewports)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-CURRENT-SCISSOR-VIEWPORTS) function}@c
@functionsubindex{(setf %cepl-context-current-scissor-viewports)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-current-stencil-mask-back} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-CURRENT-STENCIL-MASK-BACK function}@c
@functionsubindex{%cepl-context-current-stencil-mask-back}@c
@deffnx {Function} {(setf %cepl-context-current-stencil-mask-back)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-CURRENT-STENCIL-MASK-BACK) function}@c
@functionsubindex{(setf %cepl-context-current-stencil-mask-back)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-current-stencil-mask-front} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-CURRENT-STENCIL-MASK-FRONT function}@c
@functionsubindex{%cepl-context-current-stencil-mask-front}@c
@deffnx {Function} {(setf %cepl-context-current-stencil-mask-front)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-CURRENT-STENCIL-MASK-FRONT) function}@c
@functionsubindex{(setf %cepl-context-current-stencil-mask-front)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-current-stencil-params-back} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-CURRENT-STENCIL-PARAMS-BACK function}@c
@functionsubindex{%cepl-context-current-stencil-params-back}@c
@deffnx {Function} {(setf %cepl-context-current-stencil-params-back)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-CURRENT-STENCIL-PARAMS-BACK) function}@c
@functionsubindex{(setf %cepl-context-current-stencil-params-back)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-current-stencil-params-front} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-CURRENT-STENCIL-PARAMS-FRONT function}@c
@functionsubindex{%cepl-context-current-stencil-params-front}@c
@deffnx {Function} {(setf %cepl-context-current-stencil-params-front)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-CURRENT-STENCIL-PARAMS-FRONT) function}@c
@functionsubindex{(setf %cepl-context-current-stencil-params-front)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-current-surface} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-CURRENT-SURFACE function}@c
@functionsubindex{%cepl-context-current-surface}@c
@deffnx {Function} {(setf %cepl-context-current-surface)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-CURRENT-SURFACE) function}@c
@functionsubindex{(setf %cepl-context-current-surface)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-current-tfs} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-CURRENT-TFS function}@c
@functionsubindex{%cepl-context-current-tfs}@c
@deffnx {Function} {(setf %cepl-context-current-tfs)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-CURRENT-TFS) function}@c
@functionsubindex{(setf %cepl-context-current-tfs)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-current-viewport} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-CURRENT-VIEWPORT function}@c
@functionsubindex{%cepl-context-current-viewport}@c
@deffnx {Function} {(setf %cepl-context-current-viewport)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-CURRENT-VIEWPORT) function}@c
@functionsubindex{(setf %cepl-context-current-viewport)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-default-framebuffer} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-DEFAULT-FRAMEBUFFER function}@c
@functionsubindex{%cepl-context-default-framebuffer}@c
@deffnx {Function} {(setf %cepl-context-default-framebuffer)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-DEFAULT-FRAMEBUFFER) function}@c
@functionsubindex{(setf %cepl-context-default-framebuffer)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-default-viewport} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-DEFAULT-VIEWPORT function}@c
@functionsubindex{%cepl-context-default-viewport}@c
@deffnx {Function} {(setf %cepl-context-default-viewport)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-DEFAULT-VIEWPORT) function}@c
@functionsubindex{(setf %cepl-context-default-viewport)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-depth-clamp} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-DEPTH-CLAMP function}@c
@functionsubindex{%cepl-context-depth-clamp}@c
@deffnx {Function} {(setf %cepl-context-depth-clamp)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-DEPTH-CLAMP) function}@c
@functionsubindex{(setf %cepl-context-depth-clamp)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-depth-func} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-DEPTH-FUNC function}@c
@functionsubindex{%cepl-context-depth-func}@c
@deffnx {Function} {(setf %cepl-context-depth-func)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-DEPTH-FUNC) function}@c
@functionsubindex{(setf %cepl-context-depth-func)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-depth-mask} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-DEPTH-MASK function}@c
@functionsubindex{%cepl-context-depth-mask}@c
@deffnx {Function} {(setf %cepl-context-depth-mask)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-DEPTH-MASK) function}@c
@functionsubindex{(setf %cepl-context-depth-mask)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-depth-range} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-DEPTH-RANGE function}@c
@functionsubindex{%cepl-context-depth-range}@c
@deffnx {Function} {(setf %cepl-context-depth-range)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-DEPTH-RANGE) function}@c
@functionsubindex{(setf %cepl-context-depth-range)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-draw-fbo-binding} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-DRAW-FBO-BINDING function}@c
@functionsubindex{%cepl-context-draw-fbo-binding}@c
@deffnx {Function} {(setf %cepl-context-draw-fbo-binding)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-DRAW-FBO-BINDING) function}@c
@functionsubindex{(setf %cepl-context-draw-fbo-binding)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-fbos} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-FBOS function}@c
@functionsubindex{%cepl-context-fbos}@c
@deffnx {Function} {(setf %cepl-context-fbos)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-FBOS) function}@c
@functionsubindex{(setf %cepl-context-fbos)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-front-face} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-FRONT-FACE function}@c
@functionsubindex{%cepl-context-front-face}@c
@deffnx {Function} {(setf %cepl-context-front-face)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-FRONT-FACE) function}@c
@functionsubindex{(setf %cepl-context-front-face)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-gl-context} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-GL-CONTEXT function}@c
@functionsubindex{%cepl-context-gl-context}@c
@deffnx {Function} {(setf %cepl-context-gl-context)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-GL-CONTEXT) function}@c
@functionsubindex{(setf %cepl-context-gl-context)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-gl-version-float} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-GL-VERSION-FLOAT function}@c
@functionsubindex{%cepl-context-gl-version-float}@c
@deffnx {Function} {(setf %cepl-context-gl-version-float)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-GL-VERSION-FLOAT) function}@c
@functionsubindex{(setf %cepl-context-gl-version-float)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-id} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-ID function}@c
@functionsubindex{%cepl-context-id}@c
@deffnx {Function} {(setf %cepl-context-id)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-ID) function}@c
@functionsubindex{(setf %cepl-context-id)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-instance-count} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-INSTANCE-COUNT function}@c
@functionsubindex{%cepl-context-instance-count}@c
@deffnx {Function} {(setf %cepl-context-instance-count)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-INSTANCE-COUNT) function}@c
@functionsubindex{(setf %cepl-context-instance-count)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-max-draw-buffer-count} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-MAX-DRAW-BUFFER-COUNT function}@c
@functionsubindex{%cepl-context-max-draw-buffer-count}@c
@deffnx {Function} {(setf %cepl-context-max-draw-buffer-count)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-MAX-DRAW-BUFFER-COUNT) function}@c
@functionsubindex{(setf %cepl-context-max-draw-buffer-count)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-pack-alignment} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-PACK-ALIGNMENT function}@c
@functionsubindex{%cepl-context-pack-alignment}@c
@deffnx {Function} {(setf %cepl-context-pack-alignment)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-PACK-ALIGNMENT) function}@c
@functionsubindex{(setf %cepl-context-pack-alignment)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-read-fbo-binding} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-READ-FBO-BINDING function}@c
@functionsubindex{%cepl-context-read-fbo-binding}@c
@deffnx {Function} {(setf %cepl-context-read-fbo-binding)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-READ-FBO-BINDING) function}@c
@functionsubindex{(setf %cepl-context-read-fbo-binding)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-requested-gl-version} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-REQUESTED-GL-VERSION function}@c
@functionsubindex{%cepl-context-requested-gl-version}@c
@deffnx {Function} {(setf %cepl-context-requested-gl-version)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-REQUESTED-GL-VERSION) function}@c
@functionsubindex{(setf %cepl-context-requested-gl-version)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-shared} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-SHARED function}@c
@functionsubindex{%cepl-context-shared}@c
@deffnx {Function} {(setf %cepl-context-shared)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-SHARED) function}@c
@functionsubindex{(setf %cepl-context-shared)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-surfaces} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-SURFACES function}@c
@functionsubindex{%cepl-context-surfaces}@c
@deffnx {Function} {(setf %cepl-context-surfaces)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-SURFACES) function}@c
@functionsubindex{(setf %cepl-context-surfaces)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-uninitialized-resources} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-UNINITIALIZED-RESOURCES function}@c
@functionsubindex{%cepl-context-uninitialized-resources}@c
@deffnx {Function} {(setf %cepl-context-uninitialized-resources)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-UNINITIALIZED-RESOURCES) function}@c
@functionsubindex{(setf %cepl-context-uninitialized-resources)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-unpack-alignment} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-UNPACK-ALIGNMENT function}@c
@functionsubindex{%cepl-context-unpack-alignment}@c
@deffnx {Function} {(setf %cepl-context-unpack-alignment)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-UNPACK-ALIGNMENT) function}@c
@functionsubindex{(setf %cepl-context-unpack-alignment)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cepl-context-vao-binding-id} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CEPL-CONTEXT-VAO-BINDING-ID function}@c
@functionsubindex{%cepl-context-vao-binding-id}@c
@deffnx {Function} {(setf %cepl-context-vao-binding-id)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF %CEPL-CONTEXT-VAO-BINDING-ID) function}@c
@functionsubindex{(setf %cepl-context-vao-binding-id)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cffi-type->gl-enum} CFFI-TYPE-NAME
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%CFFI-TYPE->GL-ENUM function}@c
@functionsubindex{%cffi-type->gl-enum}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%color-mask} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%COLOR-MASK function}@c
@functionsubindex{%color-mask}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/color/color<dot>lisp file, , @t{core/color/color.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%color-masks} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%COLOR-MASKS function}@c
@functionsubindex{%color-masks}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/color/color<dot>lisp file, , @t{core/color/color.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%compile-closure} CODE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%COMPILE-CLOSURE function}@c
@functionsubindex{%compile-closure}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%compile-link-and-upload} NAME PRIMITIVE STAGE-PAIRS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%COMPILE-LINK-AND-UPLOAD function}@c
@functionsubindex{%compile-link-and-upload}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%copy-compile-context} INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%COPY-COMPILE-CONTEXT function}@c
@functionsubindex{%copy-compile-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/compile-context<dot>lisp file, , @t{core/pipelines/compile-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%create-implicit-uniform-uploader} COMPILED-STAGES UNIFORM-NAMES
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%CREATE-IMPLICIT-UNIFORM-UPLOADER function}@c
@functionsubindex{%create-implicit-uniform-uploader}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%cull-face} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%CULL-FACE function}@c
@functionsubindex{%cull-face}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/face/face<dot>lisp file, , @t{core/face/face.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%current-blend-params} ()
@anchor{go to the CEPL<dot>BLENDING<colon><colon>%CURRENT-BLEND-PARAMS function}@c
@functionsubindex{%current-blend-params}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%current-stencil-params} FACE CEPL-CONTEXT
@anchor{go to the CEPL<dot>STENCIL<colon><colon>%CURRENT-STENCIL-PARAMS function}@c
@functionsubindex{%current-stencil-params}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>STENCIL package, , @t{cepl.stencil}}
@item Source
@ref{go to the cepl/core/stencil/stencil<dot>lisp file, , @t{core/stencil/stencil.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%current-viewport} CEPL-CONTEXT
@anchor{go to the CEPL<dot>VIEWPORTS<colon><colon>%CURRENT-VIEWPORT function}@c
@functionsubindex{%current-viewport}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>VIEWPORTS package, , @t{cepl.viewports}}
@item Source
@ref{go to the cepl/core/viewports/viewport<dot>lisp file, , @t{core/viewports/viewport.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%def-complete-pipeline} NAME ORIGINAL-GPIPE-ARGS STAGE-PAIRS AGGREGATE-ACTUAL-UNIFORMS AGGREGATE-PUBLIC-UNIFORMS POST RAW-CONTEXT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%DEF-COMPLETE-PIPELINE function}@c
@functionsubindex{%def-complete-pipeline}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%def-gpu-function} NAME IN-ARGS UNIFORMS BODY SHARED DOC-STRING EQUIV RAW-CONTEXT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%DEF-GPU-FUNCTION function}@c
@functionsubindex{%def-gpu-function}@c
This is the meat of defun-g. it is broken down as follows:@*

   [0] makes a gpu-func-spec that will be populated a stored later.@*

   [1] Adds a external function definition to varjo also make sure it will be
       called on load@*

   [2] %test-&-process-spec compiles the code to check for errors and log
       dependencies. (this is called at runtime)@*

   [3] %make-gpu-func-spec is called at expand time to write a lisp function
       with the same signature as the gpu-function. This gives code hinting and
       also a decent error message if you try calling it from the cpu.@*
       We don't do this when using defun-g-equiv as we want to shadow the lisp
       function.@*

   [4] the purpose of %recompile-gpu-function-and-pipelines is to recompile and
       functions or pipelines that depend on this gpu function. It does this
       by calling %recompile-gpu-function-and-pipelines on all the gpu function
       that depend on this func and then the recompile-function for all
       pipelines that depend on this gpu function. To this end it walks depth
       first too all affected pipelines.@*

   [5] At runtime this looks for any gpu function that listed this function as
       one of its missing dependencies and calls %test-&-process-spec on them.
       Note that this will (possibly) update the spec but will not trigger a
       recompile in the pipelines.
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%def-partial-pipeline} NAME FUNC-SPECS STAGE-PAIRS AGGREGATE-ACTUAL-UNIFORMS RAW-CONTEXT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%DEF-PARTIAL-PIPELINE function}@c
@functionsubindex{%def-partial-pipeline}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%defn} NAME TYPED-ARGS RESULT-TYPES INLINABLE-P INLINE-P BODY
@anchor{go to the CEPL<dot>DEFN<colon><colon>%DEFN function}@c
@functionsubindex{%defn}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>DEFN package, , @t{cepl.defn}}
@item Source
@ref{go to the cepl<dot>build/defn/defn<dot>lisp file, , @t{defn/defn.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%defpipeline-gfuncs} NAME GPIPE-ARGS CONTEXT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%DEFPIPELINE-GFUNCS function}@c
@functionsubindex{%defpipeline-gfuncs}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%delete-sampler} SAMPLER
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>%DELETE-SAMPLER function}@c
@functionsubindex{%delete-sampler}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%depth-clamp} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%DEPTH-CLAMP function}@c
@functionsubindex{%depth-clamp}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/depth/depth<dot>lisp file, , @t{core/depth/depth.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%depth-mask} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%DEPTH-MASK function}@c
@functionsubindex{%depth-mask}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/depth/depth<dot>lisp file, , @t{core/depth/depth.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%depth-range-vec2} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%DEPTH-RANGE-VEC2 function}@c
@functionsubindex{%depth-range-vec2}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/depth/depth<dot>lisp file, , @t{core/depth/depth.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%depth-test-function} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%DEPTH-TEST-FUNCTION function}@c
@functionsubindex{%depth-test-function}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/depth/depth<dot>lisp file, , @t{core/depth/depth.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%fbo-draw-buffers} FBO
@anchor{go to the CEPL<dot>FBOS<colon><colon>%FBO-DRAW-BUFFERS function}@c
@functionsubindex{%fbo-draw-buffers}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%fbo-owns} FBO ATTACHMENT-NAME
@anchor{go to the CEPL<dot>FBOS<colon><colon>%FBO-OWNS function}@c
@functionsubindex{%fbo-owns}@c
@deffnx {Function} {(setf %fbo-owns)} VALUE FBO ATTACHMENT-NAME
@anchor{go to the CEPL<dot>FBOS<colon><colon>(SETF %FBO-OWNS) function}@c
@functionsubindex{(setf %fbo-owns)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%find-tex-image-format} ELEMENT-FORMAT
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>%FIND-TEX-IMAGE-FORMAT function}@c
@functionsubindex{%find-tex-image-format}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%force-depth-test-function} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%FORCE-DEPTH-TEST-FUNCTION function}@c
@functionsubindex{%force-depth-test-function}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/depth/depth<dot>lisp file, , @t{core/depth/depth.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%front-face} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%FRONT-FACE function}@c
@functionsubindex{%front-face}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/face/face<dot>lisp file, , @t{core/face/face.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%gen-attachment-blend} ATTACHMENTS FBO BODY
@anchor{go to the CEPL<dot>BLENDING<colon><colon>%GEN-ATTACHMENT-BLEND function}@c
@functionsubindex{%gen-attachment-blend}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%gen-pass-key} ()
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%GEN-PASS-KEY function}@c
@functionsubindex{%gen-pass-key}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%gen-texture} PATTERN
@anchor{go to the CEPL<dot>FBOS<colon><colon>%GEN-TEXTURE function}@c
@functionsubindex{%gen-texture}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%get-default-texture-format} ATTACHMENT
@anchor{go to the CEPL<dot>FBOS<colon><colon>%GET-DEFAULT-TEXTURE-FORMAT function}@c
@functionsubindex{%get-default-texture-format}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%get-id} ()
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>%GET-ID function}@c
@functionsubindex{%get-id}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%gl-calc-byte-size} ELEM-SIZE DIMENSIONS ROW-ALIGNMENT
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>%GL-CALC-BYTE-SIZE function}@c
@functionsubindex{%gl-calc-byte-size}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/populate<dot>lisp file, , @t{core/c-arrays/populate.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%gl-make-shader-from-varjo} COMPILED-STAGE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%GL-MAKE-SHADER-FROM-VARJO function}@c
@functionsubindex{%gl-make-shader-from-varjo}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%implicit-uniforms-dont-have-type-mismatches} UNIFORMS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%IMPLICIT-UNIFORMS-DONT-HAVE-TYPE-MISMATCHES function}@c
@functionsubindex{%implicit-uniforms-dont-have-type-mismatches}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%inner-with-context} VAR-NAME CEPL-CONTEXT FORGO-LET BODY CTX-VAR
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%INNER-WITH-CONTEXT function}@c
@functionsubindex{%inner-with-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%loop-setting-per-attachment-blend-params} FBO
@anchor{go to the CEPL<dot>BLENDING<colon><colon>%LOOP-SETTING-PER-ATTACHMENT-BLEND-PARAMS function}@c
@functionsubindex{%loop-setting-per-attachment-blend-params}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%make-buffer-stream} &key (VAO VAO) (%START %START) (%START-BYTE %START-BYTE) (BASE-VERTEX BASE-VERTEX) (LENGTH LENGTH) (%INDEX-TYPE-ENUM %INDEX-TYPE-ENUM) (%INDEX-TYPE-SIZE %INDEX-TYPE-SIZE) (GPU-ARRAYS GPU-ARRAYS) (%PRIMITIVE %PRIMITIVE) (PRIMITIVE-GROUP-ID PRIMITIVE-GROUP-ID) (DRAW-MODE-VAL DRAW-MODE-VAL) (PATCH-LENGTH PATCH-LENGTH) (MANAGED MANAGED)
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%MAKE-BUFFER-STREAM function}@c
@functionsubindex{%make-buffer-stream}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%make-buffer-texture} TEX-OBJ DIMENSIONS IMAGE-FORMAT MIPMAP LAYER-COUNT CUBES RECTANGLE MULTISAMPLE IMMUTABLE INITIAL-CONTENTS PIXEL-FORMAT
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>%MAKE-BUFFER-TEXTURE function}@c
@functionsubindex{%make-buffer-texture}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%make-cepl-context} &key (ID ID) (GL-CONTEXT GL-CONTEXT) (REQUESTED-GL-VERSION REQUESTED-GL-VERSION) (GL-VERSION-FLOAT GL-VERSION-FLOAT) (BOUND-THREAD BOUND-THREAD) (UNINITIALIZED-RESOURCES UNINITIALIZED-RESOURCES) (SHARED SHARED) (SURFACES SURFACES) (CURRENT-PROGRAM CURRENT-PROGRAM) (CURRENT-TFS CURRENT-TFS) (CURRENT-SURFACE CURRENT-SURFACE) (VAO-BINDING-ID VAO-BINDING-ID) (CURRENT-VIEWPORT CURRENT-VIEWPORT) (DEFAULT-VIEWPORT DEFAULT-VIEWPORT) (CURRENT-SCISSOR-VIEWPORTS CURRENT-SCISSOR-VIEWPORTS) (DEFAULT-FRAMEBUFFER DEFAULT-FRAMEBUFFER) (READ-FBO-BINDING READ-FBO-BINDING) (DRAW-FBO-BINDING DRAW-FBO-BINDING) (CURRENT-STENCIL-PARAMS-FRONT CURRENT-STENCIL-PARAMS-FRONT) (CURRENT-STENCIL-PARAMS-BACK CURRENT-STENCIL-PARAMS-BACK) (CURRENT-STENCIL-MASK-FRONT CURRENT-STENCIL-MASK-FRONT) (CURRENT-STENCIL-MASK-BACK CURRENT-STENCIL-MASK-BACK) (CURRENT-BLEND-PARAMS CURRENT-BLEND-PARAMS) (FBOS FBOS) (ARRAY-OF-BOUND-GPU-BUFFERS ARRAY-OF-BOUND-GPU-BUFFERS) (ARRAY-OF-GPU-BUFFERS ARRAY-OF-GPU-BUFFERS) (ARRAY-OF-UBO-BINDINGS-BUFFER-IDS ARRAY-OF-UBO-BINDINGS-BUFFER-IDS) (ARRAY-OF-UBO-BINDING-RANGES ARRAY-OF-UBO-BINDING-RANGES) (ARRAY-OF-SSBO-BINDINGS-BUFFER-IDS ARRAY-OF-SSBO-BINDINGS-BUFFER-IDS) (ARRAY-OF-SSBO-BINDING-RANGES ARRAY-OF-SSBO-BINDING-RANGES) (ARRAY-OF-TRANSFORM-FEEDBACK-BINDINGS-BUFFER-IDS ARRAY-OF-TRANSFORM-FEEDBACK-BINDINGS-BUFFER-IDS) (ARRAY-OF-BOUND-SAMPLERS ARRAY-OF-BOUND-SAMPLERS) (ARRAY-OF-BOUND-QUERIES ARRAY-OF-BOUND-QUERIES) (ARRAY-OF-TEXTURES ARRAY-OF-TEXTURES) (DEPTH-FUNC DEPTH-FUNC) (DEPTH-MASK DEPTH-MASK) (COLOR-MASKS COLOR-MASKS) (DEPTH-RANGE DEPTH-RANGE) (DEPTH-CLAMP DEPTH-CLAMP) (CULL-FACE CULL-FACE) (FRONT-FACE FRONT-FACE) (CLEAR-COLOR CLEAR-COLOR) (PACK-ALIGNMENT PACK-ALIGNMENT) (UNPACK-ALIGNMENT UNPACK-ALIGNMENT) (MAX-DRAW-BUFFER-COUNT MAX-DRAW-BUFFER-COUNT) (INSTANCE-COUNT INSTANCE-COUNT)
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%MAKE-CEPL-CONTEXT function}@c
@functionsubindex{%make-cepl-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%make-cube-texture} TEX-OBJ DIMENSIONS MIPMAP LAYER-COUNT CUBES BUFFER-STORAGE RECTANGLE IMMUTABLE INITIAL-CONTENTS IMAGE-FORMAT PIXEL-FORMAT GENERATE-MIPMAPS SAMPLES FIXED-SAMPLE-LOCATIONS
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>%MAKE-CUBE-TEXTURE function}@c
@functionsubindex{%make-cube-texture}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%make-default-framebuffer} DIMENSIONS &optional DOUBLE-BUFFERING DEPTH
@anchor{go to the CEPL<dot>FBOS<colon><colon>%MAKE-DEFAULT-FRAMEBUFFER function}@c
@functionsubindex{%make-default-framebuffer}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%make-glsl-stage-spec} NAME IN-ARGS UNIFORMS CONTEXT BODY-STRING COMPILED
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%MAKE-GLSL-STAGE-SPEC function}@c
@functionsubindex{%make-glsl-stage-spec}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%make-gpu-func-spec} NAME IN-ARGS UNIFORMS CONTEXT BODY SHARED EQUIVALENT-INARGS EQUIVALENT-UNIFORMS ACTUAL-UNIFORMS DOC-STRING DECLARATIONS MISSING-DEPENDENCIES DIFF-TAG
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%MAKE-GPU-FUNC-SPEC function}@c
@functionsubindex{%make-gpu-func-spec}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%make-stand-in-lisp-func-for-glsl-stage} SPEC
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%MAKE-STAND-IN-LISP-FUNC-FOR-GLSL-STAGE function}@c
@functionsubindex{%make-stand-in-lisp-func-for-glsl-stage}@c
Makes a regular lisp function with the same names and arguments
  (where possible) as the glsl-stage who's spec is provided.@*

  If called the function will throw an error saying that the function
  can't currently be used from the cpu.
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/glsl-stages<dot>lisp file, , @t{core/pipelines/glsl-stages.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%make-texture} TEX-OBJ DIMENSIONS MIPMAP LAYER-COUNT CUBES BUFFER-STORAGE RECTANGLE IMMUTABLE INITIAL-CONTENTS IMAGE-FORMAT PIXEL-FORMAT GENERATE-MIPMAPS SAMPLES FIXED-SAMPLE-LOCATIONS
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>%MAKE-TEXTURE function}@c
@functionsubindex{%make-texture}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%make-texture-with-lisp-data} TEX-OBJ DIMENSIONS MIPMAP LAYER-COUNT CUBES BUFFER-STORAGE RECTANGLE IMMUTABLE INITIAL-CONTENTS GENERATE-MIPMAPS ELEMENT-TYPE IMAGE-FORMAT PIXEL-FORMAT SAMPLES FIXED-SAMPLE-LOCATIONS
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>%MAKE-TEXTURE-WITH-LISP-DATA function}@c
@functionsubindex{%make-texture-with-lisp-data}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%memcpy} DESTINATION-POINTER SOURCE-POINTER BYTE-LENGTH
@anchor{go to the CEPL<dot>TYPES<colon><colon>%MEMCPY function}@c
@functionsubindex{%memcpy}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%pack-alignment} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%PACK-ALIGNMENT function}@c
@functionsubindex{%pack-alignment}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/pixel-store/pixel-store<dot>lisp file, , @t{core/pixel-store/pixel-store.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%per-attachment-blending-available-p} ()
@anchor{go to the CEPL<dot>FBOS<colon><colon>%PER-ATTACHMENT-BLENDING-AVAILABLE-P function}@c
@functionsubindex{%per-attachment-blending-available-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%post-init} FUNC
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%POST-INIT function}@c
@functionsubindex{%post-init}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%print-mem} POINTER &optional SIZE-IN-BYTES
@anchor{go to the CEPL-UTILS<colon><colon>%PRINT-MEM function}@c
@functionsubindex{%print-mem}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%process-with-gpu-array-range-macro-args} TARGET ACCESS-SET
@anchor{go to the CEPL<dot>GPU-ARRAYS<colon><colon>%PROCESS-WITH-GPU-ARRAY-RANGE-MACRO-ARGS function}@c
@functionsubindex{%process-with-gpu-array-range-macro-args}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS package, , @t{cepl.gpu-arrays}}
@item Source
@ref{go to the cepl/core/gpu-arrays/with-and-push<dot>lisp file, , @t{core/gpu-arrays/with-and-push.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%process-with-gpu-array-range-runtime} GPU-ARRAY START LENGTH
@anchor{go to the CEPL<dot>GPU-ARRAYS<colon><colon>%PROCESS-WITH-GPU-ARRAY-RANGE-RUNTIME function}@c
@functionsubindex{%process-with-gpu-array-range-runtime}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS package, , @t{cepl.gpu-arrays}}
@item Source
@ref{go to the cepl/core/gpu-arrays/with-and-push<dot>lisp file, , @t{core/gpu-arrays/with-and-push.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%pull-spec-common} ASSET-NAME
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%PULL-SPEC-COMMON function}@c
@functionsubindex{%pull-spec-common}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%register-ssbo-id} CTX SSBO-BINDING-POINT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%REGISTER-SSBO-ID function}@c
@functionsubindex{%register-ssbo-id}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%register-ubo-id} CTX UBO-BINDING-POINT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%REGISTER-UBO-ID function}@c
@functionsubindex{%register-ubo-id}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%sampler-context-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%SAMPLER-CONTEXT-ID function}@c
@functionsubindex{%sampler-context-id}@c
@deffnx {Function} {(setf %sampler-context-id)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF %SAMPLER-CONTEXT-ID) function}@c
@functionsubindex{(setf %sampler-context-id)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%scissor-viewport} ()
@anchor{go to the CEPL<dot>SCISSOR<colon><colon>%SCISSOR-VIEWPORT function}@c
@functionsubindex{%scissor-viewport}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SCISSOR package, , @t{cepl.scissor}}
@item Source
@ref{go to the cepl/core/scissor/scissor<dot>lisp file, , @t{core/scissor/scissor.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-border-color} SAMPLER VALUE
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>%SET-BORDER-COLOR function}@c
@functionsubindex{%set-border-color}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-color-mask} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%SET-COLOR-MASK function}@c
@functionsubindex{%set-color-mask}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/color/color<dot>lisp file, , @t{core/color/color.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-color-masks} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%SET-COLOR-MASKS function}@c
@functionsubindex{%set-color-masks}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/color/color<dot>lisp file, , @t{core/color/color.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-compare} SAMPLER VALUE
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>%SET-COMPARE function}@c
@functionsubindex{%set-compare}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-cull-face} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%SET-CULL-FACE function}@c
@functionsubindex{%set-cull-face}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/face/face<dot>lisp file, , @t{core/face/face.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-current-blend-params} ()
@anchor{go to the CEPL<dot>BLENDING<colon><colon>%SET-CURRENT-BLEND-PARAMS function}@c
@functionsubindex{%set-current-blend-params}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-current-blend-params-from-fbo} ()
@anchor{go to the CEPL<dot>BLENDING<colon><colon>%SET-CURRENT-BLEND-PARAMS-FROM-FBO function}@c
@functionsubindex{%set-current-blend-params-from-fbo}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-current-viewport} CEPL-CONTEXT VIEWPORT
@anchor{go to the CEPL<dot>VIEWPORTS<colon><colon>%SET-CURRENT-VIEWPORT function}@c
@functionsubindex{%set-current-viewport}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>VIEWPORTS package, , @t{cepl.viewports}}
@item Source
@ref{go to the cepl/core/viewports/viewport<dot>lisp file, , @t{core/viewports/viewport.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-default-fbo-and-viewport} SURFACE CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%SET-DEFAULT-FBO-AND-VIEWPORT function}@c
@functionsubindex{%set-default-fbo-and-viewport}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-default-fbo-viewport} NEW-DIMENSIONS
@anchor{go to the CEPL<dot>FBOS<colon><colon>%SET-DEFAULT-FBO-VIEWPORT function}@c
@functionsubindex{%set-default-fbo-viewport}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-depth-clamp} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%SET-DEPTH-CLAMP function}@c
@functionsubindex{%set-depth-clamp}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/depth/depth<dot>lisp file, , @t{core/depth/depth.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-depth-mask} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%SET-DEPTH-MASK function}@c
@functionsubindex{%set-depth-mask}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/depth/depth<dot>lisp file, , @t{core/depth/depth.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-depth-range-vec2} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%SET-DEPTH-RANGE-VEC2 function}@c
@functionsubindex{%set-depth-range-vec2}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/depth/depth<dot>lisp file, , @t{core/depth/depth.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-depth-test-function} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%SET-DEPTH-TEST-FUNCTION function}@c
@functionsubindex{%set-depth-test-function}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/depth/depth<dot>lisp file, , @t{core/depth/depth.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-draw-fbo-no-check} CEPL-CONTEXT FBO
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%SET-DRAW-FBO-NO-CHECK function}@c
@functionsubindex{%set-draw-fbo-no-check}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-fbo-bound} CEPL-CONTEXT FBO
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%SET-FBO-BOUND function}@c
@functionsubindex{%set-fbo-bound}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-fbo-no-check} CEPL-CONTEXT FBO
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%SET-FBO-NO-CHECK function}@c
@functionsubindex{%set-fbo-no-check}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-front-face} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%SET-FRONT-FACE function}@c
@functionsubindex{%set-front-face}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/face/face<dot>lisp file, , @t{core/face/face.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-lod-bias} SAMPLER VALUE
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>%SET-LOD-BIAS function}@c
@functionsubindex{%set-lod-bias}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-magnify-filter} SAMPLER VALUE
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>%SET-MAGNIFY-FILTER function}@c
@functionsubindex{%set-magnify-filter}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-max-lod} SAMPLER VALUE
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>%SET-MAX-LOD function}@c
@functionsubindex{%set-max-lod}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-min-lod} SAMPLER VALUE
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>%SET-MIN-LOD function}@c
@functionsubindex{%set-min-lod}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-minify-filter} SAMPLER VALUE
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>%SET-MINIFY-FILTER function}@c
@functionsubindex{%set-minify-filter}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-pack-alignment} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%SET-PACK-ALIGNMENT function}@c
@functionsubindex{%set-pack-alignment}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/pixel-store/pixel-store<dot>lisp file, , @t{core/pixel-store/pixel-store.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-read-fbo-no-check} CEPL-CONTEXT FBO
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%SET-READ-FBO-NO-CHECK function}@c
@functionsubindex{%set-read-fbo-no-check}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-resolution} VIEWPORT X Y
@anchor{go to the CEPL<dot>VIEWPORTS<colon><colon>%SET-RESOLUTION function}@c
@functionsubindex{%set-resolution}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>VIEWPORTS package, , @t{cepl.viewports}}
@item Source
@ref{go to the cepl/core/viewports/viewport<dot>lisp file, , @t{core/viewports/viewport.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-scissor-viewport} ()
@anchor{go to the CEPL<dot>SCISSOR<colon><colon>%SET-SCISSOR-VIEWPORT function}@c
@functionsubindex{%set-scissor-viewport}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SCISSOR package, , @t{cepl.scissor}}
@item Source
@ref{go to the cepl/core/scissor/scissor<dot>lisp file, , @t{core/scissor/scissor.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-unpack-alignment} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%SET-UNPACK-ALIGNMENT function}@c
@functionsubindex{%set-unpack-alignment}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/pixel-store/pixel-store<dot>lisp file, , @t{core/pixel-store/pixel-store.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%set-wrap} SAMPLER VALUE
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>%SET-WRAP function}@c
@functionsubindex{%set-wrap}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%stencil-mask} FACE CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%STENCIL-MASK function}@c
@functionsubindex{%stencil-mask}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/stencil/mask<dot>lisp file, , @t{core/stencil/mask.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%test-&-process-spec} SPEC &key CACHE-SPEC
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%TEST-&-PROCESS-SPEC function}@c
@functionsubindex{%test-&-process-spec}@c
Use varjo to compile the code.@*
   [0] If the compilation throws a could-not-find-function error, then record
   that missing function's name as a missing dependency.@*

   [1] If it succeeds then look at the list of used external-functions, and
   check which of the names of the macros match the names of a gpu function.
   The ones that match are the dependencies.@*

   [2] We also record the uniforms in the compiled result. The uniforms in the
   definition are the public interface, but the compiler may have removed or
   modified the uniforms. To this end we store the final uniforms and the forms
   that transform between the public uniform arguments and the internal ones.

   [3] We call 'add-layout-to-struct-uniforms' here to ensure that the ubo/ssbo
   arguments have the correct layout information. This is not important for
   the test compilation, but instead for the uniform information that is
   gathered from this test compile (actual-uniforms).
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%texture-dimensions} INITIAL-CONTENTS DIMENSIONS
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>%TEXTURE-DIMENSIONS function}@c
@functionsubindex{%texture-dimensions}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%unbind-fbo} ()
@anchor{go to the CEPL<dot>FBOS<colon><colon>%UNBIND-FBO function}@c
@functionsubindex{%unbind-fbo}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%unbind-tfs-arrays} CTX TFS
@anchor{go to the CEPL<dot>TRANSFORM-FEEDBACK<colon><colon>%UNBIND-TFS-ARRAYS function}@c
@functionsubindex{%unbind-tfs-arrays}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TRANSFORM-FEEDBACK package, , @t{cepl.transform-feedback}}
@item Source
@ref{go to the cepl/core/transform-feedback/transform-feedback<dot>lisp file, , @t{core/transform-feedback/transform-feedback.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%unpack-alignment} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%UNPACK-ALIGNMENT function}@c
@functionsubindex{%unpack-alignment}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/pixel-store/pixel-store<dot>lisp file, , @t{core/pixel-store/pixel-store.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%update-default-framebuffer-dimensions} X Y
@anchor{go to the CEPL<dot>VIEWPORTS<colon><colon>%UPDATE-DEFAULT-FRAMEBUFFER-DIMENSIONS function}@c
@functionsubindex{%update-default-framebuffer-dimensions}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>VIEWPORTS package, , @t{cepl.viewports}}
@item Source
@ref{go to the cepl/core/viewports/viewport<dot>lisp file, , @t{core/viewports/viewport.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%update-fbo-state} FBO
@anchor{go to the CEPL<dot>FBOS<colon><colon>%UPDATE-FBO-STATE function}@c
@functionsubindex{%update-fbo-state}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%update-glsl-stage-data} SPEC
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%UPDATE-GLSL-STAGE-DATA function}@c
@functionsubindex{%update-glsl-stage-data}@c
[0] Add or update the spec
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%update-gpu-function-data} SPEC DEPENDS-ON COMPILED
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%UPDATE-GPU-FUNCTION-DATA function}@c
@functionsubindex{%update-gpu-function-data}@c
[0] Add or update the spec@*

   [1] (re)subscribe to all the dependencies@*

   [2] cache the compile result so we can retrieve it with #'pull1-g
       or the code with #'pull-g
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%upload-tex} TEX TEX-TYPE LEVEL-NUM DIMENSIONS LAYER-NUM FACE-NUM PIX-FORMAT PIX-TYPE POINTER/OFFSET ROW-ALIGNMENT
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>%UPLOAD-TEX function}@c
@functionsubindex{%upload-tex}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%valid-index-type-p} X
@anchor{go to the %CEPL<dot>TYPES<colon><colon>%VALID-INDEX-TYPE-P function}@c
@functionsubindex{%valid-index-type-p}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%varjo-compile-as-pipeline} NAME PRIMITIVE PARSED-GPIPE-ARGS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>%VARJO-COMPILE-AS-PIPELINE function}@c
@functionsubindex{%varjo-compile-as-pipeline}@c
Compile the gpu functions for a pipeline@*
   The argument to this function is a list of pairs.
   Each pair contains:@*
   - the shader stage (e.g. vertex fragment etc)@*
   - the name of the gpu function to use for this stage
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {%with-context} VAR-NAME CEPL-CONTEXT FORGO-LET BODY CTX-VAR
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>%WITH-CONTEXT function}@c
@functionsubindex{%with-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {across-c} FUNCTION C-ARRAY
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>ACROSS-C function}@c
@functionsubindex{across-c}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/map<dot>lisp file, , @t{core/c-arrays/map.lisp}} (file)
@end table
@end deffn
@deffn {Function} {active-p} ()
@anchor{go to the CEPL<dot>LIFECYCLE<colon><colon>ACTIVE-P function}@c
@functionsubindex{active-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>LIFECYCLE package, , @t{cepl.lifecycle}}
@item Source
@ref{go to the cepl/core/lifecycle<dot>lisp file, , @t{core/lifecycle.lisp}} (file)
@end table
@end deffn
@deffn {Function} {add-compile-results-to-pipeline} NAME COMPILED-RESULTS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ADD-COMPILE-RESULTS-TO-PIPELINE function}@c
@functionsubindex{add-compile-results-to-pipeline}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Function} {add-layout-to-struct-uniforms} NAME TARGET-KIND UNIFORMS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ADD-LAYOUT-TO-STRUCT-UNIFORMS function}@c
@functionsubindex{add-layout-to-struct-uniforms}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {aggregate-uniforms} NAME TARGET-KIND FUNC-SPECS &optional ACTUAL-UNIFORMS-P
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>AGGREGATE-UNIFORMS function}@c
@functionsubindex{aggregate-uniforms}@c
The reason we need to aggregate uniforms is as follows:@*
   - pipelines are made of composed gpu functions@*
   - each gpu function may introduce uniforms@*
   - to this end we need to make sure the different functions' uniforms are
     compatible and then return a final list of aggregated uniforms.@*

   The way we do this is:@*
   [0] Remove all duplicates, this handles all cases where the same uniform is
       in different gpu-functions@*
   [1] Now if there is any more than one instance of each uniform name then
       there is a clash@*

   Sidenote:@*
   [X] We call 'add-layout-to-struct-uniforms' here to ensure that the ubo/ssbo
       arguments have the correct layout information. This is not important for
       the test compilation, but instead for the uniform information that is
       gathered from this test compile (actual-uniforms).
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {allocate-immutable-texture} TEXTURE
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>ALLOCATE-IMMUTABLE-TEXTURE function}@c
@functionsubindex{allocate-immutable-texture}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {allocate-mutable-texture} TEXTURE
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>ALLOCATE-MUTABLE-TEXTURE function}@c
@functionsubindex{allocate-mutable-texture}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {allocate-texture} TEXTURE
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>ALLOCATE-TEXTURE function}@c
@functionsubindex{allocate-texture}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {any-samples-passed-conservative-query-active-p} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>ANY-SAMPLES-PASSED-CONSERVATIVE-QUERY-ACTIVE-P function}@c
@functionsubindex{any-samples-passed-conservative-query-active-p}@c
@deffnx {Function} {(setf any-samples-passed-conservative-query-active-p)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF ANY-SAMPLES-PASSED-CONSERVATIVE-QUERY-ACTIVE-P) function}@c
@functionsubindex{(setf any-samples-passed-conservative-query-active-p)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {any-samples-passed-conservative-query-cache-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>ANY-SAMPLES-PASSED-CONSERVATIVE-QUERY-CACHE-ID function}@c
@functionsubindex{any-samples-passed-conservative-query-cache-id}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {any-samples-passed-conservative-query-enum} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>ANY-SAMPLES-PASSED-CONSERVATIVE-QUERY-ENUM function}@c
@functionsubindex{any-samples-passed-conservative-query-enum}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {any-samples-passed-conservative-query-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>ANY-SAMPLES-PASSED-CONSERVATIVE-QUERY-ID function}@c
@functionsubindex{any-samples-passed-conservative-query-id}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {any-samples-passed-conservative-query-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>ANY-SAMPLES-PASSED-CONSERVATIVE-QUERY-P function}@c
@functionsubindex{any-samples-passed-conservative-query-p}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {any-samples-passed-query-active-p} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>ANY-SAMPLES-PASSED-QUERY-ACTIVE-P function}@c
@functionsubindex{any-samples-passed-query-active-p}@c
@deffnx {Function} {(setf any-samples-passed-query-active-p)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF ANY-SAMPLES-PASSED-QUERY-ACTIVE-P) function}@c
@functionsubindex{(setf any-samples-passed-query-active-p)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {any-samples-passed-query-cache-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>ANY-SAMPLES-PASSED-QUERY-CACHE-ID function}@c
@functionsubindex{any-samples-passed-query-cache-id}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {any-samples-passed-query-enum} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>ANY-SAMPLES-PASSED-QUERY-ENUM function}@c
@functionsubindex{any-samples-passed-query-enum}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {any-samples-passed-query-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>ANY-SAMPLES-PASSED-QUERY-ID function}@c
@functionsubindex{any-samples-passed-query-id}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {any-samples-passed-query-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>ANY-SAMPLES-PASSED-QUERY-P function}@c
@functionsubindex{any-samples-passed-query-p}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {aref-c*-1d} C-ARRAY X
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>AREF-C*-1D function}@c
@functionsubindex{aref-c*-1d}@c
@deffnx {Function} {(setf aref-c*-1d)} VALUE C-ARRAY X
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>(SETF AREF-C*-1D) function}@c
@functionsubindex{(setf aref-c*-1d)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/aref-c<dot>lisp file, , @t{core/c-arrays/aref-c.lisp}} (file)
@end table
@end deffn
@deffn {Function} {aref-c*-2d} C-ARRAY X Y
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>AREF-C*-2D function}@c
@functionsubindex{aref-c*-2d}@c
@deffnx {Function} {(setf aref-c*-2d)} VALUE C-ARRAY X Y
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>(SETF AREF-C*-2D) function}@c
@functionsubindex{(setf aref-c*-2d)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/aref-c<dot>lisp file, , @t{core/c-arrays/aref-c.lisp}} (file)
@end table
@end deffn
@deffn {Function} {aref-c*-3d} C-ARRAY X Y Z
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>AREF-C*-3D function}@c
@functionsubindex{aref-c*-3d}@c
@deffnx {Function} {(setf aref-c*-3d)} VALUE C-ARRAY X Y Z
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>(SETF AREF-C*-3D) function}@c
@functionsubindex{(setf aref-c*-3d)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/aref-c<dot>lisp file, , @t{core/c-arrays/aref-c.lisp}} (file)
@end table
@end deffn
@deffn {Function} {aref-c*-4d} C-ARRAY X Y Z W
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>AREF-C*-4D function}@c
@functionsubindex{aref-c*-4d}@c
@deffnx {Function} {(setf aref-c*-4d)} VALUE C-ARRAY X Y Z W
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>(SETF AREF-C*-4D) function}@c
@functionsubindex{(setf aref-c*-4d)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/aref-c<dot>lisp file, , @t{core/c-arrays/aref-c.lisp}} (file)
@end table
@end deffn
@deffn {Function} {arrays-indirect-command-p} OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ARRAYS-INDIRECT-COMMAND-P function}@c
@functionsubindex{arrays-indirect-command-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/multi-draw<dot>lisp file, , @t{core/pipelines/multi-draw.lisp}} (file)
@end table
@end deffn
@deffn {Function} {arrays-indirect-command-pointer} INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ARRAYS-INDIRECT-COMMAND-POINTER function}@c
@functionsubindex{arrays-indirect-command-pointer}@c
@deffnx {Function} {(setf arrays-indirect-command-pointer)} VALUE INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF ARRAYS-INDIRECT-COMMAND-POINTER) function}@c
@functionsubindex{(setf arrays-indirect-command-pointer)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/multi-draw<dot>lisp file, , @t{core/pipelines/multi-draw.lisp}} (file)
@end table
@end deffn
@deffn {Function} {assendingp} LIST
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ASSENDINGP function}@c
@functionsubindex{assendingp}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/pipeline-validation<dot>lisp file, , @t{core/pipelines/pipeline-validation.lisp}} (file)
@end table
@end deffn
@deffn {Function} {assert-arg-format} GFUNC-NAME X
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ASSERT-ARG-FORMAT function}@c
@functionsubindex{assert-arg-format}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {assert-glsl-arg-format} NAME ARG
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ASSERT-GLSL-ARG-FORMAT function}@c
@functionsubindex{assert-glsl-arg-format}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/glsl-stages<dot>lisp file, , @t{core/pipelines/glsl-stages.lisp}} (file)
@end table
@end deffn
@deffn {Function} {assert-glsl-stage-types} IN-ARGS UNIFORMS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ASSERT-GLSL-STAGE-TYPES function}@c
@functionsubindex{assert-glsl-stage-types}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/glsl-stages<dot>lisp file, , @t{core/pipelines/glsl-stages.lisp}} (file)
@end table
@end deffn
@deffn {Function} {assert-layout-consistent} G-STRUCT-INFO TARGET-LAYOUT
@anchor{go to the CEPL<dot>TYPES<colon><colon>ASSERT-LAYOUT-CONSISTENT function}@c
@functionsubindex{assert-layout-consistent}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {assert-no-other-context-is-bound-to-thread} THIS-THREAD
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>ASSERT-NO-OTHER-CONTEXT-IS-BOUND-TO-THREAD function}@c
@functionsubindex{assert-no-other-context-is-bound-to-thread}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {assert-valid-args-for-buffer-backed-texture} IMAGE-FORMAT CUBES RECTANGLE MULTISAMPLE MIPMAP LAYER-COUNT TEXTURE-TYPE
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>ASSERT-VALID-ARGS-FOR-BUFFER-BACKED-TEXTURE function}@c
@functionsubindex{assert-valid-args-for-buffer-backed-texture}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {assert-valid-gpipe-form} PIPELINE-NAME GPIPE-ARGS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ASSERT-VALID-GPIPE-FORM function}@c
@functionsubindex{assert-valid-gpipe-form}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/pipeline-validation<dot>lisp file, , @t{core/pipelines/pipeline-validation.lisp}} (file)
@end table
@end deffn
@deffn {Function} {assert-valid-gpipe-shader-implicit-form} PIPELINE-NAME GPIPE-ARGS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ASSERT-VALID-GPIPE-SHADER-IMPLICIT-FORM function}@c
@functionsubindex{assert-valid-gpipe-shader-implicit-form}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/pipeline-validation<dot>lisp file, , @t{core/pipelines/pipeline-validation.lisp}} (file)
@end table
@end deffn
@deffn {Function} {assert-valid-stage-specs} NAMES
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ASSERT-VALID-STAGE-SPECS function}@c
@functionsubindex{assert-valid-stage-specs}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/pipeline-validation<dot>lisp file, , @t{core/pipelines/pipeline-validation.lisp}} (file)
@end table
@end deffn
@deffn {Function} {att-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>ATT-P function}@c
@functionsubindex{att-p}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {attachment-compatible} ATTACHMENT-NAME IMAGE-FORMAT &optional FOR-BIND
@anchor{go to the CEPL<dot>FBOS<colon><colon>ATTACHMENT-COMPATIBLE function}@c
@functionsubindex{attachment-compatible}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {attachment-pattern*} VALS
@anchor{go to the CEPL<dot>FBOS<colon><colon>ATTACHMENT-PATTERN* function}@c
@functionsubindex{attachment-pattern*}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {attachment-viewport-allowing-t} FBO ATTACHMENT-NAME
@anchor{go to the CEPL<dot>FBOS<colon><colon>ATTACHMENT-VIEWPORT-ALLOWING-T function}@c
@functionsubindex{attachment-viewport-allowing-t}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {bake-and-g->} CONTEXT-WITH-PRIMITIVE PRIMITIVE STAGE-PAIRS UNIFORMS-TO-BAKE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>BAKE-AND-G-> function}@c
@functionsubindex{bake-and-g->}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/bake<dot>lisp file, , @t{core/pipelines/bake.lisp}} (file)
@end table
@end deffn
@deffn {Function} {base-gstruct-wrapper-p} OBJECT
@anchor{go to the CEPL<dot>TYPES<colon><colon>BASE-GSTRUCT-WRAPPER-P function}@c
@functionsubindex{base-gstruct-wrapper-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {base-gstruct-wrapper-pointer} INSTANCE
@anchor{go to the CEPL<dot>TYPES<colon><colon>BASE-GSTRUCT-WRAPPER-POINTER function}@c
@functionsubindex{base-gstruct-wrapper-pointer}@c
@deffnx {Function} {(setf base-gstruct-wrapper-pointer)} VALUE INSTANCE
@anchor{go to the CEPL<dot>TYPES<colon><colon>(SETF BASE-GSTRUCT-WRAPPER-POINTER) function}@c
@functionsubindex{(setf base-gstruct-wrapper-pointer)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {begin-scoped-gpu-query} QUERY
@anchor{go to the CEPL<dot>QUERIES<colon><colon>BEGIN-SCOPED-GPU-QUERY function}@c
@functionsubindex{begin-scoped-gpu-query}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>QUERIES package, , @t{cepl.queries}}
@item Source
@ref{go to the cepl/core/queries/query<dot>lisp file, , @t{core/queries/query.lisp}} (file)
@end table
@end deffn
@deffn {Function} {bind-scratch-texture} ()
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>BIND-SCRATCH-TEXTURE function}@c
@functionsubindex{bind-scratch-texture}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/def<dot>lisp file, , @t{core/textures/def.lisp}} (file)
@end table
@end deffn
@deffn {Function} {blank-buffer-object} BUFFER
@anchor{go to the CEPL<dot>GPU-BUFFERS<colon><colon>BLANK-BUFFER-OBJECT function}@c
@functionsubindex{blank-buffer-object}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-BUFFERS package, , @t{cepl.gpu-buffers}}
@item Source
@ref{go to the cepl/core/gpu-buffers/gpu-buffers<dot>lisp file, , @t{core/gpu-buffers/gpu-buffers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {blank-buffer-stream} BUFFER-STREAM
@anchor{go to the CEPL<dot>STREAMS<colon><colon>BLANK-BUFFER-STREAM function}@c
@functionsubindex{blank-buffer-stream}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>STREAMS package, , @t{cepl.streams}}
@item Source
@ref{go to the cepl/core/streams/buffer-streams<dot>lisp file, , @t{core/streams/buffer-streams.lisp}} (file)
@end table
@end deffn
@deffn {Function} {blank-c-array-object} C-ARRAY
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>BLANK-C-ARRAY-OBJECT function}@c
@functionsubindex{blank-c-array-object}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/def<dot>lisp file, , @t{core/c-arrays/def.lisp}} (file)
@end table
@end deffn
@deffn {Function} {blank-gpu-array-b-object} GPU-ARRAY
@anchor{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED<colon><colon>BLANK-GPU-ARRAY-B-OBJECT function}@c
@functionsubindex{blank-gpu-array-b-object}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED package, , @t{cepl.gpu-arrays.buffer-backed}}
@item Source
@ref{go to the cepl/core/gpu-arrays/buffer-backed<dot>lisp file, , @t{core/gpu-arrays/buffer-backed.lisp}} (file)
@end table
@end deffn
@deffn {Function} {blank-texture-object} TEXTURE
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>BLANK-TEXTURE-OBJECT function}@c
@functionsubindex{blank-texture-object}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/def<dot>lisp file, , @t{core/textures/def.lisp}} (file)
@end table
@end deffn
@deffn {Function} {blend-func-namep} KEYWORD
@anchor{go to the CEPL<dot>BLENDING<colon><colon>BLEND-FUNC-NAMEP function}@c
@functionsubindex{blend-func-namep}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@end table
@end deffn
@deffn {Function} {boop-p} OBJECT
@anchor{go to the DEFXSTAR-HIDDEN<colon><colon>BOOP-P function}@c
@functionsubindex{boop-p}@c
@table @strong
@item Package
@ref{go to the DEFXSTAR-HIDDEN package, , @t{defxstar-hidden}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {boop-x} INSTANCE
@anchor{go to the DEFXSTAR-HIDDEN<colon><colon>BOOP-X function}@c
@functionsubindex{boop-x}@c
@deffnx {Function} {(setf boop-x)} VALUE INSTANCE
@anchor{go to the DEFXSTAR-HIDDEN<colon><colon>(SETF BOOP-X) function}@c
@functionsubindex{(setf boop-x)}@c
@table @strong
@item Package
@ref{go to the DEFXSTAR-HIDDEN package, , @t{defxstar-hidden}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {boop-y} INSTANCE
@anchor{go to the DEFXSTAR-HIDDEN<colon><colon>BOOP-Y function}@c
@functionsubindex{boop-y}@c
@deffnx {Function} {(setf boop-y)} VALUE INSTANCE
@anchor{go to the DEFXSTAR-HIDDEN<colon><colon>(SETF BOOP-Y) function}@c
@functionsubindex{(setf boop-y)}@c
@table @strong
@item Package
@ref{go to the DEFXSTAR-HIDDEN package, , @t{defxstar-hidden}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {border-color} SAMPLER
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>BORDER-COLOR function}@c
@functionsubindex{border-color}@c
@deffnx {Function} {(setf border-color)} VALUE SAMPLER
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>(SETF BORDER-COLOR) function}@c
@functionsubindex{(setf border-color)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {(setf border-color)} VALUE TEXTURE
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>(SETF BORDER-COLOR) function}@c
@functionsubindex{(setf border-color)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/texture-samplers<dot>lisp file, , @t{core/textures/texture-samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-bound-static} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>BUFFER-BOUND-STATIC function}@c
@functionsubindex{buffer-bound-static}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-kind->cache-index} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>BUFFER-KIND->CACHE-INDEX function}@c
@functionsubindex{buffer-kind->cache-index}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-kind->enum} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>BUFFER-KIND->ENUM function}@c
@functionsubindex{buffer-kind->enum}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-reserve-block-raw} BUFFER BYTE-SIZE TARGET USAGE
@anchor{go to the CEPL<dot>GPU-BUFFERS<colon><colon>BUFFER-RESERVE-BLOCK-RAW function}@c
@functionsubindex{buffer-reserve-block-raw}@c

This function creates an empty block of data in the opengl buffer.@*
It will remove ALL data currently in the buffer.@*

It also will not update the format of the buffer so you must be sure to handle
this yourself. It is much safer to use this as an assistant function to one
which takes care of these issues
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-BUFFERS package, , @t{cepl.gpu-buffers}}
@item Source
@ref{go to the cepl/core/gpu-buffers/gpu-buffers<dot>lisp file, , @t{core/gpu-buffers/gpu-buffers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-reserve-blocks-from-sizes} BUFFER BYTE-SIZES TARGET USAGE
@anchor{go to the CEPL<dot>GPU-BUFFERS<colon><colon>BUFFER-RESERVE-BLOCKS-FROM-SIZES function}@c
@functionsubindex{buffer-reserve-blocks-from-sizes}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-BUFFERS package, , @t{cepl.gpu-buffers}}
@item Source
@ref{go to the cepl/core/gpu-buffers/gpu-buffers<dot>lisp file, , @t{core/gpu-buffers/gpu-buffers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-set-arrays-from-sizes} BUFFER BYTE-SIZES USAGE
@anchor{go to the CEPL<dot>GPU-BUFFERS<colon><colon>BUFFER-SET-ARRAYS-FROM-SIZES function}@c
@functionsubindex{buffer-set-arrays-from-sizes}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-BUFFERS package, , @t{cepl.gpu-buffers}}
@item Source
@ref{go to the cepl/core/gpu-buffers/gpu-buffers<dot>lisp file, , @t{core/gpu-buffers/gpu-buffers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-stream-compatible-typep} SLOT
@anchor{go to the CEPL<dot>TYPES<colon><colon>BUFFER-STREAM-COMPATIBLE-TYPEP function}@c
@functionsubindex{buffer-stream-compatible-typep}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-texture-allocated-p} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-TEXTURE-ALLOCATED-P function}@c
@functionsubindex{buffer-texture-allocated-p}@c
@deffnx {Function} {(setf buffer-texture-allocated-p)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-TEXTURE-ALLOCATED-P) function}@c
@functionsubindex{(setf buffer-texture-allocated-p)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-texture-base-dimensions} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-TEXTURE-BASE-DIMENSIONS function}@c
@functionsubindex{buffer-texture-base-dimensions}@c
@deffnx {Function} {(setf buffer-texture-base-dimensions)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-TEXTURE-BASE-DIMENSIONS) function}@c
@functionsubindex{(setf buffer-texture-base-dimensions)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-texture-cache-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-TEXTURE-CACHE-ID function}@c
@functionsubindex{buffer-texture-cache-id}@c
@deffnx {Function} {(setf buffer-texture-cache-id)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-TEXTURE-CACHE-ID) function}@c
@functionsubindex{(setf buffer-texture-cache-id)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-texture-cubes-p} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-TEXTURE-CUBES-P function}@c
@functionsubindex{buffer-texture-cubes-p}@c
@deffnx {Function} {(setf buffer-texture-cubes-p)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-TEXTURE-CUBES-P) function}@c
@functionsubindex{(setf buffer-texture-cubes-p)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-texture-fixed-sample-locations-p} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-TEXTURE-FIXED-SAMPLE-LOCATIONS-P function}@c
@functionsubindex{buffer-texture-fixed-sample-locations-p}@c
@deffnx {Function} {(setf buffer-texture-fixed-sample-locations-p)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-TEXTURE-FIXED-SAMPLE-LOCATIONS-P) function}@c
@functionsubindex{(setf buffer-texture-fixed-sample-locations-p)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-texture-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-TEXTURE-ID function}@c
@functionsubindex{buffer-texture-id}@c
@deffnx {Function} {(setf buffer-texture-id)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-TEXTURE-ID) function}@c
@functionsubindex{(setf buffer-texture-id)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-texture-image-format} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-TEXTURE-IMAGE-FORMAT function}@c
@functionsubindex{buffer-texture-image-format}@c
@deffnx {Function} {(setf buffer-texture-image-format)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-TEXTURE-IMAGE-FORMAT) function}@c
@functionsubindex{(setf buffer-texture-image-format)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-texture-last-sampler-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-TEXTURE-LAST-SAMPLER-ID function}@c
@functionsubindex{buffer-texture-last-sampler-id}@c
@deffnx {Function} {(setf buffer-texture-last-sampler-id)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-TEXTURE-LAST-SAMPLER-ID) function}@c
@functionsubindex{(setf buffer-texture-last-sampler-id)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-texture-layer-count} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-TEXTURE-LAYER-COUNT function}@c
@functionsubindex{buffer-texture-layer-count}@c
@deffnx {Function} {(setf buffer-texture-layer-count)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-TEXTURE-LAYER-COUNT) function}@c
@functionsubindex{(setf buffer-texture-layer-count)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-texture-mipmap-levels} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-TEXTURE-MIPMAP-LEVELS function}@c
@functionsubindex{buffer-texture-mipmap-levels}@c
@deffnx {Function} {(setf buffer-texture-mipmap-levels)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-TEXTURE-MIPMAP-LEVELS) function}@c
@functionsubindex{(setf buffer-texture-mipmap-levels)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-texture-mutable-p} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-TEXTURE-MUTABLE-P function}@c
@functionsubindex{buffer-texture-mutable-p}@c
@deffnx {Function} {(setf buffer-texture-mutable-p)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-TEXTURE-MUTABLE-P) function}@c
@functionsubindex{(setf buffer-texture-mutable-p)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-texture-samples} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-TEXTURE-SAMPLES function}@c
@functionsubindex{buffer-texture-samples}@c
@deffnx {Function} {(setf buffer-texture-samples)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-TEXTURE-SAMPLES) function}@c
@functionsubindex{(setf buffer-texture-samples)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {buffer-texture-type} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>BUFFER-TEXTURE-TYPE function}@c
@functionsubindex{buffer-texture-type}@c
@deffnx {Function} {(setf buffer-texture-type)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF BUFFER-TEXTURE-TYPE) function}@c
@functionsubindex{(setf buffer-texture-type)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {c-arr-to-lisp-struct-elems} C-ARRAY
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>C-ARR-TO-LISP-STRUCT-ELEMS function}@c
@functionsubindex{c-arr-to-lisp-struct-elems}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/rest<dot>lisp file, , @t{core/c-arrays/rest.lisp}} (file)
@end table
@end deffn
@deffn {Function} {c-arr-to-lisp-val-elems} C-ARRAY
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>C-ARR-TO-LISP-VAL-ELEMS function}@c
@functionsubindex{c-arr-to-lisp-val-elems}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/rest<dot>lisp file, , @t{core/c-arrays/rest.lisp}} (file)
@end table
@end deffn
@deffn {Function} {c-array-byte-size} C-ARRAY
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>C-ARRAY-BYTE-SIZE function}@c
@functionsubindex{c-array-byte-size}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/populate<dot>lisp file, , @t{core/c-arrays/populate.lisp}} (file)
@end table
@end deffn
@deffn {Function} {c-array-rank} C-ARRAY
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>C-ARRAY-RANK function}@c
@functionsubindex{c-array-rank}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/def<dot>lisp file, , @t{core/c-arrays/def.lisp}} (file)
@end table
@end deffn
@deffn {Function} {calc-aligned-offset} BASE-OFFSET BASE-ALIGNMENT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>CALC-ALIGNED-OFFSET function}@c
@functionsubindex{calc-aligned-offset}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/layout<dot>lisp file, , @t{core/types/layout.lisp}} (file)
@end table
@end deffn
@deffn {Function} {calc-array-of-col-mat-layout} LAYOUT-SPECIFIER NAME PARENT-TYPE-BASE-OFFSET PARENT-TYPE-ALIGNED-OFFSET LAST-SLOT-BASE-OFFSET LAST-SLOT-ALIGNED-OFFSET LAST-SLOT-MACHINE-SIZE TYPE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>CALC-ARRAY-OF-COL-MAT-LAYOUT function}@c
@functionsubindex{calc-array-of-col-mat-layout}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/layout<dot>lisp file, , @t{core/types/layout.lisp}} (file)
@end table
@end deffn
@deffn {Function} {calc-array-of-scalar-or-vectors-layout} LAYOUT-SPECIFIER NAME PARENT-TYPE-BASE-OFFSET PARENT-TYPE-ALIGNED-OFFSET LAST-SLOT-BASE-OFFSET LAST-SLOT-ALIGNED-OFFSET LAST-SLOT-MACHINE-SIZE TYPE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>CALC-ARRAY-OF-SCALAR-OR-VECTORS-LAYOUT function}@c
@functionsubindex{calc-array-of-scalar-or-vectors-layout}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/layout<dot>lisp file, , @t{core/types/layout.lisp}} (file)
@end table
@end deffn
@deffn {Function} {calc-array-of-structs-layout} LAYOUT-SPECIFIER NAME PARENT-TYPE-BASE-OFFSET PARENT-TYPE-ALIGNED-OFFSET LAST-SLOT-BASE-OFFSET LAST-SLOT-ALIGNED-OFFSET LAST-SLOT-MACHINE-SIZE TYPE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>CALC-ARRAY-OF-STRUCTS-LAYOUT function}@c
@functionsubindex{calc-array-of-structs-layout}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/layout<dot>lisp file, , @t{core/types/layout.lisp}} (file)
@end table
@end deffn
@deffn {Function} {calc-base-offset} PARENT-TYPE-ALIGNED-OFFSET LAST-SLOT-BASE-OFFSET LAST-SLOT-ALIGNED-OFFSET LAST-SLOT-MACHINE-SIZE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>CALC-BASE-OFFSET function}@c
@functionsubindex{calc-base-offset}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/layout<dot>lisp file, , @t{core/types/layout.lisp}} (file)
@end table
@end deffn
@deffn {Function} {calc-col-mat-layout} LAYOUT-SPECIFIER NAME PARENT-TYPE-BASE-OFFSET PARENT-TYPE-ALIGNED-OFFSET LAST-SLOT-BASE-OFFSET LAST-SLOT-ALIGNED-OFFSET LAST-SLOT-MACHINE-SIZE TYPE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>CALC-COL-MAT-LAYOUT function}@c
@functionsubindex{calc-col-mat-layout}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/layout<dot>lisp file, , @t{core/types/layout.lisp}} (file)
@end table
@end deffn
@deffn {Function} {calc-feedback-style-and-names} VARYING-PAIRS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>CALC-FEEDBACK-STYLE-AND-NAMES function}@c
@functionsubindex{calc-feedback-style-and-names}@c
returns the mode, the var names & the number of streams
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {calc-image-format} ELEMENT-TYPE INITIAL-CONTENTS
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>CALC-IMAGE-FORMAT function}@c
@functionsubindex{calc-image-format}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {calc-layout} LAYOUT-SPECIFIER NAME PARENT-TYPE-BASE-OFFSET PARENT-TYPE-ALIGNED-OFFSET LAST-SLOT-BASE-OFFSET LAST-SLOT-ALIGNED-OFFSET LAST-SLOT-MACHINE-SIZE TYPE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>CALC-LAYOUT function}@c
@functionsubindex{calc-layout}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/layout<dot>lisp file, , @t{core/types/layout.lisp}} (file)
@end table
@end deffn
@deffn {Function} {calc-max-num-mipmap-levels} DIMENSIONS
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>CALC-MAX-NUM-MIPMAP-LEVELS function}@c
@functionsubindex{calc-max-num-mipmap-levels}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {calc-minify-filter} BETWEEN-ARRAYS-ON-THIS-LEVEL BETWEEN-ARRAYS-ON-DIFFERENT-LEVELS
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>CALC-MINIFY-FILTER function}@c
@functionsubindex{calc-minify-filter}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {calc-query-get-func-for-gpu-array} ARR
@anchor{go to the CEPL<dot>QUERIES<colon><colon>CALC-QUERY-GET-FUNC-FOR-GPU-ARRAY function}@c
@functionsubindex{calc-query-get-func-for-gpu-array}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>QUERIES package, , @t{cepl.queries}}
@item Source
@ref{go to the cepl/core/queries/query<dot>lisp file, , @t{core/queries/query.lisp}} (file)
@end table
@end deffn
@deffn {Function} {calc-sampler-type} TEXTURE-TYPE IMAGE-FORMAT &optional SHADOW-SAMPLER
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>CALC-SAMPLER-TYPE function}@c
@functionsubindex{calc-sampler-type}@c
Makes the keyword that names the sampler-type for the given texture-type and format
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {calc-scalar-layout} LAYOUT-SPECIFIER NAME PARENT-TYPE-ALIGNED-OFFSET LAST-SLOT-BASE-OFFSET LAST-SLOT-ALIGNED-OFFSET LAST-SLOT-MACHINE-SIZE TYPE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>CALC-SCALAR-LAYOUT function}@c
@functionsubindex{calc-scalar-layout}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/layout<dot>lisp file, , @t{core/types/layout.lisp}} (file)
@end table
@end deffn
@deffn {Function} {calc-struct-layout} LAYOUT-SPECIFIER NAME PARENT-TYPE-ALIGNED-OFFSET LAST-SLOT-BASE-OFFSET LAST-SLOT-ALIGNED-OFFSET LAST-SLOT-MACHINE-SIZE TYPE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>CALC-STRUCT-LAYOUT function}@c
@functionsubindex{calc-struct-layout}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/layout<dot>lisp file, , @t{core/types/layout.lisp}} (file)
@end table
@end deffn
@deffn {Function} {calc-struct-member-layout} LAYOUT-SPECIFIER MEMBER-NAME-TYPE-PAIRS PARENT-TYPE-ALIGNED-OFFSET LAST-SLOT-BASE-OFFSET LAST-SLOT-ALIGNED-OFFSET LAST-SLOT-MACHINE-SIZE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>CALC-STRUCT-MEMBER-LAYOUT function}@c
@functionsubindex{calc-struct-member-layout}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/layout<dot>lisp file, , @t{core/types/layout.lisp}} (file)
@end table
@end deffn
@deffn {Function} {calc-vector-base-alignment} TYPE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>CALC-VECTOR-BASE-ALIGNMENT function}@c
@functionsubindex{calc-vector-base-alignment}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/layout<dot>lisp file, , @t{core/types/layout.lisp}} (file)
@end table
@end deffn
@deffn {Function} {calc-vector-layout} LAYOUT-SPECIFIER NAME PARENT-TYPE-ALIGNED-OFFSET LAST-SLOT-BASE-OFFSET LAST-SLOT-ALIGNED-OFFSET LAST-SLOT-MACHINE-SIZE TYPE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>CALC-VECTOR-LAYOUT function}@c
@functionsubindex{calc-vector-layout}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/layout<dot>lisp file, , @t{core/types/layout.lisp}} (file)
@end table
@end deffn
@deffn {Function} {call-listeners} ()
@anchor{go to the CEPL<dot>LIFECYCLE<colon><colon>CALL-LISTENERS function}@c
@functionsubindex{call-listeners}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>LIFECYCLE package, , @t{cepl.lifecycle}}
@item Source
@ref{go to the cepl/core/lifecycle<dot>lisp file, , @t{core/lifecycle.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl-client-wait-sync} SYNC FLAGS TIMEOUT
@anchor{go to the CEPL<dot>SYNC<colon><colon>CEPL-CLIENT-WAIT-SYNC function}@c
@functionsubindex{cepl-client-wait-sync}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SYNC package, , @t{cepl.sync}}
@item Source
@ref{go to the cepl/core/sync/sync<dot>lisp file, , @t{core/sync/sync.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl-context-p} OBJECT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>CEPL-CONTEXT-P function}@c
@functionsubindex{cepl-context-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.pipelines.arrays-indirect-command.from-foreign} ()
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>PIPELINES<dot>ARRAYS-INDIRECT-COMMAND<dot>FROM-FOREIGN function}@c
@functionsubindex{cepl.pipelines.arrays-indirect-command.from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/pipelines/multi-draw<dot>lisp file, , @t{core/pipelines/multi-draw.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.pipelines.arrays-indirect-command.make} POINTER
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>PIPELINES<dot>ARRAYS-INDIRECT-COMMAND<dot>MAKE function}@c
@functionsubindex{cepl.pipelines.arrays-indirect-command.make}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/pipelines/multi-draw<dot>lisp file, , @t{core/pipelines/multi-draw.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.pipelines.arrays-indirect-command.to-foreign} ()
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>PIPELINES<dot>ARRAYS-INDIRECT-COMMAND<dot>TO-FOREIGN function}@c
@functionsubindex{cepl.pipelines.arrays-indirect-command.to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/pipelines/multi-draw<dot>lisp file, , @t{core/pipelines/multi-draw.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.pipelines.elements-indirect-command.from-foreign} ()
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>PIPELINES<dot>ELEMENTS-INDIRECT-COMMAND<dot>FROM-FOREIGN function}@c
@functionsubindex{cepl.pipelines.elements-indirect-command.from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/pipelines/multi-draw<dot>lisp file, , @t{core/pipelines/multi-draw.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.pipelines.elements-indirect-command.make} POINTER
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>PIPELINES<dot>ELEMENTS-INDIRECT-COMMAND<dot>MAKE function}@c
@functionsubindex{cepl.pipelines.elements-indirect-command.make}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/pipelines/multi-draw<dot>lisp file, , @t{core/pipelines/multi-draw.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.pipelines.elements-indirect-command.to-foreign} ()
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>PIPELINES<dot>ELEMENTS-INDIRECT-COMMAND<dot>TO-FOREIGN function}@c
@functionsubindex{cepl.pipelines.elements-indirect-command.to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/pipelines/multi-draw<dot>lisp file, , @t{core/pipelines/multi-draw.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pc.from-foreign} ()
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PC<dot>FROM-FOREIGN function}@c
@functionsubindex{cepl.types.predefined.g-pc.from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pc.make} POINTER
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PC<dot>MAKE function}@c
@functionsubindex{cepl.types.predefined.g-pc.make}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pc.to-foreign} ()
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PC<dot>TO-FOREIGN function}@c
@functionsubindex{cepl.types.predefined.g-pc.to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pn.from-foreign} ()
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PN<dot>FROM-FOREIGN function}@c
@functionsubindex{cepl.types.predefined.g-pn.from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pn.make} POINTER
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PN<dot>MAKE function}@c
@functionsubindex{cepl.types.predefined.g-pn.make}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pn.to-foreign} ()
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PN<dot>TO-FOREIGN function}@c
@functionsubindex{cepl.types.predefined.g-pn.to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pnb.from-foreign} ()
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PNB<dot>FROM-FOREIGN function}@c
@functionsubindex{cepl.types.predefined.g-pnb.from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pnb.make} POINTER
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PNB<dot>MAKE function}@c
@functionsubindex{cepl.types.predefined.g-pnb.make}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pnb.to-foreign} ()
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PNB<dot>TO-FOREIGN function}@c
@functionsubindex{cepl.types.predefined.g-pnb.to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pnc.from-foreign} ()
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PNC<dot>FROM-FOREIGN function}@c
@functionsubindex{cepl.types.predefined.g-pnc.from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pnc.make} POINTER
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PNC<dot>MAKE function}@c
@functionsubindex{cepl.types.predefined.g-pnc.make}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pnc.to-foreign} ()
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PNC<dot>TO-FOREIGN function}@c
@functionsubindex{cepl.types.predefined.g-pnc.to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pncb.from-foreign} ()
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PNCB<dot>FROM-FOREIGN function}@c
@functionsubindex{cepl.types.predefined.g-pncb.from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pncb.make} POINTER
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PNCB<dot>MAKE function}@c
@functionsubindex{cepl.types.predefined.g-pncb.make}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pncb.to-foreign} ()
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PNCB<dot>TO-FOREIGN function}@c
@functionsubindex{cepl.types.predefined.g-pncb.to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pnt.from-foreign} ()
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PNT<dot>FROM-FOREIGN function}@c
@functionsubindex{cepl.types.predefined.g-pnt.from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pnt.make} POINTER
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PNT<dot>MAKE function}@c
@functionsubindex{cepl.types.predefined.g-pnt.make}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pnt.to-foreign} ()
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PNT<dot>TO-FOREIGN function}@c
@functionsubindex{cepl.types.predefined.g-pnt.to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pntb.from-foreign} ()
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PNTB<dot>FROM-FOREIGN function}@c
@functionsubindex{cepl.types.predefined.g-pntb.from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pntb.make} POINTER
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PNTB<dot>MAKE function}@c
@functionsubindex{cepl.types.predefined.g-pntb.make}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pntb.to-foreign} ()
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PNTB<dot>TO-FOREIGN function}@c
@functionsubindex{cepl.types.predefined.g-pntb.to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pntc.from-foreign} ()
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PNTC<dot>FROM-FOREIGN function}@c
@functionsubindex{cepl.types.predefined.g-pntc.from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pntc.make} POINTER
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PNTC<dot>MAKE function}@c
@functionsubindex{cepl.types.predefined.g-pntc.make}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pntc.to-foreign} ()
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PNTC<dot>TO-FOREIGN function}@c
@functionsubindex{cepl.types.predefined.g-pntc.to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pntcb.from-foreign} ()
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PNTCB<dot>FROM-FOREIGN function}@c
@functionsubindex{cepl.types.predefined.g-pntcb.from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pntcb.make} POINTER
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PNTCB<dot>MAKE function}@c
@functionsubindex{cepl.types.predefined.g-pntcb.make}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pntcb.to-foreign} ()
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PNTCB<dot>TO-FOREIGN function}@c
@functionsubindex{cepl.types.predefined.g-pntcb.to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pt.from-foreign} ()
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PT<dot>FROM-FOREIGN function}@c
@functionsubindex{cepl.types.predefined.g-pt.from-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pt.make} POINTER
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PT<dot>MAKE function}@c
@functionsubindex{cepl.types.predefined.g-pt.make}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cepl.types.predefined.g-pt.to-foreign} ()
@anchor{go to the CEPL<dot>HIDDEN<colon><colon>CEPL<dot>TYPES<dot>PREDEFINED<dot>G-PT<dot>TO-FOREIGN function}@c
@functionsubindex{cepl.types.predefined.g-pt.to-foreign}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HIDDEN package, , @t{cepl.hidden}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {change-state} TARGET-STATE
@anchor{go to the CEPL<dot>LIFECYCLE<colon><colon>CHANGE-STATE function}@c
@functionsubindex{change-state}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>LIFECYCLE package, , @t{cepl.lifecycle}}
@item Source
@ref{go to the cepl/core/lifecycle<dot>lisp file, , @t{core/lifecycle.lisp}} (file)
@end table
@end deffn
@deffn {Function} {check-c-array-dimensions} DIMENSIONS TOTAL-SIZE ROW-ALIGNMENT
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>CHECK-C-ARRAY-DIMENSIONS function}@c
@functionsubindex{check-c-array-dimensions}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/make<dot>lisp file, , @t{core/c-arrays/make.lisp}} (file)
@end table
@end deffn
@deffn {Function} {check-immutable-feature} ()
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>CHECK-IMMUTABLE-FEATURE function}@c
@functionsubindex{check-immutable-feature}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {check-sampler-feature} ()
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>CHECK-SAMPLER-FEATURE function}@c
@functionsubindex{check-sampler-feature}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {check-single-element-not-list} INITIAL-CONTENTS DIMENSIONS ELEMENT-TYPE
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>CHECK-SINGLE-ELEMENT-NOT-LIST function}@c
@functionsubindex{check-single-element-not-list}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/make<dot>lisp file, , @t{core/c-arrays/make.lisp}} (file)
@end table
@end deffn
@deffn {Function} {check-version-for-per-attachment-params} ()
@anchor{go to the CEPL<dot>BLENDING<colon><colon>CHECK-VERSION-FOR-PER-ATTACHMENT-PARAMS function}@c
@functionsubindex{check-version-for-per-attachment-params}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@end table
@end deffn
@deffn {Function} {clone-stage-spec} SPEC &key NEW-CONTEXT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>CLONE-STAGE-SPEC function}@c
@functionsubindex{clone-stage-spec}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Function} {compile-context-p} OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>COMPILE-CONTEXT-P function}@c
@functionsubindex{compile-context-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/compile-context<dot>lisp file, , @t{core/pipelines/compile-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {compile-context-primitive} INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>COMPILE-CONTEXT-PRIMITIVE function}@c
@functionsubindex{compile-context-primitive}@c
@deffnx {Function} {(setf compile-context-primitive)} VALUE INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF COMPILE-CONTEXT-PRIMITIVE) function}@c
@functionsubindex{(setf compile-context-primitive)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/compile-context<dot>lisp file, , @t{core/pipelines/compile-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {compile-context-stage} INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>COMPILE-CONTEXT-STAGE function}@c
@functionsubindex{compile-context-stage}@c
@deffnx {Function} {(setf compile-context-stage)} VALUE INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF COMPILE-CONTEXT-STAGE) function}@c
@functionsubindex{(setf compile-context-stage)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/compile-context<dot>lisp file, , @t{core/pipelines/compile-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {compile-context-static-p} INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>COMPILE-CONTEXT-STATIC-P function}@c
@functionsubindex{compile-context-static-p}@c
@deffnx {Function} {(setf compile-context-static-p)} VALUE INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF COMPILE-CONTEXT-STATIC-P) function}@c
@functionsubindex{(setf compile-context-static-p)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/compile-context<dot>lisp file, , @t{core/pipelines/compile-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {compile-context-versions} INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>COMPILE-CONTEXT-VERSIONS function}@c
@functionsubindex{compile-context-versions}@c
@deffnx {Function} {(setf compile-context-versions)} VALUE INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF COMPILE-CONTEXT-VERSIONS) function}@c
@functionsubindex{(setf compile-context-versions)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/compile-context<dot>lisp file, , @t{core/pipelines/compile-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {compile-pixel-format} PIXEL-FORMAT
@anchor{go to the CEPL<dot>PIXEL-FORMATS<colon><colon>COMPILE-PIXEL-FORMAT function}@c
@functionsubindex{compile-pixel-format}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIXEL-FORMATS package, , @t{cepl.pixel-formats}}
@item Source
@ref{go to the cepl/core/types/pixel-format<dot>lisp file, , @t{core/types/pixel-format.lisp}} (file)
@end table
@end deffn
@deffn {Function} {complete-single-stage-pipeline} STAGE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>COMPLETE-SINGLE-STAGE-PIPELINE function}@c
@functionsubindex{complete-single-stage-pipeline}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {complete-unbound-context} UNBOUND-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>COMPLETE-UNBOUND-CONTEXT function}@c
@functionsubindex{complete-unbound-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {compute-expander} PROFILE-NAME SPACE-SYMB
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>COMPUTE-EXPANDER function}@c
@functionsubindex{compute-expander}@c
This runs the compute function over the provided space using the
   currently bound program. Please note: It Does Not bind the program so
   this function should only be used from another function which@*
   is handling the binding.
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {compute-glsl-version-from-stage-pairs} STAGE-PAIRS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>COMPUTE-GLSL-VERSION-FROM-STAGE-PAIRS function}@c
@functionsubindex{compute-glsl-version-from-stage-pairs}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {compute-space-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COMPUTE-SPACE-P function}@c
@functionsubindex{compute-space-p}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cons-aware-1d-p} X
@anchor{go to the CEPL<dot>VAOS<colon><colon>CONS-AWARE-1D-P function}@c
@functionsubindex{cons-aware-1d-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>VAOS package, , @t{cepl.vaos}}
@item Source
@ref{go to the cepl/core/vaos/vaos<dot>lisp file, , @t{core/vaos/vaos.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-any-samples-passed-conservative-query} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-ANY-SAMPLES-PASSED-CONSERVATIVE-QUERY function}@c
@functionsubindex{copy-any-samples-passed-conservative-query}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-any-samples-passed-query} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-ANY-SAMPLES-PASSED-QUERY function}@c
@functionsubindex{copy-any-samples-passed-query}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-att} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-ATT function}@c
@functionsubindex{copy-att}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-boop6} INSTANCE
@anchor{go to the CEPL-UTILS<colon><colon>COPY-BOOP6 function}@c
@functionsubindex{copy-boop6}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-buffer-stream} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-BUFFER-STREAM function}@c
@functionsubindex{copy-buffer-stream}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-buffer-texture} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-BUFFER-TEXTURE function}@c
@functionsubindex{copy-buffer-texture}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-c-array} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-C-ARRAY function}@c
@functionsubindex{copy-c-array}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-c-array-to-ssbo} SRC DST
@anchor{go to the CEPL<dot>SSBOS<colon><colon>COPY-C-ARRAY-TO-SSBO function}@c
@functionsubindex{copy-c-array-to-ssbo}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SSBOS package, , @t{cepl.ssbos}}
@item Source
@ref{go to the cepl/core/ssbos/ssbos<dot>lisp file, , @t{core/ssbos/ssbos.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-c-array-to-ubo} SRC DST
@anchor{go to the CEPL<dot>UBOS<colon><colon>COPY-C-ARRAY-TO-UBO function}@c
@functionsubindex{copy-c-array-to-ubo}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>UBOS package, , @t{cepl.ubos}}
@item Source
@ref{go to the cepl/core/ubos/ubo<dot>lisp file, , @t{core/ubos/ubo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-cepl-context} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>COPY-CEPL-CONTEXT function}@c
@functionsubindex{copy-cepl-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-compile-context} COMPILE-CONTEXT &key PRIMITIVE VERSIONS STAGE STATIC-P
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>COPY-COMPILE-CONTEXT function}@c
@functionsubindex{copy-compile-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/compile-context<dot>lisp file, , @t{core/pipelines/compile-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-compute-space} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-COMPUTE-SPACE function}@c
@functionsubindex{copy-compute-space}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-delayed} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>COPY-DELAYED function}@c
@functionsubindex{copy-delayed}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/delayed-resource-init<dot>lisp file, , @t{core/context/delayed-resource-init.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-empty-fbo-params} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-EMPTY-FBO-PARAMS function}@c
@functionsubindex{copy-empty-fbo-params}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-fbo} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-FBO function}@c
@functionsubindex{copy-fbo}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-glambda-state} INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>COPY-GLAMBDA-STATE function}@c
@functionsubindex{copy-glambda-state}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-lambda<dot>lisp file, , @t{core/pipelines/gpu-lambda.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-gpu-array} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-GPU-ARRAY function}@c
@functionsubindex{copy-gpu-array}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-gpu-array-bb} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-GPU-ARRAY-BB function}@c
@functionsubindex{copy-gpu-array-bb}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-gpu-array-t} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-GPU-ARRAY-T function}@c
@functionsubindex{copy-gpu-array-t}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-gpu-buffer} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-GPU-BUFFER function}@c
@functionsubindex{copy-gpu-buffer}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-gpu-fence} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-GPU-FENCE function}@c
@functionsubindex{copy-gpu-fence}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-gpu-query} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-GPU-QUERY function}@c
@functionsubindex{copy-gpu-query}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-lisp-array-to-ssbo} SRC DST
@anchor{go to the CEPL<dot>SSBOS<colon><colon>COPY-LISP-ARRAY-TO-SSBO function}@c
@functionsubindex{copy-lisp-array-to-ssbo}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SSBOS package, , @t{cepl.ssbos}}
@item Source
@ref{go to the cepl/core/ssbos/ssbos<dot>lisp file, , @t{core/ssbos/ssbos.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-lisp-array-to-ubo} SRC DST
@anchor{go to the CEPL<dot>UBOS<colon><colon>COPY-LISP-ARRAY-TO-UBO function}@c
@functionsubindex{copy-lisp-array-to-ubo}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>UBOS package, , @t{cepl.ubos}}
@item Source
@ref{go to the cepl/core/ubos/ubo<dot>lisp file, , @t{core/ubos/ubo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-lisp-list-to-ssbo} SRC DST
@anchor{go to the CEPL<dot>SSBOS<colon><colon>COPY-LISP-LIST-TO-SSBO function}@c
@functionsubindex{copy-lisp-list-to-ssbo}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SSBOS package, , @t{cepl.ssbos}}
@item Source
@ref{go to the cepl/core/ssbos/ssbos<dot>lisp file, , @t{core/ssbos/ssbos.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-lisp-list-to-ubo} SRC DST
@anchor{go to the CEPL<dot>UBOS<colon><colon>COPY-LISP-LIST-TO-UBO function}@c
@functionsubindex{copy-lisp-list-to-ubo}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>UBOS package, , @t{cepl.ubos}}
@item Source
@ref{go to the cepl/core/ubos/ubo<dot>lisp file, , @t{core/ubos/ubo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-pipeline-state} INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>COPY-PIPELINE-STATE function}@c
@functionsubindex{copy-pipeline-state}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-pixel-format} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-PIXEL-FORMAT function}@c
@functionsubindex{copy-pixel-format}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-primitives-generated-query} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-PRIMITIVES-GENERATED-QUERY function}@c
@functionsubindex{copy-primitives-generated-query}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-render-buffer} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-RENDER-BUFFER function}@c
@functionsubindex{copy-render-buffer}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-sampler} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-SAMPLER function}@c
@functionsubindex{copy-sampler}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-sampler-id-box} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-SAMPLER-ID-BOX function}@c
@functionsubindex{copy-sampler-id-box}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-samples-passed-query} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-SAMPLES-PASSED-QUERY function}@c
@functionsubindex{copy-samples-passed-query}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-scoped-gpu-query} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-SCOPED-GPU-QUERY function}@c
@functionsubindex{copy-scoped-gpu-query}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-ssbo} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-SSBO function}@c
@functionsubindex{copy-ssbo}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-ssbo-to-new-c-array} SRC
@anchor{go to the CEPL<dot>SSBOS<colon><colon>COPY-SSBO-TO-NEW-C-ARRAY function}@c
@functionsubindex{copy-ssbo-to-new-c-array}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SSBOS package, , @t{cepl.ssbos}}
@item Source
@ref{go to the cepl/core/ssbos/ssbos<dot>lisp file, , @t{core/ssbos/ssbos.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-ssbo-to-new-lisp-data} SRC
@anchor{go to the CEPL<dot>SSBOS<colon><colon>COPY-SSBO-TO-NEW-LISP-DATA function}@c
@functionsubindex{copy-ssbo-to-new-lisp-data}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SSBOS package, , @t{cepl.ssbos}}
@item Source
@ref{go to the cepl/core/ssbos/ssbos<dot>lisp file, , @t{core/ssbos/ssbos.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-stencil-params} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-STENCIL-PARAMS function}@c
@functionsubindex{copy-stencil-params}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-texture} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-TEXTURE function}@c
@functionsubindex{copy-texture}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-time-elapsed-query} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-TIME-ELAPSED-QUERY function}@c
@functionsubindex{copy-time-elapsed-query}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-timestamp-query} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-TIMESTAMP-QUERY function}@c
@functionsubindex{copy-timestamp-query}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-transform-feedback-primitives-written-query} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-TRANSFORM-FEEDBACK-PRIMITIVES-WRITTEN-QUERY function}@c
@functionsubindex{copy-transform-feedback-primitives-written-query}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-transform-feedback-stream} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-TRANSFORM-FEEDBACK-STREAM function}@c
@functionsubindex{copy-transform-feedback-stream}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-ubo} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>COPY-UBO function}@c
@functionsubindex{copy-ubo}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-ubo-to-new-c-array} SRC
@anchor{go to the CEPL<dot>UBOS<colon><colon>COPY-UBO-TO-NEW-C-ARRAY function}@c
@functionsubindex{copy-ubo-to-new-c-array}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>UBOS package, , @t{cepl.ubos}}
@item Source
@ref{go to the cepl/core/ubos/ubo<dot>lisp file, , @t{core/ubos/ubo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-ubo-to-new-lisp-data} SRC
@anchor{go to the CEPL<dot>UBOS<colon><colon>COPY-UBO-TO-NEW-LISP-DATA function}@c
@functionsubindex{copy-ubo-to-new-lisp-data}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>UBOS package, , @t{cepl.ubos}}
@item Source
@ref{go to the cepl/core/ubos/ubo<dot>lisp file, , @t{core/ubos/ubo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-uidx} INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>COPY-UIDX function}@c
@functionsubindex{copy-uidx}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Function} {copy-unbound-cepl-context} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>COPY-UNBOUND-CEPL-CONTEXT function}@c
@functionsubindex{copy-unbound-cepl-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {cube->fbo-arrays} FBO-OBJ FUZZY-ARGS
@anchor{go to the CEPL<dot>FBOS<colon><colon>CUBE->FBO-ARRAYS function}@c
@functionsubindex{cube->fbo-arrays}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {current-blend-params} &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>BLENDING<colon><colon>CURRENT-BLEND-PARAMS function}@c
@functionsubindex{current-blend-params}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@end table
@end deffn
@deffn {Function} {def-dispatch-func} CTX COMPILE-CONTEXT NAME INIT-FUNC-NAME UNIFORM-ASSIGNERS AGGREGATE-PUBLIC-UNIFORMS STATE-VAR STATE-TAG COMPUTE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>DEF-DISPATCH-FUNC function}@c
@functionsubindex{def-dispatch-func}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {default-fbo-attachment-enum} ATTACHMENT-NUM
@anchor{go to the CEPL<dot>FBOS<colon><colon>DEFAULT-FBO-ATTACHMENT-ENUM function}@c
@functionsubindex{default-fbo-attachment-enum}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {defun-g-common} NAME ARGS BODY EQUIV
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>DEFUN-G-COMMON function}@c
@functionsubindex{defun-g-common}@c
Define a function that runs on the gpu.
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {defx*} DEFNAME NAME SLOTS
@anchor{go to the CEPL-UTILS<colon><colon>DEFX* function}@c
@functionsubindex{defx*}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {delay-initialization} CEPL-CONTEXT INIT-THUNK WAITING-ON-THESE-RESOURCES
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>DELAY-INITIALIZATION function}@c
@functionsubindex{delay-initialization}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/delayed-resource-init<dot>lisp file, , @t{core/context/delayed-resource-init.lisp}} (file)
@end table
@end deffn
@deffn {Function} {delayed-p} OBJECT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>DELAYED-P function}@c
@functionsubindex{delayed-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/delayed-resource-init<dot>lisp file, , @t{core/context/delayed-resource-init.lisp}} (file)
@end table
@end deffn
@deffn {Function} {delayed-thunk} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>DELAYED-THUNK function}@c
@functionsubindex{delayed-thunk}@c
@deffnx {Function} {(setf delayed-thunk)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF DELAYED-THUNK) function}@c
@functionsubindex{(setf delayed-thunk)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/delayed-resource-init<dot>lisp file, , @t{core/context/delayed-resource-init.lisp}} (file)
@end table
@end deffn
@deffn {Function} {delayed-waiting-on} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>DELAYED-WAITING-ON function}@c
@functionsubindex{delayed-waiting-on}@c
@deffnx {Function} {(setf delayed-waiting-on)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF DELAYED-WAITING-ON) function}@c
@functionsubindex{(setf delayed-waiting-on)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/delayed-resource-init<dot>lisp file, , @t{core/context/delayed-resource-init.lisp}} (file)
@end table
@end deffn
@deffn {Function} {describe-image-format} FORMAT
@anchor{go to the CEPL<dot>PIXEL-FORMATS<colon><colon>DESCRIBE-IMAGE-FORMAT function}@c
@functionsubindex{describe-image-format}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIXEL-FORMATS package, , @t{cepl.pixel-formats}}
@item Source
@ref{go to the cepl/core/types/pixel-format<dot>lisp file, , @t{core/types/pixel-format.lisp}} (file)
@end table
@end deffn
@deffn {Function} {describe-pixel-format} OBJECT
@anchor{go to the CEPL<dot>PIXEL-FORMATS<colon><colon>DESCRIBE-PIXEL-FORMAT function}@c
@functionsubindex{describe-pixel-format}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIXEL-FORMATS package, , @t{cepl.pixel-formats}}
@item Source
@ref{go to the cepl/core/types/pixel-format<dot>lisp file, , @t{core/types/pixel-format.lisp}} (file)
@end table
@end deffn
@deffn {Function} {dimensions-at-mipmap-level} TEXTURE LEVEL
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>DIMENSIONS-AT-MIPMAP-LEVEL function}@c
@functionsubindex{dimensions-at-mipmap-level}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {discard-context-id} ID
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>DISCARD-CONTEXT-ID function}@c
@functionsubindex{discard-context-id}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {dispatch-dyn-gpu-call} PLINE CALL-ARGS RET-TYPES
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>DISPATCH-DYN-GPU-CALL function}@c
@functionsubindex{dispatch-dyn-gpu-call}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/funcall-g<dot>lisp file, , @t{core/pipelines/funcall-g.lisp}} (file)
@end table
@end deffn
@deffn {Function} {dispatch-make-assigner} INDEXES LOCAL-ARG-NAME ARG-NAME TYPE GLSL-NAME QUALIFIERS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>DISPATCH-MAKE-ASSIGNER function}@c
@functionsubindex{dispatch-make-assigner}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Function} {draw-buffer-pattern-p} DRAW-BUFFERS
@anchor{go to the CEPL<dot>FBOS<colon><colon>DRAW-BUFFER-PATTERN-P function}@c
@functionsubindex{draw-buffer-pattern-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {draw-expander} PROFILE-NAME CTX-SYMB STREAM-SYMB DRAW-MODE-SYMB PRIMITIVE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>DRAW-EXPANDER function}@c
@functionsubindex{draw-expander}@c
This draws the single stream provided using the currently
   bound program. Please note: It Does Not bind the program so
   this function should only be used from another function which
   is handling the binding.
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {draw-mode-symbol-group-id} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>DRAW-MODE-SYMBOL-GROUP-ID function}@c
@functionsubindex{draw-mode-symbol-group-id}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {dyn-code-to-pipeline-and-stages} CODE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>DYN-CODE-TO-PIPELINE-AND-STAGES function}@c
@functionsubindex{dyn-code-to-pipeline-and-stages}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/funcall-g<dot>lisp file, , @t{core/pipelines/funcall-g.lisp}} (file)
@end table
@end deffn
@deffn {Function} {elements-indirect-command-p} OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ELEMENTS-INDIRECT-COMMAND-P function}@c
@functionsubindex{elements-indirect-command-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/multi-draw<dot>lisp file, , @t{core/pipelines/multi-draw.lisp}} (file)
@end table
@end deffn
@deffn {Function} {elements-indirect-command-pointer} INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ELEMENTS-INDIRECT-COMMAND-POINTER function}@c
@functionsubindex{elements-indirect-command-pointer}@c
@deffnx {Function} {(setf elements-indirect-command-pointer)} VALUE INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF ELEMENTS-INDIRECT-COMMAND-POINTER) function}@c
@functionsubindex{(setf elements-indirect-command-pointer)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/multi-draw<dot>lisp file, , @t{core/pipelines/multi-draw.lisp}} (file)
@end table
@end deffn
@deffn {Function} {empty-fbo-args-p} FUZZY-ARGS
@anchor{go to the CEPL<dot>FBOS<colon><colon>EMPTY-FBO-ARGS-P function}@c
@functionsubindex{empty-fbo-args-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {empty-fbo-params-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>EMPTY-FBO-PARAMS-P function}@c
@functionsubindex{empty-fbo-params-p}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {enable-transform-feedback} PROG-ID MODE NAMES
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ENABLE-TRANSFORM-FEEDBACK function}@c
@functionsubindex{enable-transform-feedback}@c
Returns the number of gpu-arrays that should be bound in the
   transform-feedback-stream
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {end-scoped-gpu-query} QUERY
@anchor{go to the CEPL<dot>QUERIES<colon><colon>END-SCOPED-GPU-QUERY function}@c
@functionsubindex{end-scoped-gpu-query}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>QUERIES package, , @t{cepl.queries}}
@item Source
@ref{go to the cepl/core/queries/query<dot>lisp file, , @t{core/queries/query.lisp}} (file)
@end table
@end deffn
@deffn {Function} {ensure-cepl-compatible-setup} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>ENSURE-CEPL-COMPATIBLE-SETUP function}@c
@functionsubindex{ensure-cepl-compatible-setup}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {ensure-fbo-array-size} FBO DESIRED-SIZE
@anchor{go to the CEPL<dot>FBOS<colon><colon>ENSURE-FBO-ARRAY-SIZE function}@c
@functionsubindex{ensure-fbo-array-size}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {error-on-invalid-upload-formats} TARGET IMAGE-FORMAT PIXEL-FORMAT PIXEL-TYPE
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>ERROR-ON-INVALID-UPLOAD-FORMATS function}@c
@functionsubindex{error-on-invalid-upload-formats}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {escape-tildes} STR
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>ESCAPE-TILDES function}@c
@functionsubindex{escape-tildes}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {establish-texture-type} DIMENSIONS MIPMAP LAYERS CUBES PO2 MULTISAMPLE BUFFER RECTANGLE
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>ESTABLISH-TEXTURE-TYPE function}@c
@functionsubindex{establish-texture-type}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {expand-lambda-defpipeline} NAME CONTEXT GPIPE-ARGS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>EXPAND-LAMBDA-DEFPIPELINE function}@c
@functionsubindex{expand-lambda-defpipeline}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {expand-mappable-slot-to-layout} SLOT TYPE NORMALIZE
@anchor{go to the CEPL<dot>TYPES<colon><colon>EXPAND-MAPPABLE-SLOT-TO-LAYOUT function}@c
@functionsubindex{expand-mappable-slot-to-layout}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {expand-slot-to-layout} SLOT &optional TYPE NORMALIZE
@anchor{go to the CEPL<dot>TYPES<colon><colon>EXPAND-SLOT-TO-LAYOUT function}@c
@functionsubindex{expand-slot-to-layout}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {expand-unmappable-slot-to-layout} SLOT TYPE NORMALIZE
@anchor{go to the CEPL<dot>TYPES<colon><colon>EXPAND-UNMAPPABLE-SLOT-TO-LAYOUT function}@c
@functionsubindex{expand-unmappable-slot-to-layout}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {extract-dimension-from-make-fbo-pattern} PATTERN
@anchor{go to the CEPL<dot>FBOS<colon><colon>EXTRACT-DIMENSION-FROM-MAKE-FBO-PATTERN function}@c
@functionsubindex{extract-dimension-from-make-fbo-pattern}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {extract-matching-dimension-value} ARGS
@anchor{go to the CEPL<dot>FBOS<colon><colon>EXTRACT-MATCHING-DIMENSION-VALUE function}@c
@functionsubindex{extract-matching-dimension-value}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {fallback-iuniform-func} ()
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>FALLBACK-IUNIFORM-FUNC function}@c
@functionsubindex{fallback-iuniform-func}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {fallback-sampler-set} SAMPLER
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>FALLBACK-SAMPLER-SET function}@c
@functionsubindex{fallback-sampler-set}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/texture-samplers<dot>lisp file, , @t{core/textures/texture-samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {fbo-attach-array} CEPL-CONTEXT FBO TEX-ARRAY ATTACHMENT-NAME
@anchor{go to the CEPL<dot>FBOS<colon><colon>FBO-ATTACH-ARRAY function}@c
@functionsubindex{fbo-attach-array}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {fbo-attach-render-buffer} CEPL-CONTEXT FBO RENDER-BUFFER ATTACHMENT-NAME
@anchor{go to the CEPL<dot>FBOS<colon><colon>FBO-ATTACH-RENDER-BUFFER function}@c
@functionsubindex{fbo-attach-render-buffer}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {fbo-color-arrays} FBO
@anchor{go to the CEPL<dot>FBOS<colon><colon>FBO-COLOR-ARRAYS function}@c
@functionsubindex{fbo-color-arrays}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {fbo-detach} CEPL-CONTEXT FBO ATTACHMENT-NAME
@anchor{go to the CEPL<dot>FBOS<colon><colon>FBO-DETACH function}@c
@functionsubindex{fbo-detach}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {fbo-gen-attach} FBO CHECK-DIMENSIONS-MATCHP &rest ARGS
@anchor{go to the CEPL<dot>FBOS<colon><colon>FBO-GEN-ATTACH function}@c
@functionsubindex{fbo-gen-attach}@c
The are 4 kinds of valid argument:@*
   - keyword naming an attachment: This makes a new texture@*
     with size of (current-viewport) and attaches@*
   - (keyword texarray): attaches the tex-array@*
   - (keyword texture): attaches the root tex-array@*
   - (keyword some-type) any types that supports the generic dimensions function
                         creates a new texture at the framesize of the object
                         and attaches it to attachment named by keyword
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {find-compatible-c-array-type} CURRENT-SET DATA
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>FIND-COMPATIBLE-C-ARRAY-TYPE function}@c
@functionsubindex{find-compatible-c-array-type}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/make<dot>lisp file, , @t{core/c-arrays/make.lisp}} (file)
@end table
@end deffn
@deffn {Function} {find-gpu-func-spec-by-name-and-vals} NAME IN-VALS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>FIND-GPU-FUNC-SPEC-BY-NAME-AND-VALS function}@c
@functionsubindex{find-gpu-func-spec-by-name-and-vals}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/funcall-g<dot>lisp file, , @t{core/pipelines/funcall-g.lisp}} (file)
@end table
@end deffn
@deffn {Function} {find-invalid-defpipeline-options} OPTIONS VALID-KEYS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>FIND-INVALID-DEFPIPELINE-OPTIONS function}@c
@functionsubindex{find-invalid-defpipeline-options}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/pipeline-validation<dot>lisp file, , @t{core/pipelines/pipeline-validation.lisp}} (file)
@end table
@end deffn
@deffn {Function} {find-suitable-type} DATUM
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>FIND-SUITABLE-TYPE function}@c
@functionsubindex{find-suitable-type}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/make<dot>lisp file, , @t{core/c-arrays/make.lisp}} (file)
@end table
@end deffn
@deffn {Function} {first-elem} X
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>FIRST-ELEM function}@c
@functionsubindex{first-elem}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/make<dot>lisp file, , @t{core/c-arrays/make.lisp}} (file)
@end table
@end deffn
@deffn {Function} {force-bind-vao} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>FORCE-BIND-VAO function}@c
@functionsubindex{force-bind-vao}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {force-depth-test-function} FUNCTION &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>FORCE-DEPTH-TEST-FUNCTION function}@c
@functionsubindex{force-depth-test-function}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/depth/depth<dot>lisp file, , @t{core/depth/depth.lisp}} (file)
@end table
@end deffn
@deffn {Function} {force-sampler-bound} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>FORCE-SAMPLER-BOUND function}@c
@functionsubindex{force-sampler-bound}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/samplers/context<dot>lisp file, , @t{core/samplers/context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {force-scissor-viewport} ()
@anchor{go to the CEPL<dot>SCISSOR<colon><colon>FORCE-SCISSOR-VIEWPORT function}@c
@functionsubindex{force-scissor-viewport}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SCISSOR package, , @t{cepl.scissor}}
@item Source
@ref{go to the cepl/core/scissor/scissor<dot>lisp file, , @t{core/scissor/scissor.lisp}} (file)
@end table
@end deffn
@deffn {Function} {force-use-program} CTX PROGRAM-ID
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>FORCE-USE-PROGRAM function}@c
@functionsubindex{force-use-program}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/programs<dot>lisp file, , @t{core/pipelines/programs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {forget-fbo} CEPL-CONTEXT FBO
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>FORGET-FBO function}@c
@functionsubindex{forget-fbo}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {forget-gpu-buffer} CEPL-CONTEXT GPU-BUFFER
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>FORGET-GPU-BUFFER function}@c
@functionsubindex{forget-gpu-buffer}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {forget-texture} CEPL-CONTEXT TEXTURE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>FORGET-TEXTURE function}@c
@functionsubindex{forget-texture}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {forgiving-list-dimension-guess} LIST
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>FORGIVING-LIST-DIMENSION-GUESS function}@c
@functionsubindex{forgiving-list-dimension-guess}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/make<dot>lisp file, , @t{core/c-arrays/make.lisp}} (file)
@end table
@end deffn
@deffn {Function} {format-array-slot-for-cstruct} SLOT LAYOUT
@anchor{go to the CEPL<dot>TYPES<colon><colon>FORMAT-ARRAY-SLOT-FOR-CSTRUCT function}@c
@functionsubindex{format-array-slot-for-cstruct}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {format-slot-for-cstruct} SLOT LAYOUT
@anchor{go to the CEPL<dot>TYPES<colon><colon>FORMAT-SLOT-FOR-CSTRUCT function}@c
@functionsubindex{format-slot-for-cstruct}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {format-slot-for-varjo} SLOT
@anchor{go to the CEPL<dot>TYPES<colon><colon>FORMAT-SLOT-FOR-VARJO function}@c
@functionsubindex{format-slot-for-varjo}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {free-context} CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>FREE-CONTEXT function}@c
@functionsubindex{free-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {free-fbo} FBO
@anchor{go to the CEPL<dot>FBOS<colon><colon>FREE-FBO function}@c
@functionsubindex{free-fbo}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {free-gpu-array-bb} GPU-ARRAY
@anchor{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED<colon><colon>FREE-GPU-ARRAY-BB function}@c
@functionsubindex{free-gpu-array-bb}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED package, , @t{cepl.gpu-arrays.buffer-backed}}
@item Source
@ref{go to the cepl/core/gpu-arrays/buffer-backed<dot>lisp file, , @t{core/gpu-arrays/buffer-backed.lisp}} (file)
@end table
@end deffn
@deffn {Function} {free-gpu-array-t} ()
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>FREE-GPU-ARRAY-T function}@c
@functionsubindex{free-gpu-array-t}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/def<dot>lisp file, , @t{core/textures/def.lisp}} (file)
@end table
@end deffn
@deffn {Function} {free-gpu-buffer} BUFFER
@anchor{go to the CEPL<dot>GPU-BUFFERS<colon><colon>FREE-GPU-BUFFER function}@c
@functionsubindex{free-gpu-buffer}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-BUFFERS package, , @t{cepl.gpu-buffers}}
@item Source
@ref{go to the cepl/core/gpu-buffers/gpu-buffers<dot>lisp file, , @t{core/gpu-buffers/gpu-buffers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {free-gpu-buffers} BUFFERS
@anchor{go to the CEPL<dot>GPU-BUFFERS<colon><colon>FREE-GPU-BUFFERS function}@c
@functionsubindex{free-gpu-buffers}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-BUFFERS package, , @t{cepl.gpu-buffers}}
@item Source
@ref{go to the cepl/core/gpu-buffers/gpu-buffers<dot>lisp file, , @t{core/gpu-buffers/gpu-buffers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {free-user-fbo} FBO
@anchor{go to the CEPL<dot>FBOS<colon><colon>FREE-USER-FBO function}@c
@functionsubindex{free-user-fbo}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {from-active} TARGET-STATE
@anchor{go to the CEPL<dot>LIFECYCLE<colon><colon>FROM-ACTIVE function}@c
@functionsubindex{from-active}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>LIFECYCLE package, , @t{cepl.lifecycle}}
@item Source
@ref{go to the cepl/core/lifecycle<dot>lisp file, , @t{core/lifecycle.lisp}} (file)
@end table
@end deffn
@deffn {Function} {from-suspended} TARGET-STATE
@anchor{go to the CEPL<dot>LIFECYCLE<colon><colon>FROM-SUSPENDED function}@c
@functionsubindex{from-suspended}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>LIFECYCLE package, , @t{cepl.lifecycle}}
@item Source
@ref{go to the cepl/core/lifecycle<dot>lisp file, , @t{core/lifecycle.lisp}} (file)
@end table
@end deffn
@deffn {Function} {from-unitialized} TARGET-STATE
@anchor{go to the CEPL<dot>LIFECYCLE<colon><colon>FROM-UNITIALIZED function}@c
@functionsubindex{from-unitialized}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>LIFECYCLE package, , @t{cepl.lifecycle}}
@item Source
@ref{go to the cepl/core/lifecycle<dot>lisp file, , @t{core/lifecycle.lisp}} (file)
@end table
@end deffn
@deffn {Function} {funcs-these-funcs-use} NAMES &optional INCLUDE-NAMES
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>FUNCS-THESE-FUNCS-USE function}@c
@functionsubindex{funcs-these-funcs-use}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Function} {funcs-this-func-uses} KEY
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>FUNCS-THIS-FUNC-USES function}@c
@functionsubindex{funcs-this-func-uses}@c
Recursivly searches for functions by this function.@*
Sorts the list of function names by dependency so the earlier
names are depended on by the functions named later in the list
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Function} {function-arg-p} ARG
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>FUNCTION-ARG-P function}@c
@functionsubindex{function-arg-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {function-formp} X
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>FUNCTION-FORMP function}@c
@functionsubindex{function-formp}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/pipeline-validation<dot>lisp file, , @t{core/pipelines/pipeline-validation.lisp}} (file)
@end table
@end deffn
@deffn {Function} {function-keyed-pipeline} FUNC
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>FUNCTION-KEYED-PIPELINE function}@c
@functionsubindex{function-keyed-pipeline}@c
@deffnx {Function} {(setf function-keyed-pipeline)} SPEC FUNC
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF FUNCTION-KEYED-PIPELINE) function}@c
@functionsubindex{(setf function-keyed-pipeline)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Function} {function-uniforms} FUNC-SPECS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>FUNCTION-UNIFORMS function}@c
@functionsubindex{function-uniforms}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {fuzzy-args->arrays} FBO-OBJ FUZZY-ARGS
@anchor{go to the CEPL<dot>FBOS<colon><colon>FUZZY-ARGS->ARRAYS function}@c
@functionsubindex{fuzzy-args->arrays}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {g-pc-p} OBJECT
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PC-P function}@c
@functionsubindex{g-pc-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {g-pc-pointer} INSTANCE
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PC-POINTER function}@c
@functionsubindex{g-pc-pointer}@c
@deffnx {Function} {(setf g-pc-pointer)} VALUE INSTANCE
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>(SETF G-PC-POINTER) function}@c
@functionsubindex{(setf g-pc-pointer)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {g-pn-p} OBJECT
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PN-P function}@c
@functionsubindex{g-pn-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {g-pn-pointer} INSTANCE
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PN-POINTER function}@c
@functionsubindex{g-pn-pointer}@c
@deffnx {Function} {(setf g-pn-pointer)} VALUE INSTANCE
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>(SETF G-PN-POINTER) function}@c
@functionsubindex{(setf g-pn-pointer)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {g-pnb-p} OBJECT
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNB-P function}@c
@functionsubindex{g-pnb-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {g-pnb-pointer} INSTANCE
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNB-POINTER function}@c
@functionsubindex{g-pnb-pointer}@c
@deffnx {Function} {(setf g-pnb-pointer)} VALUE INSTANCE
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>(SETF G-PNB-POINTER) function}@c
@functionsubindex{(setf g-pnb-pointer)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {g-pnc-p} OBJECT
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNC-P function}@c
@functionsubindex{g-pnc-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {g-pnc-pointer} INSTANCE
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNC-POINTER function}@c
@functionsubindex{g-pnc-pointer}@c
@deffnx {Function} {(setf g-pnc-pointer)} VALUE INSTANCE
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>(SETF G-PNC-POINTER) function}@c
@functionsubindex{(setf g-pnc-pointer)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {g-pncb-p} OBJECT
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNCB-P function}@c
@functionsubindex{g-pncb-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {g-pncb-pointer} INSTANCE
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNCB-POINTER function}@c
@functionsubindex{g-pncb-pointer}@c
@deffnx {Function} {(setf g-pncb-pointer)} VALUE INSTANCE
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>(SETF G-PNCB-POINTER) function}@c
@functionsubindex{(setf g-pncb-pointer)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {g-pnt-p} OBJECT
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNT-P function}@c
@functionsubindex{g-pnt-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {g-pnt-pointer} INSTANCE
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNT-POINTER function}@c
@functionsubindex{g-pnt-pointer}@c
@deffnx {Function} {(setf g-pnt-pointer)} VALUE INSTANCE
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>(SETF G-PNT-POINTER) function}@c
@functionsubindex{(setf g-pnt-pointer)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {g-pntb-p} OBJECT
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNTB-P function}@c
@functionsubindex{g-pntb-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {g-pntb-pointer} INSTANCE
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNTB-POINTER function}@c
@functionsubindex{g-pntb-pointer}@c
@deffnx {Function} {(setf g-pntb-pointer)} VALUE INSTANCE
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>(SETF G-PNTB-POINTER) function}@c
@functionsubindex{(setf g-pntb-pointer)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {g-pntc-p} OBJECT
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNTC-P function}@c
@functionsubindex{g-pntc-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {g-pntc-pointer} INSTANCE
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNTC-POINTER function}@c
@functionsubindex{g-pntc-pointer}@c
@deffnx {Function} {(setf g-pntc-pointer)} VALUE INSTANCE
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>(SETF G-PNTC-POINTER) function}@c
@functionsubindex{(setf g-pntc-pointer)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {g-pntcb-p} OBJECT
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNTCB-P function}@c
@functionsubindex{g-pntcb-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {g-pntcb-pointer} INSTANCE
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PNTCB-POINTER function}@c
@functionsubindex{g-pntcb-pointer}@c
@deffnx {Function} {(setf g-pntcb-pointer)} VALUE INSTANCE
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>(SETF G-PNTCB-POINTER) function}@c
@functionsubindex{(setf g-pntcb-pointer)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {g-pt-p} OBJECT
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PT-P function}@c
@functionsubindex{g-pt-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {g-pt-pointer} INSTANCE
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>G-PT-POINTER function}@c
@functionsubindex{g-pt-pointer}@c
@deffnx {Function} {(setf g-pt-pointer)} VALUE INSTANCE
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>(SETF G-PT-POINTER) function}@c
@functionsubindex{(setf g-pt-pointer)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {g-struct-info} NAME &key ERROR-IF-NOT-FOUND
@anchor{go to the CEPL<dot>TYPES<colon><colon>G-STRUCT-INFO function}@c
@functionsubindex{g-struct-info}@c
@deffnx {Function} {(setf g-struct-info)} SLOTS NAME
@anchor{go to the CEPL<dot>TYPES<colon><colon>(SETF G-STRUCT-INFO) function}@c
@functionsubindex{(setf g-struct-info)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gen-buffer} ()
@anchor{go to the CEPL<dot>GPU-BUFFERS<colon><colon>GEN-BUFFER function}@c
@functionsubindex{gen-buffer}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-BUFFERS package, , @t{cepl.gpu-buffers}}
@item Source
@ref{go to the cepl/core/gpu-buffers/gpu-buffers<dot>lisp file, , @t{core/gpu-buffers/gpu-buffers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gen-buffer-tex-initial-contents} INITIAL-CONTENTS DIMENSIONS IMAGE-FORMAT CUBES RECTANGLE MULTISAMPLE MIPMAP LAYER-COUNT PIXEL-FORMAT
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>GEN-BUFFER-TEX-INITIAL-CONTENTS function}@c
@functionsubindex{gen-buffer-tex-initial-contents}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gen-c-array-sizes} DIMENSIONS ELEMENT-BYTE-SIZE ALIGNMENT
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>GEN-C-ARRAY-SIZES function}@c
@functionsubindex{gen-c-array-sizes}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/make<dot>lisp file, , @t{core/c-arrays/make.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gen-complete-lambda-pipeline-code} CTX COMPUTE IMPLICIT-U-LETS IMPLICIT-U-UPLOADS IMPLICIT-UNIFORM-TRANSFORMS POST PRIMITIVE STREAM-SYMB STREAM-TYPE U-CLEANUP U-LETS U-UPLOADS UNIFORM-NAMES
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GEN-COMPLETE-LAMBDA-PIPELINE-CODE function}@c
@functionsubindex{gen-complete-lambda-pipeline-code}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-lambda<dot>lisp file, , @t{core/pipelines/gpu-lambda.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gen-depth-stencil-texture} DEPTH STENCIL
@anchor{go to the CEPL<dot>FBOS<colon><colon>GEN-DEPTH-STENCIL-TEXTURE function}@c
@functionsubindex{gen-depth-stencil-texture}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gen-draw-buffer-call-from-array-form} FORM
@anchor{go to the CEPL<dot>FBOS<colon><colon>GEN-DRAW-BUFFER-CALL-FROM-ARRAY-FORM function}@c
@functionsubindex{gen-draw-buffer-call-from-array-form}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gen-draw-buffer-call-from-pattern} DRAW-BUFFERS
@anchor{go to the CEPL<dot>FBOS<colon><colon>GEN-DRAW-BUFFER-CALL-FROM-PATTERN function}@c
@functionsubindex{gen-draw-buffer-call-from-pattern}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gen-pipeline-init} NAME PRIMITIVE STAGE-PAIRS POST AGGREGATE-PUBLIC-UNIFORMS UNIFORM-ASSIGNERS STATE-TAG
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GEN-PIPELINE-INIT function}@c
@functionsubindex{gen-pipeline-init}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gen-query-id} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GEN-QUERY-ID function}@c
@functionsubindex{gen-query-id}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gen-recompile-func} NAME ORIGINAL-GPIPE-ARGS RAW-CONTEXT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GEN-RECOMPILE-FUNC function}@c
@functionsubindex{gen-recompile-func}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gen-texture} ()
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>GEN-TEXTURE function}@c
@functionsubindex{gen-texture}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gen-update-spec} NAME STAGE-PAIRS RAW-CONTEXT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GEN-UPDATE-SPEC function}@c
@functionsubindex{gen-update-spec}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gen-vertex-stage-code-calling-func} SPEC
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GEN-VERTEX-STAGE-CODE-CALLING-FUNC function}@c
@functionsubindex{gen-vertex-stage-code-calling-func}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/funcall-g<dot>lisp file, , @t{core/pipelines/funcall-g.lisp}} (file)
@end table
@end deffn
@deffn {Function} {generate-uniform-upload-forms} UNIFORM-ASSIGNERS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GENERATE-UNIFORM-UPLOAD-FORMS function}@c
@functionsubindex{generate-uniform-upload-forms}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {get-best-glsl-version} CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>GET-BEST-GLSL-VERSION function}@c
@functionsubindex{get-best-glsl-version}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/version<dot>lisp file, , @t{core/context/version.lisp}} (file)
@end table
@end deffn
@deffn {Function} {get-body-string} BODY
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GET-BODY-STRING function}@c
@functionsubindex{get-body-string}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/glsl-stages<dot>lisp file, , @t{core/pipelines/glsl-stages.lisp}} (file)
@end table
@end deffn
@deffn {Function} {get-component-length} COMPONENTS
@anchor{go to the CEPL<dot>PIXEL-FORMATS<colon><colon>GET-COMPONENT-LENGTH function}@c
@functionsubindex{get-component-length}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIXEL-FORMATS package, , @t{cepl.pixel-formats}}
@item Source
@ref{go to the cepl/core/types/pixel-format<dot>lisp file, , @t{core/types/pixel-format.lisp}} (file)
@end table
@end deffn
@deffn {Function} {get-dyn-return-types-from-stage} STAGE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GET-DYN-RETURN-TYPES-FROM-STAGE function}@c
@functionsubindex{get-dyn-return-types-from-stage}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/funcall-g<dot>lisp file, , @t{core/pipelines/funcall-g.lisp}} (file)
@end table
@end deffn
@deffn {Function} {get-feedback-out-vars} STAGES
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GET-FEEDBACK-OUT-VARS function}@c
@functionsubindex{get-feedback-out-vars}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {get-foreign-uniform-function} TYPE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GET-FOREIGN-UNIFORM-FUNCTION function}@c
@functionsubindex{get-foreign-uniform-function}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniforms<dot>lisp file, , @t{core/pipelines/uniforms.lisp}} (file)
@end table
@end deffn
@deffn {Function} {get-foreign-uniform-function-name} TYPE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GET-FOREIGN-UNIFORM-FUNCTION-NAME function}@c
@functionsubindex{get-foreign-uniform-function-name}@c
Used when uploading from a foreign data source (like a c-array)
   This lets your uploading from an offset the source
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniforms<dot>lisp file, , @t{core/pipelines/uniforms.lisp}} (file)
@end table
@end deffn
@deffn {Function} {get-free-context-id} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>GET-FREE-CONTEXT-ID function}@c
@functionsubindex{get-free-context-id}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {get-free-ssbo-id} ()
@anchor{go to the CEPL<dot>SSBOS<colon><colon>GET-FREE-SSBO-ID function}@c
@functionsubindex{get-free-ssbo-id}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SSBOS package, , @t{cepl.ssbos}}
@item Source
@ref{go to the cepl/core/ssbos/ssbos<dot>lisp file, , @t{core/ssbos/ssbos.lisp}} (file)
@end table
@end deffn
@deffn {Function} {get-free-ubo-id} ()
@anchor{go to the CEPL<dot>UBOS<colon><colon>GET-FREE-UBO-ID function}@c
@functionsubindex{get-free-ubo-id}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>UBOS package, , @t{cepl.ubos}}
@item Source
@ref{go to the cepl/core/ubos/ubo<dot>lisp file, , @t{core/ubos/ubo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {get-func-as-stage-code} FUNC-SPEC
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GET-FUNC-AS-STAGE-CODE function}@c
@functionsubindex{get-func-as-stage-code}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {get-gl-attachment-enum} CEPL-CONTEXT FBO X
@anchor{go to the CEPL<dot>FBOS<colon><colon>GET-GL-ATTACHMENT-ENUM function}@c
@functionsubindex{get-gl-attachment-enum}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {get-gpu-func-spec-tag} ()
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GET-GPU-FUNC-SPEC-TAG function}@c
@functionsubindex{get-gpu-func-spec-tag}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Function} {get-possible-designators-for-name} NAME
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GET-POSSIBLE-DESIGNATORS-FOR-NAME function}@c
@functionsubindex{get-possible-designators-for-name}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {get-sampler-id-box} LOD-BIAS MIN-LOD MAX-LOD MINIFY-FILTER MAGNIFY-FILTER WRAP COMPARE
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>GET-SAMPLER-ID-BOX function}@c
@functionsubindex{get-sampler-id-box}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {get-shader-storage-block-index} PROGRAM NAME
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GET-SHADER-STORAGE-BLOCK-INDEX function}@c
@functionsubindex{get-shader-storage-block-index}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Function} {get-stage-key} STAGE-DESIGNATOR &optional OPTIONS-ON-ERROR
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GET-STAGE-KEY function}@c
@functionsubindex{get-stage-key}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {get-stage-kind-from-context} CONTEXT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GET-STAGE-KIND-FROM-CONTEXT function}@c
@functionsubindex{get-stage-kind-from-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/glsl-stages<dot>lisp file, , @t{core/pipelines/glsl-stages.lisp}} (file)
@end table
@end deffn
@deffn {Function} {get-transform-feedback-primitive} STAGES
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GET-TRANSFORM-FEEDBACK-PRIMITIVE function}@c
@functionsubindex{get-transform-feedback-primitive}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {get-uniform-block-index} PROGRAM NAME
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GET-UNIFORM-BLOCK-INDEX function}@c
@functionsubindex{get-uniform-block-index}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Function} {get-uniform-function} TYPE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GET-UNIFORM-FUNCTION function}@c
@functionsubindex{get-uniform-function}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniforms<dot>lisp file, , @t{core/pipelines/uniforms.lisp}} (file)
@end table
@end deffn
@deffn {Function} {get-uniform-function-name} TYPE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GET-UNIFORM-FUNCTION-NAME function}@c
@functionsubindex{get-uniform-function-name}@c
Used when uploading lisp data
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniforms<dot>lisp file, , @t{core/pipelines/uniforms.lisp}} (file)
@end table
@end deffn
@deffn {Function} {get-varyings} PROG-ID INDEX
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GET-VARYINGS function}@c
@functionsubindex{get-varyings}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gl-calc-byte-size} TYPE DIMENSIONS ROW-ALIGNMENT
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>GL-CALC-BYTE-SIZE function}@c
@functionsubindex{gl-calc-byte-size}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/populate<dot>lisp file, , @t{core/c-arrays/populate.lisp}} (file)
@end table
@end deffn
@deffn {Function} {glambda-state-p} OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GLAMBDA-STATE-P function}@c
@functionsubindex{glambda-state-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-lambda<dot>lisp file, , @t{core/pipelines/gpu-lambda.lisp}} (file)
@end table
@end deffn
@deffn {Function} {glambda-state-pipeline} INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GLAMBDA-STATE-PIPELINE function}@c
@functionsubindex{glambda-state-pipeline}@c
@deffnx {Function} {(setf glambda-state-pipeline)} VALUE INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF GLAMBDA-STATE-PIPELINE) function}@c
@functionsubindex{(setf glambda-state-pipeline)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-lambda<dot>lisp file, , @t{core/pipelines/gpu-lambda.lisp}} (file)
@end table
@end deffn
@deffn {Function} {glambda-state-recompiler} INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GLAMBDA-STATE-RECOMPILER function}@c
@functionsubindex{glambda-state-recompiler}@c
@deffnx {Function} {(setf glambda-state-recompiler)} VALUE INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF GLAMBDA-STATE-RECOMPILER) function}@c
@functionsubindex{(setf glambda-state-recompiler)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-lambda<dot>lisp file, , @t{core/pipelines/gpu-lambda.lisp}} (file)
@end table
@end deffn
@deffn {Function} {glambda-state-spec} INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GLAMBDA-STATE-SPEC function}@c
@functionsubindex{glambda-state-spec}@c
@deffnx {Function} {(setf glambda-state-spec)} VALUE INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF GLAMBDA-STATE-SPEC) function}@c
@functionsubindex{(setf glambda-state-spec)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-lambda<dot>lisp file, , @t{core/pipelines/gpu-lambda.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-array-bb-dimensions} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-BB-DIMENSIONS function}@c
@functionsubindex{gpu-array-bb-dimensions}@c
@deffnx {Function} {(setf gpu-array-bb-dimensions)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-BB-DIMENSIONS) function}@c
@functionsubindex{(setf gpu-array-bb-dimensions)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-array-sub-data} GPU-ARRAY C-ARRAY &key TYPES-MUST-MATCH
@anchor{go to the CEPL<dot>GPU-BUFFERS<colon><colon>GPU-ARRAY-SUB-DATA function}@c
@functionsubindex{gpu-array-sub-data}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-BUFFERS package, , @t{cepl.gpu-buffers}}
@item Source
@ref{go to the cepl/core/gpu-buffers/gpu-buffers<dot>lisp file, , @t{core/gpu-buffers/gpu-buffers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-array-t-dimensions} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-ARRAY-T-DIMENSIONS function}@c
@functionsubindex{gpu-array-t-dimensions}@c
@deffnx {Function} {(setf gpu-array-t-dimensions)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF GPU-ARRAY-T-DIMENSIONS) function}@c
@functionsubindex{(setf gpu-array-t-dimensions)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-fence-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-FENCE-P function}@c
@functionsubindex{gpu-fence-p}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-func-specs} NAME &optional ERROR-IF-MISSING
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GPU-FUNC-SPECS function}@c
@functionsubindex{gpu-func-specs}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Function} {gpu-query-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>GPU-QUERY-P function}@c
@functionsubindex{gpu-query-p}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {guess-a-varjo-array-type} X
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GUESS-A-VARJO-ARRAY-TYPE function}@c
@functionsubindex{guess-a-varjo-array-type}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {guess-a-varjo-bool-type} X
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GUESS-A-VARJO-BOOL-TYPE function}@c
@functionsubindex{guess-a-varjo-bool-type}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {guess-a-varjo-float-type} X
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GUESS-A-VARJO-FLOAT-TYPE function}@c
@functionsubindex{guess-a-varjo-float-type}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {guess-a-varjo-integer-type} X
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GUESS-A-VARJO-INTEGER-TYPE function}@c
@functionsubindex{guess-a-varjo-integer-type}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {guess-a-varjo-number-type} X
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GUESS-A-VARJO-NUMBER-TYPE function}@c
@functionsubindex{guess-a-varjo-number-type}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {guess-a-varjo-type} X
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>GUESS-A-VARJO-TYPE function}@c
@functionsubindex{guess-a-varjo-type}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {handle-empty-framebuffer} FBO-OBJ ARGS
@anchor{go to the CEPL<dot>FBOS<colon><colon>HANDLE-EMPTY-FRAMEBUFFER function}@c
@functionsubindex{handle-empty-framebuffer}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {handle-transform-feedback} CTX DRAW-MODE PROG-ID TFS-PRIMITIVE TFS-ARRAY-COUNT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>HANDLE-TRANSFORM-FEEDBACK function}@c
@functionsubindex{handle-transform-feedback}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {has-func-type-in-args} FUNC-SPECS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>HAS-FUNC-TYPE-IN-ARGS function}@c
@functionsubindex{has-func-type-in-args}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {init-buffer-stream-from-id} STREAM-OBJ VAO-GL-OBJECT GPU-ARRAYS INDEX-ARRAY START LENGTH BASE-VERTEX RETAIN-ARRAYS
@anchor{go to the CEPL<dot>STREAMS<colon><colon>INIT-BUFFER-STREAM-FROM-ID function}@c
@functionsubindex{init-buffer-stream-from-id}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>STREAMS package, , @t{cepl.streams}}
@item Source
@ref{go to the cepl/core/streams/buffer-streams<dot>lisp file, , @t{core/streams/buffer-streams.lisp}} (file)
@end table
@end deffn
@deffn {Function} {init-buffer-stream-from-shared} NEW-STREAM SRC-STREAM BASE-VERTEX
@anchor{go to the CEPL<dot>STREAMS<colon><colon>INIT-BUFFER-STREAM-FROM-SHARED function}@c
@functionsubindex{init-buffer-stream-from-shared}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>STREAMS package, , @t{cepl.streams}}
@item Source
@ref{go to the cepl/core/streams/buffer-streams<dot>lisp file, , @t{core/streams/buffer-streams.lisp}} (file)
@end table
@end deffn
@deffn {Function} {init-gl-context} CEPL-CONTEXT SURFACE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>INIT-GL-CONTEXT function}@c
@functionsubindex{init-gl-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {init-gpu-array-from-c-array} ARR C-ARRAY ACCESS-STYLE DIMENSIONS
@anchor{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED<colon><colon>INIT-GPU-ARRAY-FROM-C-ARRAY function}@c
@functionsubindex{init-gpu-array-from-c-array}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED package, , @t{cepl.gpu-arrays.buffer-backed}}
@item Source
@ref{go to the cepl/core/gpu-arrays/buffer-backed<dot>lisp file, , @t{core/gpu-arrays/buffer-backed.lisp}} (file)
@end table
@end deffn
@deffn {Function} {init-gpu-array-no-data} ARRAY DIMENSIONS ELEMENT-TYPE ACCESS-STYLE ROW-ALIGNMENT
@anchor{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED<colon><colon>INIT-GPU-ARRAY-NO-DATA function}@c
@functionsubindex{init-gpu-array-no-data}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED package, , @t{cepl.gpu-arrays.buffer-backed}}
@item Source
@ref{go to the cepl/core/gpu-arrays/buffer-backed<dot>lisp file, , @t{core/gpu-arrays/buffer-backed.lisp}} (file)
@end table
@end deffn
@deffn {Function} {init-gpu-arrays-from-c-arrays} G-ARRAYS C-ARRAYS ACCESS-STYLE
@anchor{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED<colon><colon>INIT-GPU-ARRAYS-FROM-C-ARRAYS function}@c
@functionsubindex{init-gpu-arrays-from-c-arrays}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED package, , @t{cepl.gpu-arrays.buffer-backed}}
@item Source
@ref{go to the cepl/core/gpu-arrays/buffer-backed<dot>lisp file, , @t{core/gpu-arrays/buffer-backed.lisp}} (file)
@end table
@end deffn
@deffn {Function} {init-gpu-buffer-now} NEW-BUFFER GL-OBJECT INITIAL-CONTENTS BUFFER-TARGET USAGE
@anchor{go to the CEPL<dot>GPU-BUFFERS<colon><colon>INIT-GPU-BUFFER-NOW function}@c
@functionsubindex{init-gpu-buffer-now}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-BUFFERS package, , @t{cepl.gpu-buffers}}
@item Source
@ref{go to the cepl/core/gpu-buffers/gpu-buffers<dot>lisp file, , @t{core/gpu-buffers/gpu-buffers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {init-gpu-buffer-now-with-layouts} NEW-BUFFER GL-OBJECT LAYOUTS USAGE KEEP-DATA
@anchor{go to the CEPL<dot>GPU-BUFFERS<colon><colon>INIT-GPU-BUFFER-NOW-WITH-LAYOUTS function}@c
@functionsubindex{init-gpu-buffer-now-with-layouts}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-BUFFERS package, , @t{cepl.gpu-buffers}}
@item Source
@ref{go to the cepl/core/gpu-buffers/gpu-buffers<dot>lisp file, , @t{core/gpu-buffers/gpu-buffers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {init-pending-surfaces} CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>INIT-PENDING-SURFACES function}@c
@functionsubindex{init-pending-surfaces}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/surface<dot>lisp file, , @t{core/context/surface.lisp}} (file)
@end table
@end deffn
@deffn {Function} {initialize-all-delay-items-in-context} CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>INITIALIZE-ALL-DELAY-ITEMS-IN-CONTEXT function}@c
@functionsubindex{initialize-all-delay-items-in-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/delayed-resource-init<dot>lisp file, , @t{core/context/delayed-resource-init.lisp}} (file)
@end table
@end deffn
@deffn {Function} {initialize-all-delayed} THUNKS
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>INITIALIZE-ALL-DELAYED function}@c
@functionsubindex{initialize-all-delayed}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/delayed-resource-init<dot>lisp file, , @t{core/context/delayed-resource-init.lisp}} (file)
@end table
@end deffn
@deffn {Function} {initialize-as-empty-fbo} FBO
@anchor{go to the CEPL<dot>FBOS<colon><colon>INITIALIZE-AS-EMPTY-FBO function}@c
@functionsubindex{initialize-as-empty-fbo}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {initialize-delayed} DELAY-AGAIN ITEM
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>INITIALIZE-DELAYED function}@c
@functionsubindex{initialize-delayed}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/delayed-resource-init<dot>lisp file, , @t{core/context/delayed-resource-init.lisp}} (file)
@end table
@end deffn
@deffn {Function} {initialize-regular-fbo} FBO-OBJ
@anchor{go to the CEPL<dot>FBOS<colon><colon>INITIALIZE-REGULAR-FBO function}@c
@functionsubindex{initialize-regular-fbo}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {interactive-delete-gpu-function} NAME
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>INTERACTIVE-DELETE-GPU-FUNCTION function}@c
@functionsubindex{interactive-delete-gpu-function}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {interactive-pick-gpu-function} NAME
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>INTERACTIVE-PICK-GPU-FUNCTION function}@c
@functionsubindex{interactive-pick-gpu-function}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Function} {lambda-arg-p} X
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>LAMBDA-ARG-P function}@c
@functionsubindex{lambda-arg-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {lambda-g->lisp-code} GLAMBDA
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>LAMBDA-G->LISP-CODE function}@c
@functionsubindex{lambda-g->lisp-code}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-lambda<dot>lisp file, , @t{core/pipelines/gpu-lambda.lisp}} (file)
@end table
@end deffn
@deffn {Function} {lambda-g->state} LAMBDA-G
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>LAMBDA-G->STATE function}@c
@functionsubindex{lambda-g->state}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-lambda<dot>lisp file, , @t{core/pipelines/gpu-lambda.lisp}} (file)
@end table
@end deffn
@deffn {Function} {lambda-g->varjo-lambda-code} GLAMBDA
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>LAMBDA-G->VARJO-LAMBDA-CODE function}@c
@functionsubindex{lambda-g->varjo-lambda-code}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-lambda<dot>lisp file, , @t{core/pipelines/gpu-lambda.lisp}} (file)
@end table
@end deffn
@deffn {Function} {legacy-add-surface} CONTEXT TITLE WIDTH HEIGHT FULLSCREEN RESIZABLE NO-FRAME HIDDEN MAKE-CURRENT GL-VERSION
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>LEGACY-ADD-SURFACE function}@c
@functionsubindex{legacy-add-surface}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/surface<dot>lisp file, , @t{core/context/surface.lisp}} (file)
@end table
@end deffn
@deffn {Function} {link-shaders} SHADERS PROG-ID COMPILED-STAGES TRANSFORM-FEEDBACK-MODE TRANSFORM-FEEDBACK-NAMES
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>LINK-SHADERS function}@c
@functionsubindex{link-shaders}@c
Links all the shaders into the program provided
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {lisp-equivalent-of-keyword-cffi-type} NAME
@anchor{go to the CEPL<dot>TYPES<colon><colon>LISP-EQUIVALENT-OF-KEYWORD-CFFI-TYPE function}@c
@functionsubindex{lisp-equivalent-of-keyword-cffi-type}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/cffi-helpers<dot>lisp file, , @t{core/types/cffi-helpers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {list-of-c-arrays-p} X
@anchor{go to the CEPL<dot>GPU-BUFFERS<colon><colon>LIST-OF-C-ARRAYS-P function}@c
@functionsubindex{list-of-c-arrays-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-BUFFERS package, , @t{cepl.gpu-buffers}}
@item Source
@ref{go to the cepl/core/gpu-buffers/gpu-buffers<dot>lisp file, , @t{core/gpu-buffers/gpu-buffers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {load-shader} FILE-PATH &optional SHADER-TYPE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>LOAD-SHADER function}@c
@functionsubindex{load-shader}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {load-shaders} &rest SHADER-PATHS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>LOAD-SHADERS function}@c
@functionsubindex{load-shaders}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {loop-disabling-attachments} FBO
@anchor{go to the CEPL<dot>BLENDING<colon><colon>LOOP-DISABLING-ATTACHMENTS function}@c
@functionsubindex{loop-disabling-attachments}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@end table
@end deffn
@deffn {Function} {loop-enabling-attachments} FBO
@anchor{go to the CEPL<dot>BLENDING<colon><colon>LOOP-ENABLING-ATTACHMENTS function}@c
@functionsubindex{loop-enabling-attachments}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@end table
@end deffn
@deffn {Function} {lowest-suitable-glsl-version} COMPILE-CONTEXT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>LOWEST-SUITABLE-GLSL-VERSION function}@c
@functionsubindex{lowest-suitable-glsl-version}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {machine-unit-size} TYPE &optional STRIDE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MACHINE-UNIT-SIZE function}@c
@functionsubindex{machine-unit-size}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/layout<dot>lisp file, , @t{core/types/layout.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-arg-assigners} UNIFORM-ARGS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>MAKE-ARG-ASSIGNERS function}@c
@functionsubindex{make-arg-assigners}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-array-assigners} INDEXES ARG-NAME TYPE GLSL-NAME-PATH &optional BYTE-OFFSET
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>MAKE-ARRAY-ASSIGNERS function}@c
@functionsubindex{make-array-assigners}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-array-slot-getter} SLOT TYPE-NAME FOREIGN-STRUCT-NAME LAYOUT
@anchor{go to the CEPL<dot>TYPES<colon><colon>MAKE-ARRAY-SLOT-GETTER function}@c
@functionsubindex{make-array-slot-getter}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-array-slot-setter} SLOT TYPE-NAME LAYOUT
@anchor{go to the CEPL<dot>TYPES<colon><colon>MAKE-ARRAY-SLOT-SETTER function}@c
@functionsubindex{make-array-slot-setter}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-arrays-indirect-command} &key COUNT INSTANCE-COUNT FIRST BASE-INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>MAKE-ARRAYS-INDIRECT-COMMAND function}@c
@functionsubindex{make-arrays-indirect-command}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/multi-draw<dot>lisp file, , @t{core/pipelines/multi-draw.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-assigner} &key LET-FORMS UPLOADERS POINTER-ARG ARG-NAME LOCAL-ARG-NAME CLEANUP ALWAYS-UPLOADP
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>MAKE-ASSIGNER function}@c
@functionsubindex{make-assigner}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-assigner-let} &key NAME INDEX TYPE BODY
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>MAKE-ASSIGNER-LET function}@c
@functionsubindex{make-assigner-let}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-base-gstruct-wrapper} &key (POINTER POINTER)
@anchor{go to the CEPL<dot>TYPES<colon><colon>MAKE-BASE-GSTRUCT-WRAPPER function}@c
@functionsubindex{make-base-gstruct-wrapper}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-boop6} &key (BOOP-X BOOP-X) (BOOP-Y BOOP-Y)
@anchor{go to the DEFXSTAR-HIDDEN<colon><colon>MAKE-BOOP6 function}@c
@functionsubindex{make-boop6}@c
@table @strong
@item Package
@ref{go to the DEFXSTAR-HIDDEN package, , @t{defxstar-hidden}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-buffer-stream-from-id} VAO-GL-OBJECT GPU-ARRAYS &key INDEX-ARRAY START LENGTH RETAIN-ARRAYS PRIMITIVE BASE-VERTEX
@anchor{go to the CEPL<dot>STREAMS<colon><colon>MAKE-BUFFER-STREAM-FROM-ID function}@c
@functionsubindex{make-buffer-stream-from-id}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>STREAMS package, , @t{cepl.streams}}
@item Source
@ref{go to the cepl/core/streams/buffer-streams<dot>lisp file, , @t{core/streams/buffer-streams.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-compile-context} &key (PRIMITIVE PRIMITIVE) (VERSIONS VERSIONS) (STAGE STAGE) (STATIC-P STATIC-P)
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>MAKE-COMPILE-CONTEXT function}@c
@functionsubindex{make-compile-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/compile-context<dot>lisp file, , @t{core/pipelines/compile-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-complete-lambda-pipeline} COMPILE-CONTEXT STAGE-PAIRS FUNC-SPECS POST REGISTER-SPEC
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>MAKE-COMPLETE-LAMBDA-PIPELINE function}@c
@functionsubindex{make-complete-lambda-pipeline}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-lambda<dot>lisp file, , @t{core/pipelines/gpu-lambda.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-context-internals} IS-IMPLICIT-CONTEXT-P &optional GL-VERSION
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>MAKE-CONTEXT-INTERNALS function}@c
@functionsubindex{make-context-internals}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-default-sampler-id-box} ()
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>MAKE-DEFAULT-SAMPLER-ID-BOX function}@c
@functionsubindex{make-default-sampler-id-box}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-delayed} &key (WAITING-ON WAITING-ON) (THUNK THUNK)
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>MAKE-DELAYED function}@c
@functionsubindex{make-delayed}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/delayed-resource-init<dot>lisp file, , @t{core/context/delayed-resource-init.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-elements-indirect-command} &key COUNT INSTANCE-COUNT FIRST-INDEX BASE-VERTEX BASE-INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>MAKE-ELEMENTS-INDIRECT-COMMAND function}@c
@functionsubindex{make-elements-indirect-command}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/multi-draw<dot>lisp file, , @t{core/pipelines/multi-draw.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-eprim-slot-setter} SLOT TYPE-NAME FOREIGN-STRUCT-NAME LAYOUT
@anchor{go to the CEPL<dot>TYPES<colon><colon>MAKE-EPRIM-SLOT-SETTER function}@c
@functionsubindex{make-eprim-slot-setter}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-existing-fbo-empty} FBO LAST-ATTACHMENT
@anchor{go to the CEPL<dot>FBOS<colon><colon>MAKE-EXISTING-FBO-EMPTY function}@c
@functionsubindex{make-existing-fbo-empty}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-fbo-non-empty} FBO
@anchor{go to the CEPL<dot>FBOS<colon><colon>MAKE-FBO-NON-EMPTY function}@c
@functionsubindex{make-fbo-non-empty}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-fbo-now} FBO-OBJ
@anchor{go to the CEPL<dot>FBOS<colon><colon>MAKE-FBO-NOW function}@c
@functionsubindex{make-fbo-now}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-g-pnb} &key POSITION NORMAL TANGENT BI-TANGENT
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>MAKE-G-PNB function}@c
@functionsubindex{make-g-pnb}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-g-pncb} &key POSITION NORMAL TANGENT BI-TANGENT COLOR
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>MAKE-G-PNCB function}@c
@functionsubindex{make-g-pncb}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-g-pntb} &key POSITION NORMAL TANGENT BI-TANGENT TEXTURE
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>MAKE-G-PNTB function}@c
@functionsubindex{make-g-pntb}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-g-pntcb} &key POSITION NORMAL TANGENT BI-TANGENT TEXTURE COLOR
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>MAKE-G-PNTCB function}@c
@functionsubindex{make-g-pntcb}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-glambda-state} &key (PIPELINE PIPELINE) (RECOMPILER RECOMPILER) (SPEC SPEC)
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>MAKE-GLAMBDA-STATE function}@c
@functionsubindex{make-glambda-state}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-lambda<dot>lisp file, , @t{core/pipelines/gpu-lambda.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-gpu-array-share-data} GPU-ARRAY-TO-MODIFY GPU-ARRAY-WITH-DATA BYTE-OFFSET-INTO-SOURCE-DATA ELEMENT-TYPE DIMENSIONS ROW-ALIGNMENT PIXEL-FORMAT
@anchor{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED<colon><colon>MAKE-GPU-ARRAY-SHARE-DATA function}@c
@functionsubindex{make-gpu-array-share-data}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED package, , @t{cepl.gpu-arrays.buffer-backed}}
@item Source
@ref{go to the cepl/core/gpu-arrays/buffer-backed<dot>lisp file, , @t{core/gpu-arrays/buffer-backed.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-gpu-lambda} ARGS BODY
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>MAKE-GPU-LAMBDA function}@c
@functionsubindex{make-gpu-lambda}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-lambda<dot>lisp file, , @t{core/pipelines/gpu-lambda.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-gpu-query} ()
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MAKE-GPU-QUERY function}@c
@functionsubindex{make-gpu-query}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-instance-wrapper-def} NAME FOREIGN-STRUCT-NAME WRAPPER-CONSTRUCTOR-NAME SLOTS TYPED-POPULATE SLOT-LAYOUTS
@anchor{go to the CEPL<dot>TYPES<colon><colon>MAKE-INSTANCE-WRAPPER-DEF function}@c
@functionsubindex{make-instance-wrapper-def}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-lambda-pipeline} GPIPE-ARGS RAW/COMPILED-CONTEXT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>MAKE-LAMBDA-PIPELINE function}@c
@functionsubindex{make-lambda-pipeline}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-lambda<dot>lisp file, , @t{core/pipelines/gpu-lambda.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-lambda-pipeline-inner} GPIPE-ARGS COMPILE-CONTEXT &key REGISTER-LAMBDA-PIPELINE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>MAKE-LAMBDA-PIPELINE-INNER function}@c
@functionsubindex{make-lambda-pipeline-inner}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-lambda<dot>lisp file, , @t{core/pipelines/gpu-lambda.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-lambda-pipeline-spec} PROG-ID COMPILED-STAGES
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>MAKE-LAMBDA-PIPELINE-SPEC function}@c
@functionsubindex{make-lambda-pipeline-spec}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-make-struct} CONSTRUCTOR-NAME WRAPPER-CONSTRUCTOR-NAME AWRAP-TYPE-NAME SLOTS
@anchor{go to the CEPL<dot>TYPES<colon><colon>MAKE-MAKE-STRUCT function}@c
@functionsubindex{make-make-struct}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-partial-lambda-pipeline} FUNC-SPECS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>MAKE-PARTIAL-LAMBDA-PIPELINE function}@c
@functionsubindex{make-partial-lambda-pipeline}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-lambda<dot>lisp file, , @t{core/pipelines/gpu-lambda.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-pipeline-spec} NAME STAGES CONTEXT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>MAKE-PIPELINE-SPEC function}@c
@functionsubindex{make-pipeline-spec}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-pipeline-state} &key (DIFF-TAG DIFF-TAG) (PROG-IDS PROG-IDS) (IMPLICIT-UNIFORM-UPLOAD-FUNC IMPLICIT-UNIFORM-UPLOAD-FUNC) (TFS-PRIMITIVE TFS-PRIMITIVE) (TFS-ARRAY-COUNT TFS-ARRAY-COUNT) (HAS-FRAGMENT-STAGE HAS-FRAGMENT-STAGE) (UNIFORM-INT-IDS UNIFORM-INT-IDS) (UNIFORM-UINT-IDS UNIFORM-UINT-IDS)
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>MAKE-PIPELINE-STATE function}@c
@functionsubindex{make-pipeline-state}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-populate} NAME TYPED-POPULATE SLOTS
@anchor{go to the CEPL<dot>TYPES<colon><colon>MAKE-POPULATE function}@c
@functionsubindex{make-populate}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-pull-push} NAME SLOTS
@anchor{go to the CEPL<dot>TYPES<colon><colon>MAKE-PULL-PUSH function}@c
@functionsubindex{make-pull-push}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-render-buffer-now} RENDER-BUFFER DIMENSIONS IMAGE-FORMAT MULTISAMPLE
@anchor{go to the CEPL<dot>RENDER-BUFFERS<colon><colon>MAKE-RENDER-BUFFER-NOW function}@c
@functionsubindex{make-render-buffer-now}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>RENDER-BUFFERS package, , @t{cepl.render-buffers}}
@item Source
@ref{go to the cepl/core/render-buffers/render-buffer<dot>lisp file, , @t{core/render-buffers/render-buffer.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-sampler-assigner} INDEXES ARG-NAME TYPE GLSL-NAME-PATH
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>MAKE-SAMPLER-ASSIGNER function}@c
@functionsubindex{make-sampler-assigner}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-sampler-now} SAMPLER-OBJ LOD-BIAS MIN-LOD MAX-LOD MINIFY-FILTER MAGNIFY-FILTER WRAP COMPARE
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>MAKE-SAMPLER-NOW function}@c
@functionsubindex{make-sampler-now}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-scoped-gpu-query} &key (ID ID) (ENUM ENUM) (CACHE-ID CACHE-ID) (ACTIVE-P ACTIVE-P)
@anchor{go to the %CEPL<dot>TYPES<colon><colon>MAKE-SCOPED-GPU-QUERY function}@c
@functionsubindex{make-scoped-gpu-query}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-shader} SHADER-TYPE SOURCE-STRING &optional SHADER-ID
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>MAKE-SHADER function}@c
@functionsubindex{make-shader}@c
This makes a new opengl shader object by compiling the text
   in the specified file and, unless specified, establishing the
   shader type from the file extension
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-simple-assigner} INDEXES ARG-NAME TYPE GLSL-NAME-PATH &optional BYTE-OFFSET
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>MAKE-SIMPLE-ASSIGNER function}@c
@functionsubindex{make-simple-assigner}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-slot-getter} SLOT TYPE-NAME FOREIGN-STRUCT-NAME LAYOUT
@anchor{go to the CEPL<dot>TYPES<colon><colon>MAKE-SLOT-GETTER function}@c
@functionsubindex{make-slot-getter}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-slot-setter} SLOT TYPE-NAME FOREIGN-STRUCT-NAME LAYOUT
@anchor{go to the CEPL<dot>TYPES<colon><colon>MAKE-SLOT-SETTER function}@c
@functionsubindex{make-slot-setter}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-ssbo-assigner} INDEXES ARG-NAME VARJO-TYPE GLSL-NAME
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>MAKE-SSBO-ASSIGNER function}@c
@functionsubindex{make-ssbo-assigner}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-ssbo-from-buffer} &rest NOT-YET-IMPLEMENTED
@anchor{go to the CEPL<dot>SSBOS<colon><colon>MAKE-SSBO-FROM-BUFFER function}@c
@functionsubindex{make-ssbo-from-buffer}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SSBOS package, , @t{cepl.ssbos}}
@item Source
@ref{go to the cepl/core/ssbos/ssbos<dot>lisp file, , @t{core/ssbos/ssbos.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-stand-in-lisp-func} SPEC
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>MAKE-STAND-IN-LISP-FUNC function}@c
@functionsubindex{make-stand-in-lisp-func}@c
Makes a regular lisp function with the same names and arguments
  (where possible) as the gpu function who's spec is provided.@*

  If called the function will throw an error saying that the function
  can't currently be used from the cpu.@*

  This means we get function arg hints, doc-string and also we have the
  opportunity to provide a cpu implementation one day we want to.
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-struct-assigners} INDEXES ARG-NAME TYPE GLSL-NAME-PATH &optional BYTE-OFFSET
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>MAKE-STRUCT-ASSIGNERS function}@c
@functionsubindex{make-struct-assigners}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-struct-attrib-assigner} TYPE-NAME SLOTS
@anchor{go to the CEPL<dot>TYPES<colon><colon>MAKE-STRUCT-ATTRIB-ASSIGNER function}@c
@functionsubindex{make-struct-attrib-assigner}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-struct-pixel-format} NAME SLOTS
@anchor{go to the CEPL<dot>TYPES<colon><colon>MAKE-STRUCT-PIXEL-FORMAT function}@c
@functionsubindex{make-struct-pixel-format}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-surface-from-pending} PENDING-SURFACE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>MAKE-SURFACE-FROM-PENDING function}@c
@functionsubindex{make-surface-from-pending}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/surface<dot>lisp file, , @t{core/context/surface.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-t-slot-getter} SLOT TYPE-NAME FOREIGN-STRUCT-NAME
@anchor{go to the CEPL<dot>TYPES<colon><colon>MAKE-T-SLOT-GETTER function}@c
@functionsubindex{make-t-slot-getter}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-t-slot-setter} SLOT TYPE-NAME LAYOUT
@anchor{go to the CEPL<dot>TYPES<colon><colon>MAKE-T-SLOT-SETTER function}@c
@functionsubindex{make-t-slot-setter}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-texture-now} TEX-OBJ INITIAL-CONTENTS DIMENSIONS ELEMENT-TYPE MIPMAP LAYER-COUNT CUBES RECTANGLE IMMUTABLE BUFFER-STORAGE GENERATE-MIPMAPS PIXEL-FORMAT SAMPLES FIXED-SAMPLE-LOCATIONS
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>MAKE-TEXTURE-NOW function}@c
@functionsubindex{make-texture-now}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-ubo-assigner} INDEXES ARG-NAME VARJO-TYPE GLSL-NAME
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>MAKE-UBO-ASSIGNER function}@c
@functionsubindex{make-ubo-assigner}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-ubo-from-buffer} &rest NOT-YET-IMPLEMENTED
@anchor{go to the CEPL<dot>UBOS<colon><colon>MAKE-UBO-FROM-BUFFER function}@c
@functionsubindex{make-ubo-from-buffer}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>UBOS package, , @t{cepl.ubos}}
@item Source
@ref{go to the cepl/core/ubos/ubo<dot>lisp file, , @t{core/ubos/ubo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-uidx} &key (INT INT) (UINT UINT)
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>MAKE-UIDX function}@c
@functionsubindex{make-uidx}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-unbound-cepl-context} &key (CONSUMED CONSUMED) (GL-CONTEXT GL-CONTEXT) (REQUESTED-GL-VERSION REQUESTED-GL-VERSION) (SHARED SHARED) (SURFACE SURFACE) (SURFACES SURFACES)
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>MAKE-UNBOUND-CEPL-CONTEXT function}@c
@functionsubindex{make-unbound-cepl-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-varjo-struct-def} NAME SLOTS
@anchor{go to the CEPL<dot>TYPES<colon><colon>MAKE-VARJO-STRUCT-DEF function}@c
@functionsubindex{make-varjo-struct-def}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {make-varjo-struct-lookup} NAME
@anchor{go to the CEPL<dot>TYPES<colon><colon>MAKE-VARJO-STRUCT-LOOKUP function}@c
@functionsubindex{make-varjo-struct-lookup}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {mapg-context-p} CTX
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>MAPG-CONTEXT-P function}@c
@functionsubindex{mapg-context-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/mapg-context<dot>lisp file, , @t{core/pipelines/mapg-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {massage-compute-stage-name} NAME
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>MASSAGE-COMPUTE-STAGE-NAME function}@c
@functionsubindex{massage-compute-stage-name}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {merge-into-assigner} POINTER-ARG ASSINGERS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>MERGE-INTO-ASSIGNER function}@c
@functionsubindex{merge-into-assigner}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Function} {multisample-texture-p} TEXTURE
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>MULTISAMPLE-TEXTURE-P function}@c
@functionsubindex{multisample-texture-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {nest-simple-loops} DIMENSIONS INDEX-VARS BODY &optional LOOP-OP
@anchor{go to the CEPL<dot>TYPES<colon><colon>NEST-SIMPLE-LOOPS function}@c
@functionsubindex{nest-simple-loops}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {new-func-key} NAME IN-ARGS-TYPES
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>NEW-FUNC-KEY function}@c
@functionsubindex{new-func-key}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Function} {normalize-slot-description} QUALIFIED-STRUCT-NAME SLOT-DESCRIPTION SLOT-LAYOUT TYPE-NAME READERS WRITERS
@anchor{go to the CEPL<dot>TYPES<colon><colon>NORMALIZE-SLOT-DESCRIPTION function}@c
@functionsubindex{normalize-slot-description}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {note-change} SAMPLER
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>NOTE-CHANGE function}@c
@functionsubindex{note-change}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {pack-pixels-from-texture} TEX-ARRAY PIXEL-FORMAT ROW-ALIGNMENT POINTER/OFFSET
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>PACK-PIXELS-FROM-TEXTURE function}@c
@functionsubindex{pack-pixels-from-texture}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {pairs-key-to-stage} STAGE-PAIRS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>PAIRS-KEY-TO-STAGE function}@c
@functionsubindex{pairs-key-to-stage}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {parse-compile-context} NAME RAW-CONTEXT FOR
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>PARSE-COMPILE-CONTEXT function}@c
@functionsubindex{parse-compile-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/compile-context<dot>lisp file, , @t{core/pipelines/compile-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {parse-defn-args} TYPED-ARGS RESULT-TYPES
@anchor{go to the CEPL<dot>DEFN<colon><colon>PARSE-DEFN-ARGS function}@c
@functionsubindex{parse-defn-args}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>DEFN package, , @t{cepl.defn}}
@item Source
@ref{go to the cepl<dot>build/defn/defn<dot>lisp file, , @t{defn/defn.lisp}} (file)
@end table
@end deffn
@deffn {Function} {parse-gpipe-args} ARGS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>PARSE-GPIPE-ARGS function}@c
@functionsubindex{parse-gpipe-args}@c
Gets the stage pairs and context for the given gpipe form.@*
   If there are only two gpu functions named and no explicit stages then@*
   it is assumed that the first is the vertex stage and the second the fragment
   stage.@*
   Otherwise you are expected to name the stages. You can name one and then let
   this function fill in the rest, but I think that's a bit hairy and will
   probably be removed.@*

   stage pairs are of the form (stage-name . gpu-function-name)
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {parse-gpipe-args-explicit} ARGS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>PARSE-GPIPE-ARGS-EXPLICIT function}@c
@functionsubindex{parse-gpipe-args-explicit}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {parse-gpipe-args-implicit} ARGS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>PARSE-GPIPE-ARGS-IMPLICIT function}@c
@functionsubindex{parse-gpipe-args-implicit}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {parsed-gpipe-args->v-translate-args} NAME PIPELINE-PRIMITIVE STAGE-KIND FUNC-SPEC &optional REPLACEMENTS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>PARSED-GPIPE-ARGS->V-TRANSLATE-ARGS function}@c
@functionsubindex{parsed-gpipe-args->v-translate-args}@c
parsed-gpipe-args->v-translate-args processed the (stage . gfunc-name) pairs
   that %compile-link-and-upload want to call v-rolling-translate on.@*
   To do this we need to look up the gpu function spec and turn them into valid
   arguments for the rolling-translate function.@*
   It also:@*
   [0] if it's a glsl-stage then it is already compiled. Pass the
       compile-result and let varjo handle it@*
   [1] is what handles the transformation of func (including gpu-lambdas)
   [2] 'replacements' specifies uniforms to replace in the stage. 
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {patch-uninitialized-context-with-version} CEPL-CONTEXT REQUESTED-GL-VERSION
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>PATCH-UNINITIALIZED-CONTEXT-WITH-VERSION function}@c
@functionsubindex{patch-uninitialized-context-with-version}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {pipeline-spec} NAME
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>PIPELINE-SPEC function}@c
@functionsubindex{pipeline-spec}@c
@deffnx {Function} {(setf pipeline-spec)} VALUE NAME
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF PIPELINE-SPEC) function}@c
@functionsubindex{(setf pipeline-spec)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Function} {pipeline-state-diff-tag} INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>PIPELINE-STATE-DIFF-TAG function}@c
@functionsubindex{pipeline-state-diff-tag}@c
@deffnx {Function} {(setf pipeline-state-diff-tag)} VALUE INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF PIPELINE-STATE-DIFF-TAG) function}@c
@functionsubindex{(setf pipeline-state-diff-tag)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {pipeline-state-has-fragment-stage} INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>PIPELINE-STATE-HAS-FRAGMENT-STAGE function}@c
@functionsubindex{pipeline-state-has-fragment-stage}@c
@deffnx {Function} {(setf pipeline-state-has-fragment-stage)} VALUE INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF PIPELINE-STATE-HAS-FRAGMENT-STAGE) function}@c
@functionsubindex{(setf pipeline-state-has-fragment-stage)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {pipeline-state-implicit-uniform-upload-func} INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>PIPELINE-STATE-IMPLICIT-UNIFORM-UPLOAD-FUNC function}@c
@functionsubindex{pipeline-state-implicit-uniform-upload-func}@c
@deffnx {Function} {(setf pipeline-state-implicit-uniform-upload-func)} VALUE INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF PIPELINE-STATE-IMPLICIT-UNIFORM-UPLOAD-FUNC) function}@c
@functionsubindex{(setf pipeline-state-implicit-uniform-upload-func)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {pipeline-state-p} OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>PIPELINE-STATE-P function}@c
@functionsubindex{pipeline-state-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {pipeline-state-prog-ids} INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>PIPELINE-STATE-PROG-IDS function}@c
@functionsubindex{pipeline-state-prog-ids}@c
@deffnx {Function} {(setf pipeline-state-prog-ids)} VALUE INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF PIPELINE-STATE-PROG-IDS) function}@c
@functionsubindex{(setf pipeline-state-prog-ids)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {pipeline-state-tfs-array-count} INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>PIPELINE-STATE-TFS-ARRAY-COUNT function}@c
@functionsubindex{pipeline-state-tfs-array-count}@c
@deffnx {Function} {(setf pipeline-state-tfs-array-count)} VALUE INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF PIPELINE-STATE-TFS-ARRAY-COUNT) function}@c
@functionsubindex{(setf pipeline-state-tfs-array-count)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {pipeline-state-tfs-primitive} INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>PIPELINE-STATE-TFS-PRIMITIVE function}@c
@functionsubindex{pipeline-state-tfs-primitive}@c
@deffnx {Function} {(setf pipeline-state-tfs-primitive)} VALUE INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF PIPELINE-STATE-TFS-PRIMITIVE) function}@c
@functionsubindex{(setf pipeline-state-tfs-primitive)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {pipeline-state-uniform-int-ids} INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>PIPELINE-STATE-UNIFORM-INT-IDS function}@c
@functionsubindex{pipeline-state-uniform-int-ids}@c
@deffnx {Function} {(setf pipeline-state-uniform-int-ids)} VALUE INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF PIPELINE-STATE-UNIFORM-INT-IDS) function}@c
@functionsubindex{(setf pipeline-state-uniform-int-ids)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {pipeline-state-uniform-uint-ids} INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>PIPELINE-STATE-UNIFORM-UINT-IDS function}@c
@functionsubindex{pipeline-state-uniform-uint-ids}@c
@deffnx {Function} {(setf pipeline-state-uniform-uint-ids)} VALUE INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF PIPELINE-STATE-UNIFORM-UINT-IDS) function}@c
@functionsubindex{(setf pipeline-state-uniform-uint-ids)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {pixel-format!} COMPONENTS &optional TYPE NORMALIZE REVERSED
@anchor{go to the CEPL<dot>PIXEL-FORMATS<colon><colon>PIXEL-FORMAT! function}@c
@functionsubindex{pixel-format!}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIXEL-FORMATS package, , @t{cepl.pixel-formats}}
@item Source
@ref{go to the cepl/core/types/pixel-format<dot>lisp file, , @t{core/types/pixel-format.lisp}} (file)
@end table
@end deffn
@deffn {Function} {po2p} X
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>PO2P function}@c
@functionsubindex{po2p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {populate-arrays-indirect-command} OBJECT DATA
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>POPULATE-ARRAYS-INDIRECT-COMMAND function}@c
@functionsubindex{populate-arrays-indirect-command}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/multi-draw<dot>lisp file, , @t{core/pipelines/multi-draw.lisp}} (file)
@end table
@end deffn
@deffn {Function} {populate-elements-indirect-command} OBJECT DATA
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>POPULATE-ELEMENTS-INDIRECT-COMMAND function}@c
@functionsubindex{populate-elements-indirect-command}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/multi-draw<dot>lisp file, , @t{core/pipelines/multi-draw.lisp}} (file)
@end table
@end deffn
@deffn {Function} {populate-g-pc} OBJECT DATA
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>POPULATE-G-PC function}@c
@functionsubindex{populate-g-pc}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {populate-g-pn} OBJECT DATA
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>POPULATE-G-PN function}@c
@functionsubindex{populate-g-pn}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {populate-g-pnb} OBJECT DATA
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>POPULATE-G-PNB function}@c
@functionsubindex{populate-g-pnb}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {populate-g-pnc} OBJECT DATA
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>POPULATE-G-PNC function}@c
@functionsubindex{populate-g-pnc}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {populate-g-pncb} OBJECT DATA
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>POPULATE-G-PNCB function}@c
@functionsubindex{populate-g-pncb}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {populate-g-pnt} OBJECT DATA
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>POPULATE-G-PNT function}@c
@functionsubindex{populate-g-pnt}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {populate-g-pntb} OBJECT DATA
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>POPULATE-G-PNTB function}@c
@functionsubindex{populate-g-pntb}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {populate-g-pntc} OBJECT DATA
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>POPULATE-G-PNTC function}@c
@functionsubindex{populate-g-pntc}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {populate-g-pntcb} OBJECT DATA
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>POPULATE-G-PNTCB function}@c
@functionsubindex{populate-g-pntcb}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {populate-g-pt} OBJECT DATA
@anchor{go to the CEPL<dot>TYPES<dot>PREDEFINED<colon><colon>POPULATE-G-PT function}@c
@functionsubindex{populate-g-pt}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES<dot>PREDEFINED package, , @t{cepl.types.predefined}}
@item Source
@ref{go to the cepl/core/types/predefined/gpu-structs<dot>lisp file, , @t{core/types/predefined/gpu-structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {post-gl-init} FBO-OBJ &key ID DRAW-BUFFER-MAP CLEAR-MASK
@anchor{go to the CEPL<dot>FBOS<colon><colon>POST-GL-INIT function}@c
@functionsubindex{post-gl-init}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {potential-struct-layout} NAME LAYOUT-SPECIFIER SLOT-DESCRIPTIONS
@anchor{go to the CEPL<dot>TYPES<colon><colon>POTENTIAL-STRUCT-LAYOUT function}@c
@functionsubindex{potential-struct-layout}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {pre-gl-init} FBO-OBJ &key COLOR-ARRAYS DEPTH-ARRAY STENCIL-ARRAY IS-DEFAULT BLENDING-PARAMS
@anchor{go to the CEPL<dot>FBOS<colon><colon>PRE-GL-INIT function}@c
@functionsubindex{pre-gl-init}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {preprocess-gpu-arrays-for-vao} GPU-ARRAYS
@anchor{go to the CEPL<dot>VAOS<colon><colon>PREPROCESS-GPU-ARRAYS-FOR-VAO function}@c
@functionsubindex{preprocess-gpu-arrays-for-vao}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>VAOS package, , @t{cepl.vaos}}
@item Source
@ref{go to the cepl/core/vaos/vaos<dot>lisp file, , @t{core/vaos/vaos.lisp}} (file)
@end table
@end deffn
@deffn {Function} {primary-context} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>PRIMARY-CONTEXT function}@c
@functionsubindex{primary-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {primary-thread} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>PRIMARY-THREAD function}@c
@functionsubindex{primary-thread}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {primitive-keyword-to-enum-val} KWD
@anchor{go to the %CEPL<dot>TYPES<colon><colon>PRIMITIVE-KEYWORD-TO-ENUM-VAL function}@c
@functionsubindex{primitive-keyword-to-enum-val}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {primitive-vert-length} PRIM
@anchor{go to the %CEPL<dot>TYPES<colon><colon>PRIMITIVE-VERT-LENGTH function}@c
@functionsubindex{primitive-vert-length}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {primitives-generated-query-active-p} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>PRIMITIVES-GENERATED-QUERY-ACTIVE-P function}@c
@functionsubindex{primitives-generated-query-active-p}@c
@deffnx {Function} {(setf primitives-generated-query-active-p)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF PRIMITIVES-GENERATED-QUERY-ACTIVE-P) function}@c
@functionsubindex{(setf primitives-generated-query-active-p)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {primitives-generated-query-cache-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>PRIMITIVES-GENERATED-QUERY-CACHE-ID function}@c
@functionsubindex{primitives-generated-query-cache-id}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {primitives-generated-query-enum} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>PRIMITIVES-GENERATED-QUERY-ENUM function}@c
@functionsubindex{primitives-generated-query-enum}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {primitives-generated-query-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>PRIMITIVES-GENERATED-QUERY-ID function}@c
@functionsubindex{primitives-generated-query-id}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {primitives-generated-query-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>PRIMITIVES-GENERATED-QUERY-P function}@c
@functionsubindex{primitives-generated-query-p}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {process-defn-declares} FUNC-NAME DECLS
@anchor{go to the CEPL<dot>DEFN<colon><colon>PROCESS-DEFN-DECLARES function}@c
@functionsubindex{process-defn-declares}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>DEFN package, , @t{cepl.defn}}
@item Source
@ref{go to the cepl<dot>build/defn/defn<dot>lisp file, , @t{defn/defn.lisp}} (file)
@end table
@end deffn
@deffn {Function} {process-fbo-init-pattern} PATTERN
@anchor{go to the CEPL<dot>FBOS<colon><colon>PROCESS-FBO-INIT-PATTERN function}@c
@functionsubindex{process-fbo-init-pattern}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {process-glsl-arg} ARG
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>PROCESS-GLSL-ARG function}@c
@functionsubindex{process-glsl-arg}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/glsl-stages<dot>lisp file, , @t{core/pipelines/glsl-stages.lisp}} (file)
@end table
@end deffn
@deffn {Function} {process-layout} LAYOUT
@anchor{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED<colon><colon>PROCESS-LAYOUT function}@c
@functionsubindex{process-layout}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-ARRAYS<dot>BUFFER-BACKED package, , @t{cepl.gpu-arrays.buffer-backed}}
@item Source
@ref{go to the cepl/core/gpu-arrays/buffer-backed<dot>lisp file, , @t{core/gpu-arrays/buffer-backed.lisp}} (file)
@end table
@end deffn
@deffn {Function} {process-layout} LAYOUT
@anchor{go to the CEPL<dot>GPU-BUFFERS<colon><colon>PROCESS-LAYOUT function}@c
@functionsubindex{process-layout}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>GPU-BUFFERS package, , @t{cepl.gpu-buffers}}
@item Source
@ref{go to the cepl/core/gpu-buffers/gpu-buffers<dot>lisp file, , @t{core/gpu-buffers/gpu-buffers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {process-layout-specifier} LAYOUT-SPECIFIER
@anchor{go to the %CEPL<dot>TYPES<colon><colon>PROCESS-LAYOUT-SPECIFIER function}@c
@functionsubindex{process-layout-specifier}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/layout<dot>lisp file, , @t{core/types/layout.lisp}} (file)
@end table
@end deffn
@deffn {Function} {process-mp-path} PATHNAME NAME
@anchor{go to the CEPL<colon><colon>PROCESS-MP-PATH function}@c
@functionsubindex{process-mp-path}@c
@table @strong
@item Package
@ref{go to the CEPL package, , @t{cepl}}
@item Source
@ref{go to the cepl/project<dot>lisp file, , @t{project.lisp}} (file)
@end table
@end deffn
@deffn {Function} {process-pixel-format} COMPONENTS TYPE NORMALIZE REVERSED
@anchor{go to the CEPL<dot>PIXEL-FORMATS<colon><colon>PROCESS-PIXEL-FORMAT function}@c
@functionsubindex{process-pixel-format}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIXEL-FORMATS package, , @t{cepl.pixel-formats}}
@item Source
@ref{go to the cepl/core/types/pixel-format<dot>lisp file, , @t{core/types/pixel-format.lisp}} (file)
@end table
@end deffn
@deffn {Function} {process-stream-layout} LAYOUT
@anchor{go to the CEPL<dot>STREAMS<colon><colon>PROCESS-STREAM-LAYOUT function}@c
@functionsubindex{process-stream-layout}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>STREAMS package, , @t{cepl.streams}}
@item Source
@ref{go to the cepl/core/streams/buffer-streams<dot>lisp file, , @t{core/streams/buffer-streams.lisp}} (file)
@end table
@end deffn
@deffn {Function} {program-attrib-count} PROGRAM
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>PROGRAM-ATTRIB-COUNT function}@c
@functionsubindex{program-attrib-count}@c
Returns the number of attributes used by the shader
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/programs<dot>lisp file, , @t{core/pipelines/programs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {program-attributes} PROGRAM
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>PROGRAM-ATTRIBUTES function}@c
@functionsubindex{program-attributes}@c
Returns a list of details of the attributes used by
   the program. Each element in the list is a list in the
   format: (attribute-name attribute-type attribute-size)
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/programs<dot>lisp file, , @t{core/pipelines/programs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {program-uniform-count} PROG-ID
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>PROGRAM-UNIFORM-COUNT function}@c
@functionsubindex{program-uniform-count}@c
Returns the number of uniforms used by the shader
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/programs<dot>lisp file, , @t{core/pipelines/programs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {program-uniforms} PROGRAM-ID
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>PROGRAM-UNIFORMS function}@c
@functionsubindex{program-uniforms}@c
Returns a list of details of the uniforms used by@*
   the program. Each element in the list is a list in the
   format: (uniform-name uniform-type uniform-size)
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/programs<dot>lisp file, , @t{core/pipelines/programs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {ptr-index-1d} C-ARRAY X
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>PTR-INDEX-1D function}@c
@functionsubindex{ptr-index-1d}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/aref-c<dot>lisp file, , @t{core/c-arrays/aref-c.lisp}} (file)
@end table
@end deffn
@deffn {Function} {ptr-index-2d} C-ARRAY X Y
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>PTR-INDEX-2D function}@c
@functionsubindex{ptr-index-2d}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/aref-c<dot>lisp file, , @t{core/c-arrays/aref-c.lisp}} (file)
@end table
@end deffn
@deffn {Function} {ptr-index-3d} C-ARRAY X Y Z
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>PTR-INDEX-3D function}@c
@functionsubindex{ptr-index-3d}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/aref-c<dot>lisp file, , @t{core/c-arrays/aref-c.lisp}} (file)
@end table
@end deffn
@deffn {Function} {ptr-index-4d} C-ARRAY X Y Z W
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>PTR-INDEX-4D function}@c
@functionsubindex{ptr-index-4d}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/aref-c<dot>lisp file, , @t{core/c-arrays/aref-c.lisp}} (file)
@end table
@end deffn
@deffn {Function} {pull-g-soft-multi-func-message} ASSET-NAME
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>PULL-G-SOFT-MULTI-FUNC-MESSAGE function}@c
@functionsubindex{pull-g-soft-multi-func-message}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Function} {read-gpu-function-choice} INTRO-TEXT GFUNC-NAME
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>READ-GPU-FUNCTION-CHOICE function}@c
@functionsubindex{read-gpu-function-choice}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Function} {recompile-name} NAME
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>RECOMPILE-NAME function}@c
@functionsubindex{recompile-name}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Function} {register-event-listener} FUNCTION
@anchor{go to the CEPL<dot>HOST<colon><colon>REGISTER-EVENT-LISTENER function}@c
@functionsubindex{register-event-listener}@c
Register a function to be called on each event from the host
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-common<dot>lisp file, , @t{host/api-common.lisp}} (file)
@end table
@end deffn
@deffn {Function} {register-fbo} CEPL-CONTEXT FBO
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>REGISTER-FBO function}@c
@functionsubindex{register-fbo}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {register-gpu-buffer} CEPL-CONTEXT GPU-BUFFER
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>REGISTER-GPU-BUFFER function}@c
@functionsubindex{register-gpu-buffer}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {register-lambda-pipeline} SPEC CLOSURE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>REGISTER-LAMBDA-PIPELINE function}@c
@functionsubindex{register-lambda-pipeline}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-lambda<dot>lisp file, , @t{core/pipelines/gpu-lambda.lisp}} (file)
@end table
@end deffn
@deffn {Function} {register-named-pipeline} NAME FUNC
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>REGISTER-NAMED-PIPELINE function}@c
@functionsubindex{register-named-pipeline}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {register-texture} CEPL-CONTEXT TEXTURE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>REGISTER-TEXTURE function}@c
@functionsubindex{register-texture}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {reinit-on-context} GPU-ARRAY
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>REINIT-ON-CONTEXT function}@c
@functionsubindex{reinit-on-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {render-buffer-element-type} RENDER-BUFFER
@anchor{go to the CEPL<dot>RENDER-BUFFERS<colon><colon>RENDER-BUFFER-ELEMENT-TYPE function}@c
@functionsubindex{render-buffer-element-type}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>RENDER-BUFFERS package, , @t{cepl.render-buffers}}
@item Source
@ref{go to the cepl/core/render-buffers/render-buffer<dot>lisp file, , @t{core/render-buffers/render-buffer.lisp}} (file)
@end table
@end deffn
@deffn {Function} {replace-host} HOST-OBJ
@anchor{go to the CEPL<dot>HOST<colon><colon>REPLACE-HOST function}@c
@functionsubindex{replace-host}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>HOST package, , @t{cepl.host}}
@item Source
@ref{go to the cepl/host/api-api<dot>lisp file, , @t{host/api-api.lisp}} (file)
@end table
@end deffn
@deffn {Function} {request-program-id-for} CONTEXT NAME
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>REQUEST-PROGRAM-ID-FOR function}@c
@functionsubindex{request-program-id-for}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Function} {restore-state} CONTEXT PROGRAM STENCIL VAO FBOS-BOUND DEPTH-TEST-FUNCTION DEPTH-MASK DEPTH-RANGE DEPTH-CLAMP CLEAR-COLOR CULL-FACE FRONT-FACE VIEWPORT COLOR-MASK-INDICES TEX-UNIT-IDS BUFFER-TARGETS SCISSOR-VIEWPORT-INDICES UBO-INDICES SSBO-INDICES UNPACK-ALIGNMENT PACK-ALIGNMENT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>RESTORE-STATE function}@c
@functionsubindex{restore-state}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/known-state-blocks<dot>lisp file, , @t{core/context/known-state-blocks.lisp}} (file)
@end table
@end deffn
@deffn {Function} {rm-index-to-coords} INDEX SUBSCRIPTS
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>RM-INDEX-TO-COORDS function}@c
@functionsubindex{rm-index-to-coords}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/populate<dot>lisp file, , @t{core/c-arrays/populate.lisp}} (file)
@end table
@end deffn
@deffn {Function} {round-to-next-multiple} VAL MULTIPLE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>ROUND-TO-NEXT-MULTIPLE function}@c
@functionsubindex{round-to-next-multiple}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/layout<dot>lisp file, , @t{core/types/layout.lisp}} (file)
@end table
@end deffn
@deffn {Function} {sampler-id-box-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>SAMPLER-ID-BOX-P function}@c
@functionsubindex{sampler-id-box-p}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {sampler-on-context} ()
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>SAMPLER-ON-CONTEXT function}@c
@functionsubindex{sampler-on-context}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {sampler-typep} TYPE
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>SAMPLER-TYPEP function}@c
@functionsubindex{sampler-typep}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {samples-passed-query-active-p} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>SAMPLES-PASSED-QUERY-ACTIVE-P function}@c
@functionsubindex{samples-passed-query-active-p}@c
@deffnx {Function} {(setf samples-passed-query-active-p)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF SAMPLES-PASSED-QUERY-ACTIVE-P) function}@c
@functionsubindex{(setf samples-passed-query-active-p)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {samples-passed-query-cache-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>SAMPLES-PASSED-QUERY-CACHE-ID function}@c
@functionsubindex{samples-passed-query-cache-id}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {samples-passed-query-enum} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>SAMPLES-PASSED-QUERY-ENUM function}@c
@functionsubindex{samples-passed-query-enum}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {samples-passed-query-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>SAMPLES-PASSED-QUERY-ID function}@c
@functionsubindex{samples-passed-query-id}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {samples-passed-query-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>SAMPLES-PASSED-QUERY-P function}@c
@functionsubindex{samples-passed-query-p}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {scalar-type-p} TYPE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>SCALAR-TYPE-P function}@c
@functionsubindex{scalar-type-p}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/layout<dot>lisp file, , @t{core/types/layout.lisp}} (file)
@end table
@end deffn
@deffn {Function} {scan-array-for-type} DATA
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>SCAN-ARRAY-FOR-TYPE function}@c
@functionsubindex{scan-array-for-type}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/make<dot>lisp file, , @t{core/c-arrays/make.lisp}} (file)
@end table
@end deffn
@deffn {Function} {scan-for-type} DATA
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>SCAN-FOR-TYPE function}@c
@functionsubindex{scan-for-type}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/make<dot>lisp file, , @t{core/c-arrays/make.lisp}} (file)
@end table
@end deffn
@deffn {Function} {scan-list-for-type} DATA
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>SCAN-LIST-FOR-TYPE function}@c
@functionsubindex{scan-list-for-type}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/make<dot>lisp file, , @t{core/c-arrays/make.lisp}} (file)
@end table
@end deffn
@deffn {Function} {scoped-gpu-query-cache-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>SCOPED-GPU-QUERY-CACHE-ID function}@c
@functionsubindex{scoped-gpu-query-cache-id}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {scoped-gpu-query-enum} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>SCOPED-GPU-QUERY-ENUM function}@c
@functionsubindex{scoped-gpu-query-enum}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {scoped-gpu-query-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>SCOPED-GPU-QUERY-ID function}@c
@functionsubindex{scoped-gpu-query-id}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {scoped-gpu-query-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>SCOPED-GPU-QUERY-P function}@c
@functionsubindex{scoped-gpu-query-p}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {serialize-stage-pairs} STAGE-PAIRS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>SERIALIZE-STAGE-PAIRS function}@c
@functionsubindex{serialize-stage-pairs}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {set-buffer-bound-static} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>SET-BUFFER-BOUND-STATIC function}@c
@functionsubindex{set-buffer-bound-static}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {set-context-defaults} CEPL-CONTEXT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>SET-CONTEXT-DEFAULTS function}@c
@functionsubindex{set-context-defaults}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/make<dot>lisp file, , @t{core/context/make.lisp}} (file)
@end table
@end deffn
@deffn {Function} {set-current-blend-params} PARAMS &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>BLENDING<colon><colon>SET-CURRENT-BLEND-PARAMS function}@c
@functionsubindex{set-current-blend-params}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@end table
@end deffn
@deffn {Function} {set-current-blend-params-from-fbo} FBO &optional CEPL-CONTEXT
@anchor{go to the CEPL<dot>BLENDING<colon><colon>SET-CURRENT-BLEND-PARAMS-FROM-FBO function}@c
@functionsubindex{set-current-blend-params-from-fbo}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>BLENDING package, , @t{cepl.blending}}
@item Source
@ref{go to the cepl/core/blending/blending<dot>lisp file, , @t{core/blending/blending.lisp}} (file)
@end table
@end deffn
@deffn {Function} {set-patch-stream-primitive} STREAM PRIMITIVE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>SET-PATCH-STREAM-PRIMITIVE function}@c
@functionsubindex{set-patch-stream-primitive}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {set-sampler-bound} ()
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>SET-SAMPLER-BOUND function}@c
@functionsubindex{set-sampler-bound}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/samplers/context<dot>lisp file, , @t{core/samplers/context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {shader-type-from-path} PATH
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>SHADER-TYPE-FROM-PATH function}@c
@functionsubindex{shader-type-from-path}@c
This uses the extension to return the type of the shader.
   Currently it only recognises .vert or .frag files
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {slow-query-mipmap-count} TEXTURE
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>SLOW-QUERY-MIPMAP-COUNT function}@c
@functionsubindex{slow-query-mipmap-count}@c
This is a hack, never use it in production code.@*

GL has no function for querying the number of mipmap levels@*
so what we do is get the maxiumum possible count and iterate through checking
the width to see at what point the width reaches 0 or GL throws an error.
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {spec-changed-p} SPEC OLD-SPEC
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>SPEC-CHANGED-P function}@c
@functionsubindex{spec-changed-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Function} {split-args-for-dyn-call} ARGS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>SPLIT-ARGS-FOR-DYN-CALL function}@c
@functionsubindex{split-args-for-dyn-call}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/funcall-g<dot>lisp file, , @t{core/pipelines/funcall-g.lisp}} (file)
@end table
@end deffn
@deffn {Function} {ssbo-bind-buffer-id-range} CTX ID SSBO-BINDING-POINT OFFSET SIZE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>SSBO-BIND-BUFFER-ID-RANGE function}@c
@functionsubindex{ssbo-bind-buffer-id-range}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {stage-formp} X
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>STAGE-FORMP function}@c
@functionsubindex{stage-formp}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/pipeline-validation<dot>lisp file, , @t{core/pipelines/pipeline-validation.lisp}} (file)
@end table
@end deffn
@deffn {Function} {stages-require-partial-pipeline} FUNC-SPECS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>STAGES-REQUIRE-PARTIAL-PIPELINE function}@c
@functionsubindex{stages-require-partial-pipeline}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {stateless-quad-geometry-stage} &rest ARGS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>STATELESS-QUAD-GEOMETRY-STAGE function}@c
@functionsubindex{stateless-quad-geometry-stage}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/quad-stages<dot>lisp file, , @t{core/pipelines/quad-stages.lisp}} (file)
@end table
@end deffn
@deffn {Function} {stateless-quad-vertex-stage} &rest ARGS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>STATELESS-QUAD-VERTEX-STAGE function}@c
@functionsubindex{stateless-quad-vertex-stage}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/quad-stages<dot>lisp file, , @t{core/pipelines/quad-stages.lisp}} (file)
@end table
@end deffn
@deffn {Function} {stencil-operation-enum-to-func} ENUM
@anchor{go to the CEPL<dot>STENCIL<colon><colon>STENCIL-OPERATION-ENUM-TO-FUNC function}@c
@functionsubindex{stencil-operation-enum-to-func}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>STENCIL package, , @t{cepl.stencil}}
@item Source
@ref{go to the cepl/core/stencil/stencil<dot>lisp file, , @t{core/stencil/stencil.lisp}} (file)
@end table
@end deffn
@deffn {Function} {stencil-operation-to-enum} OPERATION
@anchor{go to the CEPL<dot>STENCIL<colon><colon>STENCIL-OPERATION-TO-ENUM function}@c
@functionsubindex{stencil-operation-to-enum}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>STENCIL package, , @t{cepl.stencil}}
@item Source
@ref{go to the cepl/core/stencil/stencil<dot>lisp file, , @t{core/stencil/stencil.lisp}} (file)
@end table
@end deffn
@deffn {Function} {stencil-params-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>STENCIL-PARAMS-P function}@c
@functionsubindex{stencil-params-p}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {stencil-test-enum-to-func} ENUM
@anchor{go to the CEPL<dot>STENCIL<colon><colon>STENCIL-TEST-ENUM-TO-FUNC function}@c
@functionsubindex{stencil-test-enum-to-func}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>STENCIL package, , @t{cepl.stencil}}
@item Source
@ref{go to the cepl/core/stencil/stencil<dot>lisp file, , @t{core/stencil/stencil.lisp}} (file)
@end table
@end deffn
@deffn {Function} {stencil-test-to-enum} TEST
@anchor{go to the CEPL<dot>STENCIL<colon><colon>STENCIL-TEST-TO-ENUM function}@c
@functionsubindex{stencil-test-to-enum}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>STENCIL package, , @t{cepl.stencil}}
@item Source
@ref{go to the cepl/core/stencil/stencil<dot>lisp file, , @t{core/stencil/stencil.lisp}} (file)
@end table
@end deffn
@deffn {Function} {suitable-array-for-index-p} ARRAY
@anchor{go to the CEPL<dot>VAOS<colon><colon>SUITABLE-ARRAY-FOR-INDEX-P function}@c
@functionsubindex{suitable-array-for-index-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>VAOS package, , @t{cepl.vaos}}
@item Source
@ref{go to the cepl/core/vaos/vaos<dot>lisp file, , @t{core/vaos/vaos.lisp}} (file)
@end table
@end deffn
@deffn {Function} {surface-dimensions} SURFACE
@anchor{go to the CEPL<dot>INTERNALS<colon><colon>SURFACE-DIMENSIONS function}@c
@functionsubindex{surface-dimensions}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>INTERNALS package, , @t{cepl.internals}}
@item Source
@ref{go to the cepl/core/internals<dot>lisp file, , @t{core/internals.lisp}} (file)
@end table
@end deffn
@deffn {Function} {surface-resolution} SURFACE
@anchor{go to the CEPL<dot>INTERNALS<colon><colon>SURFACE-RESOLUTION function}@c
@functionsubindex{surface-resolution}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>INTERNALS package, , @t{cepl.internals}}
@item Source
@ref{go to the cepl/core/internals<dot>lisp file, , @t{core/internals.lisp}} (file)
@end table
@end deffn
@deffn {Function} {suspended-p} ()
@anchor{go to the CEPL<dot>LIFECYCLE<colon><colon>SUSPENDED-P function}@c
@functionsubindex{suspended-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>LIFECYCLE package, , @t{cepl.lifecycle}}
@item Source
@ref{go to the cepl/core/lifecycle<dot>lisp file, , @t{core/lifecycle.lisp}} (file)
@end table
@end deffn
@deffn {Function} {swap-versions} STAGE-PAIRS GLSL-VERSION
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>SWAP-VERSIONS function}@c
@functionsubindex{swap-versions}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/defpipeline<dot>lisp file, , @t{core/pipelines/defpipeline.lisp}} (file)
@end table
@end deffn
@deffn {Function} {(setf tex-compare)} VALUE TEXTURE
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>(SETF TEX-COMPARE) function}@c
@functionsubindex{(setf tex-compare)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/texture-samplers<dot>lisp file, , @t{core/textures/texture-samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {tex-kind->cache-index} KIND
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>TEX-KIND->CACHE-INDEX function}@c
@functionsubindex{tex-kind->cache-index}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {(setf tex-lod-bias)} VALUE TEXTURE
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>(SETF TEX-LOD-BIAS) function}@c
@functionsubindex{(setf tex-lod-bias)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/texture-samplers<dot>lisp file, , @t{core/textures/texture-samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {(setf tex-magnify-filter)} VALUE TEXTURE
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>(SETF TEX-MAGNIFY-FILTER) function}@c
@functionsubindex{(setf tex-magnify-filter)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/texture-samplers<dot>lisp file, , @t{core/textures/texture-samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {(setf tex-max-lod)} VALUE TEXTURE
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>(SETF TEX-MAX-LOD) function}@c
@functionsubindex{(setf tex-max-lod)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/texture-samplers<dot>lisp file, , @t{core/textures/texture-samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {(setf tex-min-lod)} VALUE TEXTURE
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>(SETF TEX-MIN-LOD) function}@c
@functionsubindex{(setf tex-min-lod)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/texture-samplers<dot>lisp file, , @t{core/textures/texture-samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {(setf tex-minify-filter)} VALUE TEXTURE
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>(SETF TEX-MINIFY-FILTER) function}@c
@functionsubindex{(setf tex-minify-filter)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/texture-samplers<dot>lisp file, , @t{core/textures/texture-samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {tex-storage-1d} TARGET LEVELS IMAGE-FORMAT WIDTH
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>TEX-STORAGE-1D function}@c
@functionsubindex{tex-storage-1d}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {tex-storage-2d} TARGET LEVELS IMAGE-FORMAT WIDTH HEIGHT
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>TEX-STORAGE-2D function}@c
@functionsubindex{tex-storage-2d}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {tex-storage-2d-multisample} TARGET IMAGE-FORMAT WIDTH HEIGHT SAMPLES FIXED-SAMPLE-LOCATIONS
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>TEX-STORAGE-2D-MULTISAMPLE function}@c
@functionsubindex{tex-storage-2d-multisample}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {tex-storage-3d} TARGET LEVELS IMAGE-FORMAT WIDTH HEIGHT DEPTH
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>TEX-STORAGE-3D function}@c
@functionsubindex{tex-storage-3d}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {tex-storage-3d-multisample} TARGET IMAGE-FORMAT WIDTH HEIGHT DEPTH SAMPLES FIXED-SAMPLE-LOCATIONS
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>TEX-STORAGE-3D-MULTISAMPLE function}@c
@functionsubindex{tex-storage-3d-multisample}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {(setf tex-wrap)} VALUE TEXTURE
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>(SETF TEX-WRAP) function}@c
@functionsubindex{(setf tex-wrap)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/texture-samplers<dot>lisp file, , @t{core/textures/texture-samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {time-elapsed-query-active-p} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TIME-ELAPSED-QUERY-ACTIVE-P function}@c
@functionsubindex{time-elapsed-query-active-p}@c
@deffnx {Function} {(setf time-elapsed-query-active-p)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF TIME-ELAPSED-QUERY-ACTIVE-P) function}@c
@functionsubindex{(setf time-elapsed-query-active-p)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {time-elapsed-query-cache-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TIME-ELAPSED-QUERY-CACHE-ID function}@c
@functionsubindex{time-elapsed-query-cache-id}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {time-elapsed-query-enum} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TIME-ELAPSED-QUERY-ENUM function}@c
@functionsubindex{time-elapsed-query-enum}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {time-elapsed-query-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TIME-ELAPSED-QUERY-ID function}@c
@functionsubindex{time-elapsed-query-id}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {time-elapsed-query-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TIME-ELAPSED-QUERY-P function}@c
@functionsubindex{time-elapsed-query-p}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {timestamp-query-cache-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TIMESTAMP-QUERY-CACHE-ID function}@c
@functionsubindex{timestamp-query-cache-id}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {timestamp-query-enum} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TIMESTAMP-QUERY-ENUM function}@c
@functionsubindex{timestamp-query-enum}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {timestamp-query-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TIMESTAMP-QUERY-ID function}@c
@functionsubindex{timestamp-query-id}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {timestamp-query-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TIMESTAMP-QUERY-P function}@c
@functionsubindex{timestamp-query-p}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {to-active} TARGET-STATE
@anchor{go to the CEPL<dot>LIFECYCLE<colon><colon>TO-ACTIVE function}@c
@functionsubindex{to-active}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>LIFECYCLE package, , @t{cepl.lifecycle}}
@item Source
@ref{go to the cepl/core/lifecycle<dot>lisp file, , @t{core/lifecycle.lisp}} (file)
@end table
@end deffn
@deffn {Function} {to-cepl-type-spec} SPEC
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>TO-CEPL-TYPE-SPEC function}@c
@functionsubindex{to-cepl-type-spec}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/funcall-g<dot>lisp file, , @t{core/pipelines/funcall-g.lisp}} (file)
@end table
@end deffn
@deffn {Function} {to-shutting-down} ()
@anchor{go to the CEPL<dot>LIFECYCLE<colon><colon>TO-SHUTTING-DOWN function}@c
@functionsubindex{to-shutting-down}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>LIFECYCLE package, , @t{cepl.lifecycle}}
@item Source
@ref{go to the cepl/core/lifecycle<dot>lisp file, , @t{core/lifecycle.lisp}} (file)
@end table
@end deffn
@deffn {Function} {to-suspended} TARGET-STATE
@anchor{go to the CEPL<dot>LIFECYCLE<colon><colon>TO-SUSPENDED function}@c
@functionsubindex{to-suspended}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>LIFECYCLE package, , @t{cepl.lifecycle}}
@item Source
@ref{go to the cepl/core/lifecycle<dot>lisp file, , @t{core/lifecycle.lisp}} (file)
@end table
@end deffn
@deffn {Function} {transform-feedback-bind-buffer-id-range} CTX ID TFB-BINDING-POINT OFFSET SIZE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>TRANSFORM-FEEDBACK-BIND-BUFFER-ID-RANGE function}@c
@functionsubindex{transform-feedback-bind-buffer-id-range}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {transform-feedback-primitives-written-query-active-p} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TRANSFORM-FEEDBACK-PRIMITIVES-WRITTEN-QUERY-ACTIVE-P function}@c
@functionsubindex{transform-feedback-primitives-written-query-active-p}@c
@deffnx {Function} {(setf transform-feedback-primitives-written-query-active-p)} VALUE INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>(SETF TRANSFORM-FEEDBACK-PRIMITIVES-WRITTEN-QUERY-ACTIVE-P) function}@c
@functionsubindex{(setf transform-feedback-primitives-written-query-active-p)}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {transform-feedback-primitives-written-query-cache-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TRANSFORM-FEEDBACK-PRIMITIVES-WRITTEN-QUERY-CACHE-ID function}@c
@functionsubindex{transform-feedback-primitives-written-query-cache-id}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {transform-feedback-primitives-written-query-enum} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TRANSFORM-FEEDBACK-PRIMITIVES-WRITTEN-QUERY-ENUM function}@c
@functionsubindex{transform-feedback-primitives-written-query-enum}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {transform-feedback-primitives-written-query-id} INSTANCE
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TRANSFORM-FEEDBACK-PRIMITIVES-WRITTEN-QUERY-ID function}@c
@functionsubindex{transform-feedback-primitives-written-query-id}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {transform-feedback-primitives-written-query-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TRANSFORM-FEEDBACK-PRIMITIVES-WRITTEN-QUERY-P function}@c
@functionsubindex{transform-feedback-primitives-written-query-p}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {transform-feedback-stream-p} OBJECT
@anchor{go to the %CEPL<dot>TYPES<colon><colon>TRANSFORM-FEEDBACK-STREAM-P function}@c
@functionsubindex{transform-feedback-stream-p}@c
@table @strong
@item Package
@ref{go to the %CEPL<dot>TYPES package, , @t{%cepl.types}}
@item Source
@ref{go to the cepl/core/types/cepl-types<dot>lisp file, , @t{core/types/cepl-types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {try-guessing-a-varjo-type-for-symbol} S
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>TRY-GUESSING-A-VARJO-TYPE-FOR-SYMBOL function}@c
@functionsubindex{try-guessing-a-varjo-type-for-symbol}@c
This function is provided to varjo to allow inference of the
   types of implicit uniforms.
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {try-injecting-a-constant} CONSTANT-NAME
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>TRY-INJECTING-A-CONSTANT function}@c
@functionsubindex{try-injecting-a-constant}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {type-contains-structs} TYPE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>TYPE-CONTAINS-STRUCTS function}@c
@functionsubindex{type-contains-structs}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/glsl-stages<dot>lisp file, , @t{core/pipelines/glsl-stages.lisp}} (file)
@end table
@end deffn
@deffn {Function} {typed-defp} X
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>TYPED-DEFP function}@c
@functionsubindex{typed-defp}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/pipeline-validation<dot>lisp file, , @t{core/pipelines/pipeline-validation.lisp}} (file)
@end table
@end deffn
@deffn {Function} {ubo-bind-buffer-id-range} CTX ID UBO-BINDING-POINT OFFSET SIZE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>UBO-BIND-BUFFER-ID-RANGE function}@c
@functionsubindex{ubo-bind-buffer-id-range}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/cepl-context<dot>lisp file, , @t{core/context/cepl-context.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uidx-int} INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>UIDX-INT function}@c
@functionsubindex{uidx-int}@c
@deffnx {Function} {(setf uidx-int)} VALUE INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF UIDX-INT) function}@c
@functionsubindex{(setf uidx-int)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uidx-p} OBJECT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>UIDX-P function}@c
@functionsubindex{uidx-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uidx-uint} INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>UIDX-UINT function}@c
@functionsubindex{uidx-uint}@c
@deffnx {Function} {(setf uidx-uint)} VALUE INSTANCE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>(SETF UIDX-UINT) function}@c
@functionsubindex{(setf uidx-uint)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniform-assigners-generation<dot>lisp file, , @t{core/pipelines/uniform-assigners-generation.lisp}} (file)
@end table
@end deffn
@deffn {Function} {unbind-texture-from-scratch} ()
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>UNBIND-TEXTURE-FROM-SCRATCH function}@c
@functionsubindex{unbind-texture-from-scratch}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/def<dot>lisp file, , @t{core/textures/def.lisp}} (file)
@end table
@end deffn
@deffn {Function} {unbound-cepl-context-consumed} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>UNBOUND-CEPL-CONTEXT-CONSUMED function}@c
@functionsubindex{unbound-cepl-context-consumed}@c
@deffnx {Function} {(setf unbound-cepl-context-consumed)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF UNBOUND-CEPL-CONTEXT-CONSUMED) function}@c
@functionsubindex{(setf unbound-cepl-context-consumed)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {unbound-cepl-context-gl-context} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>UNBOUND-CEPL-CONTEXT-GL-CONTEXT function}@c
@functionsubindex{unbound-cepl-context-gl-context}@c
@deffnx {Function} {(setf unbound-cepl-context-gl-context)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF UNBOUND-CEPL-CONTEXT-GL-CONTEXT) function}@c
@functionsubindex{(setf unbound-cepl-context-gl-context)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {unbound-cepl-context-p} OBJECT
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>UNBOUND-CEPL-CONTEXT-P function}@c
@functionsubindex{unbound-cepl-context-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {unbound-cepl-context-requested-gl-version} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>UNBOUND-CEPL-CONTEXT-REQUESTED-GL-VERSION function}@c
@functionsubindex{unbound-cepl-context-requested-gl-version}@c
@deffnx {Function} {(setf unbound-cepl-context-requested-gl-version)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF UNBOUND-CEPL-CONTEXT-REQUESTED-GL-VERSION) function}@c
@functionsubindex{(setf unbound-cepl-context-requested-gl-version)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {unbound-cepl-context-shared} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>UNBOUND-CEPL-CONTEXT-SHARED function}@c
@functionsubindex{unbound-cepl-context-shared}@c
@deffnx {Function} {(setf unbound-cepl-context-shared)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF UNBOUND-CEPL-CONTEXT-SHARED) function}@c
@functionsubindex{(setf unbound-cepl-context-shared)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {unbound-cepl-context-surface} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>UNBOUND-CEPL-CONTEXT-SURFACE function}@c
@functionsubindex{unbound-cepl-context-surface}@c
@deffnx {Function} {(setf unbound-cepl-context-surface)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF UNBOUND-CEPL-CONTEXT-SURFACE) function}@c
@functionsubindex{(setf unbound-cepl-context-surface)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {unbound-cepl-context-surfaces} INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>UNBOUND-CEPL-CONTEXT-SURFACES function}@c
@functionsubindex{unbound-cepl-context-surfaces}@c
@deffnx {Function} {(setf unbound-cepl-context-surfaces)} VALUE INSTANCE
@anchor{go to the CEPL<dot>CONTEXT<colon><colon>(SETF UNBOUND-CEPL-CONTEXT-SURFACES) function}@c
@functionsubindex{(setf unbound-cepl-context-surfaces)}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>CONTEXT package, , @t{cepl.context}}
@item Source
@ref{go to the cepl/core/context/types<dot>lisp file, , @t{core/context/types.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uniform-1b} ()
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>UNIFORM-1B function}@c
@functionsubindex{uniform-1b}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniforms<dot>lisp file, , @t{core/pipelines/uniforms.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uniform-1f} ()
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>UNIFORM-1F function}@c
@functionsubindex{uniform-1f}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniforms<dot>lisp file, , @t{core/pipelines/uniforms.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uniform-1i} ()
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>UNIFORM-1I function}@c
@functionsubindex{uniform-1i}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniforms<dot>lisp file, , @t{core/pipelines/uniforms.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uniform-2f} ()
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>UNIFORM-2F function}@c
@functionsubindex{uniform-2f}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniforms<dot>lisp file, , @t{core/pipelines/uniforms.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uniform-2i} ()
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>UNIFORM-2I function}@c
@functionsubindex{uniform-2i}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniforms<dot>lisp file, , @t{core/pipelines/uniforms.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uniform-3f} ()
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>UNIFORM-3F function}@c
@functionsubindex{uniform-3f}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniforms<dot>lisp file, , @t{core/pipelines/uniforms.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uniform-3i} ()
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>UNIFORM-3I function}@c
@functionsubindex{uniform-3i}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniforms<dot>lisp file, , @t{core/pipelines/uniforms.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uniform-4f} ()
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>UNIFORM-4F function}@c
@functionsubindex{uniform-4f}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniforms<dot>lisp file, , @t{core/pipelines/uniforms.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uniform-4i} ()
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>UNIFORM-4I function}@c
@functionsubindex{uniform-4i}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniforms<dot>lisp file, , @t{core/pipelines/uniforms.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uniform-matrix-2ft} ()
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>UNIFORM-MATRIX-2FT function}@c
@functionsubindex{uniform-matrix-2ft}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniforms<dot>lisp file, , @t{core/pipelines/uniforms.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uniform-matrix-2fvt} LOCATION COUNT PTR
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>UNIFORM-MATRIX-2FVT function}@c
@functionsubindex{uniform-matrix-2fvt}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniforms<dot>lisp file, , @t{core/pipelines/uniforms.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uniform-matrix-3ft} ()
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>UNIFORM-MATRIX-3FT function}@c
@functionsubindex{uniform-matrix-3ft}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniforms<dot>lisp file, , @t{core/pipelines/uniforms.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uniform-matrix-3fvt} LOCATION COUNT PTR
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>UNIFORM-MATRIX-3FVT function}@c
@functionsubindex{uniform-matrix-3fvt}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniforms<dot>lisp file, , @t{core/pipelines/uniforms.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uniform-matrix-4ft} ()
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>UNIFORM-MATRIX-4FT function}@c
@functionsubindex{uniform-matrix-4ft}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniforms<dot>lisp file, , @t{core/pipelines/uniforms.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uniform-matrix-4fvt} LOCATION COUNT PTR
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>UNIFORM-MATRIX-4FVT function}@c
@functionsubindex{uniform-matrix-4fvt}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniforms<dot>lisp file, , @t{core/pipelines/uniforms.lisp}} (file)
@end table
@end deffn
@deffn {Function} {uniform-sampler} ()
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>UNIFORM-SAMPLER function}@c
@functionsubindex{uniform-sampler}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/uniforms<dot>lisp file, , @t{core/pipelines/uniforms.lisp}} (file)
@end table
@end deffn
@deffn {Function} {update-clear-mask} FBO
@anchor{go to the CEPL<dot>FBOS<colon><colon>UPDATE-CLEAR-MASK function}@c
@functionsubindex{update-clear-mask}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {update-data} DATA TYPE
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>UPDATE-DATA function}@c
@functionsubindex{update-data}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/make<dot>lisp file, , @t{core/c-arrays/make.lisp}} (file)
@end table
@end deffn
@deffn {Function} {update-draw-buffer-map} FBO
@anchor{go to the CEPL<dot>FBOS<colon><colon>UPDATE-DRAW-BUFFER-MAP function}@c
@functionsubindex{update-draw-buffer-map}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {update-pipeline-spec} SPEC
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>UPDATE-PIPELINE-SPEC function}@c
@functionsubindex{update-pipeline-spec}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Function} {update-specs-with-missing-dependencies} ()
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>UPDATE-SPECS-WITH-MISSING-DEPENDENCIES function}@c
@functionsubindex{update-specs-with-missing-dependencies}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Function} {upload-c-array-to-gpu-array-t} GPU-ARRAY C-ARRAY &optional PIXEL-FORMAT
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>UPLOAD-C-ARRAY-TO-GPU-ARRAY-T function}@c
@functionsubindex{upload-c-array-to-gpu-array-t}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {upload-gpu-array-bb-to-gpu-array-t} GPU-ARRAY-T GPU-ARRAY-BB &optional PIXEL-FORMAT
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>UPLOAD-GPU-ARRAY-BB-TO-GPU-ARRAY-T function}@c
@functionsubindex{upload-gpu-array-bb-to-gpu-array-t}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {use-program} CTX PROGRAM-ID
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>USE-PROGRAM function}@c
@functionsubindex{use-program}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/programs<dot>lisp file, , @t{core/pipelines/programs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {valid-index-p} TEXTURE MIPMAP-LEVEL LAYER CUBE-FACE
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>VALID-INDEX-P function}@c
@functionsubindex{valid-index-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {valid-pixel-format-p} COMPONENTS TYPE NORMALIZE REVERSED
@anchor{go to the CEPL<dot>PIXEL-FORMATS<colon><colon>VALID-PIXEL-FORMAT-P function}@c
@functionsubindex{valid-pixel-format-p}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIXEL-FORMATS package, , @t{cepl.pixel-formats}}
@item Source
@ref{go to the cepl/core/types/pixel-format<dot>lisp file, , @t{core/types/pixel-format.lisp}} (file)
@end table
@end deffn
@deffn {Function} {validate-defstruct-g-form} NAME SLOTS
@anchor{go to the CEPL<dot>TYPES<colon><colon>VALIDATE-DEFSTRUCT-G-FORM function}@c
@functionsubindex{validate-defstruct-g-form}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {validate-dimensions} DATA DIMENSIONS STRUCT-ELEM-TYPE-P
@anchor{go to the CEPL<dot>C-ARRAYS<colon><colon>VALIDATE-DIMENSIONS function}@c
@functionsubindex{validate-dimensions}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>C-ARRAYS package, , @t{cepl.c-arrays}}
@item Source
@ref{go to the cepl/core/c-arrays/populate<dot>lisp file, , @t{core/c-arrays/populate.lisp}} (file)
@end table
@end deffn
@deffn {Function} {validate-pixel-format} INITIAL-CONTENTS PIXEL-FORMAT
@anchor{go to the CEPL<dot>TEXTURES<colon><colon>VALIDATE-PIXEL-FORMAT function}@c
@functionsubindex{validate-pixel-format}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TEXTURES package, , @t{cepl.textures}}
@item Source
@ref{go to the cepl/core/textures/textures<dot>lisp file, , @t{core/textures/textures.lisp}} (file)
@end table
@end deffn
@deffn {Function} {validate-stage-names} NAMES
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>VALIDATE-STAGE-NAMES function}@c
@functionsubindex{validate-stage-names}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-functions<dot>lisp file, , @t{core/pipelines/gpu-functions.lisp}} (file)
@end table
@end deffn
@deffn {Function} {validate-varjo-type-spec} SPEC
@anchor{go to the CEPL<dot>TYPES<colon><colon>VALIDATE-VARJO-TYPE-SPEC function}@c
@functionsubindex{validate-varjo-type-spec}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>TYPES package, , @t{cepl.types}}
@item Source
@ref{go to the cepl/core/types/structs<dot>lisp file, , @t{core/types/structs.lisp}} (file)
@end table
@end deffn
@deffn {Function} {varjo->gl-stage-names} STAGE
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>VARJO->GL-STAGE-NAMES function}@c
@functionsubindex{varjo->gl-stage-names}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-pipeline-base<dot>lisp file, , @t{core/pipelines/gpu-pipeline-base.lisp}} (file)
@end table
@end deffn
@deffn {Function} {viewport-for-array} ARR
@anchor{go to the CEPL<dot>FBOS<colon><colon>VIEWPORT-FOR-ARRAY function}@c
@functionsubindex{viewport-for-array}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>FBOS package, , @t{cepl.fbos}}
@item Source
@ref{go to the cepl/core/fbos/fbo<dot>lisp file, , @t{core/fbos/fbo.lisp}} (file)
@end table
@end deffn
@deffn {Function} {vs-spliced-values} ENV THIS &rest SARGS
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>VS-SPLICED-VALUES function}@c
@functionsubindex{vs-spliced-values}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/funcall-g<dot>lisp file, , @t{core/pipelines/funcall-g.lisp}} (file)
@end table
@end deffn
@deffn {Function} {with-setf-internals} ENV PLACES VALUES
@anchor{go to the CEPL-UTILS<colon><colon>WITH-SETF-INTERNALS function}@c
@functionsubindex{with-setf-internals}@c
@table @strong
@item Package
@ref{go to the CEPL-UTILS package, , @t{cepl-utils}}
@item Source
@ref{go to the cepl/core/utils<dot>lisp file, , @t{core/utils.lisp}} (file)
@end table
@end deffn
@deffn {Function} {wrap-allowing-recompilation} PIPELINE LAMBDA-PIPELINE-SPEC GPIPE-ARGS COMPILE-CONTEXT
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>WRAP-ALLOWING-RECOMPILATION function}@c
@functionsubindex{wrap-allowing-recompilation}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/gpu-lambda<dot>lisp file, , @t{core/pipelines/gpu-lambda.lisp}} (file)
@end table
@end deffn
@deffn {Function} {wrap-eq} WRAP-A WRAP-B
@anchor{go to the CEPL<dot>SAMPLERS<colon><colon>WRAP-EQ function}@c
@functionsubindex{wrap-eq}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>SAMPLERS package, , @t{cepl.samplers}}
@item Source
@ref{go to the cepl/core/samplers/samplers<dot>lisp file, , @t{core/samplers/samplers.lisp}} (file)
@end table
@end deffn
@deffn {Function} {xsymbolp} X
@anchor{go to the CEPL<dot>PIPELINES<colon><colon>XSYMBOLP function}@c
@functionsubindex{xsymbolp}@c
@table @strong
@item Package
@ref{go to the CEPL<dot>PIPELINES package, , @t{cepl.pipelines}}
@item Source
@ref{go to the cepl/core/pipelines/pipeline-validation<dot>lisp file, , @t{core/pipelines/pipeline-validation.lisp}} (file)
@end table
@end deffn
" :AFTER-MENU-CONTENTS NIL) #20# #21# #22#) :BEFORE-MENU-CONTENTS NIL :AFTER-MENU-CONTENTS NIL) #S(NET.DIDIERVERNA.DECLT::CONTEXT :SYSTEMS (#<ASDF/SYSTEM:SYSTEM "cepl"> #<ASDF/SYSTEM:SYSTEM "cepl.build">) :PACKAGES (#<PACKAGE "CEPL"> #<PACKAGE "CEPL.PIPELINES"> #<PACKAGE "CEPL.COMPUTE"> #<PACKAGE "CEPL.QUERIES"> #<PACKAGE "CEPL.SYNC"> #<PACKAGE "CEPL.TRANSFORM-FEEDBACK"> #<PACKAGE "CEPL.SCISSOR"> #<PACKAGE "CEPL.STENCIL"> #<PACKAGE "CEPL.BLENDING"> #<PACKAGE "CEPL.FBOS"> #<PACKAGE "CEPL.RENDER-BUFFERS"> #<PACKAGE "CEPL.SAMPLERS"> ...) :EXTERNAL-DEFINITIONS #<HASH-TABLE :TEST EQUAL :COUNT 923 {100C2282E3}> :INTERNAL-DEFINITIONS #<HASH-TABLE :TEST EQUAL :COUNT 1067 {100CA00BE3}> :HYPERLINKSP NIL) "internal" #<HASH-TABLE :TEST EQUAL :COUNT 1067 {100CA00BE3}>)
21: ((FLET "THUNK" :IN NET.DIDIERVERNA.DECLT:DECLT))
22: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (FLET "THUNK" :IN NET.DIDIERVERNA.DECLT:DECLT) {7FFFF6E0EC0B}>)
23: (NET.DIDIERVERNA.DECLT:DECLT "cepl" :LIBRARY-NAME NIL :TAGLINE NIL :VERSION NIL :CONTACT NIL :COPYRIGHT-YEARS NIL :LICENSE NIL :INTRODUCTION "" :CONCLUSION NIL :TEXI-NAME NIL :TEXI-DIRECTORY "/home/didier/quickref/texinfo/" :INFO-NAME NIL :HYPERLINKS NIL :DECLT-NOTICE :LONG)
24: (SB-INT:SIMPLE-EVAL-IN-LEXENV (NET.DIDIERVERNA.DECLT:DECLT *SYSTEM-NAME* :INTRODUCTION (WHEN *INTRODUCTION* "") :TEXI-DIRECTORY *TEXINFO-DIRECTORY*) #<NULL-LEXENV>)
25: (EVAL-TLF (NET.DIDIERVERNA.DECLT:DECLT *SYSTEM-NAME* :INTRODUCTION (WHEN *INTRODUCTION* "") :TEXI-DIRECTORY *TEXINFO-DIRECTORY*) 13 NIL)
26: ((LABELS SB-FASL::EVAL-FORM :IN SB-INT:LOAD-AS-SOURCE) (NET.DIDIERVERNA.DECLT:DECLT *SYSTEM-NAME* :INTRODUCTION (WHEN *INTRODUCTION* "") :TEXI-DIRECTORY *TEXINFO-DIRECTORY*) 13)
27: ((LAMBDA (SB-KERNEL:FORM &KEY :CURRENT-INDEX &ALLOW-OTHER-KEYS) :IN SB-INT:LOAD-AS-SOURCE) (NET.DIDIERVERNA.DECLT:DECLT *SYSTEM-NAME* :INTRODUCTION (WHEN *INTRODUCTION* "") :TEXI-DIRECTORY *TEXINFO-DIRECTORY*) :CURRENT-INDEX 13)
28: (SB-C::%DO-FORMS-FROM-INFO #<CLOSURE (LAMBDA (SB-KERNEL:FORM &KEY :CURRENT-INDEX &ALLOW-OTHER-KEYS) :IN SB-INT:LOAD-AS-SOURCE) {1001B8D9BB}> #<SB-C::SOURCE-INFO {1001B8D973}> SB-C::INPUT-ERROR-IN-LOAD)
29: (SB-INT:LOAD-AS-SOURCE #<SB-SYS:FD-STREAM for "file /home/didier/share/common-lisp/source/quickref/bin/declt" {1001B7EA03}> :VERBOSE NIL :PRINT NIL :CONTEXT "loading")
30: ((FLET SB-FASL::THUNK :IN LOAD))
31: (SB-FASL::CALL-WITH-LOAD-BINDINGS #<CLOSURE (FLET SB-FASL::THUNK :IN LOAD) {7FFFF6E0F6BB}> #<SB-SYS:FD-STREAM for "file /home/didier/share/common-lisp/source/quickref/bin/declt" {1001B7EA03}>)
32: ((FLET SB-FASL::LOAD-STREAM :IN LOAD) #<SB-SYS:FD-STREAM for "file /home/didier/share/common-lisp/source/quickref/bin/declt" {1001B7EA03}> NIL)
33: (LOAD #<SB-SYS:FD-STREAM for "file /home/didier/share/common-lisp/source/quickref/bin/declt" {1001B7EA03}> :VERBOSE NIL :PRINT NIL :IF-DOES-NOT-EXIST T :EXTERNAL-FORMAT :DEFAULT)
34: ((FLET SB-IMPL::LOAD-SCRIPT :IN SB-IMPL::PROCESS-SCRIPT) #<SB-SYS:FD-STREAM for "file /home/didier/share/common-lisp/source/quickref/bin/declt" {1001B7EA03}>)
35: ((FLET "WITHOUT-INTERRUPTS-BODY-3" :IN SB-IMPL::PROCESS-SCRIPT))
36: (SB-IMPL::PROCESS-SCRIPT "/home/didier/share/common-lisp/source/quickref/bin/declt")
37: (SB-IMPL::TOPLEVEL-INIT)
38: ((FLET "WITHOUT-INTERRUPTS-BODY-35" :IN SAVE-LISP-AND-DIE))
39: ((LABELS SB-IMPL::RESTART-LISP :IN SAVE-LISP-AND-DIE))

unhandled condition in --disable-debugger mode, quitting

